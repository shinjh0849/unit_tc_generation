public static YearMonthDay fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new YearMonthDay(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static YearMonthDay fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new YearMonthDay(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.dateOptionalTimeParser()); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.dateOptionalTimeParser()); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtMidnight(DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtMidnight(DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getYear() { [EOL]     return getValue(YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getDayOfMonth() { [EOL]     return getValue(DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getDayOfMonth() { [EOL]     return getValue(DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getDayOfMonth() { [EOL]     return getValue(DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getDayOfMonth() { [EOL]     return getValue(DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getDayOfMonth() { [EOL]     return getValue(DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getDayOfMonth() { [EOL]     return getValue(DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getDayOfMonth() { [EOL]     return getValue(DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property monthOfYear() { [EOL]     return new Property(this, MONTH_OF_YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(int value) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(int value) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(int value) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(int value) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     return getChronology(object, (Chronology) null).withZone(zone); [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     return getChronology(object, (Chronology) null).withZone(zone); [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) { [EOL]     ReadablePartial input = (ReadablePartial) object; [EOL]     int size = fieldSource.size(); [EOL]     int[] values = new int[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         values[i] = input.get(fieldSource.getFieldType(i)); [EOL]     } [EOL]     chrono.validate(fieldSource, values); [EOL]     return values; [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) { [EOL]     ReadablePartial input = (ReadablePartial) object; [EOL]     int size = fieldSource.size(); [EOL]     int[] values = new int[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         values[i] = input.get(fieldSource.getFieldType(i)); [EOL]     } [EOL]     chrono.validate(fieldSource, values); [EOL]     return values; [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     return ((Long) object).longValue(); [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     return ((Long) object).longValue(); [EOL] }
public Class<?> getSupportedType() { [EOL]     return Long.class; [EOL] }
@FromString [EOL] public static Period parse(String str) { [EOL]     return parse(str, ISOPeriodFormat.standard()); [EOL] }
@FromString [EOL] public static Period parse(String str) { [EOL]     return parse(str, ISOPeriodFormat.standard()); [EOL] }
@FromString [EOL] public static Period parse(String str) { [EOL]     return parse(str, ISOPeriodFormat.standard()); [EOL] }
public static Period parse(String str, PeriodFormatter formatter) { [EOL]     return formatter.parsePeriod(str); [EOL] }
public static Period years(int years) { [EOL]     return new Period(new int[] { years, 0, 0, 0, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period years(int years) { [EOL]     return new Period(new int[] { years, 0, 0, 0, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period years(int years) { [EOL]     return new Period(new int[] { years, 0, 0, 0, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period months(int months) { [EOL]     return new Period(new int[] { 0, months, 0, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period months(int months) { [EOL]     return new Period(new int[] { 0, months, 0, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period months(int months) { [EOL]     return new Period(new int[] { 0, months, 0, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period weeks(int weeks) { [EOL]     return new Period(new int[] { 0, 0, weeks, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period weeks(int weeks) { [EOL]     return new Period(new int[] { 0, 0, weeks, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period weeks(int weeks) { [EOL]     return new Period(new int[] { 0, 0, weeks, 0, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period days(int days) { [EOL]     return new Period(new int[] { 0, 0, 0, days, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period days(int days) { [EOL]     return new Period(new int[] { 0, 0, 0, days, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period days(int days) { [EOL]     return new Period(new int[] { 0, 0, 0, days, 0, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period hours(int hours) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, hours, 0, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period minutes(int minutes) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, minutes, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period minutes(int minutes) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, minutes, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period minutes(int minutes) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, minutes, 0, 0 }, PeriodType.standard()); [EOL] }
public static Period seconds(int seconds) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, 0, seconds, 0 }, PeriodType.standard()); [EOL] }
public static Period seconds(int seconds) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, 0, seconds, 0 }, PeriodType.standard()); [EOL] }
public static Period seconds(int seconds) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, 0, seconds, 0 }, PeriodType.standard()); [EOL] }
public static Period millis(int millis) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, 0, 0, millis }, PeriodType.standard()); [EOL] }
public static Period millis(int millis) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, 0, 0, millis }, PeriodType.standard()); [EOL] }
public static Period millis(int millis) { [EOL]     return new Period(new int[] { 0, 0, 0, 0, 0, 0, 0, millis }, PeriodType.standard()); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public Period(int hours, int minutes, int seconds, int millis) { [EOL]     super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard()); [EOL] }
public Period(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) { [EOL]     super(years, months, weeks, days, hours, minutes, seconds, millis, type); [EOL] }
public Period(long duration, PeriodType type) { [EOL]     super(duration, type, null); [EOL] }
public Period(long duration, PeriodType type) { [EOL]     super(duration, type, null); [EOL] }
public Period(Object period) { [EOL]     super(period, null, null); [EOL] }
public Period(Object period) { [EOL]     super(period, null, null); [EOL] }
private Period(int[] values, PeriodType type) { [EOL]     super(values, type); [EOL] }
public Period withPeriodType(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     if (type.equals(getPeriodType())) { [EOL]         return this; [EOL]     } [EOL]     return new Period(this, type); [EOL] }
public Period withPeriodType(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     if (type.equals(getPeriodType())) { [EOL]         return this; [EOL]     } [EOL]     return new Period(this, type); [EOL] }
public Period withPeriodType(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     if (type.equals(getPeriodType())) { [EOL]         return this; [EOL]     } [EOL]     return new Period(this, type); [EOL] }
public Period withYears(int years) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withYears(int years) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withMonths(int months) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withHours(int hours) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withHours(int hours) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period minusYears(int years) { [EOL]     return plusYears(-years); [EOL] }
public Period minusYears(int years) { [EOL]     return plusYears(-years); [EOL] }
public Period minusYears(int years) { [EOL]     return plusYears(-years); [EOL] }
public Period minusMonths(int months) { [EOL]     return plusMonths(-months); [EOL] }
public Period minusMonths(int months) { [EOL]     return plusMonths(-months); [EOL] }
public Period minusMonths(int months) { [EOL]     return plusMonths(-months); [EOL] }
public Period minusWeeks(int weeks) { [EOL]     return plusWeeks(-weeks); [EOL] }
public Period minusWeeks(int weeks) { [EOL]     return plusWeeks(-weeks); [EOL] }
public Period minusWeeks(int weeks) { [EOL]     return plusWeeks(-weeks); [EOL] }
public Period minusDays(int days) { [EOL]     return plusDays(-days); [EOL] }
public Period minusDays(int days) { [EOL]     return plusDays(-days); [EOL] }
public Period minusDays(int days) { [EOL]     return plusDays(-days); [EOL] }
public Period minusHours(int hours) { [EOL]     return plusHours(-hours); [EOL] }
public Period minusHours(int hours) { [EOL]     return plusHours(-hours); [EOL] }
public Period minusHours(int hours) { [EOL]     return plusHours(-hours); [EOL] }
public Period minusMinutes(int minutes) { [EOL]     return plusMinutes(-minutes); [EOL] }
public Period minusMinutes(int minutes) { [EOL]     return plusMinutes(-minutes); [EOL] }
public Period minusMinutes(int minutes) { [EOL]     return plusMinutes(-minutes); [EOL] }
public Period minusSeconds(int seconds) { [EOL]     return plusSeconds(-seconds); [EOL] }
public Period minusSeconds(int seconds) { [EOL]     return plusSeconds(-seconds); [EOL] }
public Period minusSeconds(int seconds) { [EOL]     return plusSeconds(-seconds); [EOL] }
public Period minusMillis(int millis) { [EOL]     return plusMillis(-millis); [EOL] }
public Period minusMillis(int millis) { [EOL]     return plusMillis(-millis); [EOL] }
public Period minusMillis(int millis) { [EOL]     return plusMillis(-millis); [EOL] }
public Period normalizedStandard() { [EOL]     return normalizedStandard(PeriodType.standard()); [EOL] }
public Period normalizedStandard(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     long millis = getMillis(); [EOL]     millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); [EOL]     millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); [EOL]     millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); [EOL]     millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); [EOL]     millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     Period result = new Period(millis, type, ISOChronology.getInstanceUTC()); [EOL]     int years = getYears(); [EOL]     int months = getMonths(); [EOL]     if (years != 0 || months != 0) { [EOL]         long totalMonths = years * 12L + months; [EOL]         if (type.isSupported(DurationFieldType.YEARS_TYPE)) { [EOL]             int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); [EOL]             result = result.withYears(normalizedYears); [EOL]             totalMonths = totalMonths - (normalizedYears * 12); [EOL]         } [EOL]         if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { [EOL]             int normalizedMonths = FieldUtils.safeToInt(totalMonths); [EOL]             result = result.withMonths(normalizedMonths); [EOL]             totalMonths = totalMonths - normalizedMonths; [EOL]         } [EOL]         if (totalMonths != 0) { [EOL]             throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public Period normalizedStandard(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     long millis = getMillis(); [EOL]     millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); [EOL]     millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); [EOL]     millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); [EOL]     millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); [EOL]     millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     Period result = new Period(millis, type, ISOChronology.getInstanceUTC()); [EOL]     int years = getYears(); [EOL]     int months = getMonths(); [EOL]     if (years != 0 || months != 0) { [EOL]         long totalMonths = years * 12L + months; [EOL]         if (type.isSupported(DurationFieldType.YEARS_TYPE)) { [EOL]             int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); [EOL]             result = result.withYears(normalizedYears); [EOL]             totalMonths = totalMonths - (normalizedYears * 12); [EOL]         } [EOL]         if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { [EOL]             int normalizedMonths = FieldUtils.safeToInt(totalMonths); [EOL]             result = result.withMonths(normalizedMonths); [EOL]             totalMonths = totalMonths - normalizedMonths; [EOL]         } [EOL]         if (totalMonths != 0) { [EOL]             throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public Period normalizedStandard(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     long millis = getMillis(); [EOL]     millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); [EOL]     millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); [EOL]     millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); [EOL]     millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); [EOL]     millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     Period result = new Period(millis, type, ISOChronology.getInstanceUTC()); [EOL]     int years = getYears(); [EOL]     int months = getMonths(); [EOL]     if (years != 0 || months != 0) { [EOL]         long totalMonths = years * 12L + months; [EOL]         if (type.isSupported(DurationFieldType.YEARS_TYPE)) { [EOL]             int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); [EOL]             result = result.withYears(normalizedYears); [EOL]             totalMonths = totalMonths - (normalizedYears * 12); [EOL]         } [EOL]         if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { [EOL]             int normalizedMonths = FieldUtils.safeToInt(totalMonths); [EOL]             result = result.withMonths(normalizedMonths); [EOL]             totalMonths = totalMonths - normalizedMonths; [EOL]         } [EOL]         if (totalMonths != 0) { [EOL]             throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public Period normalizedStandard(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     long millis = getMillis(); [EOL]     millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); [EOL]     millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); [EOL]     millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); [EOL]     millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); [EOL]     millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     Period result = new Period(millis, type, ISOChronology.getInstanceUTC()); [EOL]     int years = getYears(); [EOL]     int months = getMonths(); [EOL]     if (years != 0 || months != 0) { [EOL]         long totalMonths = years * 12L + months; [EOL]         if (type.isSupported(DurationFieldType.YEARS_TYPE)) { [EOL]             int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); [EOL]             result = result.withYears(normalizedYears); [EOL]             totalMonths = totalMonths - (normalizedYears * 12); [EOL]         } [EOL]         if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { [EOL]             int normalizedMonths = FieldUtils.safeToInt(totalMonths); [EOL]             result = result.withMonths(normalizedMonths); [EOL]             totalMonths = totalMonths - normalizedMonths; [EOL]         } [EOL]         if (totalMonths != 0) { [EOL]             throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public Period normalizedStandard(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     long millis = getMillis(); [EOL]     millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); [EOL]     millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); [EOL]     millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); [EOL]     millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); [EOL]     millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     Period result = new Period(millis, type, ISOChronology.getInstanceUTC()); [EOL]     int years = getYears(); [EOL]     int months = getMonths(); [EOL]     if (years != 0 || months != 0) { [EOL]         long totalMonths = years * 12L + months; [EOL]         if (type.isSupported(DurationFieldType.YEARS_TYPE)) { [EOL]             int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); [EOL]             result = result.withYears(normalizedYears); [EOL]             totalMonths = totalMonths - (normalizedYears * 12); [EOL]         } [EOL]         if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { [EOL]             int normalizedMonths = FieldUtils.safeToInt(totalMonths); [EOL]             result = result.withMonths(normalizedMonths); [EOL]             totalMonths = totalMonths - normalizedMonths; [EOL]         } [EOL]         if (totalMonths != 0) { [EOL]             throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static IslamicChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
int getDaysInYearMax() { [EOL]     return 355; [EOL] }
int getDaysInYear(int year) { [EOL]     return isLeapYear(year) ? 355 : 354; [EOL] }
int getDaysInYear(int year) { [EOL]     return isLeapYear(year) ? 355 : 354; [EOL] }
int getDaysInMonthMax() { [EOL]     return LONG_MONTH_LENGTH; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     if (year > MAX_YEAR) { [EOL]         throw new ArithmeticException("Year is too large: " + year + " > " + MAX_YEAR); [EOL]     } [EOL]     if (year < MIN_YEAR) { [EOL]         throw new ArithmeticException("Year is too small: " + year + " < " + MIN_YEAR); [EOL]     } [EOL]     year--; [EOL]     long cycle = year / CYCLE; [EOL]     long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE; [EOL]     int cycleRemainder = (year % CYCLE) + 1; [EOL]     for (int i = 1; i < cycleRemainder; i++) { [EOL]         millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR); [EOL]     } [EOL]     return millis; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant >= iCutover) { [EOL]         if (subtrahendInstant >= iCutover) { [EOL]             return iGregorianField.getDifference(minuendInstant, subtrahendInstant); [EOL]         } [EOL]         minuendInstant = gregorianToJulian(minuendInstant); [EOL]         return iJulianField.getDifference(minuendInstant, subtrahendInstant); [EOL]     } else { [EOL]         if (subtrahendInstant < iCutover) { [EOL]             return iJulianField.getDifference(minuendInstant, subtrahendInstant); [EOL]         } [EOL]         minuendInstant = julianToGregorian(minuendInstant); [EOL]         return iGregorianField.getDifference(minuendInstant, subtrahendInstant); [EOL]     } [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) { [EOL]     long instant = getInstantMillis(object, chrono); [EOL]     return chrono.get(fieldSource, instant); [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) { [EOL]     long instant = getInstantMillis(object, chrono); [EOL]     return chrono.get(fieldSource, instant); [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) { [EOL]     return getPartialValues(fieldSource, object, chrono); [EOL] }
public boolean isReadableInterval(Object object, Chronology chrono) { [EOL]     return false; [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public PeriodType getPeriodType(Object object) { [EOL]     ReadablePeriod period = (ReadablePeriod) object; [EOL]     return period.getPeriodType(); [EOL] }
public PeriodType getPeriodType(Object object) { [EOL]     ReadablePeriod period = (ReadablePeriod) object; [EOL]     return period.getPeriodType(); [EOL] }
public Class<?> getSupportedType() { [EOL]     return ReadablePeriod.class; [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public PeriodFormatterBuilder append(PeriodFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         throw new IllegalArgumentException("No formatter supplied"); [EOL]     } [EOL]     clearPrefix(); [EOL]     append0(formatter.getPrinter(), formatter.getParser()); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder append(PeriodFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         throw new IllegalArgumentException("No formatter supplied"); [EOL]     } [EOL]     clearPrefix(); [EOL]     append0(formatter.getPrinter(), formatter.getParser()); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) { [EOL]     iMinPrintedDigits = minDigits; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) { [EOL]     iMinPrintedDigits = minDigits; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder printZeroRarelyFirst() { [EOL]     iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendYears() { [EOL]     appendField(YEARS); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendMinutes() { [EOL]     appendField(MINUTES); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis() { [EOL]     appendField(SECONDS_OPTIONAL_MILLIS); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendSuffix(String singularText, String pluralText) { [EOL]     if (singularText == null || pluralText == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendSuffix(new PluralAffix(singularText, pluralText)); [EOL] }
public PeriodFormatterBuilder appendSeparator(String text) { [EOL]     return appendSeparator(text, text, null, true, true); [EOL] }
public PeriodFormatterBuilder appendSeparator(String text) { [EOL]     return appendSeparator(text, text, null, true, true); [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
public int parse(String periodStr, int position) { [EOL]     String text = iText; [EOL]     int textLength = text.length(); [EOL]     if (periodStr.regionMatches(true, position, text, 0, textLength)) { [EOL]         return position + textLength; [EOL]     } [EOL]     return ~position; [EOL] }
public int scan(String periodStr, final int position) { [EOL]     String text = iText; [EOL]     int textLength = text.length(); [EOL]     int sourceLength = periodStr.length(); [EOL]     search: for (int pos = position; pos < sourceLength; pos++) { [EOL]         if (periodStr.regionMatches(true, pos, text, 0, textLength)) { [EOL]             return pos; [EOL]         } [EOL]         switch(periodStr.charAt(pos)) { [EOL]             case '0': [EOL]             case '1': [EOL]             case '2': [EOL]             case '3': [EOL]             case '4': [EOL]             case '5': [EOL]             case '6': [EOL]             case '7': [EOL]             case '8': [EOL]             case '9': [EOL]             case '.': [EOL]             case ',': [EOL]             case '+': [EOL]             case '-': [EOL]                 break; [EOL]             default: [EOL]                 break search; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
boolean isSupported(PeriodType type, int field) { [EOL]     switch(field) { [EOL]         default: [EOL]             return false; [EOL]         case YEARS: [EOL]             return type.isSupported(DurationFieldType.years()); [EOL]         case MONTHS: [EOL]             return type.isSupported(DurationFieldType.months()); [EOL]         case WEEKS: [EOL]             return type.isSupported(DurationFieldType.weeks()); [EOL]         case DAYS: [EOL]             return type.isSupported(DurationFieldType.days()); [EOL]         case HOURS: [EOL]             return type.isSupported(DurationFieldType.hours()); [EOL]         case MINUTES: [EOL]             return type.isSupported(DurationFieldType.minutes()); [EOL]         case SECONDS: [EOL]             return type.isSupported(DurationFieldType.seconds()); [EOL]         case MILLIS: [EOL]             return type.isSupported(DurationFieldType.millis()); [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             return type.isSupported(DurationFieldType.seconds()) || type.isSupported(DurationFieldType.millis()); [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
BasicWeekyearDateTimeField(BasicChronology chronology) { [EOL]     super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear()); [EOL]     iChronology = chronology; [EOL] }
BasicWeekyearDateTimeField(BasicChronology chronology) { [EOL]     super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear()); [EOL]     iChronology = chronology; [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     int thisWeekyear = get(instant); [EOL]     if (thisWeekyear == year) { [EOL]         return instant; [EOL]     } [EOL]     int thisDow = iChronology.getDayOfWeek(instant); [EOL]     int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL]     int weeksInToYear = iChronology.getWeeksInYear(year); [EOL]     int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL]     int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL]     if (setToWeek > maxOutWeeks) { [EOL]         setToWeek = maxOutWeeks; [EOL]     } [EOL]     long workInstant = instant; [EOL]     workInstant = iChronology.setYear(workInstant, year); [EOL]     int workWoyYear = get(workInstant); [EOL]     if (workWoyYear < year) { [EOL]         workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } else if (workWoyYear > year) { [EOL]         workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL]     workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL]     workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL]     return workInstant; [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     int thisWeekyear = get(instant); [EOL]     if (thisWeekyear == year) { [EOL]         return instant; [EOL]     } [EOL]     int thisDow = iChronology.getDayOfWeek(instant); [EOL]     int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL]     int weeksInToYear = iChronology.getWeeksInYear(year); [EOL]     int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL]     int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL]     if (setToWeek > maxOutWeeks) { [EOL]         setToWeek = maxOutWeeks; [EOL]     } [EOL]     long workInstant = instant; [EOL]     workInstant = iChronology.setYear(workInstant, year); [EOL]     int workWoyYear = get(workInstant); [EOL]     if (workWoyYear < year) { [EOL]         workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } else if (workWoyYear > year) { [EOL]         workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL]     workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL]     workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL]     return workInstant; [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     int thisWeekyear = get(instant); [EOL]     if (thisWeekyear == year) { [EOL]         return instant; [EOL]     } [EOL]     int thisDow = iChronology.getDayOfWeek(instant); [EOL]     int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL]     int weeksInToYear = iChronology.getWeeksInYear(year); [EOL]     int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL]     int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL]     if (setToWeek > maxOutWeeks) { [EOL]         setToWeek = maxOutWeeks; [EOL]     } [EOL]     long workInstant = instant; [EOL]     workInstant = iChronology.setYear(workInstant, year); [EOL]     int workWoyYear = get(workInstant); [EOL]     if (workWoyYear < year) { [EOL]         workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } else if (workWoyYear > year) { [EOL]         workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL]     workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL]     workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL]     return workInstant; [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     int thisWeekyear = get(instant); [EOL]     if (thisWeekyear == year) { [EOL]         return instant; [EOL]     } [EOL]     int thisDow = iChronology.getDayOfWeek(instant); [EOL]     int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL]     int weeksInToYear = iChronology.getWeeksInYear(year); [EOL]     int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL]     int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL]     if (setToWeek > maxOutWeeks) { [EOL]         setToWeek = maxOutWeeks; [EOL]     } [EOL]     long workInstant = instant; [EOL]     workInstant = iChronology.setYear(workInstant, year); [EOL]     int workWoyYear = get(workInstant); [EOL]     if (workWoyYear < year) { [EOL]         workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } else if (workWoyYear > year) { [EOL]         workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL]     workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL]     workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL]     return workInstant; [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     int thisWeekyear = get(instant); [EOL]     if (thisWeekyear == year) { [EOL]         return instant; [EOL]     } [EOL]     int thisDow = iChronology.getDayOfWeek(instant); [EOL]     int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL]     int weeksInToYear = iChronology.getWeeksInYear(year); [EOL]     int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL]     int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL]     if (setToWeek > maxOutWeeks) { [EOL]         setToWeek = maxOutWeeks; [EOL]     } [EOL]     long workInstant = instant; [EOL]     workInstant = iChronology.setYear(workInstant, year); [EOL]     int workWoyYear = get(workInstant); [EOL]     if (workWoyYear < year) { [EOL]         workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } else if (workWoyYear > year) { [EOL]         workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL]     workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL]     workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL]     return workInstant; [EOL] }
public int getMinimumValue() { [EOL]     return iChronology.getMinYear(); [EOL] }
public int getMaximumValue() { [EOL]     return iChronology.getMaxYear(); [EOL] }
@Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL]     return size() > PATTERN_CACHE_SIZE; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter forPattern(String pattern) { [EOL]     return createFormatterForPattern(pattern); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter mediumDate() { [EOL]     return createFormatterForStyleIndex(MEDIUM, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL]     int length = pattern.length(); [EOL]     int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         String token = parseToken(pattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 builder.appendEraText(); [EOL]                 break; [EOL]             case 'C': [EOL]                 builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]                 if (tokenLen == 2) { [EOL]                     boolean lenientParse = true; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             lenientParse = false; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL]                             break; [EOL]                         case 'y': [EOL]                         case 'Y': [EOL]                         default: [EOL]                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL]                             break; [EOL]                     } [EOL]                 } else { [EOL]                     int maxDigits = 9; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             maxDigits = tokenLen; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendWeekyear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'y': [EOL]                             builder.appendYear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'Y': [EOL]                             builder.appendYearOfEra(tokenLen, maxDigits); [EOL]                             break; [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 3) { [EOL]                     if (tokenLen >= 4) { [EOL]                         builder.appendMonthOfYearText(); [EOL]                     } else { [EOL]                         builder.appendMonthOfYearShortText(); [EOL]                     } [EOL]                 } else { [EOL]                     builder.appendMonthOfYear(tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 builder.appendDayOfMonth(tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 builder.appendHalfdayOfDayText(); [EOL]                 break; [EOL]             case 'h': [EOL]                 builder.appendClockhourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'H': [EOL]                 builder.appendHourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'k': [EOL]                 builder.appendClockhourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'K': [EOL]                 builder.appendHourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 builder.appendMinuteOfHour(tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 builder.appendSecondOfMinute(tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'e': [EOL]                 builder.appendDayOfWeek(tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendDayOfWeekText(); [EOL]                 } else { [EOL]                     builder.appendDayOfWeekShortText(); [EOL]                 } [EOL]                 break; [EOL]             case 'D': [EOL]                 builder.appendDayOfYear(tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 builder.appendWeekOfWeekyear(tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendTimeZoneName(); [EOL]                 } else { [EOL]                     builder.appendTimeZoneShortName(null); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL]                 } else if (tokenLen == 2) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL]                 } else { [EOL]                     builder.appendTimeZoneId(); [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     builder.appendLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     builder.appendLiteral(new String(sub)); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static String parseToken(String pattern, int[] indexRef) { [EOL]     StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForPattern(String pattern) { [EOL]     if (pattern == null || pattern.length() == 0) { [EOL]         throw new IllegalArgumentException("Invalid pattern specification"); [EOL]     } [EOL]     DateTimeFormatter formatter = null; [EOL]     synchronized (PATTERN_CACHE) { [EOL]         formatter = PATTERN_CACHE.get(pattern); [EOL]         if (formatter == null) { [EOL]             DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL]             parsePatternTo(builder, pattern); [EOL]             formatter = builder.toFormatter(); [EOL]             PATTERN_CACHE.put(pattern, formatter); [EOL]         } [EOL]     } [EOL]     return formatter; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL]     int type = DATETIME; [EOL]     if (dateStyle == NONE) { [EOL]         type = TIME; [EOL]     } else if (timeStyle == NONE) { [EOL]         type = DATE; [EOL]     } [EOL]     StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type); [EOL]     return new DateTimeFormatter(llf, llf); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
String getPattern(Locale locale) { [EOL]     DateFormat f = null; [EOL]     switch(iType) { [EOL]         case DATE: [EOL]             f = DateFormat.getDateInstance(iDateStyle, locale); [EOL]             break; [EOL]         case TIME: [EOL]             f = DateFormat.getTimeInstance(iTimeStyle, locale); [EOL]             break; [EOL]         case DATETIME: [EOL]             f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale); [EOL]             break; [EOL]     } [EOL]     if (f instanceof SimpleDateFormat == false) { [EOL]         throw new IllegalArgumentException("No datetime pattern for locale: " + locale); [EOL]     } [EOL]     return ((SimpleDateFormat) f).toPattern(); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public long getStandardSeconds() { [EOL]     return getMillis() / DateTimeConstants.MILLIS_PER_SECOND; [EOL] }
public Seconds toStandardSeconds() { [EOL]     long seconds = getStandardSeconds(); [EOL]     return Seconds.seconds(FieldUtils.safeToInt(seconds)); [EOL] }
public Duration plus(long amount) { [EOL]     return withDurationAdded(amount, 1); [EOL] }
public Duration plus(ReadableDuration amount) { [EOL]     if (amount == null) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(amount.getMillis(), 1); [EOL] }
public Duration plus(ReadableDuration amount) { [EOL]     if (amount == null) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(amount.getMillis(), 1); [EOL] }
public Duration multipliedBy(long multiplicand) { [EOL]     if (multiplicand == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand)); [EOL] }
public Duration multipliedBy(long multiplicand) { [EOL]     if (multiplicand == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand)); [EOL] }
public Duration dividedBy(long divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeDivide(getMillis(), divisor)); [EOL] }
public Duration dividedBy(long divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeDivide(getMillis(), divisor)); [EOL] }
public Duration dividedBy(long divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeDivide(getMillis(), divisor)); [EOL] }
public Duration negated() { [EOL]     if (getMillis() == Long.MIN_VALUE) { [EOL]         throw new ArithmeticException("Negation of this duration would overflow"); [EOL]     } [EOL]     return new Duration(-getMillis()); [EOL] }
public static PeriodFormatter standard() { [EOL]     if (cStandard == null) { [EOL]         cStandard = new PeriodFormatterBuilder().appendLiteral("P").appendYears().appendSuffix("Y").appendMonths().appendSuffix("M").appendWeeks().appendSuffix("W").appendDays().appendSuffix("D").appendSeparatorIfFieldsAfter("T").appendHours().appendSuffix("H").appendMinutes().appendSuffix("M").appendSecondsWithOptionalMillis().appendSuffix("S").toFormatter(); [EOL]     } [EOL]     return cStandard; [EOL] }
public static PeriodFormatter standard() { [EOL]     if (cStandard == null) { [EOL]         cStandard = new PeriodFormatterBuilder().appendLiteral("P").appendYears().appendSuffix("Y").appendMonths().appendSuffix("M").appendWeeks().appendSuffix("W").appendDays().appendSuffix("D").appendSeparatorIfFieldsAfter("T").appendHours().appendSuffix("H").appendMinutes().appendSuffix("M").appendSecondsWithOptionalMillis().appendSuffix("S").toFormatter(); [EOL]     } [EOL]     return cStandard; [EOL] }
public DurationField getLeapDurationField() { [EOL]     return getWrappedField().getLeapDurationField(); [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long prev = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     prev = chrono.millisOfDay().set(prev, 0); [EOL]     prev = chrono.millisOfDay().add(prev, iMillisOfDay); [EOL]     prev = setDayOfMonthPrevious(chrono, prev); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]         } [EOL]     } else { [EOL]         prev = setDayOfWeek(chrono, prev); [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = chrono.monthOfYear().set(prev, iMonthOfYear); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]             prev = setDayOfWeek(chrono, prev); [EOL]         } [EOL]     } [EOL]     return prev - offset; [EOL] }
private long setDayOfMonthPrevious(Chronology chrono, long prev) { [EOL]     try { [EOL]         prev = setDayOfMonth(chrono, prev); [EOL]     } catch (IllegalArgumentException e) { [EOL]         if (iMonthOfYear == 2 && iDayOfMonth == 29) { [EOL]             while (chrono.year().isLeap(prev) == false) { [EOL]                 prev = chrono.year().add(prev, -1); [EOL]             } [EOL]             prev = setDayOfMonth(chrono, prev); [EOL]         } else { [EOL]             throw e; [EOL]         } [EOL]     } [EOL]     return prev; [EOL] }
private long setDayOfMonthPrevious(Chronology chrono, long prev) { [EOL]     try { [EOL]         prev = setDayOfMonth(chrono, prev); [EOL]     } catch (IllegalArgumentException e) { [EOL]         if (iMonthOfYear == 2 && iDayOfMonth == 29) { [EOL]             while (chrono.year().isLeap(prev) == false) { [EOL]                 prev = chrono.year().add(prev, -1); [EOL]             } [EOL]             prev = setDayOfMonth(chrono, prev); [EOL]         } else { [EOL]             throw e; [EOL]         } [EOL]     } [EOL]     return prev; [EOL] }
private long setDayOfMonthPrevious(Chronology chrono, long prev) { [EOL]     try { [EOL]         prev = setDayOfMonth(chrono, prev); [EOL]     } catch (IllegalArgumentException e) { [EOL]         if (iMonthOfYear == 2 && iDayOfMonth == 29) { [EOL]             while (chrono.year().isLeap(prev) == false) { [EOL]                 prev = chrono.year().add(prev, -1); [EOL]             } [EOL]             prev = setDayOfMonth(chrono, prev); [EOL]         } else { [EOL]             throw e; [EOL]         } [EOL]     } [EOL]     return prev; [EOL] }
private long setDayOfWeek(Chronology chrono, long instant) { [EOL]     int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL]     int daysToAdd = iDayOfWeek - dayOfWeek; [EOL]     if (daysToAdd != 0) { [EOL]         if (iAdvance) { [EOL]             if (daysToAdd < 0) { [EOL]                 daysToAdd += 7; [EOL]             } [EOL]         } else { [EOL]             if (daysToAdd > 0) { [EOL]                 daysToAdd -= 7; [EOL]             } [EOL]         } [EOL]         instant = chrono.dayOfWeek().add(instant, daysToAdd); [EOL]     } [EOL]     return instant; [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     return iOfYear.previous(instant, standardOffset, saveMillis); [EOL] }
public long previousTransition(long instant) { [EOL]     instant++; [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.previous(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant < 0 && start > 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.previous(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant < 0 && end > 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return ((start > end) ? start : end) - 1; [EOL] }
public long nextTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     i = (i >= 0) ? (i + 1) : ~i; [EOL]     if (i < transitions.length) { [EOL]         return transitions[i]; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return instant; [EOL]     } [EOL]     long end = transitions[transitions.length - 1]; [EOL]     if (instant < end) { [EOL]         instant = end; [EOL]     } [EOL]     return iTailZone.nextTransition(instant); [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public long nextTransition(long instant) { [EOL]     return iZone.nextTransition(instant); [EOL] }
public long previousTransition(long instant) { [EOL]     return iZone.previousTransition(instant); [EOL] }
public int getValue(long duration) { [EOL]     return getWrappedField().getValue(duration) / iScalar; [EOL] }
public long getValueAsLong(long duration, long instant) { [EOL]     return getWrappedField().getValueAsLong(duration, instant) / iScalar; [EOL] }
public long getMillis(long value) { [EOL]     long scaled = FieldUtils.safeMultiply(value, iScalar); [EOL]     return getWrappedField().getMillis(scaled); [EOL] }
public long getMillis(long value) { [EOL]     long scaled = FieldUtils.safeMultiply(value, iScalar); [EOL]     return getWrappedField().getMillis(scaled); [EOL] }
public long getMillis(long value) { [EOL]     long scaled = FieldUtils.safeMultiply(value, iScalar); [EOL]     return getWrappedField().getMillis(scaled); [EOL] }
public long getMillis(long value) { [EOL]     long scaled = FieldUtils.safeMultiply(value, iScalar); [EOL]     return getWrappedField().getMillis(scaled); [EOL] }
public long getMillis(long value) { [EOL]     long scaled = FieldUtils.safeMultiply(value, iScalar); [EOL]     return getWrappedField().getMillis(scaled); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar; [EOL] }
public long getUnitMillis() { [EOL]     return getWrappedField().getUnitMillis() * iScalar; [EOL] }
public long getUnitMillis() { [EOL]     return getWrappedField().getUnitMillis() * iScalar; [EOL] }
public long getUnitMillis() { [EOL]     return getWrappedField().getUnitMillis() * iScalar; [EOL] }
public int getScalar() { [EOL]     return iScalar; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ISOChronology) { [EOL]         ISOChronology chrono = (ISOChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public long getValueAsLong(long duration) { [EOL]     return duration / getUnitMillis(); [EOL] }
public int getValue(long duration, long instant) { [EOL]     return FieldUtils.safeToInt(getValueAsLong(duration, instant)); [EOL] }
public long getMillis(int value) { [EOL]     return value * getUnitMillis(); [EOL] }
public long getMillis(long value) { [EOL]     return FieldUtils.safeMultiply(value, getUnitMillis()); [EOL] }
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] }
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]         fields.year = new SkipDateTimeField(this, fields.year); [EOL]         fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL]         fields.era = ERA_FIELD; [EOL]         fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13); [EOL]         fields.months = fields.monthOfYear.getDurationField(); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
@FromString [EOL] public static Months parseMonths(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Months.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Months.months(p.getMonths()); [EOL] }
@FromString [EOL] public static Months parseMonths(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Months.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Months.months(p.getMonths()); [EOL] }
@FromString [EOL] public static Months parseMonths(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Months.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Months.months(p.getMonths()); [EOL] }
public int getMonths() { [EOL]     return getValue(); [EOL] }
public Months plus(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     return Months.months(FieldUtils.safeAdd(getValue(), months)); [EOL] }
public Months plus(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     return Months.months(FieldUtils.safeAdd(getValue(), months)); [EOL] }
public Months plus(Months months) { [EOL]     if (months == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(months.getValue()); [EOL] }
public Months plus(Months months) { [EOL]     if (months == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(months.getValue()); [EOL] }
public Months minus(int months) { [EOL]     return plus(FieldUtils.safeNegate(months)); [EOL] }
public Months minus(int months) { [EOL]     return plus(FieldUtils.safeNegate(months)); [EOL] }
public Months minus(int months) { [EOL]     return plus(FieldUtils.safeNegate(months)); [EOL] }
public Months minus(Months months) { [EOL]     if (months == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(months.getValue()); [EOL] }
public Months minus(Months months) { [EOL]     if (months == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(months.getValue()); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "P" + String.valueOf(getValue()) + "M"; [EOL] }
public Interval(long startInstant, long endInstant, DateTimeZone zone) { [EOL]     super(startInstant, endInstant, ISOChronology.getInstance(zone)); [EOL] }
public Interval(long startInstant, long endInstant, DateTimeZone zone) { [EOL]     super(startInstant, endInstant, ISOChronology.getInstance(zone)); [EOL] }
public Interval(long startInstant, long endInstant, DateTimeZone zone) { [EOL]     super(startInstant, endInstant, ISOChronology.getInstance(zone)); [EOL] }
public Interval gap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (thisStart > otherEnd) { [EOL]         return new Interval(otherEnd, thisStart, getChronology()); [EOL]     } else if (otherStart > thisEnd) { [EOL]         return new Interval(thisEnd, otherStart, getChronology()); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public Interval gap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (thisStart > otherEnd) { [EOL]         return new Interval(otherEnd, thisStart, getChronology()); [EOL]     } else if (otherStart > thisEnd) { [EOL]         return new Interval(thisEnd, otherStart, getChronology()); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public Interval gap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (thisStart > otherEnd) { [EOL]         return new Interval(otherEnd, thisStart, getChronology()); [EOL]     } else if (otherStart > thisEnd) { [EOL]         return new Interval(thisEnd, otherStart, getChronology()); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public boolean abuts(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (getStartMillis() == now || getEndMillis() == now); [EOL]     } else { [EOL]         return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis()); [EOL]     } [EOL] }
public boolean abuts(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (getStartMillis() == now || getEndMillis() == now); [EOL]     } else { [EOL]         return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis()); [EOL]     } [EOL] }
public boolean abuts(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (getStartMillis() == now || getEndMillis() == now); [EOL]     } else { [EOL]         return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis()); [EOL]     } [EOL] }
public boolean abuts(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (getStartMillis() == now || getEndMillis() == now); [EOL]     } else { [EOL]         return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis()); [EOL]     } [EOL] }
public Interval withChronology(Chronology chronology) { [EOL]     if (getChronology() == chronology) { [EOL]         return this; [EOL]     } [EOL]     return new Interval(getStartMillis(), getEndMillis(), chronology); [EOL] }
public Interval withChronology(Chronology chronology) { [EOL]     if (getChronology() == chronology) { [EOL]         return this; [EOL]     } [EOL]     return new Interval(getStartMillis(), getEndMillis(), chronology); [EOL] }
public Interval withStartMillis(long startInstant) { [EOL]     if (startInstant == getStartMillis()) { [EOL]         return this; [EOL]     } [EOL]     return new Interval(startInstant, getEndMillis(), getChronology()); [EOL] }
public Interval withStartMillis(long startInstant) { [EOL]     if (startInstant == getStartMillis()) { [EOL]         return this; [EOL]     } [EOL]     return new Interval(startInstant, getEndMillis(), getChronology()); [EOL] }
public Interval withStart(ReadableInstant start) { [EOL]     long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]     return withStartMillis(startMillis); [EOL] }
public Interval withDurationAfterStart(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long startMillis = getStartMillis(); [EOL]     long endMillis = chrono.add(startMillis, durationMillis, 1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withDurationAfterStart(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long startMillis = getStartMillis(); [EOL]     long endMillis = chrono.add(startMillis, durationMillis, 1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withPeriodBeforeEnd(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return withDurationBeforeEnd(null); [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(period, endMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withPeriodBeforeEnd(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return withDurationBeforeEnd(null); [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(period, endMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public static YearMonth now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new YearMonth(zone); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public static YearMonth now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new YearMonth(zone); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
@FromString [EOL] public static YearMonth parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public static YearMonth parse(String str, DateTimeFormatter formatter) { [EOL]     LocalDate date = formatter.parseLocalDate(str); [EOL]     return new YearMonth(date.getYear(), date.getMonthOfYear()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public static YearMonth parse(String str, DateTimeFormatter formatter) { [EOL]     LocalDate date = formatter.parseLocalDate(str); [EOL]     return new YearMonth(date.getYear(), date.getMonthOfYear()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Chronology chronology) { [EOL]     super(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
private Object readResolve() { [EOL]     if (DateTimeZone.UTC.equals(getChronology().getZone()) == false) { [EOL]         return new YearMonth(this, getChronology().withUTC()); [EOL]     } [EOL]     return this; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text, Locale locale) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, text, locale); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text, Locale locale) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, text, locale); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text, Locale locale) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, text, locale); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text, Locale locale) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, text, locale); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public final String getAsShortText(long instant) { [EOL]     return getAsShortText(instant, null); [EOL] }
public final String getAsShortText(long instant) { [EOL]     return getAsShortText(instant, null); [EOL] }
public long addWrapField(long instant, int value) { [EOL]     int current = get(instant); [EOL]     int wrapped = FieldUtils.getWrappedValue(current, value, getMinimumValue(instant), getMaximumValue(instant)); [EOL]     return set(instant, wrapped); [EOL] }
public long addWrapField(long instant, int value) { [EOL]     int current = get(instant); [EOL]     int wrapped = FieldUtils.getWrappedValue(current, value, getMinimumValue(instant), getMaximumValue(instant)); [EOL]     return set(instant, wrapped); [EOL] }
public long addWrapField(long instant, int value) { [EOL]     int current = get(instant); [EOL]     int wrapped = FieldUtils.getWrappedValue(current, value, getMinimumValue(instant), getMaximumValue(instant)); [EOL]     return set(instant, wrapped); [EOL] }
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     int current = values[fieldIndex]; [EOL]     int wrapped = FieldUtils.getWrappedValue(current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); [EOL]     return set(instant, fieldIndex, values, wrapped); [EOL] }
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     int current = values[fieldIndex]; [EOL]     int wrapped = FieldUtils.getWrappedValue(current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); [EOL]     return set(instant, fieldIndex, values, wrapped); [EOL] }
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     int current = values[fieldIndex]; [EOL]     int wrapped = FieldUtils.getWrappedValue(current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); [EOL]     return set(instant, fieldIndex, values, wrapped); [EOL] }
public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     int current = values[fieldIndex]; [EOL]     int wrapped = FieldUtils.getWrappedValue(current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); [EOL]     return set(instant, fieldIndex, values, wrapped); [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     int value = convertText(text, locale); [EOL]     return set(instant, value); [EOL] }
public boolean isLeap(long instant) { [EOL]     return false; [EOL] }
public long remainder(long instant) { [EOL]     return instant - roundFloor(instant); [EOL] }
public RemainderDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type, int divisor) { [EOL]     super(field, type); [EOL]     if (divisor < 2) { [EOL]         throw new IllegalArgumentException("The divisor must be at least 2"); [EOL]     } [EOL]     iRangeField = rangeField; [EOL]     iDurationField = field.getDurationField(); [EOL]     iDivisor = divisor; [EOL] }
public RemainderDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type, int divisor) { [EOL]     super(field, type); [EOL]     if (divisor < 2) { [EOL]         throw new IllegalArgumentException("The divisor must be at least 2"); [EOL]     } [EOL]     iRangeField = rangeField; [EOL]     iDurationField = field.getDurationField(); [EOL]     iDivisor = divisor; [EOL] }
public RemainderDateTimeField(DividedDateTimeField dividedField) { [EOL]     this(dividedField, dividedField.getType()); [EOL] }
public RemainderDateTimeField(DividedDateTimeField dividedField) { [EOL]     this(dividedField, dividedField.getType()); [EOL] }
public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) { [EOL]     this(dividedField, dividedField.getWrappedField().getDurationField(), type); [EOL] }
public RemainderDateTimeField(DividedDateTimeField dividedField, DurationField durationField, DateTimeFieldType type) { [EOL]     super(dividedField.getWrappedField(), type); [EOL]     iDivisor = dividedField.iDivisor; [EOL]     iDurationField = durationField; [EOL]     iRangeField = dividedField.iDurationField; [EOL] }
public int get(long instant) { [EOL]     int value = getWrappedField().get(instant); [EOL]     if (value >= 0) { [EOL]         return value % iDivisor; [EOL]     } else { [EOL]         return (iDivisor - 1) + ((value + 1) % iDivisor); [EOL]     } [EOL] }
public int get(long instant) { [EOL]     int value = getWrappedField().get(instant); [EOL]     if (value >= 0) { [EOL]         return value % iDivisor; [EOL]     } else { [EOL]         return (iDivisor - 1) + ((value + 1) % iDivisor); [EOL]     } [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1); [EOL]     int divided = getDivided(getWrappedField().get(instant)); [EOL]     return getWrappedField().set(instant, divided * iDivisor + value); [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1); [EOL]     int divided = getDivided(getWrappedField().get(instant)); [EOL]     return getWrappedField().set(instant, divided * iDivisor + value); [EOL] }
@Override [EOL] public DurationField getDurationField() { [EOL]     return iDurationField; [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iRangeField; [EOL] }
public int getMinimumValue() { [EOL]     return 0; [EOL] }
public int getMaximumValue() { [EOL]     return iDivisor - 1; [EOL] }
private int getDivided(int value) { [EOL]     if (value >= 0) { [EOL]         return value / iDivisor; [EOL]     } else { [EOL]         return ((value + 1) / iDivisor) - 1; [EOL]     } [EOL] }
private int getDivided(int value) { [EOL]     if (value >= 0) { [EOL]         return value / iDivisor; [EOL]     } else { [EOL]         return ((value + 1) / iDivisor) - 1; [EOL]     } [EOL] }
private int getDivided(int value) { [EOL]     if (value >= 0) { [EOL]         return value / iDivisor; [EOL]     } else { [EOL]         return ((value + 1) / iDivisor) - 1; [EOL]     } [EOL] }
public int getMinimumValue() { [EOL]     return 1; [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL]     return iChronology.getDaysInMonthMaxForSet(instant, value); [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL]     return iChronology.getDaysInMonthMaxForSet(instant, value); [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static int calculateDigitCount(long value) { [EOL]     if (value < 0) { [EOL]         if (value != Long.MIN_VALUE) { [EOL]             return calculateDigitCount(-value) + 1; [EOL]         } else { [EOL]             return 20; [EOL]         } [EOL]     } [EOL]     return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1))))); [EOL] }
static String createErrorMessage(final String text, final int errorPos) { [EOL]     int sampleLen = errorPos + 32; [EOL]     String sampleText; [EOL]     if (text.length() <= sampleLen + 3) { [EOL]         sampleText = text; [EOL]     } else { [EOL]         sampleText = text.substring(0, sampleLen).concat("..."); [EOL]     } [EOL]     if (errorPos <= 0) { [EOL]         return "Invalid format: \"" + sampleText + '"'; [EOL]     } [EOL]     if (errorPos >= text.length()) { [EOL]         return "Invalid format: \"" + sampleText + "\" is too short"; [EOL]     } [EOL]     return "Invalid format: \"" + sampleText + "\" is malformed at \"" + sampleText.substring(errorPos) + '"'; [EOL] }
static String createErrorMessage(final String text, final int errorPos) { [EOL]     int sampleLen = errorPos + 32; [EOL]     String sampleText; [EOL]     if (text.length() <= sampleLen + 3) { [EOL]         sampleText = text; [EOL]     } else { [EOL]         sampleText = text.substring(0, sampleLen).concat("..."); [EOL]     } [EOL]     if (errorPos <= 0) { [EOL]         return "Invalid format: \"" + sampleText + '"'; [EOL]     } [EOL]     if (errorPos >= text.length()) { [EOL]         return "Invalid format: \"" + sampleText + "\" is too short"; [EOL]     } [EOL]     return "Invalid format: \"" + sampleText + "\" is malformed at \"" + sampleText.substring(errorPos) + '"'; [EOL] }
static int adjustYearForSet(int year) { [EOL]     if (year <= 0) { [EOL]         if (year == 0) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(year), null, null); [EOL]         } [EOL]         year++; [EOL]     } [EOL]     return year; [EOL] }
static int adjustYearForSet(int year) { [EOL]     if (year <= 0) { [EOL]         if (year == 0) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(year), null, null); [EOL]         } [EOL]         year++; [EOL]     } [EOL]     return year; [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) throws IllegalArgumentException { [EOL]     return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth); [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) throws IllegalArgumentException { [EOL]     return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth); [EOL] }
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) throws IllegalArgumentException { [EOL]     return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth); [EOL] }
boolean isLeapYear(int year) { [EOL]     return (year & 3) == 0; [EOL] }
boolean isLeapYear(int year) { [EOL]     return (year & 3) == 0; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1968; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1968; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1968; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long getAverageMillisPerYearDividedByTwo() { [EOL]     return MILLIS_PER_YEAR / 2; [EOL] }
long getApproxMillisAtEpochDividedByTwo() { [EOL]     return (1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY) / 2; [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono == null) { [EOL]         chrono = ((ReadableInstant) object).getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono == null) { [EOL]         chrono = ((ReadableInstant) object).getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized BuddhistChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     BuddhistChronology chrono; [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null); [EOL]             DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]             chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), ""); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized BuddhistChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     BuddhistChronology chrono; [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null); [EOL]             DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]             chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), ""); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public int getMinimumValue() { [EOL]     return getField().getMinimumValue(getReadablePartial()); [EOL] }
public PreciseDurationField(DurationFieldType type, long unitMillis) { [EOL]     super(type); [EOL]     iUnitMillis = unitMillis; [EOL] }
public final boolean isPrecise() { [EOL]     return true; [EOL] }
public final long getUnitMillis() { [EOL]     return iUnitMillis; [EOL] }
public long getValueAsLong(long duration, long instant) { [EOL]     return duration / iUnitMillis; [EOL] }
public long getMillis(long value, long instant) { [EOL]     return FieldUtils.safeMultiply(value, iUnitMillis); [EOL] }
public long getMillis(long value, long instant) { [EOL]     return FieldUtils.safeMultiply(value, iUnitMillis); [EOL] }
public long add(long instant, long value) { [EOL]     long addition = FieldUtils.safeMultiply(value, iUnitMillis); [EOL]     return FieldUtils.safeAdd(instant, addition); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     long difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant); [EOL]     return difference / iUnitMillis; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     long difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant); [EOL]     return difference / iUnitMillis; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     long difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant); [EOL]     return difference / iUnitMillis; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendYear = iChronology.getYear(minuendInstant); [EOL]     int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear); [EOL]     int subtrahendYear = iChronology.getYear(subtrahendInstant); [EOL]     int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear); [EOL]     long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth; [EOL]     int minuendDom = iChronology.getDayOfMonth(minuendInstant, minuendYear, minuendMonth); [EOL]     if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) { [EOL]         int subtrahendDom = iChronology.getDayOfMonth(subtrahendInstant, subtrahendYear, subtrahendMonth); [EOL]         if (subtrahendDom > minuendDom) { [EOL]             subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom); [EOL]         } [EOL]     } [EOL]     long minuendRem = minuendInstant - iChronology.getYearMonthMillis(minuendYear, minuendMonth); [EOL]     long subtrahendRem = subtrahendInstant - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth); [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public long set(long instant, int month) { [EOL]     FieldUtils.verifyValueBounds(this, month, MIN, iMax); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisDom = iChronology.getDayOfMonth(instant, thisYear); [EOL]     int maxDom = iChronology.getDaysInYearMonth(thisYear, month); [EOL]     if (thisDom > maxDom) { [EOL]         thisDom = maxDom; [EOL]     } [EOL]     return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.getMillisOfDay(instant); [EOL] }
public long set(long instant, int month) { [EOL]     FieldUtils.verifyValueBounds(this, month, MIN, iMax); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisDom = iChronology.getDayOfMonth(instant, thisYear); [EOL]     int maxDom = iChronology.getDaysInYearMonth(thisYear, month); [EOL]     if (thisDom > maxDom) { [EOL]         thisDom = maxDom; [EOL]     } [EOL]     return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.getMillisOfDay(instant); [EOL] }
public long set(long instant, int month) { [EOL]     FieldUtils.verifyValueBounds(this, month, MIN, iMax); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisDom = iChronology.getDayOfMonth(instant, thisYear); [EOL]     int maxDom = iChronology.getDaysInYearMonth(thisYear, month); [EOL]     if (thisDom > maxDom) { [EOL]         thisDom = maxDom; [EOL]     } [EOL]     return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.getMillisOfDay(instant); [EOL] }
BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) { [EOL]     super(DateTimeFieldType.dayOfYear(), days); [EOL]     iChronology = chronology; [EOL] }
public int getMaximumValue() { [EOL]     return iChronology.getDaysInYearMax(); [EOL] }
public static int safeAdd(int val1, int val2) { [EOL]     int sum = val1 + val2; [EOL]     if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " + " + val2); [EOL]     } [EOL]     return sum; [EOL] }
public static int safeAdd(int val1, int val2) { [EOL]     int sum = val1 + val2; [EOL]     if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " + " + val2); [EOL]     } [EOL]     return sum; [EOL] }
public static int safeAdd(int val1, int val2) { [EOL]     int sum = val1 + val2; [EOL]     if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " + " + val2); [EOL]     } [EOL]     return sum; [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static int safeMultiply(int val1, int val2) { [EOL]     long total = (long) val1 * (long) val2; [EOL]     if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("Multiplication overflows an int: " + val1 + " * " + val2); [EOL]     } [EOL]     return (int) total; [EOL] }
public static long safeMultiply(long val1, long val2) { [EOL]     if (val2 == 1) { [EOL]         return val1; [EOL]     } [EOL]     if (val1 == 1) { [EOL]         return val2; [EOL]     } [EOL]     if (val1 == 0 || val2 == 0) { [EOL]         return 0; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, long val2) { [EOL]     if (val2 == 1) { [EOL]         return val1; [EOL]     } [EOL]     if (val1 == 1) { [EOL]         return val2; [EOL]     } [EOL]     if (val1 == 0 || val2 == 0) { [EOL]         return 0; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, long val2) { [EOL]     if (val2 == 1) { [EOL]         return val1; [EOL]     } [EOL]     if (val1 == 1) { [EOL]         return val2; [EOL]     } [EOL]     if (val1 == 0 || val2 == 0) { [EOL]         return 0; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, long val2) { [EOL]     if (val2 == 1) { [EOL]         return val1; [EOL]     } [EOL]     if (val1 == 1) { [EOL]         return val2; [EOL]     } [EOL]     if (val1 == 0 || val2 == 0) { [EOL]         return 0; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, long val2) { [EOL]     if (val2 == 1) { [EOL]         return val1; [EOL]     } [EOL]     if (val1 == 1) { [EOL]         return val2; [EOL]     } [EOL]     if (val1 == 0 || val2 == 0) { [EOL]         return 0; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, long val2) { [EOL]     if (val2 == 1) { [EOL]         return val1; [EOL]     } [EOL]     if (val1 == 1) { [EOL]         return val2; [EOL]     } [EOL]     if (val1 == 0 || val2 == 0) { [EOL]         return 0; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static long safeMultiply(long val1, long val2) { [EOL]     if (val2 == 1) { [EOL]         return val1; [EOL]     } [EOL]     if (val1 == 1) { [EOL]         return val2; [EOL]     } [EOL]     if (val1 == 0 || val2 == 0) { [EOL]         return 0; [EOL]     } [EOL]     long total = val1 * val2; [EOL]     if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); [EOL]     } [EOL]     return total; [EOL] }
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static ConverterManager getInstance() { [EOL]     if (INSTANCE == null) { [EOL]         INSTANCE = new ConverterManager(); [EOL]     } [EOL]     return INSTANCE; [EOL] }
public static ConverterManager getInstance() { [EOL]     if (INSTANCE == null) { [EOL]         INSTANCE = new ConverterManager(); [EOL]     } [EOL]     return INSTANCE; [EOL] }
public DurationConverter getDurationConverter(Object object) { [EOL]     DurationConverter converter = (DurationConverter) iDurationConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No duration converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public DurationConverter getDurationConverter(Object object) { [EOL]     DurationConverter converter = (DurationConverter) iDurationConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No duration converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public DurationConverter addDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter addDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter getPeriodConverter(Object object) { [EOL]     PeriodConverter converter = (PeriodConverter) iPeriodConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No period converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PeriodConverter getPeriodConverter(Object object) { [EOL]     PeriodConverter converter = (PeriodConverter) iPeriodConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No period converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PeriodConverter getPeriodConverter(Object object) { [EOL]     PeriodConverter converter = (PeriodConverter) iPeriodConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No period converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PeriodConverter addPeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter addPeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public IntervalConverter getIntervalConverter(Object object) { [EOL]     IntervalConverter converter = (IntervalConverter) iIntervalConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No interval converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public IntervalConverter getIntervalConverter(Object object) { [EOL]     IntervalConverter converter = (IntervalConverter) iIntervalConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No interval converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public IntervalConverter getIntervalConverter(Object object) { [EOL]     IntervalConverter converter = (IntervalConverter) iIntervalConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No interval converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public IntervalConverter addIntervalConverter(IntervalConverter converter) throws SecurityException { [EOL]     checkAlterIntervalConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     IntervalConverter[] removed = new IntervalConverter[1]; [EOL]     iIntervalConverters = iIntervalConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public IntervalConverter addIntervalConverter(IntervalConverter converter) throws SecurityException { [EOL]     checkAlterIntervalConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     IntervalConverter[] removed = new IntervalConverter[1]; [EOL]     iIntervalConverters = iIntervalConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public boolean isLenient() { [EOL]     return iField.isLenient(); [EOL] }
protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadableInstant objects must not be null"); [EOL]     } [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]     int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis()); [EOL]     return amount; [EOL] }
protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadableInstant objects must not be null"); [EOL]     } [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]     int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis()); [EOL]     return amount; [EOL] }
protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadableInstant objects must not be null"); [EOL]     } [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]     int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis()); [EOL]     return amount; [EOL] }
protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(start) == false) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]     } [EOL]     Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]     int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972)); [EOL]     return values[0]; [EOL] }
protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(start) == false) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]     } [EOL]     Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]     int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972)); [EOL]     return values[0]; [EOL] }
protected BaseSingleFieldPeriod(int period) { [EOL]     super(); [EOL]     iPeriod = period; [EOL] }
protected BaseSingleFieldPeriod(int period) { [EOL]     super(); [EOL]     iPeriod = period; [EOL] }
protected BaseSingleFieldPeriod(int period) { [EOL]     super(); [EOL]     iPeriod = period; [EOL] }
protected int getValue() { [EOL]     return iPeriod; [EOL] }
protected void setValue(int value) { [EOL]     iPeriod = value; [EOL] }
public int size() { [EOL]     return 1; [EOL] }
public DurationFieldType getFieldType(int index) { [EOL]     if (index != 0) { [EOL]         throw new IndexOutOfBoundsException(String.valueOf(index)); [EOL]     } [EOL]     return getFieldType(); [EOL] }
public DurationFieldType getFieldType(int index) { [EOL]     if (index != 0) { [EOL]         throw new IndexOutOfBoundsException(String.valueOf(index)); [EOL]     } [EOL]     return getFieldType(); [EOL] }
public int get(DurationFieldType type) { [EOL]     if (type == getFieldType()) { [EOL]         return getValue(); [EOL]     } [EOL]     return 0; [EOL] }
public int get(DurationFieldType type) { [EOL]     if (type == getFieldType()) { [EOL]         return getValue(); [EOL]     } [EOL]     return 0; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     return (type == getFieldType()); [EOL] }
public Period toPeriod() { [EOL]     return Period.ZERO.withFields(this); [EOL] }
public boolean equals(Object period) { [EOL]     if (this == period) { [EOL]         return true; [EOL]     } [EOL]     if (period instanceof ReadablePeriod == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePeriod other = (ReadablePeriod) period; [EOL]     return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue()); [EOL] }
public boolean equals(Object period) { [EOL]     if (this == period) { [EOL]         return true; [EOL]     } [EOL]     if (period instanceof ReadablePeriod == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePeriod other = (ReadablePeriod) period; [EOL]     return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue()); [EOL] }
public boolean equals(Object period) { [EOL]     if (this == period) { [EOL]         return true; [EOL]     } [EOL]     if (period instanceof ReadablePeriod == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePeriod other = (ReadablePeriod) period; [EOL]     return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue()); [EOL] }
public boolean equals(Object period) { [EOL]     if (this == period) { [EOL]         return true; [EOL]     } [EOL]     if (period instanceof ReadablePeriod == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePeriod other = (ReadablePeriod) period; [EOL]     return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue()); [EOL] }
public boolean equals(Object period) { [EOL]     if (this == period) { [EOL]         return true; [EOL]     } [EOL]     if (period instanceof ReadablePeriod == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePeriod other = (ReadablePeriod) period; [EOL]     return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue()); [EOL] }
public boolean equals(Object period) { [EOL]     if (this == period) { [EOL]         return true; [EOL]     } [EOL]     if (period instanceof ReadablePeriod == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePeriod other = (ReadablePeriod) period; [EOL]     return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue()); [EOL] }
public int hashCode() { [EOL]     int total = 17; [EOL]     total = 27 * total + getValue(); [EOL]     total = 27 * total + getFieldType().hashCode(); [EOL]     return total; [EOL] }
public int hashCode() { [EOL]     int total = 17; [EOL]     total = 27 * total + getValue(); [EOL]     total = 27 * total + getFieldType().hashCode(); [EOL]     return total; [EOL] }
public int hashCode() { [EOL]     int total = 17; [EOL]     total = 27 * total + getValue(); [EOL]     total = 27 * total + getFieldType().hashCode(); [EOL]     return total; [EOL] }
int getMonthOfYear(long millis, int year) { [EOL]     int i = (int) ((millis - getYearMillis(year)) >> 10); [EOL]     return (isLeapYear(year)) ? ((i < 182 * 84375) ? ((i < 91 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3) : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6)) : ((i < 274 * 84375) ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9) : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12))) : ((i < 181 * 84375) ? ((i < 90 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3) : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6)) : ((i < 273 * 84375) ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9) : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12))); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInMonthMaxForSet(long instant, int value) { [EOL]     return ((value > 28 || value < 1) ? getDaysInMonthMax(instant) : 28); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInMonthMaxForSet(long instant, int value) { [EOL]     return ((value > 28 || value < 1) ? getDaysInMonthMax(instant) : 28); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInMonthMaxForSet(long instant, int value) { [EOL]     return ((value > 28 || value < 1) ? getDaysInMonthMax(instant) : 28); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (isLeapYear(year)) { [EOL]         return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } else { [EOL]         return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL]     } [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
@ToString [EOL] public String toString() { [EOL]     return "PT" + String.valueOf(getValue()) + "S"; [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "PT" + String.valueOf(getValue()) + "S"; [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "PT" + String.valueOf(getValue()) + "S"; [EOL] }
public long add(long instant, long amount) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().add(instant, amount); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public int getLeapAmount(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getLeapAmount(instant); [EOL] }
public int getLeapAmount(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getLeapAmount(instant); [EOL] }
public int getMinimumValue(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getMinimumValue(instant); [EOL] }
public int getMinimumValue(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getMinimumValue(instant); [EOL] }
public int getMinimumValue(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().getMinimumValue(instant); [EOL] }
public int getEra() { [EOL]     return getChronology().era().get(getMillis()); [EOL] }
public int getCenturyOfEra() { [EOL]     return getChronology().centuryOfEra().get(getMillis()); [EOL] }
public int getYearOfEra() { [EOL]     return getChronology().yearOfEra().get(getMillis()); [EOL] }
public int getYearOfCentury() { [EOL]     return getChronology().yearOfCentury().get(getMillis()); [EOL] }
public int getYear() { [EOL]     return getChronology().year().get(getMillis()); [EOL] }
public int getDayOfYear() { [EOL]     return getChronology().dayOfYear().get(getMillis()); [EOL] }
public int getDayOfWeek() { [EOL]     return getChronology().dayOfWeek().get(getMillis()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LenientChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LenientChronology chrono = (LenientChronology) obj; [EOL]     return getBase().equals(chrono.getBase()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LenientChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LenientChronology chrono = (LenientChronology) obj; [EOL]     return getBase().equals(chrono.getBase()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LenientChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LenientChronology chrono = (LenientChronology) obj; [EOL]     return getBase().equals(chrono.getBase()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LenientChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LenientChronology chrono = (LenientChronology) obj; [EOL]     return getBase().equals(chrono.getBase()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LenientChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LenientChronology chrono = (LenientChronology) obj; [EOL]     return getBase().equals(chrono.getBase()); [EOL] }
public int hashCode() { [EOL]     return 236548278 + getBase().hashCode() * 7; [EOL] }
public static Weeks weeksBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int weeks = chrono.weeks().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Weeks.weeks(weeks); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Weeks.weeks(amount); [EOL] }
public static Weeks weeksBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int weeks = chrono.weeks().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Weeks.weeks(weeks); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Weeks.weeks(amount); [EOL] }
public static Weeks weeksIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Weeks.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks()); [EOL]     return Weeks.weeks(amount); [EOL] }
public static Weeks weeksIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Weeks.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks()); [EOL]     return Weeks.weeks(amount); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_WEEK)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_WEEK)); [EOL] }
public Weeks plus(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     return Weeks.weeks(FieldUtils.safeAdd(getValue(), weeks)); [EOL] }
public Weeks plus(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     return Weeks.weeks(FieldUtils.safeAdd(getValue(), weeks)); [EOL] }
public Weeks plus(Weeks weeks) { [EOL]     if (weeks == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(weeks.getValue()); [EOL] }
public Weeks plus(Weeks weeks) { [EOL]     if (weeks == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(weeks.getValue()); [EOL] }
public Weeks minus(int weeks) { [EOL]     return plus(FieldUtils.safeNegate(weeks)); [EOL] }
public Weeks minus(int weeks) { [EOL]     return plus(FieldUtils.safeNegate(weeks)); [EOL] }
public Weeks minus(int weeks) { [EOL]     return plus(FieldUtils.safeNegate(weeks)); [EOL] }
GJMonthOfYearDateTimeField(BasicChronology chronology) { [EOL]     super(chronology, 2); [EOL] }
GJMonthOfYearDateTimeField(BasicChronology chronology) { [EOL]     super(chronology, 2); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(fieldValue); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength(); [EOL] }
public static DateTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new DateTime(chronology); [EOL] }
public static DateTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new DateTime(chronology); [EOL] }
@FromString [EOL] public static DateTime parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); [EOL] }
@FromString [EOL] public static DateTime parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); [EOL] }
@FromString [EOL] public static DateTime parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser().withOffsetParsed()); [EOL] }
public DateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, Chronology chronology) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0, chronology); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0, chronology); [EOL] }
public DateTime toDateTimeISO() { [EOL]     if (getChronology() == ISOChronology.getInstance()) { [EOL]         return this; [EOL]     } [EOL]     return super.toDateTimeISO(); [EOL] }
public DateTime toDateTimeISO() { [EOL]     if (getChronology() == ISOChronology.getInstance()) { [EOL]         return this; [EOL]     } [EOL]     return super.toDateTimeISO(); [EOL] }
public DateTime toDateTime(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     if (getZone() == zone) { [EOL]         return this; [EOL]     } [EOL]     return super.toDateTime(zone); [EOL] }
public DateTime toDateTime(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     if (getZone() == zone) { [EOL]         return this; [EOL]     } [EOL]     return super.toDateTime(zone); [EOL] }
public DateTime toDateTime(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     if (getChronology() == chronology) { [EOL]         return this; [EOL]     } [EOL]     return super.toDateTime(chronology); [EOL] }
public DateTime toDateTime(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     if (getChronology() == chronology) { [EOL]         return this; [EOL]     } [EOL]     return super.toDateTime(chronology); [EOL] }
public DateTime withChronology(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology)); [EOL] }
public DateTime withChronology(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology)); [EOL] }
public DateTime withChronology(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology)); [EOL] }
public DateTime withZone(DateTimeZone newZone) { [EOL]     return withChronology(getChronology().withZone(newZone)); [EOL] }
public DateTime withZone(DateTimeZone newZone) { [EOL]     return withChronology(getChronology().withZone(newZone)); [EOL] }
public DateTime withZone(DateTimeZone newZone) { [EOL]     return withChronology(getChronology().withZone(newZone)); [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getMillis(), millis); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime withEra(int era) { [EOL]     return withMillis(getChronology().era().set(getMillis(), era)); [EOL] }
public DateTime withEra(int era) { [EOL]     return withMillis(getChronology().era().set(getMillis(), era)); [EOL] }
public DateTime withCenturyOfEra(int centuryOfEra) { [EOL]     return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra)); [EOL] }
public DateTime withCenturyOfEra(int centuryOfEra) { [EOL]     return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra)); [EOL] }
public DateTime withCenturyOfEra(int centuryOfEra) { [EOL]     return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra)); [EOL] }
public DateTime withYearOfEra(int yearOfEra) { [EOL]     return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra)); [EOL] }
public DateTime withYearOfEra(int yearOfEra) { [EOL]     return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra)); [EOL] }
public DateTime withYearOfEra(int yearOfEra) { [EOL]     return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra)); [EOL] }
public DateTime withYearOfCentury(int yearOfCentury) { [EOL]     return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury)); [EOL] }
public DateTime withYearOfCentury(int yearOfCentury) { [EOL]     return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury)); [EOL] }
public DateTime withYear(int year) { [EOL]     return withMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public DateTime withYear(int year) { [EOL]     return withMillis(getChronology().year().set(getMillis(), year)); [EOL] }
public DateTime withWeekyear(int weekyear) { [EOL]     return withMillis(getChronology().weekyear().set(getMillis(), weekyear)); [EOL] }
public DateTime withWeekyear(int weekyear) { [EOL]     return withMillis(getChronology().weekyear().set(getMillis(), weekyear)); [EOL] }
public DateTime withWeekyear(int weekyear) { [EOL]     return withMillis(getChronology().weekyear().set(getMillis(), weekyear)); [EOL] }
public DateTime withMonthOfYear(int monthOfYear) { [EOL]     return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); [EOL] }
public DateTime withMonthOfYear(int monthOfYear) { [EOL]     return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear)); [EOL] }
public DateTime withDayOfYear(int dayOfYear) { [EOL]     return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); [EOL] }
public DateTime withDayOfYear(int dayOfYear) { [EOL]     return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); [EOL] }
public DateTime withDayOfYear(int dayOfYear) { [EOL]     return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); [EOL] }
public DateTime withSecondOfMinute(int second) { [EOL]     return withMillis(getChronology().secondOfMinute().set(getMillis(), second)); [EOL] }
public DateTime withSecondOfMinute(int second) { [EOL]     return withMillis(getChronology().secondOfMinute().set(getMillis(), second)); [EOL] }
public DateTime withMillisOfDay(int millis) { [EOL]     return withMillis(getChronology().millisOfDay().set(getMillis(), millis)); [EOL] }
public DateTime withMillisOfDay(int millis) { [EOL]     return withMillis(getChronology().millisOfDay().set(getMillis(), millis)); [EOL] }
public DateTime withMillisOfDay(int millis) { [EOL]     return withMillis(getChronology().millisOfDay().set(getMillis(), millis)); [EOL] }
public Property monthOfYear() { [EOL]     return new Property(this, getChronology().monthOfYear()); [EOL] }
public Property dayOfMonth() { [EOL]     return new Property(this, getChronology().dayOfMonth()); [EOL] }
public Property secondOfDay() { [EOL]     return new Property(this, getChronology().secondOfDay()); [EOL] }
public DateTime roundFloorCopy() { [EOL]     return iInstant.withMillis(iField.roundFloor(iInstant.getMillis())); [EOL] }
public DateTime roundHalfEvenCopy() { [EOL]     return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis())); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values) { [EOL]     this(types, values, null); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values) { [EOL]     this(types, values, null); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values) { [EOL]     this(types, values, null); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values) { [EOL]     this(types, values, null); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
Partial(Partial partial, int[] values) { [EOL]     super(); [EOL]     iChronology = partial.iChronology; [EOL]     iTypes = partial.iTypes; [EOL]     iValues = values; [EOL] }
Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) { [EOL]     super(); [EOL]     iChronology = chronology; [EOL]     iTypes = types; [EOL]     iValues = values; [EOL] }
Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) { [EOL]     super(); [EOL]     iChronology = chronology; [EOL]     iTypes = types; [EOL]     iValues = values; [EOL] }
Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) { [EOL]     super(); [EOL]     iChronology = chronology; [EOL]     iTypes = types; [EOL]     iValues = values; [EOL] }
Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) { [EOL]     super(); [EOL]     iChronology = chronology; [EOL]     iTypes = types; [EOL]     iValues = values; [EOL] }
Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) { [EOL]     super(); [EOL]     iChronology = chronology; [EOL]     iTypes = types; [EOL]     iValues = values; [EOL] }
public DateTimeFieldType getFieldType(int index) { [EOL]     return iTypes[index]; [EOL] }
public DateTimeFieldType getFieldType(int index) { [EOL]     return iTypes[index]; [EOL] }
public int getValue(int index) { [EOL]     return iValues[index]; [EOL] }
public int[] getValues() { [EOL]     return (int[]) iValues.clone(); [EOL] }
public Partial withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         Partial newPartial = new Partial(newChronology, iTypes, iValues); [EOL]         newChronology.validate(newPartial, iValues); [EOL]         return newPartial; [EOL]     } [EOL] }
public Partial withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         Partial newPartial = new Partial(newChronology, iTypes, iValues); [EOL]         newChronology.validate(newPartial, iValues); [EOL]         return newPartial; [EOL]     } [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial without(DateTimeFieldType fieldType) { [EOL]     int index = indexOf(fieldType); [EOL]     if (index != -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1]; [EOL]         int[] newValues = new int[size() - 1]; [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, index); [EOL]         System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index); [EOL]         System.arraycopy(iValues, 0, newValues, 0, index); [EOL]         System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index); [EOL]         Partial newPartial = new Partial(iChronology, newTypes, newValues); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     return this; [EOL] }
public Partial without(DateTimeFieldType fieldType) { [EOL]     int index = indexOf(fieldType); [EOL]     if (index != -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1]; [EOL]         int[] newValues = new int[size() - 1]; [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, index); [EOL]         System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index); [EOL]         System.arraycopy(iValues, 0, newValues, 0, index); [EOL]         System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index); [EOL]         Partial newPartial = new Partial(iChronology, newTypes, newValues); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     return this; [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] }
Property(Partial partial, int fieldIndex) { [EOL]     super(); [EOL]     iPartial = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] }
Property(Partial partial, int fieldIndex) { [EOL]     super(); [EOL]     iPartial = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] }
public DateTimeField getField() { [EOL]     return iPartial.getField(iFieldIndex); [EOL] }
public DateTimeField getField() { [EOL]     return iPartial.getField(iFieldIndex); [EOL] }
protected ReadablePartial getReadablePartial() { [EOL]     return iPartial; [EOL] }
public Partial setCopy(int value) { [EOL]     int[] newValues = iPartial.getValues(); [EOL]     newValues = getField().set(iPartial, iFieldIndex, newValues, value); [EOL]     return new Partial(iPartial, newValues); [EOL] }
public Partial setCopy(int value) { [EOL]     int[] newValues = iPartial.getValues(); [EOL]     newValues = getField().set(iPartial, iFieldIndex, newValues, value); [EOL]     return new Partial(iPartial, newValues); [EOL] }
public Partial setCopy(String text, Locale locale) { [EOL]     int[] newValues = iPartial.getValues(); [EOL]     newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale); [EOL]     return new Partial(iPartial, newValues); [EOL] }
public Partial setCopy(String text, Locale locale) { [EOL]     int[] newValues = iPartial.getValues(); [EOL]     newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale); [EOL]     return new Partial(iPartial, newValues); [EOL] }
public Partial setCopy(String text, Locale locale) { [EOL]     int[] newValues = iPartial.getValues(); [EOL]     newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale); [EOL]     return new Partial(iPartial, newValues); [EOL] }
public Partial setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public Partial setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public Partial withMinimumValue() { [EOL]     return setCopy(getMinimumValue()); [EOL] }
public Period toPeriod(PeriodType type) { [EOL]     return new Period(getMillis(), type); [EOL] }
public Period toPeriod(PeriodType type) { [EOL]     return new Period(getMillis(), type); [EOL] }
public Period toPeriodTo(ReadableInstant endInstant, PeriodType type) { [EOL]     return new Period(this, endInstant, type); [EOL] }
public Period toPeriodTo(ReadableInstant endInstant, PeriodType type) { [EOL]     return new Period(this, endInstant, type); [EOL] }
public Period toPeriodTo(ReadableInstant endInstant, PeriodType type) { [EOL]     return new Period(this, endInstant, type); [EOL] }
@FromString [EOL] public static Years parseYears(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Years.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Years.years(p.getYears()); [EOL] }
@FromString [EOL] public static Years parseYears(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Years.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Years.years(p.getYears()); [EOL] }
@FromString [EOL] public static Years parseYears(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Years.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Years.years(p.getYears()); [EOL] }
public Years minus(Years years) { [EOL]     if (years == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(years.getValue()); [EOL] }
public Years minus(Years years) { [EOL]     if (years == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(years.getValue()); [EOL] }
@FromString [EOL] public static Instant parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser()); [EOL] }
@FromString [EOL] public static Instant parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.dateTimeParser()); [EOL] }
public static Instant parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str).toInstant(); [EOL] }
public static Instant parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str).toInstant(); [EOL] }
public LocalDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC()); [EOL] }
public LocalDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC()); [EOL] }
public LocalDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC()); [EOL] }
public LocalDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC()); [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType durType = type.getDurationType(); [EOL]     if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return type.getField(getChronology()).isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType durType = type.getDurationType(); [EOL]     if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return type.getField(getChronology()).isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType durType = type.getDurationType(); [EOL]     if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return type.getField(getChronology()).isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType durType = type.getDurationType(); [EOL]     if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { [EOL]         return type.getField(getChronology()).isSupported(); [EOL]     } [EOL]     return false; [EOL] }
@Deprecated [EOL] public DateMidnight toDateMidnight(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono); [EOL] }
@Deprecated [EOL] public DateMidnight toDateMidnight(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono); [EOL] }
public DateTime toDateTime(LocalTime time, DateTimeZone zone) { [EOL]     if (time != null && getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instant = DateTimeUtils.currentTimeMillis(); [EOL]     instant = chrono.set(this, instant); [EOL]     if (time != null) { [EOL]         instant = chrono.set(time, instant); [EOL]     } [EOL]     return new DateTime(instant, chrono); [EOL] }
public DateTime toDateTime(LocalTime time, DateTimeZone zone) { [EOL]     if (time != null && getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instant = DateTimeUtils.currentTimeMillis(); [EOL]     instant = chrono.set(this, instant); [EOL]     if (time != null) { [EOL]         instant = chrono.set(time, instant); [EOL]     } [EOL]     return new DateTime(instant, chrono); [EOL] }
public DateTime toDateTime(LocalTime time, DateTimeZone zone) { [EOL]     if (time != null && getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instant = DateTimeUtils.currentTimeMillis(); [EOL]     instant = chrono.set(this, instant); [EOL]     if (time != null) { [EOL]         instant = chrono.set(time, instant); [EOL]     } [EOL]     return new DateTime(instant, chrono); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().subtract(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public Property era() { [EOL]     return new Property(this, getChronology().era()); [EOL] }
public Property centuryOfEra() { [EOL]     return new Property(this, getChronology().centuryOfEra()); [EOL] }
public Property yearOfCentury() { [EOL]     return new Property(this, getChronology().yearOfCentury()); [EOL] }
public Property yearOfEra() { [EOL]     return new Property(this, getChronology().yearOfEra()); [EOL] }
public Property weekyear() { [EOL]     return new Property(this, getChronology().weekyear()); [EOL] }
public Property weekOfWeekyear() { [EOL]     return new Property(this, getChronology().weekOfWeekyear()); [EOL] }
public Property dayOfYear() { [EOL]     return new Property(this, getChronology().dayOfYear()); [EOL] }
public Property dayOfWeek() { [EOL]     return new Property(this, getChronology().dayOfWeek()); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return ISODateTimeFormat.date().print(this); [EOL] }
protected Chronology getChronology() { [EOL]     return iInstant.getChronology(); [EOL] }
public LocalDate getLocalDate() { [EOL]     return iInstant; [EOL] }
public LocalDate addToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDate addToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDate addToCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value)); [EOL] }
public static PeriodFormatter wordBased(Locale locale) { [EOL]     PeriodFormatter pf = FORMATTERS.get(locale); [EOL]     if (pf == null) { [EOL]         ResourceBundle b = ResourceBundle.getBundle(BUNDLE_NAME, locale); [EOL]         String[] variants = { b.getString("PeriodFormat.space"), b.getString("PeriodFormat.comma"), b.getString("PeriodFormat.commandand"), b.getString("PeriodFormat.commaspaceand") }; [EOL]         pf = new PeriodFormatterBuilder().appendYears().appendSuffix(b.getString("PeriodFormat.year"), b.getString("PeriodFormat.years")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendMonths().appendSuffix(b.getString("PeriodFormat.month"), b.getString("PeriodFormat.months")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendWeeks().appendSuffix(b.getString("PeriodFormat.week"), b.getString("PeriodFormat.weeks")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendDays().appendSuffix(b.getString("PeriodFormat.day"), b.getString("PeriodFormat.days")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendHours().appendSuffix(b.getString("PeriodFormat.hour"), b.getString("PeriodFormat.hours")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendMinutes().appendSuffix(b.getString("PeriodFormat.minute"), b.getString("PeriodFormat.minutes")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendSeconds().appendSuffix(b.getString("PeriodFormat.second"), b.getString("PeriodFormat.seconds")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendMillis().appendSuffix(b.getString("PeriodFormat.millisecond"), b.getString("PeriodFormat.milliseconds")).toFormatter(); [EOL]         FORMATTERS.putIfAbsent(locale, pf); [EOL]     } [EOL]     return pf; [EOL] }
public static PeriodFormatter wordBased(Locale locale) { [EOL]     PeriodFormatter pf = FORMATTERS.get(locale); [EOL]     if (pf == null) { [EOL]         ResourceBundle b = ResourceBundle.getBundle(BUNDLE_NAME, locale); [EOL]         String[] variants = { b.getString("PeriodFormat.space"), b.getString("PeriodFormat.comma"), b.getString("PeriodFormat.commandand"), b.getString("PeriodFormat.commaspaceand") }; [EOL]         pf = new PeriodFormatterBuilder().appendYears().appendSuffix(b.getString("PeriodFormat.year"), b.getString("PeriodFormat.years")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendMonths().appendSuffix(b.getString("PeriodFormat.month"), b.getString("PeriodFormat.months")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendWeeks().appendSuffix(b.getString("PeriodFormat.week"), b.getString("PeriodFormat.weeks")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendDays().appendSuffix(b.getString("PeriodFormat.day"), b.getString("PeriodFormat.days")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendHours().appendSuffix(b.getString("PeriodFormat.hour"), b.getString("PeriodFormat.hours")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendMinutes().appendSuffix(b.getString("PeriodFormat.minute"), b.getString("PeriodFormat.minutes")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendSeconds().appendSuffix(b.getString("PeriodFormat.second"), b.getString("PeriodFormat.seconds")).appendSeparator(b.getString("PeriodFormat.commaspace"), b.getString("PeriodFormat.spaceandspace"), variants).appendMillis().appendSuffix(b.getString("PeriodFormat.millisecond"), b.getString("PeriodFormat.milliseconds")).toFormatter(); [EOL]         FORMATTERS.putIfAbsent(locale, pf); [EOL]     } [EOL]     return pf; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
GJEraDateTimeField(BasicChronology chronology) { [EOL]     super(DateTimeFieldType.era()); [EOL]     iChronology = chronology; [EOL] }
GJEraDateTimeField(BasicChronology chronology) { [EOL]     super(DateTimeFieldType.era()); [EOL]     iChronology = chronology; [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text)); [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text)); [EOL] }
public long set(long instant, String text, Locale locale) { [EOL]     return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text)); [EOL] }
public static PeriodType yearMonthDay() { [EOL]     PeriodType type = cYMD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearMonthDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days() }, new int[] { 0, 1, -1, 2, -1, -1, -1, -1 }); [EOL]         cYMD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearMonthDay() { [EOL]     PeriodType type = cYMD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearMonthDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days() }, new int[] { 0, 1, -1, 2, -1, -1, -1, -1 }); [EOL]         cYMD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearWeekDayTime() { [EOL]     PeriodType type = cYWDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearWeekDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 }); [EOL]         cYWDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearWeekDayTime() { [EOL]     PeriodType type = cYWDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearWeekDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 }); [EOL]         cYWDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearWeekDay() { [EOL]     PeriodType type = cYWD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearWeekDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days() }, new int[] { 0, -1, 1, 2, -1, -1, -1, -1 }); [EOL]         cYWD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearDay() { [EOL]     PeriodType type = cYD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days() }, new int[] { 0, -1, -1, 1, -1, -1, -1, -1 }); [EOL]         cYD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearDay() { [EOL]     PeriodType type = cYD; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearDay", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days() }, new int[] { 0, -1, -1, 1, -1, -1, -1, -1 }); [EOL]         cYD = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType years() { [EOL]     PeriodType type = cYears; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Years", new DurationFieldType[] { DurationFieldType.years() }, new int[] { 0, -1, -1, -1, -1, -1, -1, -1 }); [EOL]         cYears = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType months() { [EOL]     PeriodType type = cMonths; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Months", new DurationFieldType[] { DurationFieldType.months() }, new int[] { -1, 0, -1, -1, -1, -1, -1, -1 }); [EOL]         cMonths = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType months() { [EOL]     PeriodType type = cMonths; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Months", new DurationFieldType[] { DurationFieldType.months() }, new int[] { -1, 0, -1, -1, -1, -1, -1, -1 }); [EOL]         cMonths = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType weeks() { [EOL]     PeriodType type = cWeeks; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Weeks", new DurationFieldType[] { DurationFieldType.weeks() }, new int[] { -1, -1, 0, -1, -1, -1, -1, -1 }); [EOL]         cWeeks = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType weeks() { [EOL]     PeriodType type = cWeeks; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Weeks", new DurationFieldType[] { DurationFieldType.weeks() }, new int[] { -1, -1, 0, -1, -1, -1, -1, -1 }); [EOL]         cWeeks = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType seconds() { [EOL]     PeriodType type = cSeconds; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Seconds", new DurationFieldType[] { DurationFieldType.seconds() }, new int[] { -1, -1, -1, -1, -1, -1, 0, -1 }); [EOL]         cSeconds = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType millis() { [EOL]     PeriodType type = cMillis; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Millis", new DurationFieldType[] { DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, -1, -1, -1, 0 }); [EOL]         cMillis = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType millis() { [EOL]     PeriodType type = cMillis; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Millis", new DurationFieldType[] { DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, -1, -1, -1, 0 }); [EOL]         cMillis = type; [EOL]     } [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) { [EOL]     int realIndex = iIndices[index]; [EOL]     if (realIndex == -1) { [EOL]         throw new UnsupportedOperationException("Field is not supported"); [EOL]     } [EOL]     values[realIndex] = newValue; [EOL]     return true; [EOL] }
boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return false; [EOL]     } [EOL]     int realIndex = iIndices[index]; [EOL]     if (realIndex == -1) { [EOL]         throw new UnsupportedOperationException("Field is not supported"); [EOL]     } [EOL]     values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd); [EOL]     return true; [EOL] }
boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return false; [EOL]     } [EOL]     int realIndex = iIndices[index]; [EOL]     if (realIndex == -1) { [EOL]         throw new UnsupportedOperationException("Field is not supported"); [EOL]     } [EOL]     values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd); [EOL]     return true; [EOL] }
boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return false; [EOL]     } [EOL]     int realIndex = iIndices[index]; [EOL]     if (realIndex == -1) { [EOL]         throw new UnsupportedOperationException("Field is not supported"); [EOL]     } [EOL]     values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd); [EOL]     return true; [EOL] }
public static final long currentTimeMillis() { [EOL]     return cMillisProvider.getMillis(); [EOL] }
public static final void setCurrentMillisSystem() throws SecurityException { [EOL]     checkPermission(); [EOL]     cMillisProvider = SYSTEM_MILLIS_PROVIDER; [EOL] }
public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException { [EOL]     checkPermission(); [EOL]     if (offsetMillis == 0) { [EOL]         cMillisProvider = SYSTEM_MILLIS_PROVIDER; [EOL]     } else { [EOL]         cMillisProvider = new OffsetMillisProvider(offsetMillis); [EOL]     } [EOL] }
public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException { [EOL]     checkPermission(); [EOL]     if (offsetMillis == 0) { [EOL]         cMillisProvider = SYSTEM_MILLIS_PROVIDER; [EOL]     } else { [EOL]         cMillisProvider = new OffsetMillisProvider(offsetMillis); [EOL]     } [EOL] }
public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException { [EOL]     checkPermission(); [EOL]     if (offsetMillis == 0) { [EOL]         cMillisProvider = SYSTEM_MILLIS_PROVIDER; [EOL]     } else { [EOL]         cMillisProvider = new OffsetMillisProvider(offsetMillis); [EOL]     } [EOL] }
private static void checkPermission() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("CurrentTime.setProvider")); [EOL]     } [EOL] }
private static void checkPermission() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("CurrentTime.setProvider")); [EOL]     } [EOL] }
public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) { [EOL]     Chronology chrono = null; [EOL]     if (start != null) { [EOL]         chrono = start.getChronology(); [EOL]     } else if (end != null) { [EOL]         chrono = end.getChronology(); [EOL]     } [EOL]     if (chrono == null) { [EOL]         chrono = ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) { [EOL]     Chronology chrono = null; [EOL]     if (start != null) { [EOL]         chrono = start.getChronology(); [EOL]     } else if (end != null) { [EOL]         chrono = end.getChronology(); [EOL]     } [EOL]     if (chrono == null) { [EOL]         chrono = ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) { [EOL]     Chronology chrono = null; [EOL]     if (start != null) { [EOL]         chrono = start.getChronology(); [EOL]     } else if (end != null) { [EOL]         chrono = end.getChronology(); [EOL]     } [EOL]     if (chrono == null) { [EOL]         chrono = ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) { [EOL]     Chronology chrono = null; [EOL]     if (start != null) { [EOL]         chrono = start.getChronology(); [EOL]     } else if (end != null) { [EOL]         chrono = end.getChronology(); [EOL]     } [EOL]     if (chrono == null) { [EOL]         chrono = ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final ReadableInterval getReadableInterval(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         interval = new Interval(now, now); [EOL]     } [EOL]     return interval; [EOL] }
public static final ReadableInterval getReadableInterval(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         interval = new Interval(now, now); [EOL]     } [EOL]     return interval; [EOL] }
public static final DateTimeZone getZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         return DateTimeZone.getDefault(); [EOL]     } [EOL]     return zone; [EOL] }
public static final DateTimeZone getZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         return DateTimeZone.getDefault(); [EOL]     } [EOL]     return zone; [EOL] }
public static final double toJulianDay(long epochMillis) { [EOL]     double epochDay = epochMillis / 86400000d; [EOL]     return epochDay + 2440587.5d; [EOL] }
public static final long toJulianDayNumber(long epochMillis) { [EOL]     return (long) Math.floor(toJulianDay(epochMillis) + 0.5d); [EOL] }
public static final long toJulianDayNumber(long epochMillis) { [EOL]     return (long) Math.floor(toJulianDay(epochMillis) + 0.5d); [EOL] }
public static final long toJulianDayNumber(long epochMillis) { [EOL]     return (long) Math.floor(toJulianDay(epochMillis) + 0.5d); [EOL] }
public static final long fromJulianDay(double julianDay) { [EOL]     double epochDay = julianDay - 2440587.5d; [EOL]     return (long) (epochDay * 86400000d); [EOL] }
public static final long fromJulianDay(double julianDay) { [EOL]     double epochDay = julianDay - 2440587.5d; [EOL]     return (long) (epochDay * 86400000d); [EOL] }
public static final long fromJulianDay(double julianDay) { [EOL]     double epochDay = julianDay - 2440587.5d; [EOL]     return (long) (epochDay * 86400000d); [EOL] }
public long getMillis() { [EOL]     return System.currentTimeMillis(); [EOL] }
OffsetMillisProvider(long offsetMillis) { [EOL]     iMillis = offsetMillis; [EOL] }
OffsetMillisProvider(long offsetMillis) { [EOL]     iMillis = offsetMillis; [EOL] }
OffsetMillisProvider(long offsetMillis) { [EOL]     iMillis = offsetMillis; [EOL] }
public long getMillis() { [EOL]     return System.currentTimeMillis() + iMillis; [EOL] }
public long getMillis() { [EOL]     return System.currentTimeMillis() + iMillis; [EOL] }
public long getMillis() { [EOL]     return System.currentTimeMillis() + iMillis; [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     writableInterval.setChronology(chrono); [EOL]     long now = DateTimeUtils.currentTimeMillis(); [EOL]     writableInterval.setInterval(now, now); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     writableInterval.setChronology(chrono); [EOL]     long now = DateTimeUtils.currentTimeMillis(); [EOL]     writableInterval.setInterval(now, now); [EOL] }
protected BaseInterval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getInstantChronology(start); [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis); [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getInstantChronology(start); [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis); [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getInstantChronology(start); [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis); [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getInstantChronology(start); [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis); [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getInstantChronology(start); [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis); [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(end); [EOL]     iChronology = chrono; [EOL]     iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]     if (period == null) { [EOL]         iStartMillis = iEndMillis; [EOL]     } else { [EOL]         iStartMillis = chrono.add(period, iEndMillis, -1); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(end); [EOL]     iChronology = chrono; [EOL]     iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]     if (period == null) { [EOL]         iStartMillis = iEndMillis; [EOL]     } else { [EOL]         iStartMillis = chrono.add(period, iEndMillis, -1); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(Object interval, Chronology chrono) { [EOL]     super(); [EOL]     IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval); [EOL]     if (converter.isReadableInterval(interval, chrono)) { [EOL]         ReadableInterval input = (ReadableInterval) interval; [EOL]         iChronology = (chrono != null ? chrono : input.getChronology()); [EOL]         iStartMillis = input.getStartMillis(); [EOL]         iEndMillis = input.getEndMillis(); [EOL]     } else if (this instanceof ReadWritableInterval) { [EOL]         converter.setInto((ReadWritableInterval) this, interval, chrono); [EOL]     } else { [EOL]         MutableInterval mi = new MutableInterval(); [EOL]         converter.setInto(mi, interval, chrono); [EOL]         iChronology = mi.getChronology(); [EOL]         iStartMillis = mi.getStartMillis(); [EOL]         iEndMillis = mi.getEndMillis(); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected void setInterval(long startInstant, long endInstant, Chronology chrono) { [EOL]     checkInterval(startInstant, endInstant); [EOL]     iStartMillis = startInstant; [EOL]     iEndMillis = endInstant; [EOL]     iChronology = DateTimeUtils.getChronology(chrono); [EOL] }
protected void setInterval(long startInstant, long endInstant, Chronology chrono) { [EOL]     checkInterval(startInstant, endInstant); [EOL]     iStartMillis = startInstant; [EOL]     iEndMillis = endInstant; [EOL]     iChronology = DateTimeUtils.getChronology(chrono); [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getDayOfMonth(long millis, int year) { [EOL]     int month = getMonthOfYear(millis, year); [EOL]     return getDayOfMonth(millis, year, month); [EOL] }
int getDayOfYear(long instant, int year) { [EOL]     long yearStart = getYearMillis(year); [EOL]     return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1; [EOL] }
int getDayOfYear(long instant, int year) { [EOL]     long yearStart = getYearMillis(year); [EOL]     return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1; [EOL] }
int getDayOfYear(long instant, int year) { [EOL]     long yearStart = getYearMillis(year); [EOL]     return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1; [EOL] }
int getDayOfWeek(long instant) { [EOL]     long daysSince19700101; [EOL]     if (instant >= 0) { [EOL]         daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY; [EOL]     } else { [EOL]         daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY; [EOL]         if (daysSince19700101 < -3) { [EOL]             return 7 + (int) ((daysSince19700101 + 4) % 7); [EOL]         } [EOL]     } [EOL]     return 1 + (int) ((daysSince19700101 + 3) % 7); [EOL] }
int getDayOfWeek(long instant) { [EOL]     long daysSince19700101; [EOL]     if (instant >= 0) { [EOL]         daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY; [EOL]     } else { [EOL]         daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY; [EOL]         if (daysSince19700101 < -3) { [EOL]             return 7 + (int) ((daysSince19700101 + 4) % 7); [EOL]         } [EOL]     } [EOL]     return 1 + (int) ((daysSince19700101 + 3) % 7); [EOL] }
int getDayOfWeek(long instant) { [EOL]     long daysSince19700101; [EOL]     if (instant >= 0) { [EOL]         daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY; [EOL]     } else { [EOL]         daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY; [EOL]         if (daysSince19700101 < -3) { [EOL]             return 7 + (int) ((daysSince19700101 + 4) % 7); [EOL]         } [EOL]     } [EOL]     return 1 + (int) ((daysSince19700101 + 3) % 7); [EOL] }
int getMillisOfDay(long instant) { [EOL]     if (instant >= 0) { [EOL]         return (int) (instant % DateTimeConstants.MILLIS_PER_DAY); [EOL]     } else { [EOL]         return (DateTimeConstants.MILLIS_PER_DAY - 1) + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY); [EOL]     } [EOL] }
int getMillisOfDay(long instant) { [EOL]     if (instant >= 0) { [EOL]         return (int) (instant % DateTimeConstants.MILLIS_PER_DAY); [EOL]     } else { [EOL]         return (DateTimeConstants.MILLIS_PER_DAY - 1) + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY); [EOL]     } [EOL] }
public long set(long millis, String text, Locale locale) { [EOL]     return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text)); [EOL] }
public long set(long millis, String text, Locale locale) { [EOL]     return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text)); [EOL] }
public long set(long millis, String text, Locale locale) { [EOL]     return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text)); [EOL] }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(Object period, PeriodType type, Chronology chrono) { [EOL]     super(); [EOL]     PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period); [EOL]     type = (type == null ? converter.getPeriodType(period) : type); [EOL]     type = checkPeriodType(type); [EOL]     iType = type; [EOL]     if (this instanceof ReadWritablePeriod) { [EOL]         iValues = new int[size()]; [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         converter.setInto((ReadWritablePeriod) this, period, chrono); [EOL]     } else { [EOL]         iValues = new MutablePeriod(period, type, chrono).getValues(); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void setPeriod(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         setValues(new int[size()]); [EOL]     } else { [EOL]         setPeriodInternal(period); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
private void setPeriodInternal(ReadablePeriod period) { [EOL]     int[] newValues = new int[size()]; [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         DurationFieldType type = period.getFieldType(i); [EOL]         int value = period.getValue(i); [EOL]         checkAndUpdate(type, newValues, value); [EOL]     } [EOL]     setValues(newValues); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL]     int[] newValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); [EOL]     setValues(newValues); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
private static boolean dateByOrdinal(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfYear(3); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfYear(3); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByOrdinal(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfYear(3); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfYear(3); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByOrdinal(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfYear(3); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfYear(3); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByOrdinal(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfYear(3); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfYear(3); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
public static DateTimeFormatter localDateParser() { [EOL]     return Constants.ldp; [EOL] }
public static DateTimeFormatter dateElementParser() { [EOL]     return Constants.dpe; [EOL] }
public static DateTimeFormatter tTimeNoMillis() { [EOL]     return Constants.ttx; [EOL] }
public static DateTimeFormatter weekDateTimeNoMillis() { [EOL]     return Constants.wdtx; [EOL] }
public static DateTimeFormatter basicTTimeNoMillis() { [EOL]     return Constants.bttx; [EOL] }
public static DateTimeFormatter basicDateTime() { [EOL]     return Constants.bdt; [EOL] }
public static DateTimeFormatter basicOrdinalDateTime() { [EOL]     return Constants.bodt; [EOL] }
public static DateTimeFormatter basicOrdinalDateTimeNoMillis() { [EOL]     return Constants.bodtx; [EOL] }
public static DateTimeFormatter weekyearWeek() { [EOL]     return Constants.ww; [EOL] }
public static DateTimeFormatter dateHourMinuteSecond() { [EOL]     return Constants.dhms; [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY); [EOL] }
public Minutes multipliedBy(int scalar) { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Minutes multipliedBy(int scalar) { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Minutes multipliedBy(int scalar) { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Minutes multipliedBy(int scalar) { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public boolean isGreaterThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Minutes other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public static GregorianChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] }
public BaseDateTime(Object instant, Chronology chronology) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     iChronology = checkChronology(converter.getChronology(instant, chronology)); [EOL]     iMillis = checkInstant(converter.getInstantMillis(instant, chronology), iChronology); [EOL] }
public BaseDateTime(Object instant, Chronology chronology) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     iChronology = checkChronology(converter.getChronology(instant, chronology)); [EOL]     iMillis = checkInstant(converter.getInstantMillis(instant, chronology), iChronology); [EOL] }
public BaseDateTime(Object instant, Chronology chronology) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     iChronology = checkChronology(converter.getChronology(instant, chronology)); [EOL]     iMillis = checkInstant(converter.getInstantMillis(instant, chronology), iChronology); [EOL] }
public BaseDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance()); [EOL] }
public BaseDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(); [EOL]     iChronology = checkChronology(chronology); [EOL]     long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     iMillis = checkInstant(instant, iChronology); [EOL] }
public BaseDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL]     super(); [EOL]     iChronology = checkChronology(chronology); [EOL]     long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     iMillis = checkInstant(instant, iChronology); [EOL] }
public FixedDateTimeZone(String id, String nameKey, int wallOffset, int standardOffset) { [EOL]     super(id); [EOL]     iNameKey = nameKey; [EOL]     iWallOffset = wallOffset; [EOL]     iStandardOffset = standardOffset; [EOL] }
public int hashCode() { [EOL]     return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset; [EOL] }
public long getDurationMillis(Object object) { [EOL]     return ((ReadableDuration) object).getMillis(); [EOL] }
public AbstractReadableInstantFieldProperty() { [EOL]     super(); [EOL] }
public long remainder() { [EOL]     return getField().remainder(getMillis()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractReadableInstantFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object; [EOL]     return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public static synchronized UnsupportedDateTimeField getInstance(DateTimeFieldType type, DurationField durationField) { [EOL]     UnsupportedDateTimeField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]         if (field != null && field.getDurationField() != durationField) { [EOL]             field = null; [EOL]         } [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDateTimeField(type, durationField); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
public static synchronized UnsupportedDateTimeField getInstance(DateTimeFieldType type, DurationField durationField) { [EOL]     UnsupportedDateTimeField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]         if (field != null && field.getDurationField() != durationField) { [EOL]             field = null; [EOL]         } [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDateTimeField(type, durationField); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
public static synchronized UnsupportedDateTimeField getInstance(DateTimeFieldType type, DurationField durationField) { [EOL]     UnsupportedDateTimeField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]         if (field != null && field.getDurationField() != durationField) { [EOL]             field = null; [EOL]         } [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDateTimeField(type, durationField); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
private UnsupportedDateTimeField(DateTimeFieldType type, DurationField durationField) { [EOL]     if (type == null || durationField == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iType = type; [EOL]     iDurationField = durationField; [EOL] }
public long add(long instant, int value) { [EOL]     return getDurationField().add(instant, value); [EOL] }
public long add(long instant, long value) { [EOL]     return getDurationField().add(instant, value); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return getDurationField().getDifference(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] }
private Object readResolve() { [EOL]     return getInstance(iType, iDurationField); [EOL] }
public PreciseDateTimeField(DateTimeFieldType type, DurationField unit, DurationField range) { [EOL]     super(type, unit); [EOL]     if (!range.isPrecise()) { [EOL]         throw new IllegalArgumentException("Range duration field must be precise"); [EOL]     } [EOL]     long rangeMillis = range.getUnitMillis(); [EOL]     iRange = (int) (rangeMillis / getUnitMillis()); [EOL]     if (iRange < 2) { [EOL]         throw new IllegalArgumentException("The effective range must be at least 2"); [EOL]     } [EOL]     iRangeField = range; [EOL] }
public PreciseDateTimeField(DateTimeFieldType type, DurationField unit, DurationField range) { [EOL]     super(type, unit); [EOL]     if (!range.isPrecise()) { [EOL]         throw new IllegalArgumentException("Range duration field must be precise"); [EOL]     } [EOL]     long rangeMillis = range.getUnitMillis(); [EOL]     iRange = (int) (rangeMillis / getUnitMillis()); [EOL]     if (iRange < 2) { [EOL]         throw new IllegalArgumentException("The effective range must be at least 2"); [EOL]     } [EOL]     iRangeField = range; [EOL] }
public PreciseDateTimeField(DateTimeFieldType type, DurationField unit, DurationField range) { [EOL]     super(type, unit); [EOL]     if (!range.isPrecise()) { [EOL]         throw new IllegalArgumentException("Range duration field must be precise"); [EOL]     } [EOL]     long rangeMillis = range.getUnitMillis(); [EOL]     iRange = (int) (rangeMillis / getUnitMillis()); [EOL]     if (iRange < 2) { [EOL]         throw new IllegalArgumentException("The effective range must be at least 2"); [EOL]     } [EOL]     iRangeField = range; [EOL] }
public int get(long instant) { [EOL]     if (instant >= 0) { [EOL]         return (int) ((instant / getUnitMillis()) % iRange); [EOL]     } else { [EOL]         return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange); [EOL]     } [EOL] }
public int get(long instant) { [EOL]     if (instant >= 0) { [EOL]         return (int) ((instant / getUnitMillis()) % iRange); [EOL]     } else { [EOL]         return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange); [EOL]     } [EOL] }
public long addWrapField(long instant, int amount) { [EOL]     int thisValue = get(instant); [EOL]     int wrappedValue = FieldUtils.getWrappedValue(thisValue, amount, getMinimumValue(), getMaximumValue()); [EOL]     return instant + (wrappedValue - thisValue) * getUnitMillis(); [EOL] }
public long addWrapField(long instant, int amount) { [EOL]     int thisValue = get(instant); [EOL]     int wrappedValue = FieldUtils.getWrappedValue(thisValue, amount, getMinimumValue(), getMaximumValue()); [EOL]     return instant + (wrappedValue - thisValue) * getUnitMillis(); [EOL] }
public long addWrapField(long instant, int amount) { [EOL]     int thisValue = get(instant); [EOL]     int wrappedValue = FieldUtils.getWrappedValue(thisValue, amount, getMinimumValue(), getMaximumValue()); [EOL]     return instant + (wrappedValue - thisValue) * getUnitMillis(); [EOL] }
public int getMaximumValue() { [EOL]     return iRange - 1; [EOL] }
public int getRange() { [EOL]     return iRange; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); [EOL] }
private long localToUTC(long localInstant) { [EOL]     DateTimeZone zone = getZone(); [EOL]     int offset = zone.getOffsetFromLocal(localInstant); [EOL]     localInstant -= offset; [EOL]     if (offset != zone.getOffset(localInstant)) { [EOL]         throw new IllegalInstantException(localInstant, zone.getID()); [EOL]     } [EOL]     return localInstant; [EOL] }
private long localToUTC(long localInstant) { [EOL]     DateTimeZone zone = getZone(); [EOL]     int offset = zone.getOffsetFromLocal(localInstant); [EOL]     localInstant -= offset; [EOL]     if (offset != zone.getOffset(localInstant)) { [EOL]         throw new IllegalInstantException(localInstant, zone.getID()); [EOL]     } [EOL]     return localInstant; [EOL] }
public int get(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.get(localInstant); [EOL] }
public int get(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.get(localInstant); [EOL] }
public int get(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.get(localInstant); [EOL] }
public long add(long instant, int value) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         long localInstant = iField.add(instant + offset, value); [EOL]         return localInstant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.add(localInstant, value); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long add(long instant, int value) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         long localInstant = iField.add(instant + offset, value); [EOL]         return localInstant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.add(localInstant, value); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         instant = iField.roundFloor(instant + offset); [EOL]         return instant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.roundFloor(localInstant); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         instant = iField.roundFloor(instant + offset); [EOL]         return instant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.roundFloor(localInstant); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long roundCeiling(long instant) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         instant = iField.roundCeiling(instant + offset); [EOL]         return instant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.roundCeiling(localInstant); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long roundCeiling(long instant) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         instant = iField.roundCeiling(instant + offset); [EOL]         return instant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.roundCeiling(localInstant); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.remainder(localInstant); [EOL] }
public long remainder(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.remainder(localInstant); [EOL] }
private int getOffsetToAdd(long instant) { [EOL]     int offset = this.iZone.getOffset(instant); [EOL]     long sum = instant + offset; [EOL]     if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) { [EOL]         throw new ArithmeticException("Adding time zone offset caused overflow"); [EOL]     } [EOL]     return offset; [EOL] }
public boolean isLenient() { [EOL]     return false; [EOL] }
public IllegalInstantException(String message) { [EOL]     super(message); [EOL] }
public IllegalInstantException(String message) { [EOL]     super(message); [EOL] }
public IllegalInstantException(String message) { [EOL]     super(message); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue); [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength(); [EOL] }
private static String createMessage(String fieldName, String value) { [EOL]     StringBuffer buf = new StringBuffer().append("Value "); [EOL]     if (value == null) { [EOL]         buf.append("null"); [EOL]     } else { [EOL]         buf.append('"'); [EOL]         buf.append(value); [EOL]         buf.append('"'); [EOL]     } [EOL]     buf.append(" for ").append(fieldName).append(' ').append("is not supported"); [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, String value) { [EOL]     StringBuffer buf = new StringBuffer().append("Value "); [EOL]     if (value == null) { [EOL]         buf.append("null"); [EOL]     } else { [EOL]         buf.append('"'); [EOL]         buf.append(value); [EOL]         buf.append('"'); [EOL]     } [EOL]     buf.append(" for ").append(fieldName).append(' ').append("is not supported"); [EOL]     return buf.toString(); [EOL] }
public IllegalFieldValueException(DateTimeFieldType fieldType, String value) { [EOL]     super(createMessage(fieldType.getName(), value)); [EOL]     iDateTimeFieldType = fieldType; [EOL]     iDurationFieldType = null; [EOL]     iFieldName = fieldType.getName(); [EOL]     iStringValue = value; [EOL]     iNumberValue = null; [EOL]     iLowerBound = null; [EOL]     iUpperBound = null; [EOL]     iMessage = super.getMessage(); [EOL] }
public IllegalFieldValueException(DateTimeFieldType fieldType, String value) { [EOL]     super(createMessage(fieldType.getName(), value)); [EOL]     iDateTimeFieldType = fieldType; [EOL]     iDurationFieldType = null; [EOL]     iFieldName = fieldType.getName(); [EOL]     iStringValue = value; [EOL]     iNumberValue = null; [EOL]     iLowerBound = null; [EOL]     iUpperBound = null; [EOL]     iMessage = super.getMessage(); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public LocalTime minusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().subtract(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().subtract(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public Property hourOfDay() { [EOL]     return new Property(this, getChronology().hourOfDay()); [EOL] }
public Property secondOfMinute() { [EOL]     return new Property(this, getChronology().secondOfMinute()); [EOL] }
public DateTime toDateTimeToday(DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instantMillis = DateTimeUtils.currentTimeMillis(); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] }
public DateTime toDateTimeToday(DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instantMillis = DateTimeUtils.currentTimeMillis(); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] }
public LocalTime addNoWrapToCopy(int value) { [EOL]     long millis = iField.add(iInstant.getLocalMillis(), value); [EOL]     long rounded = iInstant.getChronology().millisOfDay().get(millis); [EOL]     if (rounded != millis) { [EOL]         throw new IllegalArgumentException("The addition exceeded the boundaries of LocalTime"); [EOL]     } [EOL]     return iInstant.withLocalMillis(millis); [EOL] }
public LocalTime addNoWrapToCopy(int value) { [EOL]     long millis = iField.add(iInstant.getLocalMillis(), value); [EOL]     long rounded = iInstant.getChronology().millisOfDay().get(millis); [EOL]     if (rounded != millis) { [EOL]         throw new IllegalArgumentException("The addition exceeded the boundaries of LocalTime"); [EOL]     } [EOL]     return iInstant.withLocalMillis(millis); [EOL] }
public LocalTime setCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); [EOL] }
public LocalTime setCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); [EOL] }
public LocalTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale)); [EOL] }
public LocalTime setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public LocalTime setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public static DurationFieldType millis() { [EOL]     return MILLIS_TYPE; [EOL] }
public static DurationFieldType seconds() { [EOL]     return SECONDS_TYPE; [EOL] }
public static DurationFieldType minutes() { [EOL]     return MINUTES_TYPE; [EOL] }
public static DurationFieldType hours() { [EOL]     return HOURS_TYPE; [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { [EOL]     UnsupportedDurationField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDurationField(type); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) { [EOL]     UnsupportedDurationField field; [EOL]     if (cCache == null) { [EOL]         cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7); [EOL]         field = null; [EOL]     } else { [EOL]         field = cCache.get(type); [EOL]     } [EOL]     if (field == null) { [EOL]         field = new UnsupportedDurationField(type); [EOL]         cCache.put(type, field); [EOL]     } [EOL]     return field; [EOL] }
public boolean isSupported() { [EOL]     return false; [EOL] }
public long add(long instant, int value) { [EOL]     throw unsupported(); [EOL] }
public long add(long instant, long value) { [EOL]     throw unsupported(); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     throw unsupported(); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     throw unsupported(); [EOL] }
private Object readResolve() { [EOL]     return getInstance(iType); [EOL] }
private UnsupportedOperationException unsupported() { [EOL]     return new UnsupportedOperationException(iType + " field is unsupported"); [EOL] }
public MutableDateTime(long instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public MutableDateTime(long instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public MutableDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] }
public MutableDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void setMillis(long instant) { [EOL]     switch(iRoundingMode) { [EOL]         case ROUND_NONE: [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]             instant = iRoundingField.roundFloor(instant); [EOL]             break; [EOL]         case ROUND_CEILING: [EOL]             instant = iRoundingField.roundCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_FLOOR: [EOL]             instant = iRoundingField.roundHalfFloor(instant); [EOL]             break; [EOL]         case ROUND_HALF_CEILING: [EOL]             instant = iRoundingField.roundHalfCeiling(instant); [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             instant = iRoundingField.roundHalfEven(instant); [EOL]             break; [EOL]     } [EOL]     super.setMillis(instant); [EOL] }
public void add(ReadableDuration duration) { [EOL]     add(duration, 1); [EOL] }
public void add(ReadableDuration duration, int scalar) { [EOL]     if (duration != null) { [EOL]         add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); [EOL]     } [EOL] }
public void add(ReadableDuration duration, int scalar) { [EOL]     if (duration != null) { [EOL]         add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); [EOL]     } [EOL] }
public void add(ReadableDuration duration, int scalar) { [EOL]     if (duration != null) { [EOL]         add(FieldUtils.safeMultiply(duration.getMillis(), scalar)); [EOL]     } [EOL] }
public void add(ReadablePeriod period) { [EOL]     add(period, 1); [EOL] }
public void add(ReadablePeriod period) { [EOL]     add(period, 1); [EOL] }
public void add(ReadablePeriod period, int scalar) { [EOL]     if (period != null) { [EOL]         setMillis(getChronology().add(period, getMillis(), scalar)); [EOL]     } [EOL] }
public void add(ReadablePeriod period, int scalar) { [EOL]     if (period != null) { [EOL]         setMillis(getChronology().add(period, getMillis(), scalar)); [EOL]     } [EOL] }
public void setChronology(Chronology chronology) { [EOL]     super.setChronology(chronology); [EOL] }
public void setZoneRetainFields(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); [EOL]     if (newZone == originalZone) { [EOL]         return; [EOL]     } [EOL]     long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); [EOL]     setChronology(getChronology().withZone(newZone)); [EOL]     setMillis(millis); [EOL] }
public void setZoneRetainFields(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     DateTimeZone originalZone = DateTimeUtils.getZone(getZone()); [EOL]     if (newZone == originalZone) { [EOL]         return; [EOL]     } [EOL]     long millis = originalZone.getMillisKeepLocal(newZone, getMillis()); [EOL]     setChronology(getChronology().withZone(newZone)); [EOL]     setMillis(millis); [EOL] }
public void addMonths(final int months) { [EOL]     if (months != 0) { [EOL]         setMillis(getChronology().months().add(getMillis(), months)); [EOL]     } [EOL] }
public void addMonths(final int months) { [EOL]     if (months != 0) { [EOL]         setMillis(getChronology().months().add(getMillis(), months)); [EOL]     } [EOL] }
public void addMonths(final int months) { [EOL]     if (months != 0) { [EOL]         setMillis(getChronology().months().add(getMillis(), months)); [EOL]     } [EOL] }
public void setWeekOfWeekyear(final int weekOfWeekyear) { [EOL]     setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); [EOL] }
public void setWeekOfWeekyear(final int weekOfWeekyear) { [EOL]     setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); [EOL] }
public void addWeeks(final int weeks) { [EOL]     if (weeks != 0) { [EOL]         setMillis(getChronology().weeks().add(getMillis(), weeks)); [EOL]     } [EOL] }
public void addWeeks(final int weeks) { [EOL]     if (weeks != 0) { [EOL]         setMillis(getChronology().weeks().add(getMillis(), weeks)); [EOL]     } [EOL] }
public void addWeeks(final int weeks) { [EOL]     if (weeks != 0) { [EOL]         setMillis(getChronology().weeks().add(getMillis(), weeks)); [EOL]     } [EOL] }
public void setDayOfYear(final int dayOfYear) { [EOL]     setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); [EOL] }
public void setDayOfYear(final int dayOfYear) { [EOL]     setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear)); [EOL] }
public void addSeconds(final int seconds) { [EOL]     if (seconds != 0) { [EOL]         setMillis(getChronology().seconds().add(getMillis(), seconds)); [EOL]     } [EOL] }
public void addSeconds(final int seconds) { [EOL]     if (seconds != 0) { [EOL]         setMillis(getChronology().seconds().add(getMillis(), seconds)); [EOL]     } [EOL] }
public void addSeconds(final int seconds) { [EOL]     if (seconds != 0) { [EOL]         setMillis(getChronology().seconds().add(getMillis(), seconds)); [EOL]     } [EOL] }
public void addMillis(final int millis) { [EOL]     if (millis != 0) { [EOL]         setMillis(getChronology().millis().add(getMillis(), millis)); [EOL]     } [EOL] }
public void addMillis(final int millis) { [EOL]     if (millis != 0) { [EOL]         setMillis(getChronology().millis().add(getMillis(), millis)); [EOL]     } [EOL] }
public void setDate(final long instant) { [EOL]     setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay())); [EOL] }
public void setDate(final ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     if (instant instanceof ReadableDateTime) { [EOL]         ReadableDateTime rdt = (ReadableDateTime) instant; [EOL]         Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); [EOL]         DateTimeZone zone = instantChrono.getZone(); [EOL]         if (zone != null) { [EOL]             instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); [EOL]         } [EOL]     } [EOL]     setDate(instantMillis); [EOL] }
public void setDate(final ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     if (instant instanceof ReadableDateTime) { [EOL]         ReadableDateTime rdt = (ReadableDateTime) instant; [EOL]         Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); [EOL]         DateTimeZone zone = instantChrono.getZone(); [EOL]         if (zone != null) { [EOL]             instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); [EOL]         } [EOL]     } [EOL]     setDate(instantMillis); [EOL] }
public void setDate(final ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     if (instant instanceof ReadableDateTime) { [EOL]         ReadableDateTime rdt = (ReadableDateTime) instant; [EOL]         Chronology instantChrono = DateTimeUtils.getChronology(rdt.getChronology()); [EOL]         DateTimeZone zone = instantChrono.getZone(); [EOL]         if (zone != null) { [EOL]             instantMillis = zone.getMillisKeepLocal(getZone(), instantMillis); [EOL]         } [EOL]     } [EOL]     setDate(instantMillis); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         throw new InternalError("Clone error"); [EOL]     } [EOL] }
public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         throw new InternalError("Clone error"); [EOL]     } [EOL] }
@ToString [EOL] public String toString() { [EOL]     return ISODateTimeFormat.dateTime().print(this); [EOL] }
Property(MutableDateTime instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
Property(MutableDateTime instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
Property(MutableDateTime instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
public DateTimeField getField() { [EOL]     return iField; [EOL] }
protected long getMillis() { [EOL]     return iInstant.getMillis(); [EOL] }
public MutableDateTime getMutableDateTime() { [EOL]     return iInstant; [EOL] }
public MutableDateTime set(String text, Locale locale) { [EOL]     iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); [EOL]     return iInstant; [EOL] }
public MutableDateTime set(String text, Locale locale) { [EOL]     iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); [EOL]     return iInstant; [EOL] }
public MutableDateTime set(String text, Locale locale) { [EOL]     iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale)); [EOL]     return iInstant; [EOL] }
public MutableDateTime set(String text) { [EOL]     set(text, null); [EOL]     return iInstant; [EOL] }
public MutableDateTime set(String text) { [EOL]     set(text, null); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundFloor() { [EOL]     iInstant.setMillis(getField().roundFloor(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfEven() { [EOL]     iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfEven() { [EOL]     iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfEven() { [EOL]     iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfEven() { [EOL]     iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
private Object readResolve() { [EOL]     return Hours.hours(getValue()); [EOL] }
public Hours plus(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     return Hours.hours(FieldUtils.safeAdd(getValue(), hours)); [EOL] }
public Hours plus(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     return Hours.hours(FieldUtils.safeAdd(getValue(), hours)); [EOL] }
public Hours minus(int hours) { [EOL]     return plus(FieldUtils.safeNegate(hours)); [EOL] }
public Hours minus(int hours) { [EOL]     return plus(FieldUtils.safeNegate(hours)); [EOL] }
public Hours minus(int hours) { [EOL]     return plus(FieldUtils.safeNegate(hours)); [EOL] }
public Hours multipliedBy(int scalar) { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Hours multipliedBy(int scalar) { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Hours multipliedBy(int scalar) { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Hours multipliedBy(int scalar) { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL]     Converter[] converters = set.iConverters; [EOL]     int length = converters.length; [EOL]     Converter converter; [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         if (supportedType == type) { [EOL]             return converter; [EOL]         } [EOL]         if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL]             set = set.remove(i, null); [EOL]             converters = set.iConverters; [EOL]             length = converters.length; [EOL]         } [EOL]     } [EOL]     if (type == null || length == 0) { [EOL]         return null; [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         for (int j = length; --j >= 0; ) { [EOL]             if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL]                 set = set.remove(j, null); [EOL]                 converters = set.iConverters; [EOL]                 length = converters.length; [EOL]                 i = length - 1; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     StringBuilder msg = new StringBuilder(); [EOL]     msg.append("Unable to find best converter for type \""); [EOL]     msg.append(type.getName()); [EOL]     msg.append("\" from remaining set: "); [EOL]     for (int i = 0; i < length; i++) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         msg.append(converter.getClass().getName()); [EOL]         msg.append('['); [EOL]         msg.append(supportedType == null ? null : supportedType.getName()); [EOL]         msg.append("], "); [EOL]     } [EOL]     throw new IllegalStateException(msg.toString()); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL]     Converter[] converters = set.iConverters; [EOL]     int length = converters.length; [EOL]     Converter converter; [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         if (supportedType == type) { [EOL]             return converter; [EOL]         } [EOL]         if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL]             set = set.remove(i, null); [EOL]             converters = set.iConverters; [EOL]             length = converters.length; [EOL]         } [EOL]     } [EOL]     if (type == null || length == 0) { [EOL]         return null; [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         for (int j = length; --j >= 0; ) { [EOL]             if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL]                 set = set.remove(j, null); [EOL]                 converters = set.iConverters; [EOL]                 length = converters.length; [EOL]                 i = length - 1; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     StringBuilder msg = new StringBuilder(); [EOL]     msg.append("Unable to find best converter for type \""); [EOL]     msg.append(type.getName()); [EOL]     msg.append("\" from remaining set: "); [EOL]     for (int i = 0; i < length; i++) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         msg.append(converter.getClass().getName()); [EOL]         msg.append('['); [EOL]         msg.append(supportedType == null ? null : supportedType.getName()); [EOL]         msg.append("], "); [EOL]     } [EOL]     throw new IllegalStateException(msg.toString()); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL]     Converter[] converters = set.iConverters; [EOL]     int length = converters.length; [EOL]     Converter converter; [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         if (supportedType == type) { [EOL]             return converter; [EOL]         } [EOL]         if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL]             set = set.remove(i, null); [EOL]             converters = set.iConverters; [EOL]             length = converters.length; [EOL]         } [EOL]     } [EOL]     if (type == null || length == 0) { [EOL]         return null; [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         for (int j = length; --j >= 0; ) { [EOL]             if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL]                 set = set.remove(j, null); [EOL]                 converters = set.iConverters; [EOL]                 length = converters.length; [EOL]                 i = length - 1; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     StringBuilder msg = new StringBuilder(); [EOL]     msg.append("Unable to find best converter for type \""); [EOL]     msg.append(type.getName()); [EOL]     msg.append("\" from remaining set: "); [EOL]     for (int i = 0; i < length; i++) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         msg.append(converter.getClass().getName()); [EOL]         msg.append('['); [EOL]         msg.append(supportedType == null ? null : supportedType.getName()); [EOL]         msg.append("], "); [EOL]     } [EOL]     throw new IllegalStateException(msg.toString()); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL]     Converter[] converters = set.iConverters; [EOL]     int length = converters.length; [EOL]     Converter converter; [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         if (supportedType == type) { [EOL]             return converter; [EOL]         } [EOL]         if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL]             set = set.remove(i, null); [EOL]             converters = set.iConverters; [EOL]             length = converters.length; [EOL]         } [EOL]     } [EOL]     if (type == null || length == 0) { [EOL]         return null; [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         for (int j = length; --j >= 0; ) { [EOL]             if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL]                 set = set.remove(j, null); [EOL]                 converters = set.iConverters; [EOL]                 length = converters.length; [EOL]                 i = length - 1; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     StringBuilder msg = new StringBuilder(); [EOL]     msg.append("Unable to find best converter for type \""); [EOL]     msg.append(type.getName()); [EOL]     msg.append("\" from remaining set: "); [EOL]     for (int i = 0; i < length; i++) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         msg.append(converter.getClass().getName()); [EOL]         msg.append('['); [EOL]         msg.append(supportedType == null ? null : supportedType.getName()); [EOL]         msg.append("], "); [EOL]     } [EOL]     throw new IllegalStateException(msg.toString()); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL]     Converter[] converters = set.iConverters; [EOL]     int length = converters.length; [EOL]     Converter converter; [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         if (supportedType == type) { [EOL]             return converter; [EOL]         } [EOL]         if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL]             set = set.remove(i, null); [EOL]             converters = set.iConverters; [EOL]             length = converters.length; [EOL]         } [EOL]     } [EOL]     if (type == null || length == 0) { [EOL]         return null; [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         for (int j = length; --j >= 0; ) { [EOL]             if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL]                 set = set.remove(j, null); [EOL]                 converters = set.iConverters; [EOL]                 length = converters.length; [EOL]                 i = length - 1; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     StringBuilder msg = new StringBuilder(); [EOL]     msg.append("Unable to find best converter for type \""); [EOL]     msg.append(type.getName()); [EOL]     msg.append("\" from remaining set: "); [EOL]     for (int i = 0; i < length; i++) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         msg.append(converter.getClass().getName()); [EOL]         msg.append('['); [EOL]         msg.append(supportedType == null ? null : supportedType.getName()); [EOL]         msg.append("], "); [EOL]     } [EOL]     throw new IllegalStateException(msg.toString()); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL]     Converter[] converters = set.iConverters; [EOL]     int length = converters.length; [EOL]     Converter converter; [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         if (supportedType == type) { [EOL]             return converter; [EOL]         } [EOL]         if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL]             set = set.remove(i, null); [EOL]             converters = set.iConverters; [EOL]             length = converters.length; [EOL]         } [EOL]     } [EOL]     if (type == null || length == 0) { [EOL]         return null; [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         for (int j = length; --j >= 0; ) { [EOL]             if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL]                 set = set.remove(j, null); [EOL]                 converters = set.iConverters; [EOL]                 length = converters.length; [EOL]                 i = length - 1; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     StringBuilder msg = new StringBuilder(); [EOL]     msg.append("Unable to find best converter for type \""); [EOL]     msg.append(type.getName()); [EOL]     msg.append("\" from remaining set: "); [EOL]     for (int i = 0; i < length; i++) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         msg.append(converter.getClass().getName()); [EOL]         msg.append('['); [EOL]         msg.append(supportedType == null ? null : supportedType.getName()); [EOL]         msg.append("], "); [EOL]     } [EOL]     throw new IllegalStateException(msg.toString()); [EOL] }
public DateTimeParser toParser() { [EOL]     Object f = getFormatter(); [EOL]     if (isParser(f)) { [EOL]         return (DateTimeParser) f; [EOL]     } [EOL]     throw new UnsupportedOperationException("Parsing is not supported"); [EOL] }
public boolean canBuildFormatter() { [EOL]     return isFormatter(getFormatter()); [EOL] }
public DateTimeFormatterBuilder append(DateTimeParser parser) { [EOL]     checkParser(parser); [EOL]     return append0(null, parser); [EOL] }
public DateTimeFormatterBuilder append(DateTimeParser parser) { [EOL]     checkParser(parser); [EOL]     return append0(null, parser); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) { [EOL]     checkPrinter(printer); [EOL]     checkParser(parser); [EOL]     return append0(printer, parser); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) { [EOL]     checkPrinter(printer); [EOL]     checkParser(parser); [EOL]     return append0(printer, parser); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) { [EOL]     checkPrinter(printer); [EOL]     checkParser(parser); [EOL]     return append0(printer, parser); [EOL] }
public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) { [EOL]     checkParser(parser); [EOL]     DateTimeParser[] parsers = new DateTimeParser[] { parser, null }; [EOL]     return append0(null, new MatchingParser(parsers)); [EOL] }
public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) { [EOL]     checkParser(parser); [EOL]     DateTimeParser[] parsers = new DateTimeParser[] { parser, null }; [EOL]     return append0(null, new MatchingParser(parsers)); [EOL] }
private void checkParser(DateTimeParser parser) { [EOL]     if (parser == null) { [EOL]         throw new IllegalArgumentException("No parser supplied"); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) { [EOL]     return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse)); [EOL] }
public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) { [EOL]     return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse)); [EOL] }
public DateTimeFormatterBuilder appendMonthOfYearText() { [EOL]     return appendText(DateTimeFieldType.monthOfYear()); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneId() { [EOL]     return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE); [EOL] }
private boolean isFormatter(Object f) { [EOL]     return (isPrinter(f) || isParser(f)); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) { [EOL]     super(); [EOL]     iType = type; [EOL]     iPivot = pivot; [EOL]     iLenientParse = lenientParse; [EOL] }
TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) { [EOL]     super(); [EOL]     iType = type; [EOL]     iPivot = pivot; [EOL]     iLenientParse = lenientParse; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int estimatePrintedLength() { [EOL]     return 2; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     int year = getTwoDigitYear(instant, chrono); [EOL]     if (year < 0) { [EOL]         buf.append('\ufffd'); [EOL]         buf.append('\ufffd'); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, year, 2); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     int year = getTwoDigitYear(instant, chrono); [EOL]     if (year < 0) { [EOL]         buf.append('\ufffd'); [EOL]         buf.append('\ufffd'); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, year, 2); [EOL]     } [EOL] }
private int getTwoDigitYear(long instant, Chronology chrono) { [EOL]     try { [EOL]         int year = iType.getField(chrono).get(instant); [EOL]         if (year < 0) { [EOL]             year = -year; [EOL]         } [EOL]         return year % 100; [EOL]     } catch (RuntimeException e) { [EOL]         return -1; [EOL]     } [EOL] }
private int getTwoDigitYear(long instant, Chronology chrono) { [EOL]     try { [EOL]         int year = iType.getField(chrono).get(instant); [EOL]         if (year < 0) { [EOL]             year = -year; [EOL]         } [EOL]         return year % 100; [EOL]     } catch (RuntimeException e) { [EOL]         return -1; [EOL]     } [EOL] }
private int getTwoDigitYear(long instant, Chronology chrono) { [EOL]     try { [EOL]         int year = iType.getField(chrono).get(instant); [EOL]         if (year < 0) { [EOL]             year = -year; [EOL]         } [EOL]         return year % 100; [EOL]     } catch (RuntimeException e) { [EOL]         return -1; [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeField field = iFieldType.getField(bucket.getChronology()); [EOL]     int limit = Math.min(iMaxDigits, text.length() - position); [EOL]     long value = 0; [EOL]     long n = field.getDurationField().getUnitMillis() * 10; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]         long nn = n / 10; [EOL]         value += (c - '0') * nn; [EOL]         n = nn; [EOL]     } [EOL]     value /= 10; [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     if (value > Integer.MAX_VALUE) { [EOL]         return ~position; [EOL]     } [EOL]     DateTimeField parseField = new PreciseDateTimeField(DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, field.getDurationField()); [EOL]     bucket.saveField(parseField, (int) value); [EOL]     return position + length; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeField field = iFieldType.getField(bucket.getChronology()); [EOL]     int limit = Math.min(iMaxDigits, text.length() - position); [EOL]     long value = 0; [EOL]     long n = field.getDurationField().getUnitMillis() * 10; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]         long nn = n / 10; [EOL]         value += (c - '0') * nn; [EOL]         n = nn; [EOL]     } [EOL]     value /= 10; [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     if (value > Integer.MAX_VALUE) { [EOL]         return ~position; [EOL]     } [EOL]     DateTimeField parseField = new PreciseDateTimeField(DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, field.getDurationField()); [EOL]     bucket.saveField(parseField, (int) value); [EOL]     return position + length; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeField field = iFieldType.getField(bucket.getChronology()); [EOL]     int limit = Math.min(iMaxDigits, text.length() - position); [EOL]     long value = 0; [EOL]     long n = field.getDurationField().getUnitMillis() * 10; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]         long nn = n / 10; [EOL]         value += (c - '0') * nn; [EOL]         n = nn; [EOL]     } [EOL]     value /= 10; [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     if (value > Integer.MAX_VALUE) { [EOL]         return ~position; [EOL]     } [EOL]     DateTimeField parseField = new PreciseDateTimeField(DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, field.getDurationField()); [EOL]     bucket.saveField(parseField, (int) value); [EOL]     return position + length; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeField field = iFieldType.getField(bucket.getChronology()); [EOL]     int limit = Math.min(iMaxDigits, text.length() - position); [EOL]     long value = 0; [EOL]     long n = field.getDurationField().getUnitMillis() * 10; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]         long nn = n / 10; [EOL]         value += (c - '0') * nn; [EOL]         n = nn; [EOL]     } [EOL]     value /= 10; [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     if (value > Integer.MAX_VALUE) { [EOL]         return ~position; [EOL]     } [EOL]     DateTimeField parseField = new PreciseDateTimeField(DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, field.getDurationField()); [EOL]     bucket.saveField(parseField, (int) value); [EOL]     return position + length; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeField field = iFieldType.getField(bucket.getChronology()); [EOL]     int limit = Math.min(iMaxDigits, text.length() - position); [EOL]     long value = 0; [EOL]     long n = field.getDurationField().getUnitMillis() * 10; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]         long nn = n / 10; [EOL]         value += (c - '0') * nn; [EOL]         n = nn; [EOL]     } [EOL]     value /= 10; [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     if (value > Integer.MAX_VALUE) { [EOL]         return ~position; [EOL]     } [EOL]     DateTimeField parseField = new PreciseDateTimeField(DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, field.getDurationField()); [EOL]     bucket.saveField(parseField, (int) value); [EOL]     return position + length; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeField field = iFieldType.getField(bucket.getChronology()); [EOL]     int limit = Math.min(iMaxDigits, text.length() - position); [EOL]     long value = 0; [EOL]     long n = field.getDurationField().getUnitMillis() * 10; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]         long nn = n / 10; [EOL]         value += (c - '0') * nn; [EOL]         n = nn; [EOL]     } [EOL]     value /= 10; [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     if (value > Integer.MAX_VALUE) { [EOL]         return ~position; [EOL]     } [EOL]     DateTimeField parseField = new PreciseDateTimeField(DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, field.getDurationField()); [EOL]     bucket.saveField(parseField, (int) value); [EOL]     return position + length; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     zeroOffset: if (iZeroOffsetParseText != null) { [EOL]         if (iZeroOffsetParseText.length() == 0) { [EOL]             if (limit > 0) { [EOL]                 char c = text.charAt(position); [EOL]                 if (c == '-' || c == '+') { [EOL]                     break zeroOffset; [EOL]                 } [EOL]             } [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position; [EOL]         } [EOL]         if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) { [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position + iZeroOffsetParseText.length(); [EOL]         } [EOL]     } [EOL]     if (limit <= 1) { [EOL]         return ~position; [EOL]     } [EOL]     boolean negative; [EOL]     char c = text.charAt(position); [EOL]     if (c == '-') { [EOL]         negative = true; [EOL]     } else if (c == '+') { [EOL]         negative = false; [EOL]     } else { [EOL]         return ~position; [EOL]     } [EOL]     limit--; [EOL]     position++; [EOL]     if (digitCount(text, position, 2) < 2) { [EOL]         return ~position; [EOL]     } [EOL]     int offset; [EOL]     int hours = FormatUtils.parseTwoDigits(text, position); [EOL]     if (hours > 23) { [EOL]         return ~position; [EOL]     } [EOL]     offset = hours * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     limit -= 2; [EOL]     position += 2; [EOL]     parse: { [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         boolean expectSeparators; [EOL]         c = text.charAt(position); [EOL]         if (c == ':') { [EOL]             expectSeparators = true; [EOL]             limit--; [EOL]             position++; [EOL]         } else if (c >= '0' && c <= '9') { [EOL]             expectSeparators = false; [EOL]         } else { [EOL]             break parse; [EOL]         } [EOL]         int count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int minutes = FormatUtils.parseTwoDigits(text, position); [EOL]         if (minutes > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != ':') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int seconds = FormatUtils.parseTwoDigits(text, position); [EOL]         if (seconds > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != '.' && text.charAt(position) != ',') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 3); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 1) { [EOL]             return ~position; [EOL]         } [EOL]         offset += (text.charAt(position++) - '0') * 100; [EOL]         if (count > 1) { [EOL]             offset += (text.charAt(position++) - '0') * 10; [EOL]             if (count > 2) { [EOL]                 offset += text.charAt(position++) - '0'; [EOL]             } [EOL]         } [EOL]     } [EOL]     bucket.setOffset(Integer.valueOf(negative ? -offset : offset)); [EOL]     return position; [EOL] }
public int estimatePrintedLength() { [EOL]     return MAX_LENGTH; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     buf.append(displayZone != null ? displayZone.getID() : ""); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     buf.append(displayZone != null ? displayZone.getID() : ""); [EOL] }
public int estimateParsedLength() { [EOL]     return MAX_LENGTH; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     String str = text.substring(position); [EOL]     String best = null; [EOL]     for (String id : ALL_IDS) { [EOL]         if (str.startsWith(id)) { [EOL]             if (best == null || id.length() > best.length()) { [EOL]                 best = id; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (best != null) { [EOL]         bucket.setZone(DateTimeZone.forID(best)); [EOL]         return position + best.length(); [EOL]     } [EOL]     return ~position; [EOL] }
MatchingParser(DateTimeParser[] parsers) { [EOL]     super(); [EOL]     iParsers = parsers; [EOL]     int est = 0; [EOL]     for (int i = parsers.length; --i >= 0; ) { [EOL]         DateTimeParser parser = parsers[i]; [EOL]         if (parser != null) { [EOL]             int len = parser.estimateParsedLength(); [EOL]             if (len > est) { [EOL]                 est = len; [EOL]             } [EOL]         } [EOL]     } [EOL]     iParsedLengthEstimate = est; [EOL] }
public int estimateParsedLength() { [EOL]     return iParsedLengthEstimate; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] parsers = iParsers; [EOL]     int length = parsers.length; [EOL]     final Object originalState = bucket.saveState(); [EOL]     boolean isOptional = false; [EOL]     int bestValidPos = position; [EOL]     Object bestValidState = null; [EOL]     int bestInvalidPos = position; [EOL]     for (int i = 0; i < length; i++) { [EOL]         DateTimeParser parser = parsers[i]; [EOL]         if (parser == null) { [EOL]             if (bestValidPos <= position) { [EOL]                 return position; [EOL]             } [EOL]             isOptional = true; [EOL]             break; [EOL]         } [EOL]         int parsePos = parser.parseInto(bucket, text, position); [EOL]         if (parsePos >= position) { [EOL]             if (parsePos > bestValidPos) { [EOL]                 if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) { [EOL]                     return parsePos; [EOL]                 } [EOL]                 bestValidPos = parsePos; [EOL]                 bestValidState = bucket.saveState(); [EOL]             } [EOL]         } else { [EOL]             if (parsePos < 0) { [EOL]                 parsePos = ~parsePos; [EOL]                 if (parsePos > bestInvalidPos) { [EOL]                     bestInvalidPos = parsePos; [EOL]                 } [EOL]             } [EOL]         } [EOL]         bucket.restoreState(originalState); [EOL]     } [EOL]     if (bestValidPos > position || (bestValidPos == position && isOptional)) { [EOL]         if (bestValidState != null) { [EOL]             bucket.restoreState(bestValidState); [EOL]         } [EOL]         return bestValidPos; [EOL]     } [EOL]     return ~bestInvalidPos; [EOL] }
public static TimeOfDay fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new TimeOfDay(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public static TimeOfDay fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new TimeOfDay(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
TimeOfDay(TimeOfDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology); [EOL]         newChronology.validate(newTimeOfDay, getValues()); [EOL]         return newTimeOfDay; [EOL]     } [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plusMillis(int millis) { [EOL]     return withFieldAdded(DurationFieldType.millis(), millis); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusSeconds(int seconds) { [EOL]     return withFieldAdded(DurationFieldType.seconds(), FieldUtils.safeNegate(seconds)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property hourOfDay() { [EOL]     return new Property(this, HOUR_OF_DAY); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay addNoWrapToCopy(int valueToAdd) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay addNoWrapToCopy(int valueToAdd) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay addNoWrapToCopy(int valueToAdd) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay addNoWrapToCopy(int valueToAdd) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay addNoWrapToCopy(int valueToAdd) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withMaximumValue() { [EOL]     return setCopy(getMaximumValue()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public boolean overlaps(ReadableInterval interval) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (thisStart < now && now < thisEnd); [EOL]     } else { [EOL]         long otherStart = interval.getStartMillis(); [EOL]         long otherEnd = interval.getEndMillis(); [EOL]         return (thisStart < otherEnd && otherStart < thisEnd); [EOL]     } [EOL] }
public boolean overlaps(ReadableInterval interval) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (thisStart < now && now < thisEnd); [EOL]     } else { [EOL]         long otherStart = interval.getStartMillis(); [EOL]         long otherEnd = interval.getEndMillis(); [EOL]         return (thisStart < otherEnd && otherStart < thisEnd); [EOL]     } [EOL] }
public boolean overlaps(ReadableInterval interval) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (thisStart < now && now < thisEnd); [EOL]     } else { [EOL]         long otherStart = interval.getStartMillis(); [EOL]         long otherEnd = interval.getEndMillis(); [EOL]         return (thisStart < otherEnd && otherStart < thisEnd); [EOL]     } [EOL] }
public boolean overlaps(ReadableInterval interval) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (thisStart < now && now < thisEnd); [EOL]     } else { [EOL]         long otherStart = interval.getStartMillis(); [EOL]         long otherEnd = interval.getEndMillis(); [EOL]         return (thisStart < otherEnd && otherStart < thisEnd); [EOL]     } [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(instant.getMillis()); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(instant.getMillis()); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(instant.getMillis()); [EOL] }
public MutableInterval toMutableInterval() { [EOL]     return new MutableInterval(getStartMillis(), getEndMillis(), getChronology()); [EOL] }
public DurationFieldType[] getFieldTypes() { [EOL]     DurationFieldType[] result = new DurationFieldType[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getFieldType(i); [EOL]     } [EOL]     return result; [EOL] }
public DurationFieldType[] getFieldTypes() { [EOL]     DurationFieldType[] result = new DurationFieldType[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getFieldType(i); [EOL]     } [EOL]     return result; [EOL] }
public Period toPeriod() { [EOL]     return new Period(this); [EOL] }
public boolean equals(Object period) { [EOL]     if (this == period) { [EOL]         return true; [EOL]     } [EOL]     if (period instanceof ReadablePeriod == false) { [EOL]         return false; [EOL]     } [EOL]     ReadablePeriod other = (ReadablePeriod) period; [EOL]     if (size() != other.size()) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public int hashCode() { [EOL]     int total = 17; [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         total = 27 * total + getValue(i); [EOL]         total = 27 * total + getFieldType(i).hashCode(); [EOL]     } [EOL]     return total; [EOL] }
public int hashCode() { [EOL]     int total = 17; [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         total = 27 * total + getValue(i); [EOL]         total = 27 * total + getFieldType(i).hashCode(); [EOL]     } [EOL]     return total; [EOL] }
public int hashCode() { [EOL]     int total = 17; [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         total = 27 * total + getValue(i); [EOL]         total = 27 * total + getFieldType(i).hashCode(); [EOL]     } [EOL]     return total; [EOL] }
public String toString(PeriodFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public String toString(PeriodFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public MutablePeriod(Object period, PeriodType type, Chronology chrono) { [EOL]     super(period, type, chrono); [EOL] }
public MutablePeriod(Object period, PeriodType type, Chronology chrono) { [EOL]     super(period, type, chrono); [EOL] }
public MutablePeriod(Object period, PeriodType type, Chronology chrono) { [EOL]     super(period, type, chrono); [EOL] }
public MutablePeriod(Object period, PeriodType type, Chronology chrono) { [EOL]     super(period, type, chrono); [EOL] }
public void clear() { [EOL]     super.setValues(new int[size()]); [EOL] }
public void add(ReadableDuration duration) { [EOL]     if (duration != null) { [EOL]         add(new Period(duration.getMillis(), getPeriodType())); [EOL]     } [EOL] }
public void add(ReadableDuration duration) { [EOL]     if (duration != null) { [EOL]         add(new Period(duration.getMillis(), getPeriodType())); [EOL]     } [EOL] }
public void mergePeriod(ReadablePeriod period) { [EOL]     super.mergePeriod(period); [EOL] }
public void addYears(int years) { [EOL]     super.addField(DurationFieldType.years(), years); [EOL] }
public void addYears(int years) { [EOL]     super.addField(DurationFieldType.years(), years); [EOL] }
public void addYears(int years) { [EOL]     super.addField(DurationFieldType.years(), years); [EOL] }
public long roundCeiling(long instant) { [EOL]     if (instant > 0) { [EOL]         instant -= 1; [EOL]         return instant - instant % iUnitMillis + iUnitMillis; [EOL]     } else { [EOL]         return instant - instant % iUnitMillis; [EOL]     } [EOL] }
public long roundCeiling(long instant) { [EOL]     if (instant > 0) { [EOL]         instant -= 1; [EOL]         return instant - instant % iUnitMillis + iUnitMillis; [EOL]     } else { [EOL]         return instant - instant % iUnitMillis; [EOL]     } [EOL] }
public long roundCeiling(long instant) { [EOL]     if (instant > 0) { [EOL]         instant -= 1; [EOL]         return instant - instant % iUnitMillis + iUnitMillis; [EOL]     } else { [EOL]         return instant - instant % iUnitMillis; [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant % iUnitMillis; [EOL]     } else { [EOL]         return (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant % iUnitMillis; [EOL]     } else { [EOL]         return (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant % iUnitMillis; [EOL]     } else { [EOL]         return (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL]     } [EOL] }
public long remainder(long instant) { [EOL]     if (instant >= 0) { [EOL]         return instant % iUnitMillis; [EOL]     } else { [EOL]         return (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL]     } [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     int thisYear = get(instant); [EOL]     int newYear = FieldUtils.safeAdd(thisYear, years); [EOL]     return set(instant, newYear); [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     int thisYear = get(instant); [EOL]     int newYear = FieldUtils.safeAdd(thisYear, years); [EOL]     return set(instant, newYear); [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     int thisYear = get(instant); [EOL]     int newYear = FieldUtils.safeAdd(thisYear, years); [EOL]     return set(instant, newYear); [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, year, iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     return iChronology.setYear(instant, year); [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, year, iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     return iChronology.setYear(instant, year); [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, year, iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     return iChronology.setYear(instant, year); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -iChronology.getYearDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     return iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -iChronology.getYearDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     return iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -iChronology.getYearDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     return iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] }
public long roundFloor(long instant) { [EOL]     return iChronology.getYearMillis(get(instant)); [EOL] }
public long roundFloor(long instant) { [EOL]     return iChronology.getYearMillis(get(instant)); [EOL] }
public long roundFloor(long instant) { [EOL]     return iChronology.getYearMillis(get(instant)); [EOL] }
public Locale getLocale() { [EOL]     return iLocale; [EOL] }
public void setZone(DateTimeZone zone) { [EOL]     iSavedState = null; [EOL]     iZone = zone; [EOL] }
public void setZone(DateTimeZone zone) { [EOL]     iSavedState = null; [EOL]     iZone = zone; [EOL] }
public Integer getPivotYear() { [EOL]     return iPivotYear; [EOL] }
public void saveField(DateTimeFieldType fieldType, String text, Locale locale) { [EOL]     saveField(new SavedField(fieldType.getField(iChrono), text, locale)); [EOL] }
public void saveField(DateTimeFieldType fieldType, String text, Locale locale) { [EOL]     saveField(new SavedField(fieldType.getField(iChrono), text, locale)); [EOL] }
public void saveField(DateTimeFieldType fieldType, String text, Locale locale) { [EOL]     saveField(new SavedField(fieldType.getField(iChrono), text, locale)); [EOL] }
public void saveField(DateTimeFieldType fieldType, String text, Locale locale) { [EOL]     saveField(new SavedField(fieldType.getField(iChrono), text, locale)); [EOL] }
public long computeMillis(boolean resetFields, String text) { [EOL]     SavedField[] savedFields = iSavedFields; [EOL]     int count = iSavedFieldsCount; [EOL]     if (iSavedFieldsShared) { [EOL]         iSavedFields = savedFields = (SavedField[]) iSavedFields.clone(); [EOL]         iSavedFieldsShared = false; [EOL]     } [EOL]     sort(savedFields, count); [EOL]     if (count > 0) { [EOL]         DurationField months = DurationFieldType.months().getField(iChrono); [EOL]         DurationField days = DurationFieldType.days().getField(iChrono); [EOL]         DurationField first = savedFields[0].iField.getDurationField(); [EOL]         if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { [EOL]             saveField(DateTimeFieldType.year(), iDefaultYear); [EOL]             return computeMillis(resetFields, text); [EOL]         } [EOL]     } [EOL]     long millis = iMillis; [EOL]     try { [EOL]         for (int i = 0; i < count; i++) { [EOL]             millis = savedFields[i].set(millis, resetFields); [EOL]         } [EOL]         if (resetFields) { [EOL]             for (int i = 0; i < count; i++) { [EOL]                 millis = savedFields[i].set(millis, i == (count - 1)); [EOL]             } [EOL]         } [EOL]     } catch (IllegalFieldValueException e) { [EOL]         if (text != null) { [EOL]             e.prependMessage("Cannot parse \"" + text + '"'); [EOL]         } [EOL]         throw e; [EOL]     } [EOL]     if (iOffset != null) { [EOL]         millis -= iOffset; [EOL]     } else if (iZone != null) { [EOL]         int offset = iZone.getOffsetFromLocal(millis); [EOL]         millis -= offset; [EOL]         if (offset != iZone.getOffset(millis)) { [EOL]             String message = "Illegal instant due to time zone offset transition (" + iZone + ')'; [EOL]             if (text != null) { [EOL]                 message = "Cannot parse \"" + text + "\": " + message; [EOL]             } [EOL]             throw new IllegalInstantException(message); [EOL]         } [EOL]     } [EOL]     return millis; [EOL] }
private static void sort(SavedField[] array, int high) { [EOL]     if (high > 10) { [EOL]         Arrays.sort(array, 0, high); [EOL]     } else { [EOL]         for (int i = 0; i < high; i++) { [EOL]             for (int j = i; j > 0 && (array[j - 1]).compareTo(array[j]) > 0; j--) { [EOL]                 SavedField t = array[j]; [EOL]                 array[j] = array[j - 1]; [EOL]                 array[j - 1] = t; [EOL]             } [EOL]         } [EOL]     } [EOL] }
private static void sort(SavedField[] array, int high) { [EOL]     if (high > 10) { [EOL]         Arrays.sort(array, 0, high); [EOL]     } else { [EOL]         for (int i = 0; i < high; i++) { [EOL]             for (int j = i; j > 0 && (array[j - 1]).compareTo(array[j]) > 0; j--) { [EOL]                 SavedField t = array[j]; [EOL]                 array[j] = array[j - 1]; [EOL]                 array[j - 1] = t; [EOL]             } [EOL]         } [EOL]     } [EOL] }
SavedField(DateTimeField field, String text, Locale locale) { [EOL]     iField = field; [EOL]     iValue = 0; [EOL]     iText = text; [EOL]     iLocale = locale; [EOL] }
SavedField(DateTimeField field, String text, Locale locale) { [EOL]     iField = field; [EOL]     iValue = 0; [EOL]     iText = text; [EOL]     iLocale = locale; [EOL] }
long set(long millis, boolean reset) { [EOL]     if (iText == null) { [EOL]         millis = iField.set(millis, iValue); [EOL]     } else { [EOL]         millis = iField.set(millis, iText, iLocale); [EOL]     } [EOL]     if (reset) { [EOL]         millis = iField.roundFloor(millis); [EOL]     } [EOL]     return millis; [EOL] }
long set(long millis, boolean reset) { [EOL]     if (iText == null) { [EOL]         millis = iField.set(millis, iValue); [EOL]     } else { [EOL]         millis = iField.set(millis, iText, iLocale); [EOL]     } [EOL]     if (reset) { [EOL]         millis = iField.roundFloor(millis); [EOL]     } [EOL]     return millis; [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
public long add(long instant, int amount) { [EOL]     instant = super.add(instant, amount); [EOL]     FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax); [EOL]     return instant; [EOL] }
public long add(long instant, long amount) { [EOL]     instant = super.add(instant, amount); [EOL]     FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax); [EOL]     return instant; [EOL] }
public long addWrapField(long instant, int amount) { [EOL]     return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax)); [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMin, iMax); [EOL]     return super.set(instant, value - iOffset); [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMin, iMax); [EOL]     return super.set(instant, value - iOffset); [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMin, iMax); [EOL]     return super.set(instant, value - iOffset); [EOL] }
public long roundHalfFloor(long instant) { [EOL]     return getWrappedField().roundHalfFloor(instant); [EOL] }
public long remainder(long instant) { [EOL]     return getWrappedField().remainder(instant); [EOL] }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     return ((month - 1) * MILLIS_PER_MONTH); [EOL] }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     return ((month - 1) * MILLIS_PER_MONTH); [EOL] }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     return ((month - 1) * MILLIS_PER_MONTH); [EOL] }
int getDayOfMonth(long millis) { [EOL]     return (getDayOfYear(millis) - 1) % MONTH_LENGTH + 1; [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     return (month != 13) ? MONTH_LENGTH : (isLeapYear(year) ? 6 : 5); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     return (month != 13) ? MONTH_LENGTH : (isLeapYear(year) ? 6 : 5); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     return (month != 13) ? MONTH_LENGTH : (isLeapYear(year) ? 6 : 5); [EOL] }
int getMonthOfYear(long millis) { [EOL]     return (getDayOfYear(millis) - 1) / MONTH_LENGTH + 1; [EOL] }
int getMonthOfYear(long millis) { [EOL]     return (getDayOfYear(millis) - 1) / MONTH_LENGTH + 1; [EOL] }
int getMaxMonth() { [EOL]     return 13; [EOL] }
long getAverageMillisPerYear() { [EOL]     return MILLIS_PER_YEAR; [EOL] }
long getAverageMillisPerMonth() { [EOL]     return MILLIS_PER_MONTH; [EOL] }
BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) { [EOL]     super(DateTimeFieldType.weekOfWeekyear(), weeks); [EOL]     iChronology = chronology; [EOL] }
BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) { [EOL]     super(DateTimeFieldType.weekOfWeekyear(), weeks); [EOL]     iChronology = chronology; [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) { [EOL]             int weekyear = values[i]; [EOL]             return iChronology.getWeeksInYear(weekyear); [EOL]         } [EOL]     } [EOL]     return 53; [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) { [EOL]             int weekyear = values[i]; [EOL]             return iChronology.getWeeksInYear(weekyear); [EOL]         } [EOL]     } [EOL]     return 53; [EOL] }
public final DateTimeField millisOfDay() { [EOL]     return iMillisOfDay; [EOL] }
public final DateTimeField dayOfWeek() { [EOL]     return iDayOfWeek; [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days daysBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.days()); [EOL]     return Days.days(amount); [EOL] }
private Days(int days) { [EOL]     super(days); [EOL] }
private Object readResolve() { [EOL]     return Days.days(getValue()); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_DAY)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_DAY)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_DAY)); [EOL] }
public boolean isGreaterThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isGreaterThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isLessThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Days other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) { [EOL]     super(yearField, DateTimeFieldType.yearOfEra()); [EOL]     iChronology = chronology; [EOL] }
@Override [EOL] public DurationField getRangeDurationField() { [EOL]     return iChronology.eras(); [EOL] }
public int get(long instant) { [EOL]     int year = getWrappedField().get(instant); [EOL]     if (year <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return year; [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue()); [EOL]     if (iChronology.getYear(instant) <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return super.set(instant, year); [EOL] }
public int getMaximumValue() { [EOL]     return getWrappedField().getMaximumValue(); [EOL] }
@FromString [EOL] public static MonthDay parse(String str) { [EOL]     return parse(str, PARSER); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay parse(String str, DateTimeFormatter formatter) { [EOL]     LocalDate date = formatter.parseLocalDate(str); [EOL]     return new MonthDay(date.getMonthOfYear(), date.getDayOfMonth()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay parse(String str, DateTimeFormatter formatter) { [EOL]     LocalDate date = formatter.parseLocalDate(str); [EOL]     return new MonthDay(date.getMonthOfYear(), date.getDayOfMonth()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
@ToString [EOL] public String toString() { [EOL]     List<DateTimeFieldType> fields = new ArrayList<DateTimeFieldType>(); [EOL]     fields.add(DateTimeFieldType.monthOfYear()); [EOL]     fields.add(DateTimeFieldType.dayOfMonth()); [EOL]     return ISODateTimeFormat.forFields(fields, true, true).print(this); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static LocalDateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new LocalDateTime(zone); [EOL] }
public static LocalDateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new LocalDateTime(zone); [EOL] }
public static LocalDateTime fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDateTime((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] }
public static LocalDateTime fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDateTime((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] }
public static LocalDateTime fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     int era = calendar.get(Calendar.ERA); [EOL]     int yearOfEra = calendar.get(Calendar.YEAR); [EOL]     return new LocalDateTime((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] }
public LocalDateTime(DateTimeZone zone) { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); [EOL] }
public LocalDateTime(DateTimeZone zone) { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); [EOL] }
public LocalDateTime(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
public LocalDateTime(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
public int size() { [EOL]     return 4; [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chrono.millisOfDay(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public LocalTime toLocalTime() { [EOL]     return new LocalTime(getLocalMillis(), getChronology()); [EOL] }
private Date correctDstTransition(Date date, final TimeZone timeZone) { [EOL]     Calendar calendar = Calendar.getInstance(timeZone); [EOL]     calendar.setTime(date); [EOL]     LocalDateTime check = LocalDateTime.fromCalendarFields(calendar); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.isBefore(this)) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         while (check.isBefore(this) == false) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         final Calendar earlier = Calendar.getInstance(timeZone); [EOL]         earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings()); [EOL]         check = LocalDateTime.fromCalendarFields(earlier); [EOL]         if (check.equals(this)) { [EOL]             calendar = earlier; [EOL]         } [EOL]     } [EOL]     return calendar.getTime(); [EOL] }
private Date correctDstTransition(Date date, final TimeZone timeZone) { [EOL]     Calendar calendar = Calendar.getInstance(timeZone); [EOL]     calendar.setTime(date); [EOL]     LocalDateTime check = LocalDateTime.fromCalendarFields(calendar); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.isBefore(this)) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         while (check.isBefore(this) == false) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         final Calendar earlier = Calendar.getInstance(timeZone); [EOL]         earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings()); [EOL]         check = LocalDateTime.fromCalendarFields(earlier); [EOL]         if (check.equals(this)) { [EOL]             calendar = earlier; [EOL]         } [EOL]     } [EOL]     return calendar.getTime(); [EOL] }
private Date correctDstTransition(Date date, final TimeZone timeZone) { [EOL]     Calendar calendar = Calendar.getInstance(timeZone); [EOL]     calendar.setTime(date); [EOL]     LocalDateTime check = LocalDateTime.fromCalendarFields(calendar); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.isBefore(this)) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         while (check.isBefore(this) == false) { [EOL]             calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000); [EOL]             check = LocalDateTime.fromCalendarFields(calendar); [EOL]         } [EOL]         calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         final Calendar earlier = Calendar.getInstance(timeZone); [EOL]         earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings()); [EOL]         check = LocalDateTime.fromCalendarFields(earlier); [EOL]         if (check.equals(this)) { [EOL]             calendar = earlier; [EOL]         } [EOL]     } [EOL]     return calendar.getTime(); [EOL] }
public LocalDateTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(period, getLocalMillis(), scalar); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().add(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public LocalDateTime minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public LocalDateTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public Class<?> getSupportedType() { [EOL]     return Calendar.class; [EOL] }
public UTCProvider() { [EOL]     super(); [EOL] }
public Set<String> getAvailableIDs() { [EOL]     return Collections.singleton("UTC"); [EOL] }
public DateTimeFormatter withLocale(Locale locale) { [EOL]     if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withChronology(Chronology chrono) { [EOL]     if (iChrono == chrono) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withChronology(Chronology chrono) { [EOL]     if (iChrono == chrono) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withPivotYear(Integer pivotYear) { [EOL]     if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withDefaultYear(int defaultYear) { [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear); [EOL] }
public DateTimeFormatter withDefaultYear(int defaultYear) { [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear); [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public long parseMillis(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(iChrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return bucket.computeMillis(true, text); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public LocalDate parseLocalDate(String text) { [EOL]     return parseLocalDateTime(text).toLocalDate(); [EOL] }
public LocalDateTime parseLocalDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null).withUTC(); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             return new LocalDateTime(millis, chrono); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public LocalDateTime parseLocalDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null).withUTC(); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             return new LocalDateTime(millis, chrono); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public LocalDateTime parseLocalDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null).withUTC(); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             return new LocalDateTime(millis, chrono); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
private Chronology selectChronology(Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     if (iChrono != null) { [EOL]         chrono = iChrono; [EOL]     } [EOL]     if (iZone != null) { [EOL]         chrono = chrono.withZone(iZone); [EOL]     } [EOL]     return chrono; [EOL] }
public long add(long instant, long duration, int scalar) { [EOL]     if (duration == 0 || scalar == 0) { [EOL]         return instant; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(duration, scalar); [EOL]     return FieldUtils.safeAdd(instant, add); [EOL] }
public long add(long instant, long duration, int scalar) { [EOL]     if (duration == 0 || scalar == 0) { [EOL]         return instant; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(duration, scalar); [EOL]     return FieldUtils.safeAdd(instant, add); [EOL] }
public long add(long instant, long duration, int scalar) { [EOL]     if (duration == 0 || scalar == 0) { [EOL]         return instant; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(duration, scalar); [EOL]     return FieldUtils.safeAdd(instant, add); [EOL] }
public long add(long instant, long duration, int scalar) { [EOL]     if (duration == 0 || scalar == 0) { [EOL]         return instant; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(duration, scalar); [EOL]     return FieldUtils.safeAdd(instant, add); [EOL] }
public long getMillis(long value, long instant) { [EOL]     return value; [EOL] }
public String toString() { [EOL]     return "DurationField[millis]"; [EOL] }
protected DateTimeFieldType(String name) { [EOL]     super(); [EOL]     iName = name; [EOL] }
public static DateTimeFieldType centuryOfEra() { [EOL]     return CENTURY_OF_ERA_TYPE; [EOL] }
public String getName() { [EOL]     return iName; [EOL] }
public boolean isSupported(Chronology chronology) { [EOL]     return getField(chronology).isSupported(); [EOL] }
public boolean isSupported(Chronology chronology) { [EOL]     return getField(chronology).isSupported(); [EOL] }
public DurationFieldType getDurationType() { [EOL]     return iUnitType; [EOL] }
public DurationFieldType getRangeDurationType() { [EOL]     return iRangeType; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public boolean isLongerThan(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) > 0; [EOL] }
public boolean isLongerThan(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) > 0; [EOL] }
public boolean isLongerThan(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) > 0; [EOL] }
public boolean isLongerThan(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         duration = Duration.ZERO; [EOL]     } [EOL]     return compareTo(duration) > 0; [EOL] }
public boolean equals(Object duration) { [EOL]     if (this == duration) { [EOL]         return true; [EOL]     } [EOL]     if (duration instanceof ReadableDuration == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableDuration other = (ReadableDuration) duration; [EOL]     return (getMillis() == other.getMillis()); [EOL] }
public boolean equals(Object duration) { [EOL]     if (this == duration) { [EOL]         return true; [EOL]     } [EOL]     if (duration instanceof ReadableDuration == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableDuration other = (ReadableDuration) duration; [EOL]     return (getMillis() == other.getMillis()); [EOL] }
public int hashCode() { [EOL]     long len = getMillis(); [EOL]     return (int) (len ^ (len >>> 32)); [EOL] }
public static GJLocaleSymbols forLocale(Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1); [EOL]     GJLocaleSymbols symbols = cFastCache[index]; [EOL]     if (symbols != null && symbols.iLocale.get() == locale) { [EOL]         return symbols; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         symbols = cCache.get(locale); [EOL]         if (symbols == null) { [EOL]             symbols = new GJLocaleSymbols(locale); [EOL]             cCache.put(locale, symbols); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = symbols; [EOL]     return symbols; [EOL] }
public static GJLocaleSymbols forLocale(Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1); [EOL]     GJLocaleSymbols symbols = cFastCache[index]; [EOL]     if (symbols != null && symbols.iLocale.get() == locale) { [EOL]         return symbols; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         symbols = cCache.get(locale); [EOL]         if (symbols == null) { [EOL]             symbols = new GJLocaleSymbols(locale); [EOL]             cCache.put(locale, symbols); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = symbols; [EOL]     return symbols; [EOL] }
public static GJLocaleSymbols forLocale(Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1); [EOL]     GJLocaleSymbols symbols = cFastCache[index]; [EOL]     if (symbols != null && symbols.iLocale.get() == locale) { [EOL]         return symbols; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         symbols = cCache.get(locale); [EOL]         if (symbols == null) { [EOL]             symbols = new GJLocaleSymbols(locale); [EOL]             cCache.put(locale, symbols); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = symbols; [EOL]     return symbols; [EOL] }
private static String[] realignMonths(String[] months) { [EOL]     String[] a = new String[13]; [EOL]     for (int i = 1; i < 13; i++) { [EOL]         a[i] = months[i - 1]; [EOL]     } [EOL]     return a; [EOL] }
private static String[] realignDaysOfWeek(String[] daysOfWeek) { [EOL]     String[] a = new String[8]; [EOL]     for (int i = 1; i < 8; i++) { [EOL]         a[i] = daysOfWeek[(i < 7) ? i + 1 : 1]; [EOL]     } [EOL]     return a; [EOL] }
private static void addSymbols(TreeMap<String, Integer> map, String[] symbols, Integer[] integers) { [EOL]     for (int i = symbols.length; --i >= 0; ) { [EOL]         String symbol = symbols[i]; [EOL]         if (symbol != null) { [EOL]             map.put(symbol, integers[i]); [EOL]         } [EOL]     } [EOL] }
private static void addNumerals(TreeMap<String, Integer> map, int start, int end, Integer[] integers) { [EOL]     for (int i = start; i <= end; i++) { [EOL]         map.put(String.valueOf(i).intern(), integers[i]); [EOL]     } [EOL] }
private static int maxLength(String[] a) { [EOL]     int max = 0; [EOL]     for (int i = a.length; --i >= 0; ) { [EOL]         String s = a[i]; [EOL]         if (s != null) { [EOL]             int len = s.length(); [EOL]             if (len > max) { [EOL]                 max = len; [EOL]             } [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
private static int maxLength(String[] a) { [EOL]     int max = 0; [EOL]     for (int i = a.length; --i >= 0; ) { [EOL]         String s = a[i]; [EOL]         if (s != null) { [EOL]             int len = s.length(); [EOL]             if (len > max) { [EOL]                 max = len; [EOL]             } [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
private static int maxLength(String[] a) { [EOL]     int max = 0; [EOL]     for (int i = a.length; --i >= 0; ) { [EOL]         String s = a[i]; [EOL]         if (s != null) { [EOL]             int len = s.length(); [EOL]             if (len > max) { [EOL]                 max = len; [EOL]             } [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
private static int maxLength(String[] a) { [EOL]     int max = 0; [EOL]     for (int i = a.length; --i >= 0; ) { [EOL]         String s = a[i]; [EOL]         if (s != null) { [EOL]             int len = s.length(); [EOL]             if (len > max) { [EOL]                 max = len; [EOL]             } [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
private static int maxLength(String[] a) { [EOL]     int max = 0; [EOL]     for (int i = a.length; --i >= 0; ) { [EOL]         String s = a[i]; [EOL]         if (s != null) { [EOL]             int len = s.length(); [EOL]             if (len > max) { [EOL]                 max = len; [EOL]             } [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
private GJLocaleSymbols(Locale locale) { [EOL]     iLocale = new WeakReference<Locale>(locale); [EOL]     DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale); [EOL]     iEras = dfs.getEras(); [EOL]     iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays()); [EOL]     iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays()); [EOL]     iMonths = realignMonths(dfs.getMonths()); [EOL]     iShortMonths = realignMonths(dfs.getShortMonths()); [EOL]     iHalfday = dfs.getAmPmStrings(); [EOL]     Integer[] integers = new Integer[13]; [EOL]     for (int i = 0; i < 13; i++) { [EOL]         integers[i] = Integer.valueOf(i); [EOL]     } [EOL]     iParseEras = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseEras, iEras, integers); [EOL]     if ("en".equals(locale.getLanguage())) { [EOL]         iParseEras.put("BCE", integers[0]); [EOL]         iParseEras.put("CE", integers[1]); [EOL]     } [EOL]     iParseDaysOfWeek = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseDaysOfWeek, iDaysOfWeek, integers); [EOL]     addSymbols(iParseDaysOfWeek, iShortDaysOfWeek, integers); [EOL]     addNumerals(iParseDaysOfWeek, 1, 7, integers); [EOL]     iParseMonths = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseMonths, iMonths, integers); [EOL]     addSymbols(iParseMonths, iShortMonths, integers); [EOL]     addNumerals(iParseMonths, 1, 12, integers); [EOL]     iMaxEraLength = maxLength(iEras); [EOL]     iMaxDayOfWeekLength = maxLength(iDaysOfWeek); [EOL]     iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek); [EOL]     iMaxMonthLength = maxLength(iMonths); [EOL]     iMaxShortMonthLength = maxLength(iShortMonths); [EOL]     iMaxHalfdayLength = maxLength(iHalfday); [EOL] }
private GJLocaleSymbols(Locale locale) { [EOL]     iLocale = new WeakReference<Locale>(locale); [EOL]     DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale); [EOL]     iEras = dfs.getEras(); [EOL]     iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays()); [EOL]     iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays()); [EOL]     iMonths = realignMonths(dfs.getMonths()); [EOL]     iShortMonths = realignMonths(dfs.getShortMonths()); [EOL]     iHalfday = dfs.getAmPmStrings(); [EOL]     Integer[] integers = new Integer[13]; [EOL]     for (int i = 0; i < 13; i++) { [EOL]         integers[i] = Integer.valueOf(i); [EOL]     } [EOL]     iParseEras = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseEras, iEras, integers); [EOL]     if ("en".equals(locale.getLanguage())) { [EOL]         iParseEras.put("BCE", integers[0]); [EOL]         iParseEras.put("CE", integers[1]); [EOL]     } [EOL]     iParseDaysOfWeek = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseDaysOfWeek, iDaysOfWeek, integers); [EOL]     addSymbols(iParseDaysOfWeek, iShortDaysOfWeek, integers); [EOL]     addNumerals(iParseDaysOfWeek, 1, 7, integers); [EOL]     iParseMonths = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseMonths, iMonths, integers); [EOL]     addSymbols(iParseMonths, iShortMonths, integers); [EOL]     addNumerals(iParseMonths, 1, 12, integers); [EOL]     iMaxEraLength = maxLength(iEras); [EOL]     iMaxDayOfWeekLength = maxLength(iDaysOfWeek); [EOL]     iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek); [EOL]     iMaxMonthLength = maxLength(iMonths); [EOL]     iMaxShortMonthLength = maxLength(iShortMonths); [EOL]     iMaxHalfdayLength = maxLength(iHalfday); [EOL] }
public int eraTextToValue(String text) { [EOL]     Integer era = iParseEras.get(text); [EOL]     if (era != null) { [EOL]         return era.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.era(), text); [EOL] }
public String monthOfYearValueToText(int value) { [EOL]     return iMonths[value]; [EOL] }
public String monthOfYearValueToText(int value) { [EOL]     return iMonths[value]; [EOL] }
public int monthOfYearTextToValue(String text) { [EOL]     Integer month = iParseMonths.get(text); [EOL]     if (month != null) { [EOL]         return month.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.monthOfYear(), text); [EOL] }
public int monthOfYearTextToValue(String text) { [EOL]     Integer month = iParseMonths.get(text); [EOL]     if (month != null) { [EOL]         return month.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.monthOfYear(), text); [EOL] }
public int getMonthMaxTextLength() { [EOL]     return iMaxMonthLength; [EOL] }
public String dayOfWeekValueToText(int value) { [EOL]     return iDaysOfWeek[value]; [EOL] }
public String dayOfWeekValueToText(int value) { [EOL]     return iDaysOfWeek[value]; [EOL] }
public int dayOfWeekTextToValue(String text) { [EOL]     Integer day = iParseDaysOfWeek.get(text); [EOL]     if (day != null) { [EOL]         return day.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.dayOfWeek(), text); [EOL] }
public int dayOfWeekTextToValue(String text) { [EOL]     Integer day = iParseDaysOfWeek.get(text); [EOL]     if (day != null) { [EOL]         return day.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.dayOfWeek(), text); [EOL] }
public int getDayOfWeekMaxTextLength() { [EOL]     return iMaxDayOfWeekLength; [EOL] }
public int halfdayTextToValue(String text) { [EOL]     String[] halfday = iHalfday; [EOL]     for (int i = halfday.length; --i >= 0; ) { [EOL]         if (halfday[i].equalsIgnoreCase(text)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.halfdayOfDay(), text); [EOL] }
public Instant toInstant() { [EOL]     return new Instant(getMillis()); [EOL] }
public DateTime toDateTimeISO() { [EOL]     return new DateTime(getMillis(), ISOChronology.getInstance(getZone())); [EOL] }
public DateTime toDateTimeISO() { [EOL]     return new DateTime(getMillis(), ISOChronology.getInstance(getZone())); [EOL] }
public DateTime toDateTime(Chronology chronology) { [EOL]     return new DateTime(getMillis(), chronology); [EOL] }
public DateTime toDateTime(Chronology chronology) { [EOL]     return new DateTime(getMillis(), chronology); [EOL] }
public int compareTo(ReadableInstant other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     long otherMillis = other.getMillis(); [EOL]     long thisMillis = getMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public int compareTo(ReadableInstant other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     long otherMillis = other.getMillis(); [EOL]     long thisMillis = getMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public int compareTo(ReadableInstant other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     long otherMillis = other.getMillis(); [EOL]     long thisMillis = getMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public int compareTo(ReadableInstant other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     long otherMillis = other.getMillis(); [EOL]     long thisMillis = getMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public boolean isBeforeNow() { [EOL]     return isBefore(DateTimeUtils.currentTimeMillis()); [EOL] }
public boolean isEqual(long instant) { [EOL]     return (getMillis() == instant); [EOL] }
public boolean isEqual(long instant) { [EOL]     return (getMillis() == instant); [EOL] }
public boolean isEqualNow() { [EOL]     return isEqual(DateTimeUtils.currentTimeMillis()); [EOL] }
public String toString(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public String toString(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public DividedDateTimeField(DateTimeField field, DateTimeFieldType type, int divisor) { [EOL]     this(field, field.getRangeDurationField(), type, divisor); [EOL] }
public DividedDateTimeField(DateTimeField field, DateTimeFieldType type, int divisor) { [EOL]     this(field, field.getRangeDurationField(), type, divisor); [EOL] }
public DividedDateTimeField(DateTimeField field, DateTimeFieldType type, int divisor) { [EOL]     this(field, field.getRangeDurationField(), type, divisor); [EOL] }
public DividedDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type, int divisor) { [EOL]     super(field, type); [EOL]     if (divisor < 2) { [EOL]         throw new IllegalArgumentException("The divisor must be at least 2"); [EOL]     } [EOL]     DurationField unitField = field.getDurationField(); [EOL]     if (unitField == null) { [EOL]         iDurationField = null; [EOL]     } else { [EOL]         iDurationField = new ScaledDurationField(unitField, type.getDurationType(), divisor); [EOL]     } [EOL]     iRangeDurationField = rangeField; [EOL]     iDivisor = divisor; [EOL]     int i = field.getMinimumValue(); [EOL]     int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1); [EOL]     int j = field.getMaximumValue(); [EOL]     int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1); [EOL]     iMin = min; [EOL]     iMax = max; [EOL] }
public DividedDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type, int divisor) { [EOL]     super(field, type); [EOL]     if (divisor < 2) { [EOL]         throw new IllegalArgumentException("The divisor must be at least 2"); [EOL]     } [EOL]     DurationField unitField = field.getDurationField(); [EOL]     if (unitField == null) { [EOL]         iDurationField = null; [EOL]     } else { [EOL]         iDurationField = new ScaledDurationField(unitField, type.getDurationType(), divisor); [EOL]     } [EOL]     iRangeDurationField = rangeField; [EOL]     iDivisor = divisor; [EOL]     int i = field.getMinimumValue(); [EOL]     int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1); [EOL]     int j = field.getMaximumValue(); [EOL]     int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1); [EOL]     iMin = min; [EOL]     iMax = max; [EOL] }
public DividedDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type, int divisor) { [EOL]     super(field, type); [EOL]     if (divisor < 2) { [EOL]         throw new IllegalArgumentException("The divisor must be at least 2"); [EOL]     } [EOL]     DurationField unitField = field.getDurationField(); [EOL]     if (unitField == null) { [EOL]         iDurationField = null; [EOL]     } else { [EOL]         iDurationField = new ScaledDurationField(unitField, type.getDurationType(), divisor); [EOL]     } [EOL]     iRangeDurationField = rangeField; [EOL]     iDivisor = divisor; [EOL]     int i = field.getMinimumValue(); [EOL]     int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1); [EOL]     int j = field.getMaximumValue(); [EOL]     int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1); [EOL]     iMin = min; [EOL]     iMax = max; [EOL] }
@Override [EOL] public DurationField getRangeDurationField() { [EOL]     if (iRangeDurationField != null) { [EOL]         return iRangeDurationField; [EOL]     } [EOL]     return super.getRangeDurationField(); [EOL] }
@Override [EOL] public DurationField getRangeDurationField() { [EOL]     if (iRangeDurationField != null) { [EOL]         return iRangeDurationField; [EOL]     } [EOL]     return super.getRangeDurationField(); [EOL] }
public int get(long instant) { [EOL]     int value = getWrappedField().get(instant); [EOL]     if (value >= 0) { [EOL]         return value / iDivisor; [EOL]     } else { [EOL]         return ((value + 1) / iDivisor) - 1; [EOL]     } [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMin, iMax); [EOL]     int remainder = getRemainder(getWrappedField().get(instant)); [EOL]     return getWrappedField().set(instant, value * iDivisor + remainder); [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMin, iMax); [EOL]     int remainder = getRemainder(getWrappedField().get(instant)); [EOL]     return getWrappedField().set(instant, value * iDivisor + remainder); [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMin, iMax); [EOL]     int remainder = getRemainder(getWrappedField().get(instant)); [EOL]     return getWrappedField().set(instant, value * iDivisor + remainder); [EOL] }
public DurationField getDurationField() { [EOL]     return iDurationField; [EOL] }
public int getMinimumValue() { [EOL]     return iMin; [EOL] }
public int getMaximumValue() { [EOL]     return iMax; [EOL] }
private int getRemainder(int value) { [EOL]     if (value >= 0) { [EOL]         return value % iDivisor; [EOL]     } else { [EOL]         return (iDivisor - 1) + ((value + 1) % iDivisor); [EOL]     } [EOL] }
private int getRemainder(int value) { [EOL]     if (value >= 0) { [EOL]         return value % iDivisor; [EOL]     } else { [EOL]         return (iDivisor - 1) + ((value + 1) % iDivisor); [EOL]     } [EOL] }
private int getRemainder(int value) { [EOL]     if (value >= 0) { [EOL]         return value % iDivisor; [EOL]     } else { [EOL]         return (iDivisor - 1) + ((value + 1) % iDivisor); [EOL]     } [EOL] }
public MutableInterval(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public MutableInterval(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public MutableInterval(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public MutableInterval(long startInstant, long endInstant, Chronology chronology) { [EOL]     super(startInstant, endInstant, chronology); [EOL] }
public MutableInterval(long startInstant, long endInstant, Chronology chronology) { [EOL]     super(startInstant, endInstant, chronology); [EOL] }
public MutableInterval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(start, duration); [EOL] }
public MutableInterval(ReadableInstant start, ReadableDuration duration) { [EOL]     super(start, duration); [EOL] }
public MutableInterval(ReadableDuration duration, ReadableInstant end) { [EOL]     super(duration, end); [EOL] }
public MutableInterval(ReadableDuration duration, ReadableInstant end) { [EOL]     super(duration, end); [EOL] }
public MutableInterval(Object interval, Chronology chronology) { [EOL]     super(interval, chronology); [EOL] }
public MutableInterval(Object interval, Chronology chronology) { [EOL]     super(interval, chronology); [EOL] }
public MutableInterval(Object interval, Chronology chronology) { [EOL]     super(interval, chronology); [EOL] }
public void setInterval(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         throw new IllegalArgumentException("Interval must not be null"); [EOL]     } [EOL]     long startMillis = interval.getStartMillis(); [EOL]     long endMillis = interval.getEndMillis(); [EOL]     Chronology chrono = interval.getChronology(); [EOL]     super.setInterval(startMillis, endMillis, chrono); [EOL] }
public void setInterval(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == null && end == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         setInterval(now, now); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]         super.setInterval(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setInterval(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == null && end == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         setInterval(now, now); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]         super.setInterval(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setStartMillis(long startInstant) { [EOL]     super.setInterval(startInstant, getEndMillis(), getChronology()); [EOL] }
public void setStartMillis(long startInstant) { [EOL]     super.setInterval(startInstant, getEndMillis(), getChronology()); [EOL] }
public void setEnd(ReadableInstant end) { [EOL]     long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]     super.setInterval(getStartMillis(), endMillis, getChronology()); [EOL] }
public void setDurationAfterStart(long duration) { [EOL]     setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration)); [EOL] }
public void setDurationAfterStart(long duration) { [EOL]     setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration)); [EOL] }
public void setDurationAfterStart(long duration) { [EOL]     setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration)); [EOL] }
public void setDurationBeforeEnd(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     setStartMillis(FieldUtils.safeAdd(getEndMillis(), -durationMillis)); [EOL] }
public void setDurationBeforeEnd(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     setStartMillis(FieldUtils.safeAdd(getEndMillis(), -durationMillis)); [EOL] }
public void setDurationBeforeEnd(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     setStartMillis(FieldUtils.safeAdd(getEndMillis(), -durationMillis)); [EOL] }
public void setPeriodAfterStart(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         setEndMillis(getStartMillis()); [EOL]     } else { [EOL]         setEndMillis(getChronology().add(period, getStartMillis(), 1)); [EOL]     } [EOL] }
public void setPeriodAfterStart(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         setEndMillis(getStartMillis()); [EOL]     } else { [EOL]         setEndMillis(getChronology().add(period, getStartMillis(), 1)); [EOL]     } [EOL] }
public void setPeriodBeforeEnd(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         setStartMillis(getEndMillis()); [EOL]     } else { [EOL]         setStartMillis(getChronology().add(period, getEndMillis(), -1)); [EOL]     } [EOL] }
public void setPeriodBeforeEnd(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         setStartMillis(getEndMillis()); [EOL]     } else { [EOL]         setStartMillis(getChronology().add(period, getEndMillis(), -1)); [EOL]     } [EOL] }
public static DateMidnight now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new DateMidnight(zone); [EOL] }
public static DateMidnight now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new DateMidnight(zone); [EOL] }
public DateMidnight(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateMidnight(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateMidnight(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateMidnight(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateMidnight(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(period, getMillis(), scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(period, getMillis(), scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(period, getMillis(), scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public DateMidnight plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public DateMidnight minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().subtract(getMillis(), days); [EOL]     return withMillis(instant); [EOL] }
private void writeObject(ObjectOutputStream oos) throws IOException { [EOL]     oos.writeObject(iInstant); [EOL]     oos.writeObject(iField.getType()); [EOL] }
private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { [EOL]     iInstant = (DateMidnight) oos.readObject(); [EOL]     DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); [EOL]     iField = type.getField(iInstant.getChronology()); [EOL] }
private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { [EOL]     iInstant = (DateMidnight) oos.readObject(); [EOL]     DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); [EOL]     iField = type.getField(iInstant.getChronology()); [EOL] }
private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { [EOL]     iInstant = (DateMidnight) oos.readObject(); [EOL]     DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); [EOL]     iField = type.getField(iInstant.getChronology()); [EOL] }
public DateMidnight addToCopy(long value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateMidnight addToCopy(long value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateMidnight addToCopy(long value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateMidnight roundHalfFloorCopy() { [EOL]     return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis())); [EOL] }
protected BasePartial(Object instant, Chronology chronology, DateTimeFormatter parser) { [EOL]     super(); [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     iValues = converter.getPartialValues(this, instant, chronology, parser); [EOL] }
protected BasePartial(Object instant, Chronology chronology, DateTimeFormatter parser) { [EOL]     super(); [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     iValues = converter.getPartialValues(this, instant, chronology, parser); [EOL] }
protected BasePartial(Object instant, Chronology chronology, DateTimeFormatter parser) { [EOL]     super(); [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     iValues = converter.getPartialValues(this, instant, chronology, parser); [EOL] }
protected BasePartial(Object instant, Chronology chronology, DateTimeFormatter parser) { [EOL]     super(); [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     iValues = converter.getPartialValues(this, instant, chronology, parser); [EOL] }
