public JacksonAnnotationIntrospector() { [EOL] }
@Override [EOL] public PropertyName findRootName(AnnotatedClass ac) { [EOL]     JsonRootName ann = ac.getAnnotation(JsonRootName.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     return new PropertyName(ann.value()); [EOL] }
@Override [EOL] public PropertyName findRootName(AnnotatedClass ac) { [EOL]     JsonRootName ann = ac.getAnnotation(JsonRootName.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     return new PropertyName(ann.value()); [EOL] }
@Override [EOL] public Object findFilterId(AnnotatedClass ac) { [EOL]     JsonFilter ann = ac.getAnnotation(JsonFilter.class); [EOL]     if (ann != null) { [EOL]         String id = ann.value(); [EOL]         if (id.length() > 0) { [EOL]             return id; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findFilterId(AnnotatedClass ac) { [EOL]     JsonFilter ann = ac.getAnnotation(JsonFilter.class); [EOL]     if (ann != null) { [EOL]         String id = ann.value(); [EOL]         if (id.length() > 0) { [EOL]             return id; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findFilterId(AnnotatedClass ac) { [EOL]     JsonFilter ann = ac.getAnnotation(JsonFilter.class); [EOL]     if (ann != null) { [EOL]         String id = ann.value(); [EOL]         if (id.length() > 0) { [EOL]             return id; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findNamingStrategy(AnnotatedClass ac) { [EOL]     JsonNaming ann = ac.getAnnotation(JsonNaming.class); [EOL]     return (ann == null) ? null : ann.value(); [EOL] }
@Override [EOL] public Object findNamingStrategy(AnnotatedClass ac) { [EOL]     JsonNaming ann = ac.getAnnotation(JsonNaming.class); [EOL]     return (ann == null) ? null : ann.value(); [EOL] }
@Override [EOL] public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) { [EOL]     JsonAutoDetect ann = ac.getAnnotation(JsonAutoDetect.class); [EOL]     return (ann == null) ? checker : checker.with(ann); [EOL] }
@Override [EOL] public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) { [EOL]     JsonAutoDetect ann = ac.getAnnotation(JsonAutoDetect.class); [EOL]     return (ann == null) ? checker : checker.with(ann); [EOL] }
@Override [EOL] public boolean hasIgnoreMarker(AnnotatedMember m) { [EOL]     return _isIgnorable(m); [EOL] }
@Override [EOL] public boolean hasIgnoreMarker(AnnotatedMember m) { [EOL]     return _isIgnorable(m); [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) { [EOL]     return _findTypeResolver(config, ac, baseType); [EOL] }
@Override [EOL] public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) { [EOL]     return _findTypeResolver(config, ac, baseType); [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public Class<?> findSerializationType(Annotated am) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationType(Annotated am) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationType(Annotated am) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ObjectIdInfo findObjectIdInfo(Annotated ann) { [EOL]     JsonIdentityInfo info = ann.getAnnotation(JsonIdentityInfo.class); [EOL]     if (info == null || info.generator() == ObjectIdGenerators.None.class) { [EOL]         return null; [EOL]     } [EOL]     return new ObjectIdInfo(info.property(), info.scope(), info.generator()); [EOL] }
@Override [EOL] public ObjectIdInfo findObjectIdInfo(Annotated ann) { [EOL]     JsonIdentityInfo info = ann.getAnnotation(JsonIdentityInfo.class); [EOL]     if (info == null || info.generator() == ObjectIdGenerators.None.class) { [EOL]         return null; [EOL]     } [EOL]     return new ObjectIdInfo(info.property(), info.scope(), info.generator()); [EOL] }
@Override [EOL] public ObjectIdInfo findObjectIdInfo(Annotated ann) { [EOL]     JsonIdentityInfo info = ann.getAnnotation(JsonIdentityInfo.class); [EOL]     if (info == null || info.generator() == ObjectIdGenerators.None.class) { [EOL]         return null; [EOL]     } [EOL]     return new ObjectIdInfo(info.property(), info.scope(), info.generator()); [EOL] }
@Override [EOL] public JsonFormat.Value findFormat(Annotated annotated) { [EOL]     JsonFormat ann = annotated.getAnnotation(JsonFormat.class); [EOL]     return (ann == null) ? null : new JsonFormat.Value(ann); [EOL] }
@Override [EOL] public JsonFormat.Value findFormat(Annotated annotated) { [EOL]     JsonFormat ann = annotated.getAnnotation(JsonFormat.class); [EOL]     return (ann == null) ? null : new JsonFormat.Value(ann); [EOL] }
@Override [EOL] public String[] findSerializationPropertyOrder(AnnotatedClass ac) { [EOL]     JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class); [EOL]     return (order == null) ? null : order.value(); [EOL] }
@Override [EOL] public String[] findSerializationPropertyOrder(AnnotatedClass ac) { [EOL]     JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class); [EOL]     return (order == null) ? null : order.value(); [EOL] }
@Override [EOL] public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) { [EOL]     JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class); [EOL]     return (order == null) ? null : order.alphabetic(); [EOL] }
@Override [EOL] public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) { [EOL]     JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class); [EOL]     return (order == null) ? null : order.alphabetic(); [EOL] }
@Override [EOL] public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) { [EOL]     JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class); [EOL]     return (order == null) ? null : order.alphabetic(); [EOL] }
@Override [EOL] public PropertyName findNameForSerialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findSerializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findSerializationName((AnnotatedMethod) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForSerialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findSerializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findSerializationName((AnnotatedMethod) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForSerialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findSerializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findSerializationName((AnnotatedMethod) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForSerialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findSerializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findSerializationName((AnnotatedMethod) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedMethod am) { [EOL]     JsonGetter ann = am.getAnnotation(JsonGetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedMethod am) { [EOL]     JsonGetter ann = am.getAnnotation(JsonGetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public boolean hasAsValueAnnotation(AnnotatedMethod am) { [EOL]     JsonValue ann = am.getAnnotation(JsonValue.class); [EOL]     return (ann != null && ann.value()); [EOL] }
@Override [EOL] public boolean hasAsValueAnnotation(AnnotatedMethod am) { [EOL]     JsonValue ann = am.getAnnotation(JsonValue.class); [EOL]     return (ann != null && ann.value()); [EOL] }
@Override [EOL] public boolean hasAsValueAnnotation(AnnotatedMethod am) { [EOL]     JsonValue ann = am.getAnnotation(JsonValue.class); [EOL]     return (ann != null && ann.value()); [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.using(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.using(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.using(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationType(Annotated am, JavaType baseType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationType(Annotated am, JavaType baseType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationType(Annotated am, JavaType baseType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findPOJOBuilder(AnnotatedClass ac) { [EOL]     JsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class); [EOL]     return ((ann == null) || (ann.builder() == NoClass.class)) ? null : ann.builder(); [EOL] }
@Override [EOL] public Class<?> findPOJOBuilder(AnnotatedClass ac) { [EOL]     JsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class); [EOL]     return ((ann == null) || (ann.builder() == NoClass.class)) ? null : ann.builder(); [EOL] }
@Override [EOL] public Class<?> findPOJOBuilder(AnnotatedClass ac) { [EOL]     JsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class); [EOL]     return ((ann == null) || (ann.builder() == NoClass.class)) ? null : ann.builder(); [EOL] }
@Override [EOL] public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedParameter param) { [EOL]     if (param != null) { [EOL]         JsonProperty pann = param.getAnnotation(JsonProperty.class); [EOL]         if (pann != null) { [EOL]             return pann.value(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedParameter param) { [EOL]     if (param != null) { [EOL]         JsonProperty pann = param.getAnnotation(JsonProperty.class); [EOL]         if (pann != null) { [EOL]             return pann.value(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedParameter param) { [EOL]     if (param != null) { [EOL]         JsonProperty pann = param.getAnnotation(JsonProperty.class); [EOL]         if (pann != null) { [EOL]             return pann.value(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public boolean hasAnyGetterAnnotation(AnnotatedMethod am) { [EOL]     return am.hasAnnotation(JsonAnyGetter.class); [EOL] }
@Override [EOL] public boolean hasAnyGetterAnnotation(AnnotatedMethod am) { [EOL]     return am.hasAnnotation(JsonAnyGetter.class); [EOL] }
@Override [EOL] public boolean hasCreatorAnnotation(Annotated a) { [EOL]     return a.hasAnnotation(JsonCreator.class); [EOL] }
@Override [EOL] public boolean hasCreatorAnnotation(Annotated a) { [EOL]     return a.hasAnnotation(JsonCreator.class); [EOL] }
protected boolean _isIgnorable(Annotated a) { [EOL]     JsonIgnore ann = a.getAnnotation(JsonIgnore.class); [EOL]     return (ann != null && ann.value()); [EOL] }
protected boolean _isIgnorable(Annotated a) { [EOL]     JsonIgnore ann = a.getAnnotation(JsonIgnore.class); [EOL]     return (ann != null && ann.value()); [EOL] }
protected boolean _isIgnorable(Annotated a) { [EOL]     JsonIgnore ann = a.getAnnotation(JsonIgnore.class); [EOL]     return (ann != null && ann.value()); [EOL] }
protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) { [EOL]     TypeResolverBuilder<?> b; [EOL]     JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class); [EOL]     JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class); [EOL]     if (resAnn != null) { [EOL]         if (info == null) { [EOL]             return null; [EOL]         } [EOL]         b = config.typeResolverBuilderInstance(ann, resAnn.value()); [EOL]     } else { [EOL]         if (info == null) { [EOL]             return null; [EOL]         } [EOL]         if (info.use() == JsonTypeInfo.Id.NONE) { [EOL]             return _constructNoTypeResolverBuilder(); [EOL]         } [EOL]         b = _constructStdTypeResolverBuilder(); [EOL]     } [EOL]     JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class); [EOL]     TypeIdResolver idRes = (idResInfo == null) ? null : config.typeIdResolverInstance(ann, idResInfo.value()); [EOL]     if (idRes != null) { [EOL]         idRes.init(baseType); [EOL]     } [EOL]     b = b.init(info.use(), idRes); [EOL]     JsonTypeInfo.As inclusion = info.include(); [EOL]     if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) { [EOL]         inclusion = JsonTypeInfo.As.PROPERTY; [EOL]     } [EOL]     b = b.inclusion(inclusion); [EOL]     b = b.typeProperty(info.property()); [EOL]     Class<?> defaultImpl = info.defaultImpl(); [EOL]     if (defaultImpl != JsonTypeInfo.None.class) { [EOL]         b = b.defaultImpl(defaultImpl); [EOL]     } [EOL]     b = b.typeIdVisibility(info.visible()); [EOL]     return b; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StdScalarSerializer(Class<?> t, boolean dummy) { [EOL]     super((Class<T>) t); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StdScalarSerializer(Class<?> t, boolean dummy) { [EOL]     super((Class<T>) t); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StdScalarSerializer(Class<?> t, boolean dummy) { [EOL]     super((Class<T>) t); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StdScalarSerializer(Class<?> t, boolean dummy) { [EOL]     super((Class<T>) t); [EOL] }
@Override [EOL] public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForScalar(value, jgen); [EOL]     serialize(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForScalar(value, jgen); [EOL] }
@Override [EOL] public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForScalar(value, jgen); [EOL]     serialize(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForScalar(value, jgen); [EOL] }
public ObjectIdInfo(String prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen) { [EOL]     this(prop, scope, gen, false); [EOL] }
public ObjectIdInfo(String prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen) { [EOL]     this(prop, scope, gen, false); [EOL] }
protected ObjectIdInfo(String prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen, boolean alwaysAsId) { [EOL]     _propertyName = prop; [EOL]     _scope = scope; [EOL]     _generator = gen; [EOL]     _alwaysAsId = alwaysAsId; [EOL] }
protected ObjectIdInfo(String prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen, boolean alwaysAsId) { [EOL]     _propertyName = prop; [EOL]     _scope = scope; [EOL]     _generator = gen; [EOL]     _alwaysAsId = alwaysAsId; [EOL] }
public String getPropertyName() { [EOL]     return _propertyName; [EOL] }
public String getPropertyName() { [EOL]     return _propertyName; [EOL] }
public String getPropertyName() { [EOL]     return _propertyName; [EOL] }
public Class<?> getScope() { [EOL]     return _scope; [EOL] }
public Class<? extends ObjectIdGenerator<?>> getGeneratorType() { [EOL]     return _generator; [EOL] }
public boolean getAlwaysAsId() { [EOL]     return _alwaysAsId; [EOL] }
public boolean getAlwaysAsId() { [EOL]     return _alwaysAsId; [EOL] }
protected DeserializationContext(DeserializerFactory df, DeserializerCache cache) { [EOL]     if (df == null) { [EOL]         throw new IllegalArgumentException("Can not pass null DeserializerFactory"); [EOL]     } [EOL]     _factory = df; [EOL]     _cache = (cache == null) ? new DeserializerCache() : cache; [EOL]     _featureFlags = 0; [EOL]     _config = null; [EOL]     _injectableValues = null; [EOL]     _view = null; [EOL] }
protected DeserializationContext(DeserializerFactory df, DeserializerCache cache) { [EOL]     if (df == null) { [EOL]         throw new IllegalArgumentException("Can not pass null DeserializerFactory"); [EOL]     } [EOL]     _factory = df; [EOL]     _cache = (cache == null) ? new DeserializerCache() : cache; [EOL]     _featureFlags = 0; [EOL]     _config = null; [EOL]     _injectableValues = null; [EOL]     _view = null; [EOL] }
protected DeserializationContext(DeserializerFactory df, DeserializerCache cache) { [EOL]     if (df == null) { [EOL]         throw new IllegalArgumentException("Can not pass null DeserializerFactory"); [EOL]     } [EOL]     _factory = df; [EOL]     _cache = (cache == null) ? new DeserializerCache() : cache; [EOL]     _featureFlags = 0; [EOL]     _config = null; [EOL]     _injectableValues = null; [EOL]     _view = null; [EOL] }
public boolean hasValueDeserializerFor(JavaType type) { [EOL]     return _cache.hasValueDeserializerFor(this, _factory, type); [EOL] }
public boolean hasValueDeserializerFor(JavaType type) { [EOL]     return _cache.hasValueDeserializerFor(this, _factory, type); [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser != null) { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, property); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser != null) { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, property); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser != null) { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, property); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
public final KeyDeserializer findKeyDeserializer(JavaType keyType, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _cache.findKeyDeserializer(this, _factory, keyType); [EOL]     if (kd instanceof ContextualKeyDeserializer) { [EOL]         kd = ((ContextualKeyDeserializer) kd).createContextual(this, property); [EOL]     } [EOL]     return kd; [EOL] }
public final KeyDeserializer findKeyDeserializer(JavaType keyType, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _cache.findKeyDeserializer(this, _factory, keyType); [EOL]     if (kd instanceof ContextualKeyDeserializer) { [EOL]         kd = ((ContextualKeyDeserializer) kd).createContextual(this, property); [EOL]     } [EOL]     return kd; [EOL] }
public final ObjectBuffer leaseObjectBuffer() { [EOL]     ObjectBuffer buf = _objectBuffer; [EOL]     if (buf == null) { [EOL]         buf = new ObjectBuffer(); [EOL]     } else { [EOL]         _objectBuffer = null; [EOL]     } [EOL]     return buf; [EOL] }
public final ObjectBuffer leaseObjectBuffer() { [EOL]     ObjectBuffer buf = _objectBuffer; [EOL]     if (buf == null) { [EOL]         buf = new ObjectBuffer(); [EOL]     } else { [EOL]         _objectBuffer = null; [EOL]     } [EOL]     return buf; [EOL] }
public final void returnObjectBuffer(ObjectBuffer buf) { [EOL]     if (_objectBuffer == null || buf.initialCapacity() >= _objectBuffer.initialCapacity()) { [EOL]         _objectBuffer = buf; [EOL]     } [EOL] }
public final void returnObjectBuffer(ObjectBuffer buf) { [EOL]     if (_objectBuffer == null || buf.initialCapacity() >= _objectBuffer.initialCapacity()) { [EOL]         _objectBuffer = buf; [EOL]     } [EOL] }
public final void returnObjectBuffer(ObjectBuffer buf) { [EOL]     if (_objectBuffer == null || buf.initialCapacity() >= _objectBuffer.initialCapacity()) { [EOL]         _objectBuffer = buf; [EOL]     } [EOL] }
public JsonMappingException instantiationException(Class<?> instClass, String msg) { [EOL]     return JsonMappingException.from(_parser, "Can not construct instance of " + instClass.getName() + ", problem: " + msg); [EOL] }
public JsonMappingException instantiationException(Class<?> instClass, String msg) { [EOL]     return JsonMappingException.from(_parser, "Can not construct instance of " + instClass.getName() + ", problem: " + msg); [EOL] }
public JsonMappingException instantiationException(Class<?> instClass, String msg) { [EOL]     return JsonMappingException.from(_parser, "Can not construct instance of " + instClass.getName() + ", problem: " + msg); [EOL] }
protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache) { [EOL]     super(df, cache); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
public Impl(DeserializerFactory df) { [EOL]     super(df, null); [EOL] }
public Impl(DeserializerFactory df) { [EOL]     super(df, null); [EOL] }
public POJOPropertyBuilder(String internalName, AnnotationIntrospector annotationIntrospector, boolean forSerialization) { [EOL]     _internalName = internalName; [EOL]     _name = internalName; [EOL]     _annotationIntrospector = annotationIntrospector; [EOL]     _forSerialization = forSerialization; [EOL] }
public POJOPropertyBuilder(String internalName, AnnotationIntrospector annotationIntrospector, boolean forSerialization) { [EOL]     _internalName = internalName; [EOL]     _name = internalName; [EOL]     _annotationIntrospector = annotationIntrospector; [EOL]     _forSerialization = forSerialization; [EOL] }
public POJOPropertyBuilder(POJOPropertyBuilder src, String newName) { [EOL]     _internalName = src._internalName; [EOL]     _name = newName; [EOL]     _annotationIntrospector = src._annotationIntrospector; [EOL]     _fields = src._fields; [EOL]     _ctorParameters = src._ctorParameters; [EOL]     _getters = src._getters; [EOL]     _setters = src._setters; [EOL]     _forSerialization = src._forSerialization; [EOL] }
@Override [EOL] public POJOPropertyBuilder withName(String newName) { [EOL]     return new POJOPropertyBuilder(this, newName); [EOL] }
@Override [EOL] public POJOPropertyBuilder withName(String newName) { [EOL]     return new POJOPropertyBuilder(this, newName); [EOL] }
@Override [EOL] public String getName() { [EOL]     return _name; [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     AnnotatedMember member = getPrimaryMember(); [EOL]     return (member == null || _annotationIntrospector == null) ? null : _annotationIntrospector.findWrapperName(member); [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     AnnotatedMember member = getPrimaryMember(); [EOL]     return (member == null || _annotationIntrospector == null) ? null : _annotationIntrospector.findWrapperName(member); [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     AnnotatedMember member = getPrimaryMember(); [EOL]     return (member == null || _annotationIntrospector == null) ? null : _annotationIntrospector.findWrapperName(member); [EOL] }
@Override [EOL] public boolean hasGetter() { [EOL]     return _getters != null; [EOL] }
@Override [EOL] public boolean hasGetter() { [EOL]     return _getters != null; [EOL] }
@Override [EOL] public boolean hasSetter() { [EOL]     return _setters != null; [EOL] }
@Override [EOL] public boolean hasSetter() { [EOL]     return _setters != null; [EOL] }
@Override [EOL] public boolean hasField() { [EOL]     return _fields != null; [EOL] }
@Override [EOL] public boolean hasField() { [EOL]     return _fields != null; [EOL] }
@Override [EOL] public boolean hasConstructorParameter() { [EOL]     return _ctorParameters != null; [EOL] }
@Override [EOL] public boolean hasConstructorParameter() { [EOL]     return _ctorParameters != null; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if (_setters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod setter = _setters.value; [EOL]     Linked<AnnotatedMethod> next = _setters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextSetter = next.value; [EOL]         Class<?> setterClass = setter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextSetter.getDeclaringClass(); [EOL]         if (setterClass != nextClass) { [EOL]             if (setterClass.isAssignableFrom(nextClass)) { [EOL]                 setter = nextSetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(setterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting setter definitions for property \"" + getName() + "\": " + setter.getFullName() + " vs " + nextSetter.getFullName()); [EOL]     } [EOL]     return setter; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if (_setters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod setter = _setters.value; [EOL]     Linked<AnnotatedMethod> next = _setters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextSetter = next.value; [EOL]         Class<?> setterClass = setter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextSetter.getDeclaringClass(); [EOL]         if (setterClass != nextClass) { [EOL]             if (setterClass.isAssignableFrom(nextClass)) { [EOL]                 setter = nextSetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(setterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting setter definitions for property \"" + getName() + "\": " + setter.getFullName() + " vs " + nextSetter.getFullName()); [EOL]     } [EOL]     return setter; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if (_setters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod setter = _setters.value; [EOL]     Linked<AnnotatedMethod> next = _setters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextSetter = next.value; [EOL]         Class<?> setterClass = setter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextSetter.getDeclaringClass(); [EOL]         if (setterClass != nextClass) { [EOL]             if (setterClass.isAssignableFrom(nextClass)) { [EOL]                 setter = nextSetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(setterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting setter definitions for property \"" + getName() + "\": " + setter.getFullName() + " vs " + nextSetter.getFullName()); [EOL]     } [EOL]     return setter; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
@Override [EOL] public AnnotatedMember getAccessor() { [EOL]     AnnotatedMember m = getGetter(); [EOL]     if (m == null) { [EOL]         m = getField(); [EOL]     } [EOL]     return m; [EOL] }
@Override [EOL] public AnnotatedMember getAccessor() { [EOL]     AnnotatedMember m = getGetter(); [EOL]     if (m == null) { [EOL]         m = getField(); [EOL]     } [EOL]     return m; [EOL] }
@Override [EOL] public AnnotatedMember getMutator() { [EOL]     AnnotatedMember m = getConstructorParameter(); [EOL]     if (m == null) { [EOL]         m = getSetter(); [EOL]         if (m == null) { [EOL]             m = getField(); [EOL]         } [EOL]     } [EOL]     return m; [EOL] }
@Override [EOL] public AnnotatedMember getMutator() { [EOL]     AnnotatedMember m = getConstructorParameter(); [EOL]     if (m == null) { [EOL]         m = getSetter(); [EOL]         if (m == null) { [EOL]             m = getField(); [EOL]         } [EOL]     } [EOL]     return m; [EOL] }
@Override [EOL] public AnnotatedMember getMutator() { [EOL]     AnnotatedMember m = getConstructorParameter(); [EOL]     if (m == null) { [EOL]         m = getSetter(); [EOL]         if (m == null) { [EOL]             m = getField(); [EOL]         } [EOL]     } [EOL]     return m; [EOL] }
@Override [EOL] public AnnotatedMember getPrimaryMember() { [EOL]     if (_forSerialization) { [EOL]         return getAccessor(); [EOL]     } [EOL]     return getMutator(); [EOL] }
@Override [EOL] public AnnotatedMember getPrimaryMember() { [EOL]     if (_forSerialization) { [EOL]         return getAccessor(); [EOL]     } [EOL]     return getMutator(); [EOL] }
@Override [EOL] public Class<?>[] findViews() { [EOL]     return fromMemberAnnotations(new WithMember<Class<?>[]>() { [EOL]  [EOL]         @Override [EOL]         public Class<?>[] withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.findViews(member); [EOL]         } [EOL]     }); [EOL] }
@Override [EOL] public Class<?>[] findViews() { [EOL]     return fromMemberAnnotations(new WithMember<Class<?>[]>() { [EOL]  [EOL]         @Override [EOL]         public Class<?>[] withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.findViews(member); [EOL]         } [EOL]     }); [EOL] }
@Override [EOL] public AnnotationIntrospector.ReferenceProperty findReferenceType() { [EOL]     return fromMemberAnnotations(new WithMember<AnnotationIntrospector.ReferenceProperty>() { [EOL]  [EOL]         @Override [EOL]         public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.findReferenceType(member); [EOL]         } [EOL]     }); [EOL] }
@Override [EOL] public AnnotationIntrospector.ReferenceProperty findReferenceType() { [EOL]     return fromMemberAnnotations(new WithMember<AnnotationIntrospector.ReferenceProperty>() { [EOL]  [EOL]         @Override [EOL]         public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.findReferenceType(member); [EOL]         } [EOL]     }); [EOL] }
@Override [EOL] public boolean isTypeId() { [EOL]     Boolean b = fromMemberAnnotations(new WithMember<Boolean>() { [EOL]  [EOL]         @Override [EOL]         public Boolean withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.isTypeId(member); [EOL]         } [EOL]     }); [EOL]     return (b != null) && b.booleanValue(); [EOL] }
@Override [EOL] public boolean isTypeId() { [EOL]     Boolean b = fromMemberAnnotations(new WithMember<Boolean>() { [EOL]  [EOL]         @Override [EOL]         public Boolean withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.isTypeId(member); [EOL]         } [EOL]     }); [EOL]     return (b != null) && b.booleanValue(); [EOL] }
@Override [EOL] public boolean isTypeId() { [EOL]     Boolean b = fromMemberAnnotations(new WithMember<Boolean>() { [EOL]  [EOL]         @Override [EOL]         public Boolean withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.isTypeId(member); [EOL]         } [EOL]     }); [EOL]     return (b != null) && b.booleanValue(); [EOL] }
@Override [EOL] public boolean isRequired() { [EOL]     Boolean b = fromMemberAnnotations(new WithMember<Boolean>() { [EOL]  [EOL]         @Override [EOL]         public Boolean withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.hasRequiredMarker(member); [EOL]         } [EOL]     }); [EOL]     return (b != null) && b.booleanValue(); [EOL] }
@Override [EOL] public boolean isRequired() { [EOL]     Boolean b = fromMemberAnnotations(new WithMember<Boolean>() { [EOL]  [EOL]         @Override [EOL]         public Boolean withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.hasRequiredMarker(member); [EOL]         } [EOL]     }); [EOL]     return (b != null) && b.booleanValue(); [EOL] }
@Override [EOL] public boolean isRequired() { [EOL]     Boolean b = fromMemberAnnotations(new WithMember<Boolean>() { [EOL]  [EOL]         @Override [EOL]         public Boolean withMember(AnnotatedMember member) { [EOL]             return _annotationIntrospector.hasRequiredMarker(member); [EOL]         } [EOL]     }); [EOL]     return (b != null) && b.booleanValue(); [EOL] }
public void addField(AnnotatedField a, String ename, boolean visible, boolean ignored) { [EOL]     _fields = new Linked<AnnotatedField>(a, _fields, ename, visible, ignored); [EOL] }
public void addField(AnnotatedField a, String ename, boolean visible, boolean ignored) { [EOL]     _fields = new Linked<AnnotatedField>(a, _fields, ename, visible, ignored); [EOL] }
public void addCtor(AnnotatedParameter a, String ename, boolean visible, boolean ignored) { [EOL]     _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, ename, visible, ignored); [EOL] }
public void addCtor(AnnotatedParameter a, String ename, boolean visible, boolean ignored) { [EOL]     _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, ename, visible, ignored); [EOL] }
public void addGetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) { [EOL]     _getters = new Linked<AnnotatedMethod>(a, _getters, ename, visible, ignored); [EOL] }
public void addGetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) { [EOL]     _getters = new Linked<AnnotatedMethod>(a, _getters, ename, visible, ignored); [EOL] }
public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) { [EOL]     _setters = new Linked<AnnotatedMethod>(a, _setters, ename, visible, ignored); [EOL] }
public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) { [EOL]     _setters = new Linked<AnnotatedMethod>(a, _setters, ename, visible, ignored); [EOL] }
public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) { [EOL]     _setters = new Linked<AnnotatedMethod>(a, _setters, ename, visible, ignored); [EOL] }
public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) { [EOL]     _setters = new Linked<AnnotatedMethod>(a, _setters, ename, visible, ignored); [EOL] }
public void removeIgnored() { [EOL]     _fields = _removeIgnored(_fields); [EOL]     _getters = _removeIgnored(_getters); [EOL]     _setters = _removeIgnored(_setters); [EOL]     _ctorParameters = _removeIgnored(_ctorParameters); [EOL] }
public void removeIgnored() { [EOL]     _fields = _removeIgnored(_fields); [EOL]     _getters = _removeIgnored(_getters); [EOL]     _setters = _removeIgnored(_setters); [EOL]     _ctorParameters = _removeIgnored(_ctorParameters); [EOL] }
public void removeNonVisible(boolean force) { [EOL]     _getters = _removeNonVisible(_getters); [EOL]     _ctorParameters = _removeNonVisible(_ctorParameters); [EOL]     if (force || (_getters == null)) { [EOL]         _fields = _removeNonVisible(_fields); [EOL]         _setters = _removeNonVisible(_setters); [EOL]     } [EOL] }
public void removeNonVisible(boolean force) { [EOL]     _getters = _removeNonVisible(_getters); [EOL]     _ctorParameters = _removeNonVisible(_ctorParameters); [EOL]     if (force || (_getters == null)) { [EOL]         _fields = _removeNonVisible(_fields); [EOL]         _setters = _removeNonVisible(_setters); [EOL]     } [EOL] }
public void trimByVisibility() { [EOL]     _fields = _trimByVisibility(_fields); [EOL]     _getters = _trimByVisibility(_getters); [EOL]     _setters = _trimByVisibility(_setters); [EOL]     _ctorParameters = _trimByVisibility(_ctorParameters); [EOL] }
public void trimByVisibility() { [EOL]     _fields = _trimByVisibility(_fields); [EOL]     _getters = _trimByVisibility(_getters); [EOL]     _setters = _trimByVisibility(_setters); [EOL]     _ctorParameters = _trimByVisibility(_ctorParameters); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void mergeAnnotations(boolean forSerialization) { [EOL]     if (forSerialization) { [EOL]         if (_getters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters); [EOL]             _getters = _getters.withValue(_getters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } else { [EOL]         if (_ctorParameters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters); [EOL]             _ctorParameters = _ctorParameters.withValue(_ctorParameters.value.withAnnotations(ann)); [EOL]         } else if (_setters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters); [EOL]             _setters = _setters.withValue(_setters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _getters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public void mergeAnnotations(boolean forSerialization) { [EOL]     if (forSerialization) { [EOL]         if (_getters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters); [EOL]             _getters = _getters.withValue(_getters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } else { [EOL]         if (_ctorParameters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters); [EOL]             _ctorParameters = _ctorParameters.withValue(_ctorParameters.value.withAnnotations(ann)); [EOL]         } else if (_setters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters); [EOL]             _setters = _setters.withValue(_setters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _getters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public void mergeAnnotations(boolean forSerialization) { [EOL]     if (forSerialization) { [EOL]         if (_getters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters); [EOL]             _getters = _getters.withValue(_getters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } else { [EOL]         if (_ctorParameters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters); [EOL]             _ctorParameters = _ctorParameters.withValue(_ctorParameters.value.withAnnotations(ann)); [EOL]         } else if (_setters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters); [EOL]             _setters = _setters.withValue(_setters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _getters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public void mergeAnnotations(boolean forSerialization) { [EOL]     if (forSerialization) { [EOL]         if (_getters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters); [EOL]             _getters = _getters.withValue(_getters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } else { [EOL]         if (_ctorParameters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters); [EOL]             _ctorParameters = _ctorParameters.withValue(_ctorParameters.value.withAnnotations(ann)); [EOL]         } else if (_setters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters); [EOL]             _setters = _setters.withValue(_setters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _getters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public void mergeAnnotations(boolean forSerialization) { [EOL]     if (forSerialization) { [EOL]         if (_getters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters); [EOL]             _getters = _getters.withValue(_getters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } else { [EOL]         if (_ctorParameters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters); [EOL]             _ctorParameters = _ctorParameters.withValue(_ctorParameters.value.withAnnotations(ann)); [EOL]         } else if (_setters != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters); [EOL]             _setters = _setters.withValue(_setters.value.withAnnotations(ann)); [EOL]         } else if (_fields != null) { [EOL]             AnnotationMap ann = _mergeAnnotations(0, _fields, _getters); [EOL]             _fields = _fields.withValue(_fields.value.withAnnotations(ann)); [EOL]         } [EOL]     } [EOL] }
private AnnotationMap _mergeAnnotations(int index, Linked<? extends AnnotatedMember>... nodes) { [EOL]     AnnotationMap ann = nodes[index].value.getAllAnnotations(); [EOL]     ++index; [EOL]     for (; index < nodes.length; ++index) { [EOL]         if (nodes[index] != null) { [EOL]             return AnnotationMap.merge(ann, _mergeAnnotations(index, nodes)); [EOL]         } [EOL]     } [EOL]     return ann; [EOL] }
private <T> Linked<T> _removeIgnored(Linked<T> node) { [EOL]     if (node == null) { [EOL]         return node; [EOL]     } [EOL]     return node.withoutIgnored(); [EOL] }
private <T> Linked<T> _removeIgnored(Linked<T> node) { [EOL]     if (node == null) { [EOL]         return node; [EOL]     } [EOL]     return node.withoutIgnored(); [EOL] }
private <T> Linked<T> _removeNonVisible(Linked<T> node) { [EOL]     if (node == null) { [EOL]         return node; [EOL]     } [EOL]     return node.withoutNonVisible(); [EOL] }
private <T> Linked<T> _removeNonVisible(Linked<T> node) { [EOL]     if (node == null) { [EOL]         return node; [EOL]     } [EOL]     return node.withoutNonVisible(); [EOL] }
private <T> Linked<T> _trimByVisibility(Linked<T> node) { [EOL]     if (node == null) { [EOL]         return node; [EOL]     } [EOL]     return node.trimByVisibility(); [EOL] }
private <T> Linked<T> _trimByVisibility(Linked<T> node) { [EOL]     if (node == null) { [EOL]         return node; [EOL]     } [EOL]     return node.trimByVisibility(); [EOL] }
public boolean anyVisible() { [EOL]     return _anyVisible(_fields) || _anyVisible(_getters) || _anyVisible(_setters) || _anyVisible(_ctorParameters); [EOL] }
public boolean anyVisible() { [EOL]     return _anyVisible(_fields) || _anyVisible(_getters) || _anyVisible(_setters) || _anyVisible(_ctorParameters); [EOL] }
public boolean anyVisible() { [EOL]     return _anyVisible(_fields) || _anyVisible(_getters) || _anyVisible(_setters) || _anyVisible(_ctorParameters); [EOL] }
public boolean anyVisible() { [EOL]     return _anyVisible(_fields) || _anyVisible(_getters) || _anyVisible(_setters) || _anyVisible(_ctorParameters); [EOL] }
public boolean anyVisible() { [EOL]     return _anyVisible(_fields) || _anyVisible(_getters) || _anyVisible(_setters) || _anyVisible(_ctorParameters); [EOL] }
private <T> boolean _anyVisible(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.isVisible) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean anyIgnorals() { [EOL]     return _anyIgnorals(_fields) || _anyIgnorals(_getters) || _anyIgnorals(_setters) || _anyIgnorals(_ctorParameters); [EOL] }
public boolean anyIgnorals() { [EOL]     return _anyIgnorals(_fields) || _anyIgnorals(_getters) || _anyIgnorals(_setters) || _anyIgnorals(_ctorParameters); [EOL] }
public boolean anyIgnorals() { [EOL]     return _anyIgnorals(_fields) || _anyIgnorals(_getters) || _anyIgnorals(_setters) || _anyIgnorals(_ctorParameters); [EOL] }
public boolean anyIgnorals() { [EOL]     return _anyIgnorals(_fields) || _anyIgnorals(_getters) || _anyIgnorals(_setters) || _anyIgnorals(_ctorParameters); [EOL] }
public boolean anyIgnorals() { [EOL]     return _anyIgnorals(_fields) || _anyIgnorals(_getters) || _anyIgnorals(_setters) || _anyIgnorals(_ctorParameters); [EOL] }
private <T> boolean _anyIgnorals(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.isMarkedIgnored) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private <T> boolean _anyIgnorals(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.isMarkedIgnored) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private <T> boolean _anyIgnorals(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.isMarkedIgnored) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public String findNewName() { [EOL]     Linked<? extends AnnotatedMember> renamed = null; [EOL]     renamed = findRenamed(_fields, renamed); [EOL]     renamed = findRenamed(_getters, renamed); [EOL]     renamed = findRenamed(_setters, renamed); [EOL]     renamed = findRenamed(_ctorParameters, renamed); [EOL]     return (renamed == null) ? null : renamed.explicitName; [EOL] }
public String findNewName() { [EOL]     Linked<? extends AnnotatedMember> renamed = null; [EOL]     renamed = findRenamed(_fields, renamed); [EOL]     renamed = findRenamed(_getters, renamed); [EOL]     renamed = findRenamed(_setters, renamed); [EOL]     renamed = findRenamed(_ctorParameters, renamed); [EOL]     return (renamed == null) ? null : renamed.explicitName; [EOL] }
public String findNewName() { [EOL]     Linked<? extends AnnotatedMember> renamed = null; [EOL]     renamed = findRenamed(_fields, renamed); [EOL]     renamed = findRenamed(_getters, renamed); [EOL]     renamed = findRenamed(_setters, renamed); [EOL]     renamed = findRenamed(_ctorParameters, renamed); [EOL]     return (renamed == null) ? null : renamed.explicitName; [EOL] }
public String findNewName() { [EOL]     Linked<? extends AnnotatedMember> renamed = null; [EOL]     renamed = findRenamed(_fields, renamed); [EOL]     renamed = findRenamed(_getters, renamed); [EOL]     renamed = findRenamed(_setters, renamed); [EOL]     renamed = findRenamed(_ctorParameters, renamed); [EOL]     return (renamed == null) ? null : renamed.explicitName; [EOL] }
public String findNewName() { [EOL]     Linked<? extends AnnotatedMember> renamed = null; [EOL]     renamed = findRenamed(_fields, renamed); [EOL]     renamed = findRenamed(_getters, renamed); [EOL]     renamed = findRenamed(_setters, renamed); [EOL]     renamed = findRenamed(_ctorParameters, renamed); [EOL]     return (renamed == null) ? null : renamed.explicitName; [EOL] }
private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node, Linked<? extends AnnotatedMember> renamed) { [EOL]     for (; node != null; node = node.next) { [EOL]         String explName = node.explicitName; [EOL]         if (explName == null) { [EOL]             continue; [EOL]         } [EOL]         if (explName.equals(_name)) { [EOL]             continue; [EOL]         } [EOL]         if (renamed == null) { [EOL]             renamed = node; [EOL]         } else { [EOL]             if (!explName.equals(renamed.explicitName)) { [EOL]                 throw new IllegalStateException("Conflicting property name definitions: '" + renamed.explicitName + "' (for " + renamed.value + ") vs '" + node.explicitName + "' (for " + node.value + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return renamed; [EOL] }
private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node, Linked<? extends AnnotatedMember> renamed) { [EOL]     for (; node != null; node = node.next) { [EOL]         String explName = node.explicitName; [EOL]         if (explName == null) { [EOL]             continue; [EOL]         } [EOL]         if (explName.equals(_name)) { [EOL]             continue; [EOL]         } [EOL]         if (renamed == null) { [EOL]             renamed = node; [EOL]         } else { [EOL]             if (!explName.equals(renamed.explicitName)) { [EOL]                 throw new IllegalStateException("Conflicting property name definitions: '" + renamed.explicitName + "' (for " + renamed.value + ") vs '" + node.explicitName + "' (for " + node.value + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return renamed; [EOL] }
private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node, Linked<? extends AnnotatedMember> renamed) { [EOL]     for (; node != null; node = node.next) { [EOL]         String explName = node.explicitName; [EOL]         if (explName == null) { [EOL]             continue; [EOL]         } [EOL]         if (explName.equals(_name)) { [EOL]             continue; [EOL]         } [EOL]         if (renamed == null) { [EOL]             renamed = node; [EOL]         } else { [EOL]             if (!explName.equals(renamed.explicitName)) { [EOL]                 throw new IllegalStateException("Conflicting property name definitions: '" + renamed.explicitName + "' (for " + renamed.value + ") vs '" + node.explicitName + "' (for " + node.value + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return renamed; [EOL] }
private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node, Linked<? extends AnnotatedMember> renamed) { [EOL]     for (; node != null; node = node.next) { [EOL]         String explName = node.explicitName; [EOL]         if (explName == null) { [EOL]             continue; [EOL]         } [EOL]         if (explName.equals(_name)) { [EOL]             continue; [EOL]         } [EOL]         if (renamed == null) { [EOL]             renamed = node; [EOL]         } else { [EOL]             if (!explName.equals(renamed.explicitName)) { [EOL]                 throw new IllegalStateException("Conflicting property name definitions: '" + renamed.explicitName + "' (for " + renamed.value + ") vs '" + node.explicitName + "' (for " + node.value + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return renamed; [EOL] }
protected <T> T fromMemberAnnotations(WithMember<T> func) { [EOL]     T result = null; [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_forSerialization) { [EOL]             if (_getters != null) { [EOL]                 result = func.withMember(_getters.value); [EOL]             } [EOL]         } else { [EOL]             if (_ctorParameters != null) { [EOL]                 result = func.withMember(_ctorParameters.value); [EOL]             } [EOL]             if (result == null && _setters != null) { [EOL]                 result = func.withMember(_setters.value); [EOL]             } [EOL]         } [EOL]         if (result == null && _fields != null) { [EOL]             result = func.withMember(_fields.value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected <T> T fromMemberAnnotations(WithMember<T> func) { [EOL]     T result = null; [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_forSerialization) { [EOL]             if (_getters != null) { [EOL]                 result = func.withMember(_getters.value); [EOL]             } [EOL]         } else { [EOL]             if (_ctorParameters != null) { [EOL]                 result = func.withMember(_ctorParameters.value); [EOL]             } [EOL]             if (result == null && _setters != null) { [EOL]                 result = func.withMember(_setters.value); [EOL]             } [EOL]         } [EOL]         if (result == null && _fields != null) { [EOL]             result = func.withMember(_fields.value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected <T> T fromMemberAnnotations(WithMember<T> func) { [EOL]     T result = null; [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_forSerialization) { [EOL]             if (_getters != null) { [EOL]                 result = func.withMember(_getters.value); [EOL]             } [EOL]         } else { [EOL]             if (_ctorParameters != null) { [EOL]                 result = func.withMember(_ctorParameters.value); [EOL]             } [EOL]             if (result == null && _setters != null) { [EOL]                 result = func.withMember(_setters.value); [EOL]             } [EOL]         } [EOL]         if (result == null && _fields != null) { [EOL]             result = func.withMember(_fields.value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected <T> T fromMemberAnnotations(WithMember<T> func) { [EOL]     T result = null; [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_forSerialization) { [EOL]             if (_getters != null) { [EOL]                 result = func.withMember(_getters.value); [EOL]             } [EOL]         } else { [EOL]             if (_ctorParameters != null) { [EOL]                 result = func.withMember(_ctorParameters.value); [EOL]             } [EOL]             if (result == null && _setters != null) { [EOL]                 result = func.withMember(_setters.value); [EOL]             } [EOL]         } [EOL]         if (result == null && _fields != null) { [EOL]             result = func.withMember(_fields.value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected <T> T fromMemberAnnotations(WithMember<T> func) { [EOL]     T result = null; [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_forSerialization) { [EOL]             if (_getters != null) { [EOL]                 result = func.withMember(_getters.value); [EOL]             } [EOL]         } else { [EOL]             if (_ctorParameters != null) { [EOL]                 result = func.withMember(_ctorParameters.value); [EOL]             } [EOL]             if (result == null && _setters != null) { [EOL]                 result = func.withMember(_setters.value); [EOL]             } [EOL]         } [EOL]         if (result == null && _fields != null) { [EOL]             result = func.withMember(_fields.value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public Linked(T v, Linked<T> n, String explName, boolean visible, boolean ignored) { [EOL]     value = v; [EOL]     next = n; [EOL]     if (explName == null) { [EOL]         explicitName = null; [EOL]     } else { [EOL]         explicitName = (explName.length() == 0) ? null : explName; [EOL]     } [EOL]     isVisible = visible; [EOL]     isMarkedIgnored = ignored; [EOL] }
public Linked(T v, Linked<T> n, String explName, boolean visible, boolean ignored) { [EOL]     value = v; [EOL]     next = n; [EOL]     if (explName == null) { [EOL]         explicitName = null; [EOL]     } else { [EOL]         explicitName = (explName.length() == 0) ? null : explName; [EOL]     } [EOL]     isVisible = visible; [EOL]     isMarkedIgnored = ignored; [EOL] }
public Linked(T v, Linked<T> n, String explName, boolean visible, boolean ignored) { [EOL]     value = v; [EOL]     next = n; [EOL]     if (explName == null) { [EOL]         explicitName = null; [EOL]     } else { [EOL]         explicitName = (explName.length() == 0) ? null : explName; [EOL]     } [EOL]     isVisible = visible; [EOL]     isMarkedIgnored = ignored; [EOL] }
public Linked(T v, Linked<T> n, String explName, boolean visible, boolean ignored) { [EOL]     value = v; [EOL]     next = n; [EOL]     if (explName == null) { [EOL]         explicitName = null; [EOL]     } else { [EOL]         explicitName = (explName.length() == 0) ? null : explName; [EOL]     } [EOL]     isVisible = visible; [EOL]     isMarkedIgnored = ignored; [EOL] }
public Linked<T> withValue(T newValue) { [EOL]     if (newValue == value) { [EOL]         return this; [EOL]     } [EOL]     return new Linked<T>(newValue, next, explicitName, isVisible, isMarkedIgnored); [EOL] }
public Linked<T> withValue(T newValue) { [EOL]     if (newValue == value) { [EOL]         return this; [EOL]     } [EOL]     return new Linked<T>(newValue, next, explicitName, isVisible, isMarkedIgnored); [EOL] }
public Linked<T> withNext(Linked<T> newNext) { [EOL]     if (newNext == next) { [EOL]         return this; [EOL]     } [EOL]     return new Linked<T>(value, newNext, explicitName, isVisible, isMarkedIgnored); [EOL] }
public Linked<T> withNext(Linked<T> newNext) { [EOL]     if (newNext == next) { [EOL]         return this; [EOL]     } [EOL]     return new Linked<T>(value, newNext, explicitName, isVisible, isMarkedIgnored); [EOL] }
public Linked<T> withoutIgnored() { [EOL]     if (isMarkedIgnored) { [EOL]         return (next == null) ? null : next.withoutIgnored(); [EOL]     } [EOL]     if (next != null) { [EOL]         Linked<T> newNext = next.withoutIgnored(); [EOL]         if (newNext != next) { [EOL]             return withNext(newNext); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public Linked<T> withoutIgnored() { [EOL]     if (isMarkedIgnored) { [EOL]         return (next == null) ? null : next.withoutIgnored(); [EOL]     } [EOL]     if (next != null) { [EOL]         Linked<T> newNext = next.withoutIgnored(); [EOL]         if (newNext != next) { [EOL]             return withNext(newNext); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public Linked<T> withoutIgnored() { [EOL]     if (isMarkedIgnored) { [EOL]         return (next == null) ? null : next.withoutIgnored(); [EOL]     } [EOL]     if (next != null) { [EOL]         Linked<T> newNext = next.withoutIgnored(); [EOL]         if (newNext != next) { [EOL]             return withNext(newNext); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public Linked<T> withoutIgnored() { [EOL]     if (isMarkedIgnored) { [EOL]         return (next == null) ? null : next.withoutIgnored(); [EOL]     } [EOL]     if (next != null) { [EOL]         Linked<T> newNext = next.withoutIgnored(); [EOL]         if (newNext != next) { [EOL]             return withNext(newNext); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public Linked<T> withoutNonVisible() { [EOL]     Linked<T> newNext = (next == null) ? null : next.withoutNonVisible(); [EOL]     return isVisible ? withNext(newNext) : newNext; [EOL] }
public Linked<T> withoutNonVisible() { [EOL]     Linked<T> newNext = (next == null) ? null : next.withoutNonVisible(); [EOL]     return isVisible ? withNext(newNext) : newNext; [EOL] }
public Linked<T> withoutNonVisible() { [EOL]     Linked<T> newNext = (next == null) ? null : next.withoutNonVisible(); [EOL]     return isVisible ? withNext(newNext) : newNext; [EOL] }
public Linked<T> withoutNonVisible() { [EOL]     Linked<T> newNext = (next == null) ? null : next.withoutNonVisible(); [EOL]     return isVisible ? withNext(newNext) : newNext; [EOL] }
public Linked<T> withoutNonVisible() { [EOL]     Linked<T> newNext = (next == null) ? null : next.withoutNonVisible(); [EOL]     return isVisible ? withNext(newNext) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeNumber(_value); [EOL] }
@Override [EOL] public final boolean isValueNode() { [EOL]     switch(getNodeType()) { [EOL]         case ARRAY: [EOL]         case OBJECT: [EOL]         case MISSING: [EOL]             return false; [EOL]         default: [EOL]             return true; [EOL]     } [EOL] }
@Override [EOL] public final boolean isValueNode() { [EOL]     switch(getNodeType()) { [EOL]         case ARRAY: [EOL]         case OBJECT: [EOL]         case MISSING: [EOL]             return false; [EOL]         default: [EOL]             return true; [EOL]     } [EOL] }
@Override [EOL] public final boolean isValueNode() { [EOL]     switch(getNodeType()) { [EOL]         case ARRAY: [EOL]         case OBJECT: [EOL]         case MISSING: [EOL]             return false; [EOL]         default: [EOL]             return true; [EOL]     } [EOL] }
@Override [EOL] public final boolean isValueNode() { [EOL]     switch(getNodeType()) { [EOL]         case ARRAY: [EOL]         case OBJECT: [EOL]         case MISSING: [EOL]             return false; [EOL]         default: [EOL]             return true; [EOL]     } [EOL] }
public final boolean isBinary() { [EOL]     return getNodeType() == JsonNodeType.BINARY; [EOL] }
public final boolean isBinary() { [EOL]     return getNodeType() == JsonNodeType.BINARY; [EOL] }
public boolean asBoolean() { [EOL]     return asBoolean(false); [EOL] }
public boolean asBoolean() { [EOL]     return asBoolean(false); [EOL] }
public boolean asBoolean(boolean defaultValue) { [EOL]     return defaultValue; [EOL] }
public boolean asBoolean(boolean defaultValue) { [EOL]     return defaultValue; [EOL] }
public List<BeanPropertyDefinition> updateProperties(DeserializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> propDefs) { [EOL]     return propDefs; [EOL] }
public List<BeanPropertyDefinition> updateProperties(DeserializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> propDefs) { [EOL]     return propDefs; [EOL] }
public BeanDeserializerBuilder updateBuilder(DeserializationConfig config, BeanDescription beanDesc, BeanDeserializerBuilder builder) { [EOL]     return builder; [EOL] }
public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer<?> deserializer) { [EOL]     return deserializer; [EOL] }
public JsonDeserializer<?> modifyMapDeserializer(DeserializationConfig config, MapType type, BeanDescription beanDesc, JsonDeserializer<?> deserializer) { [EOL]     return deserializer; [EOL] }
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore) { [EOL]     return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8)); [EOL] }
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore) { [EOL]     return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8)); [EOL] }
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore) { [EOL]     return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8)); [EOL] }
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore) { [EOL]     return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8)); [EOL] }
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) { [EOL]     _addSuperTypes(cls, endBefore, result, false); [EOL]     return result; [EOL] }
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) { [EOL]     _addSuperTypes(cls, endBefore, result, false); [EOL]     return result; [EOL] }
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) { [EOL]     _addSuperTypes(cls, endBefore, result, false); [EOL]     return result; [EOL] }
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) { [EOL]     _addSuperTypes(cls, endBefore, result, false); [EOL]     return result; [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
public static boolean isProxyType(Class<?> type) { [EOL]     String name = type.getName(); [EOL]     if (name.startsWith("net.sf.cglib.proxy.") || name.startsWith("org.hibernate.proxy.")) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isProxyType(Class<?> type) { [EOL]     String name = type.getName(); [EOL]     if (name.startsWith("net.sf.cglib.proxy.") || name.startsWith("org.hibernate.proxy.")) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isProxyType(Class<?> type) { [EOL]     String name = type.getName(); [EOL]     if (name.startsWith("net.sf.cglib.proxy.") || name.startsWith("org.hibernate.proxy.")) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollectionMapOrArray(Class<?> type) { [EOL]     if (type.isArray()) [EOL]         return true; [EOL]     if (Collection.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     if (Map.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     return false; [EOL] }
public static boolean isCollectionMapOrArray(Class<?> type) { [EOL]     if (type.isArray()) [EOL]         return true; [EOL]     if (Collection.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     if (Map.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     return false; [EOL] }
public static boolean isCollectionMapOrArray(Class<?> type) { [EOL]     if (type.isArray()) [EOL]         return true; [EOL]     if (Collection.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     if (Map.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     return false; [EOL] }
public static boolean isCollectionMapOrArray(Class<?> type) { [EOL]     if (type.isArray()) [EOL]         return true; [EOL]     if (Collection.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     if (Map.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     return false; [EOL] }
private CollectionType(Class<?> collT, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(collT, elemT, valueHandler, typeHandler, asStatic); [EOL] }
@Override [EOL] protected JavaType _narrow(Class<?> subclass) { [EOL]     return new CollectionType(subclass, _elementType, null, null, _asStatic); [EOL] }
@Override [EOL] protected JavaType _narrow(Class<?> subclass) { [EOL]     return new CollectionType(subclass, _elementType, null, null, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _elementType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionType(_class, _elementType.narrowBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _elementType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionType(_class, _elementType.narrowBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType widenContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _elementType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionType(_class, _elementType.widenBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType widenContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _elementType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionType(_class, _elementType.widenBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
public static CollectionType construct(Class<?> rawType, JavaType elemT) { [EOL]     return new CollectionType(rawType, elemT, null, null, false); [EOL] }
public static CollectionType construct(Class<?> rawType, JavaType elemT) { [EOL]     return new CollectionType(rawType, elemT, null, null, false); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "[collection type; class " + _class.getName() + ", contains " + _elementType + "]"; [EOL] }
@SuppressWarnings("unchecked") [EOL] public StdDelegatingDeserializer(Converter<?, T> converter) { [EOL]     super(Object.class); [EOL]     _converter = (Converter<Object, T>) converter; [EOL]     _delegateType = null; [EOL]     _delegateDeserializer = null; [EOL] }
@SuppressWarnings("unchecked") [EOL] public StdDelegatingDeserializer(Converter<?, T> converter) { [EOL]     super(Object.class); [EOL]     _converter = (Converter<Object, T>) converter; [EOL]     _delegateType = null; [EOL]     _delegateDeserializer = null; [EOL] }
protected StdDelegatingDeserializer<T> withDelegate(Converter<Object, T> converter, JavaType delegateType, JsonDeserializer<?> delegateDeserializer) { [EOL]     if (getClass() != StdDelegatingDeserializer.class) { [EOL]         throw new IllegalStateException("Sub-class " + getClass().getName() + " must override 'withDelegate'"); [EOL]     } [EOL]     return new StdDelegatingDeserializer<T>(converter, delegateType, delegateDeserializer); [EOL] }
protected StdDelegatingDeserializer<T> withDelegate(Converter<Object, T> converter, JavaType delegateType, JsonDeserializer<?> delegateDeserializer) { [EOL]     if (getClass() != StdDelegatingDeserializer.class) { [EOL]         throw new IllegalStateException("Sub-class " + getClass().getName() + " must override 'withDelegate'"); [EOL]     } [EOL]     return new StdDelegatingDeserializer<T>(converter, delegateType, delegateDeserializer); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (_delegateDeserializer instanceof ContextualDeserializer) { [EOL]             JsonDeserializer<?> deser = ((ContextualDeserializer) _delegateDeserializer).createContextual(ctxt, property); [EOL]             if (deser != _delegateDeserializer) { [EOL]                 return withDelegate(_converter, _delegateType, deser); [EOL]             } [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _converter.getInputType(ctxt.getTypeFactory()); [EOL]     return withDelegate(_converter, delegateType, ctxt.findContextualValueDeserializer(delegateType, property)); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (_delegateDeserializer instanceof ContextualDeserializer) { [EOL]             JsonDeserializer<?> deser = ((ContextualDeserializer) _delegateDeserializer).createContextual(ctxt, property); [EOL]             if (deser != _delegateDeserializer) { [EOL]                 return withDelegate(_converter, _delegateType, deser); [EOL]             } [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _converter.getInputType(ctxt.getTypeFactory()); [EOL]     return withDelegate(_converter, delegateType, ctxt.findContextualValueDeserializer(delegateType, property)); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (_delegateDeserializer instanceof ContextualDeserializer) { [EOL]             JsonDeserializer<?> deser = ((ContextualDeserializer) _delegateDeserializer).createContextual(ctxt, property); [EOL]             if (deser != _delegateDeserializer) { [EOL]                 return withDelegate(_converter, _delegateType, deser); [EOL]             } [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _converter.getInputType(ctxt.getTypeFactory()); [EOL]     return withDelegate(_converter, delegateType, ctxt.findContextualValueDeserializer(delegateType, property)); [EOL] }
@Override [EOL] public EnumMapSerializer _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new EnumMapSerializer(_valueType, _staticTyping, _keyEnums, vts, _valueSerializer); [EOL] }
@Override [EOL] public EnumMapSerializer _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new EnumMapSerializer(_valueType, _staticTyping, _keyEnums, vts, _valueSerializer); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
protected void serializeContents(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _valueSerializer); [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> prevSerializer = null; [EOL]     Class<?> prevClass = null; [EOL]     EnumValues keyEnums = _keyEnums; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     final TypeSerializer vts = _valueTypeSerializer; [EOL]     for (Map.Entry<? extends Enum<?>, ?> entry : value.entrySet()) { [EOL]         final Object valueElem = entry.getValue(); [EOL]         if (skipNulls && valueElem == null) { [EOL]             continue; [EOL]         } [EOL]         Enum<?> key = entry.getKey(); [EOL]         if (keyEnums == null) { [EOL]             StdSerializer<?> ser = (StdSerializer<?>) provider.findValueSerializer(key.getDeclaringClass(), _property); [EOL]             keyEnums = ((EnumSerializer) ser).getEnumValues(); [EOL]         } [EOL]         jgen.writeFieldName(keyEnums.serializedValueFor(key)); [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             continue; [EOL]         } [EOL]         Class<?> cc = valueElem.getClass(); [EOL]         JsonSerializer<Object> currSerializer; [EOL]         if (cc == prevClass) { [EOL]             currSerializer = prevSerializer; [EOL]         } else { [EOL]             currSerializer = provider.findValueSerializer(cc, _property); [EOL]             prevSerializer = currSerializer; [EOL]             prevClass = cc; [EOL]         } [EOL]         try { [EOL]             if (vts == null) { [EOL]                 currSerializer.serialize(valueElem, jgen, provider); [EOL]             } else { [EOL]                 currSerializer.serializeWithType(valueElem, jgen, provider, vts); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, entry.getKey().name()); [EOL]         } [EOL]     } [EOL] }
public SerializerFactoryConfig() { [EOL]     this(null, null, null); [EOL] }
public boolean hasSerializerModifiers() { [EOL]     return _modifiers.length > 0; [EOL] }
public boolean hasSerializerModifiers() { [EOL]     return _modifiers.length > 0; [EOL] }
public Iterable<Serializers> serializers() { [EOL]     return ArrayBuilders.arrayAsIterable(_additionalSerializers); [EOL] }
public Iterable<Serializers> serializers() { [EOL]     return ArrayBuilders.arrayAsIterable(_additionalSerializers); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected AsArraySerializerBase(AsArraySerializerBase<?> src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     super(src); [EOL]     _elementType = src._elementType; [EOL]     _staticTyping = src._staticTyping; [EOL]     _valueTypeSerializer = vts; [EOL]     _property = property; [EOL]     _elementSerializer = (JsonSerializer<Object>) elementSerializer; [EOL]     _dynamicSerializers = src._dynamicSerializers; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected AsArraySerializerBase(AsArraySerializerBase<?> src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     super(src); [EOL]     _elementType = src._elementType; [EOL]     _staticTyping = src._staticTyping; [EOL]     _valueTypeSerializer = vts; [EOL]     _property = property; [EOL]     _elementSerializer = (JsonSerializer<Object>) elementSerializer; [EOL]     _dynamicSerializers = src._dynamicSerializers; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForArray(value, jgen); [EOL]     serializeContents(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForArray(value, jgen); [EOL] }
@Override [EOL] public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForArray(value, jgen); [EOL]     serializeContents(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForArray(value, jgen); [EOL] }
protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property); [EOL]     if (map != result.map) { [EOL]         _dynamicSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property); [EOL]     if (map != result.map) { [EOL]         _dynamicSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
public DeserializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins) { [EOL]     super(base, str, mixins); [EOL]     _deserFeatures = collectFeatureDefaults(DeserializationFeature.class); [EOL]     _nodeFactory = JsonNodeFactory.instance; [EOL]     _problemHandlers = null; [EOL] }
public DeserializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins) { [EOL]     super(base, str, mixins); [EOL]     _deserFeatures = collectFeatureDefaults(DeserializationFeature.class); [EOL]     _nodeFactory = JsonNodeFactory.instance; [EOL]     _problemHandlers = null; [EOL] }
private DeserializationConfig(DeserializationConfig src, int mapperFeatures, int deserFeatures) { [EOL]     super(src, mapperFeatures); [EOL]     _deserFeatures = deserFeatures; [EOL]     _nodeFactory = src._nodeFactory; [EOL]     _problemHandlers = src._problemHandlers; [EOL] }
private DeserializationConfig(DeserializationConfig src, BaseSettings base) { [EOL]     super(src, base); [EOL]     _deserFeatures = src._deserFeatures; [EOL]     _nodeFactory = src._nodeFactory; [EOL]     _problemHandlers = src._problemHandlers; [EOL] }
private DeserializationConfig(DeserializationConfig src, String rootName) { [EOL]     super(src, rootName); [EOL]     _deserFeatures = src._deserFeatures; [EOL]     _problemHandlers = src._problemHandlers; [EOL]     _nodeFactory = src._nodeFactory; [EOL] }
protected DeserializationConfig(DeserializationConfig src, Map<ClassKey, Class<?>> mixins) { [EOL]     super(src, mixins); [EOL]     _deserFeatures = src._deserFeatures; [EOL]     _problemHandlers = src._problemHandlers; [EOL]     _nodeFactory = src._nodeFactory; [EOL] }
@Override [EOL] public DeserializationConfig without(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags &= ~f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new DeserializationConfig(this, newMapperFlags, _deserFeatures); [EOL] }
@Override [EOL] public DeserializationConfig without(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags &= ~f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new DeserializationConfig(this, newMapperFlags, _deserFeatures); [EOL] }
@Override [EOL] public DeserializationConfig without(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags &= ~f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new DeserializationConfig(this, newMapperFlags, _deserFeatures); [EOL] }
@Override [EOL] public DeserializationConfig with(AnnotationIntrospector ai) { [EOL]     return _withBase(_base.withAnnotationIntrospector(ai)); [EOL] }
@Override [EOL] public DeserializationConfig with(AnnotationIntrospector ai) { [EOL]     return _withBase(_base.withAnnotationIntrospector(ai)); [EOL] }
@Override [EOL] public DeserializationConfig with(TypeResolverBuilder<?> trb) { [EOL]     return _withBase(_base.withTypeResolverBuilder(trb)); [EOL] }
@Override [EOL] public DeserializationConfig with(TypeResolverBuilder<?> trb) { [EOL]     return _withBase(_base.withTypeResolverBuilder(trb)); [EOL] }
@Override [EOL] public DeserializationConfig with(PropertyNamingStrategy pns) { [EOL]     return _withBase(_base.withPropertyNamingStrategy(pns)); [EOL] }
@Override [EOL] public DeserializationConfig with(PropertyNamingStrategy pns) { [EOL]     return _withBase(_base.withPropertyNamingStrategy(pns)); [EOL] }
@Override [EOL] public DeserializationConfig withRootName(String rootName) { [EOL]     if (rootName == null) { [EOL]         if (_rootName == null) { [EOL]             return this; [EOL]         } [EOL]     } else if (rootName.equals(_rootName)) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, rootName); [EOL] }
@Override [EOL] public DeserializationConfig withRootName(String rootName) { [EOL]     if (rootName == null) { [EOL]         if (_rootName == null) { [EOL]             return this; [EOL]         } [EOL]     } else if (rootName.equals(_rootName)) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, rootName); [EOL] }
@Override [EOL] public DeserializationConfig withRootName(String rootName) { [EOL]     if (rootName == null) { [EOL]         if (_rootName == null) { [EOL]             return this; [EOL]         } [EOL]     } else if (rootName.equals(_rootName)) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, rootName); [EOL] }
@Override [EOL] public DeserializationConfig withRootName(String rootName) { [EOL]     if (rootName == null) { [EOL]         if (_rootName == null) { [EOL]             return this; [EOL]         } [EOL]     } else if (rootName.equals(_rootName)) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, rootName); [EOL] }
@Override [EOL] public DeserializationConfig with(HandlerInstantiator hi) { [EOL]     return _withBase(_base.withHandlerInstantiator(hi)); [EOL] }
@Override [EOL] public DeserializationConfig with(HandlerInstantiator hi) { [EOL]     return _withBase(_base.withHandlerInstantiator(hi)); [EOL] }
private final DeserializationConfig _withBase(BaseSettings newBase) { [EOL]     return (_base == newBase) ? this : new DeserializationConfig(this, newBase); [EOL] }
private final DeserializationConfig _withBase(BaseSettings newBase) { [EOL]     return (_base == newBase) ? this : new DeserializationConfig(this, newBase); [EOL] }
public DeserializationConfig with(DeserializationFeature feature) { [EOL]     int newDeserFeatures = (_deserFeatures | feature.getMask()); [EOL]     return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures); [EOL] }
public DeserializationConfig with(DeserializationFeature feature) { [EOL]     int newDeserFeatures = (_deserFeatures | feature.getMask()); [EOL]     return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures); [EOL] }
@Override [EOL] public boolean useRootWrapping() { [EOL]     if (_rootName != null) { [EOL]         return (_rootName.length() > 0); [EOL]     } [EOL]     return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL] }
@Override [EOL] public boolean useRootWrapping() { [EOL]     if (_rootName != null) { [EOL]         return (_rootName.length() > 0); [EOL]     } [EOL]     return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL] }
@Override [EOL] public boolean useRootWrapping() { [EOL]     if (_rootName != null) { [EOL]         return (_rootName.length() > 0); [EOL]     } [EOL]     return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL] }
@Override [EOL] public boolean useRootWrapping() { [EOL]     if (_rootName != null) { [EOL]         return (_rootName.length() > 0); [EOL]     } [EOL]     return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
public final boolean isEnabled(DeserializationFeature f) { [EOL]     return (_deserFeatures & f.getMask()) != 0; [EOL] }
public final boolean isEnabled(DeserializationFeature f) { [EOL]     return (_deserFeatures & f.getMask()) != 0; [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T extends BeanDescription> T introspectForCreation(JavaType type) { [EOL]     return (T) getClassIntrospector().forCreation(this, type, this); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T extends BeanDescription> T introspectForCreation(JavaType type) { [EOL]     return (T) getClassIntrospector().forCreation(this, type, this); [EOL] }
public AnnotationMap() { [EOL] }
private AnnotationMap(HashMap<Class<? extends Annotation>, Annotation> a) { [EOL]     _annotations = a; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public <A extends Annotation> A get(Class<A> cls) { [EOL]     if (_annotations == null) { [EOL]         return null; [EOL]     } [EOL]     return (A) _annotations.get(cls); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public <A extends Annotation> A get(Class<A> cls) { [EOL]     if (_annotations == null) { [EOL]         return null; [EOL]     } [EOL]     return (A) _annotations.get(cls); [EOL] }
public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] }
public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] }
public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] }
public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] }
public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] }
public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] }
public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] }
public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary) { [EOL]     if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) { [EOL]         return secondary; [EOL]     } [EOL]     if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) { [EOL]         return primary; [EOL]     } [EOL]     HashMap<Class<? extends Annotation>, Annotation> annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     for (Annotation ann : secondary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     for (Annotation ann : primary._annotations.values()) { [EOL]         annotations.put(ann.annotationType(), ann); [EOL]     } [EOL]     return new AnnotationMap(annotations); [EOL] }
public void addIfNotPresent(Annotation ann) { [EOL]     if (_annotations == null || !_annotations.containsKey(ann.annotationType())) { [EOL]         _add(ann); [EOL]     } [EOL] }
public void addIfNotPresent(Annotation ann) { [EOL]     if (_annotations == null || !_annotations.containsKey(ann.annotationType())) { [EOL]         _add(ann); [EOL]     } [EOL] }
@Override [EOL] public String toString() { [EOL]     if (_annotations == null) { [EOL]         return "[null]"; [EOL]     } [EOL]     return _annotations.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (_annotations == null) { [EOL]         return "[null]"; [EOL]     } [EOL]     return _annotations.toString(); [EOL] }
protected final void _add(Annotation ann) { [EOL]     if (_annotations == null) { [EOL]         _annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     } [EOL]     _annotations.put(ann.annotationType(), ann); [EOL] }
protected final void _add(Annotation ann) { [EOL]     if (_annotations == null) { [EOL]         _annotations = new HashMap<Class<? extends Annotation>, Annotation>(); [EOL]     } [EOL]     _annotations.put(ann.annotationType(), ann); [EOL] }
public StringDeserializer() { [EOL]     super(String.class); [EOL] }
public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] }
public AsArrayTypeDeserializer(AsArrayTypeDeserializer src, BeanProperty property) { [EOL]     super(src, property); [EOL] }
public AsArrayTypeDeserializer(AsArrayTypeDeserializer src, BeanProperty property) { [EOL]     super(src, property); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsArrayTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsArrayTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "expected closing END_ARRAY after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "expected closing END_ARRAY after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "expected closing END_ARRAY after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         if (_defaultImpl != null) { [EOL]             return _idResolver.idFromBaseType(); [EOL]         } [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class " + baseTypeName()); [EOL]     } [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String result = jp.getText(); [EOL]         jp.nextToken(); [EOL]         return result; [EOL]     } [EOL]     if (_defaultImpl != null) { [EOL]         return _idResolver.idFromBaseType(); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL] }
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         if (_defaultImpl != null) { [EOL]             return _idResolver.idFromBaseType(); [EOL]         } [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class " + baseTypeName()); [EOL]     } [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String result = jp.getText(); [EOL]         jp.nextToken(); [EOL]         return result; [EOL]     } [EOL]     if (_defaultImpl != null) { [EOL]         return _idResolver.idFromBaseType(); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL] }
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         if (_defaultImpl != null) { [EOL]             return _idResolver.idFromBaseType(); [EOL]         } [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class " + baseTypeName()); [EOL]     } [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String result = jp.getText(); [EOL]         jp.nextToken(); [EOL]         return result; [EOL]     } [EOL]     if (_defaultImpl != null) { [EOL]         return _idResolver.idFromBaseType(); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL] }
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         if (_defaultImpl != null) { [EOL]             return _idResolver.idFromBaseType(); [EOL]         } [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class " + baseTypeName()); [EOL]     } [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String result = jp.getText(); [EOL]         jp.nextToken(); [EOL]         return result; [EOL]     } [EOL]     if (_defaultImpl != null) { [EOL]         return _idResolver.idFromBaseType(); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL] }
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         if (_defaultImpl != null) { [EOL]             return _idResolver.idFromBaseType(); [EOL]         } [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class " + baseTypeName()); [EOL]     } [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String result = jp.getText(); [EOL]         jp.nextToken(); [EOL]         return result; [EOL]     } [EOL]     if (_defaultImpl != null) { [EOL]         return _idResolver.idFromBaseType(); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL] }
@Override [EOL] public AnnotatedParameter withAnnotations(AnnotationMap ann) { [EOL]     if (ann == _annotations) { [EOL]         return this; [EOL]     } [EOL]     return _owner.replaceParameterAnnotations(_index, ann); [EOL] }
@Override [EOL] public AnnotatedParameter withAnnotations(AnnotationMap ann) { [EOL]     if (ann == _annotations) { [EOL]         return this; [EOL]     } [EOL]     return _owner.replaceParameterAnnotations(_index, ann); [EOL] }
public Type getParameterType() { [EOL]     return _type; [EOL] }
public AnnotatedWithParams getOwner() { [EOL]     return _owner; [EOL] }
public int getIndex() { [EOL]     return _index; [EOL] }
public static SimpleBeanPropertyFilter filterOutAllExcept(String... propertyArray) { [EOL]     HashSet<String> properties = new HashSet<String>(propertyArray.length); [EOL]     Collections.addAll(properties, propertyArray); [EOL]     return new FilterExceptFilter(properties); [EOL] }
public static SimpleBeanPropertyFilter filterOutAllExcept(String... propertyArray) { [EOL]     HashSet<String> properties = new HashSet<String>(propertyArray.length); [EOL]     Collections.addAll(properties, propertyArray); [EOL]     return new FilterExceptFilter(properties); [EOL] }
public static SimpleBeanPropertyFilter filterOutAllExcept(String... propertyArray) { [EOL]     HashSet<String> properties = new HashSet<String>(propertyArray.length); [EOL]     Collections.addAll(properties, propertyArray); [EOL]     return new FilterExceptFilter(properties); [EOL] }
public FilterExceptFilter(Set<String> properties) { [EOL]     _propertiesToInclude = properties; [EOL] }
public FilterExceptFilter(Set<String> properties) { [EOL]     _propertiesToInclude = properties; [EOL] }
public FilterExceptFilter(Set<String> properties) { [EOL]     _propertiesToInclude = properties; [EOL] }
protected SettableBeanProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations) { [EOL]     this(propDef.getName(), type, propDef.getWrapperName(), typeDeser, contextAnnotations, propDef.isRequired()); [EOL] }
protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired) { [EOL]     if (propName == null || propName.length() == 0) { [EOL]         _propName = ""; [EOL]     } else { [EOL]         _propName = InternCache.instance.intern(propName); [EOL]     } [EOL]     _type = type; [EOL]     _wrapperName = wrapper; [EOL]     _isRequired = isRequired; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _viewMatcher = null; [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(this); [EOL]     } [EOL]     _valueTypeDeserializer = typeDeser; [EOL]     _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL] }
protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired) { [EOL]     if (propName == null || propName.length() == 0) { [EOL]         _propName = ""; [EOL]     } else { [EOL]         _propName = InternCache.instance.intern(propName); [EOL]     } [EOL]     _type = type; [EOL]     _wrapperName = wrapper; [EOL]     _isRequired = isRequired; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _viewMatcher = null; [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(this); [EOL]     } [EOL]     _valueTypeDeserializer = typeDeser; [EOL]     _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL] }
protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired) { [EOL]     if (propName == null || propName.length() == 0) { [EOL]         _propName = ""; [EOL]     } else { [EOL]         _propName = InternCache.instance.intern(propName); [EOL]     } [EOL]     _type = type; [EOL]     _wrapperName = wrapper; [EOL]     _isRequired = isRequired; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _viewMatcher = null; [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(this); [EOL]     } [EOL]     _valueTypeDeserializer = typeDeser; [EOL]     _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser) { [EOL]     _propName = src._propName; [EOL]     _type = src._type; [EOL]     _wrapperName = src._wrapperName; [EOL]     _isRequired = src._isRequired; [EOL]     _contextAnnotations = src._contextAnnotations; [EOL]     _valueTypeDeserializer = src._valueTypeDeserializer; [EOL]     _managedReferenceName = src._managedReferenceName; [EOL]     _propertyIndex = src._propertyIndex; [EOL]     if (deser == null) { [EOL]         _nullProvider = null; [EOL]         _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL]     } else { [EOL]         Object nvl = deser.getNullValue(); [EOL]         _nullProvider = (nvl == null) ? null : new NullProvider(_type, nvl); [EOL]         _valueDeserializer = (JsonDeserializer<Object>) deser; [EOL]     } [EOL]     _viewMatcher = src._viewMatcher; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser) { [EOL]     _propName = src._propName; [EOL]     _type = src._type; [EOL]     _wrapperName = src._wrapperName; [EOL]     _isRequired = src._isRequired; [EOL]     _contextAnnotations = src._contextAnnotations; [EOL]     _valueTypeDeserializer = src._valueTypeDeserializer; [EOL]     _managedReferenceName = src._managedReferenceName; [EOL]     _propertyIndex = src._propertyIndex; [EOL]     if (deser == null) { [EOL]         _nullProvider = null; [EOL]         _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL]     } else { [EOL]         Object nvl = deser.getNullValue(); [EOL]         _nullProvider = (nvl == null) ? null : new NullProvider(_type, nvl); [EOL]         _valueDeserializer = (JsonDeserializer<Object>) deser; [EOL]     } [EOL]     _viewMatcher = src._viewMatcher; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<?> deser) { [EOL]     _propName = src._propName; [EOL]     _type = src._type; [EOL]     _wrapperName = src._wrapperName; [EOL]     _isRequired = src._isRequired; [EOL]     _contextAnnotations = src._contextAnnotations; [EOL]     _valueTypeDeserializer = src._valueTypeDeserializer; [EOL]     _managedReferenceName = src._managedReferenceName; [EOL]     _propertyIndex = src._propertyIndex; [EOL]     if (deser == null) { [EOL]         _nullProvider = null; [EOL]         _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL]     } else { [EOL]         Object nvl = deser.getNullValue(); [EOL]         _nullProvider = (nvl == null) ? null : new NullProvider(_type, nvl); [EOL]         _valueDeserializer = (JsonDeserializer<Object>) deser; [EOL]     } [EOL]     _viewMatcher = src._viewMatcher; [EOL] }
public void setViews(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         _viewMatcher = null; [EOL]     } else { [EOL]         _viewMatcher = ViewMatcher.construct(views); [EOL]     } [EOL] }
public void setViews(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         _viewMatcher = null; [EOL]     } else { [EOL]         _viewMatcher = ViewMatcher.construct(views); [EOL]     } [EOL] }
public void assignIndex(int index) { [EOL]     if (_propertyIndex != -1) { [EOL]         throw new IllegalStateException("Property '" + getName() + "' already had index (" + _propertyIndex + "), trying to assign " + index); [EOL]     } [EOL]     _propertyIndex = index; [EOL] }
public void assignIndex(int index) { [EOL]     if (_propertyIndex != -1) { [EOL]         throw new IllegalStateException("Property '" + getName() + "' already had index (" + _propertyIndex + "), trying to assign " + index); [EOL]     } [EOL]     _propertyIndex = index; [EOL] }
@Override [EOL] public final String getName() { [EOL]     return _propName; [EOL] }
@Override [EOL] public JavaType getType() { [EOL]     return _type; [EOL] }
public String getManagedReferenceName() { [EOL]     return _managedReferenceName; [EOL] }
public String getManagedReferenceName() { [EOL]     return _managedReferenceName; [EOL] }
public boolean hasValueDeserializer() { [EOL]     return (_valueDeserializer != null) && (_valueDeserializer != MISSING_VALUE_DESERIALIZER); [EOL] }
public boolean hasValueDeserializer() { [EOL]     return (_valueDeserializer != null) && (_valueDeserializer != MISSING_VALUE_DESERIALIZER); [EOL] }
public boolean hasValueDeserializer() { [EOL]     return (_valueDeserializer != null) && (_valueDeserializer != MISSING_VALUE_DESERIALIZER); [EOL] }
public boolean hasValueTypeDeserializer() { [EOL]     return (_valueTypeDeserializer != null); [EOL] }
public boolean hasValueTypeDeserializer() { [EOL]     return (_valueTypeDeserializer != null); [EOL] }
public JsonDeserializer<Object> getValueDeserializer() { [EOL]     JsonDeserializer<Object> deser = _valueDeserializer; [EOL]     if (deser == MISSING_VALUE_DESERIALIZER) { [EOL]         return null; [EOL]     } [EOL]     return deser; [EOL] }
public JsonDeserializer<Object> getValueDeserializer() { [EOL]     JsonDeserializer<Object> deser = _valueDeserializer; [EOL]     if (deser == MISSING_VALUE_DESERIALIZER) { [EOL]         return null; [EOL]     } [EOL]     return deser; [EOL] }
public TypeDeserializer getValueTypeDeserializer() { [EOL]     return _valueTypeDeserializer; [EOL] }
public boolean hasViews() { [EOL]     return _viewMatcher != null; [EOL] }
public boolean hasViews() { [EOL]     return _viewMatcher != null; [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } [EOL]     if (_valueTypeDeserializer != null) { [EOL]         return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } [EOL]     if (_valueTypeDeserializer != null) { [EOL]         return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } [EOL]     if (_valueTypeDeserializer != null) { [EOL]         return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } [EOL]     if (_valueTypeDeserializer != null) { [EOL]         return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
public WritableObjectId(ObjectIdGenerator<?> generator) { [EOL]     this.generator = generator; [EOL] }
public boolean writeAsId(JsonGenerator jgen, SerializerProvider provider, ObjectIdWriter w) throws IOException, JsonGenerationException { [EOL]     if (id != null && (idWritten || w.alwaysAsId)) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean writeAsId(JsonGenerator jgen, SerializerProvider provider, ObjectIdWriter w) throws IOException, JsonGenerationException { [EOL]     if (id != null && (idWritten || w.alwaysAsId)) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean writeAsId(JsonGenerator jgen, SerializerProvider provider, ObjectIdWriter w) throws IOException, JsonGenerationException { [EOL]     if (id != null && (idWritten || w.alwaysAsId)) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public Object generateId(Object forPojo) { [EOL]     return (id = generator.generateId(forPojo)); [EOL] }
public Object generateId(Object forPojo) { [EOL]     return (id = generator.generateId(forPojo)); [EOL] }
public void writeAsField(JsonGenerator jgen, SerializerProvider provider, ObjectIdWriter w) throws IOException, JsonGenerationException { [EOL]     SerializedString name = w.propertyName; [EOL]     idWritten = true; [EOL]     if (name != null) { [EOL]         jgen.writeFieldName(name); [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]     } [EOL] }
public void writeAsField(JsonGenerator jgen, SerializerProvider provider, ObjectIdWriter w) throws IOException, JsonGenerationException { [EOL]     SerializedString name = w.propertyName; [EOL]     idWritten = true; [EOL]     if (name != null) { [EOL]         jgen.writeFieldName(name); [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
public AnnotatedField(Field field, AnnotationMap annMap) { [EOL]     super(annMap); [EOL]     _field = field; [EOL] }
public AnnotatedField(Field field, AnnotationMap annMap) { [EOL]     super(annMap); [EOL]     _field = field; [EOL] }
@Override [EOL] public AnnotatedField withAnnotations(AnnotationMap ann) { [EOL]     return new AnnotatedField(_field, ann); [EOL] }
@Override [EOL] public AnnotatedField withAnnotations(AnnotationMap ann) { [EOL]     return new AnnotatedField(_field, ann); [EOL] }
@Override [EOL] public Field getAnnotated() { [EOL]     return _field; [EOL] }
@Override [EOL] public int getModifiers() { [EOL]     return _field.getModifiers(); [EOL] }
@Override [EOL] public String getName() { [EOL]     return _field.getName(); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return (_annotations == null) ? null : _annotations.get(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return (_annotations == null) ? null : _annotations.get(acls); [EOL] }
@Override [EOL] public Type getGenericType() { [EOL]     return _field.getGenericType(); [EOL] }
@Override [EOL] public Class<?> getRawType() { [EOL]     return _field.getType(); [EOL] }
@Override [EOL] public Member getMember() { [EOL]     return _field; [EOL] }
@Override [EOL] public Member getMember() { [EOL]     return _field; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] protected BeanSerializerBase asArraySerializer() { [EOL]     if ((_objectIdWriter == null) && (_anyGetterWriter == null) && (_propertyFilterId == null)) { [EOL]         return new BeanAsArraySerializer(this); [EOL]     } [EOL]     return this; [EOL] }
private MissingNode() { [EOL] }
public static MissingNode getInstance() { [EOL]     return instance; [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.MISSING; [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.NOT_AVAILABLE; [EOL] }
@Override [EOL] public String asText() { [EOL]     return ""; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     return (o == this); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     return (o == this); [EOL] }
@Override [EOL] public String toString() { [EOL]     return ""; [EOL] }
@Override [EOL] public void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     _writeScalarPrefix(value, jgen); [EOL] }
@Override [EOL] public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     _writeScalarSuffix(value, jgen, idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     _writeScalarSuffix(value, jgen, idFromValue(value)); [EOL] }
protected final void _writeScalarPrefix(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL] }
protected final void _writeScalarSuffix(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     jgen.writeStringField(_typePropertyName, typeId); [EOL] }
protected final void _writeScalarSuffix(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     jgen.writeStringField(_typePropertyName, typeId); [EOL] }
public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     boolean canDeserialize; [EOL]     if (prop.hasTypePropertyName(propName)) { [EOL]         _typeIds[index] = jp.getText(); [EOL]         jp.skipChildren(); [EOL]         canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     } else { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         _tokens[index] = tokens; [EOL]         canDeserialize = (bean != null) && (_typeIds[index] != null); [EOL]     } [EOL]     if (canDeserialize) { [EOL]         String typeId = _typeIds[index]; [EOL]         _typeIds[index] = null; [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } [EOL]     return true; [EOL] }
public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     boolean canDeserialize; [EOL]     if (prop.hasTypePropertyName(propName)) { [EOL]         _typeIds[index] = jp.getText(); [EOL]         jp.skipChildren(); [EOL]         canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     } else { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         _tokens[index] = tokens; [EOL]         canDeserialize = (bean != null) && (_typeIds[index] != null); [EOL]     } [EOL]     if (canDeserialize) { [EOL]         String typeId = _typeIds[index]; [EOL]         _typeIds[index] = null; [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } [EOL]     return true; [EOL] }
public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     boolean canDeserialize; [EOL]     if (prop.hasTypePropertyName(propName)) { [EOL]         _typeIds[index] = jp.getText(); [EOL]         jp.skipChildren(); [EOL]         canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     } else { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         _tokens[index] = tokens; [EOL]         canDeserialize = (bean != null) && (_typeIds[index] != null); [EOL]     } [EOL]     if (canDeserialize) { [EOL]         String typeId = _typeIds[index]; [EOL]         _typeIds[index] = null; [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } [EOL]     return true; [EOL] }
public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     boolean canDeserialize; [EOL]     if (prop.hasTypePropertyName(propName)) { [EOL]         _typeIds[index] = jp.getText(); [EOL]         jp.skipChildren(); [EOL]         canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     } else { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         _tokens[index] = tokens; [EOL]         canDeserialize = (bean != null) && (_typeIds[index] != null); [EOL]     } [EOL]     if (canDeserialize) { [EOL]         String typeId = _typeIds[index]; [EOL]         _typeIds[index] = null; [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } [EOL]     return true; [EOL] }
public JsonSerializerMap(Map<TypeKey, JsonSerializer<Object>> serializers) { [EOL]     int size = findSize(serializers.size()); [EOL]     _size = size; [EOL]     int hashMask = (size - 1); [EOL]     Bucket[] buckets = new Bucket[size]; [EOL]     for (Map.Entry<TypeKey, JsonSerializer<Object>> entry : serializers.entrySet()) { [EOL]         TypeKey key = entry.getKey(); [EOL]         int index = key.hashCode() & hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, entry.getValue()); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
public JsonSerializerMap(Map<TypeKey, JsonSerializer<Object>> serializers) { [EOL]     int size = findSize(serializers.size()); [EOL]     _size = size; [EOL]     int hashMask = (size - 1); [EOL]     Bucket[] buckets = new Bucket[size]; [EOL]     for (Map.Entry<TypeKey, JsonSerializer<Object>> entry : serializers.entrySet()) { [EOL]         TypeKey key = entry.getKey(); [EOL]         int index = key.hashCode() & hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, entry.getValue()); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
public JsonSerializerMap(Map<TypeKey, JsonSerializer<Object>> serializers) { [EOL]     int size = findSize(serializers.size()); [EOL]     _size = size; [EOL]     int hashMask = (size - 1); [EOL]     Bucket[] buckets = new Bucket[size]; [EOL]     for (Map.Entry<TypeKey, JsonSerializer<Object>> entry : serializers.entrySet()) { [EOL]         TypeKey key = entry.getKey(); [EOL]         int index = key.hashCode() & hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, entry.getValue()); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 64) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 8; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 64) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 8; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
public JsonSerializer<Object> find(TypeKey key) { [EOL]     int index = key.hashCode() & (_buckets.length - 1); [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (key.equals(bucket.key)) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JsonSerializer<Object> find(TypeKey key) { [EOL]     int index = key.hashCode() & (_buckets.length - 1); [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (key.equals(bucket.key)) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JsonSerializer<Object> find(TypeKey key) { [EOL]     int index = key.hashCode() & (_buckets.length - 1); [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (key.equals(bucket.key)) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected MapperConfig(BaseSettings base, int mapperFeatures) { [EOL]     _base = base; [EOL]     _mapperFeatures = mapperFeatures; [EOL] }
protected MapperConfig(BaseSettings base, int mapperFeatures) { [EOL]     _base = base; [EOL]     _mapperFeatures = mapperFeatures; [EOL] }
protected MapperConfig(MapperConfig<T> src) { [EOL]     _base = src._base; [EOL]     _mapperFeatures = src._mapperFeatures; [EOL] }
public static <F extends Enum<F> & ConfigFeature> int collectFeatureDefaults(Class<F> enumClass) { [EOL]     int flags = 0; [EOL]     for (F value : enumClass.getEnumConstants()) { [EOL]         if (value.enabledByDefault()) { [EOL]             flags |= value.getMask(); [EOL]         } [EOL]     } [EOL]     return flags; [EOL] }
public static <F extends Enum<F> & ConfigFeature> int collectFeatureDefaults(Class<F> enumClass) { [EOL]     int flags = 0; [EOL]     for (F value : enumClass.getEnumConstants()) { [EOL]         if (value.enabledByDefault()) { [EOL]             flags |= value.getMask(); [EOL]         } [EOL]     } [EOL]     return flags; [EOL] }
public final boolean isEnabled(MapperFeature f) { [EOL]     return (_mapperFeatures & f.getMask()) != 0; [EOL] }
public final boolean isEnabled(MapperFeature f) { [EOL]     return (_mapperFeatures & f.getMask()) != 0; [EOL] }
public final boolean isAnnotationProcessingEnabled() { [EOL]     return isEnabled(MapperFeature.USE_ANNOTATIONS); [EOL] }
public final boolean isAnnotationProcessingEnabled() { [EOL]     return isEnabled(MapperFeature.USE_ANNOTATIONS); [EOL] }
public final boolean canOverrideAccessModifiers() { [EOL]     return isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] }
public final boolean canOverrideAccessModifiers() { [EOL]     return isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] }
public final boolean shouldSortPropertiesAlphabetically() { [EOL]     return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY); [EOL] }
public final boolean shouldSortPropertiesAlphabetically() { [EOL]     return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY); [EOL] }
public ClassIntrospector getClassIntrospector() { [EOL]     return _base.getClassIntrospector(); [EOL] }
public AnnotationIntrospector getAnnotationIntrospector() { [EOL]     return _base.getAnnotationIntrospector(); [EOL] }
public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     return _base.getVisibilityChecker(); [EOL] }
public final PropertyNamingStrategy getPropertyNamingStrategy() { [EOL]     return _base.getPropertyNamingStrategy(); [EOL] }
public final HandlerInstantiator getHandlerInstantiator() { [EOL]     return _base.getHandlerInstantiator(); [EOL] }
public final HandlerInstantiator getHandlerInstantiator() { [EOL]     return _base.getHandlerInstantiator(); [EOL] }
public final TypeResolverBuilder<?> getDefaultTyper(JavaType baseType) { [EOL]     return _base.getTypeResolverBuilder(); [EOL] }
public final TypeResolverBuilder<?> getDefaultTyper(JavaType baseType) { [EOL]     return _base.getTypeResolverBuilder(); [EOL] }
public final TypeFactory getTypeFactory() { [EOL]     return _base.getTypeFactory(); [EOL] }
public final JavaType constructType(Class<?> cls) { [EOL]     return getTypeFactory().constructType(cls, (TypeBindings) null); [EOL] }
public final JavaType constructType(Class<?> cls) { [EOL]     return getTypeFactory().constructType(cls, (TypeBindings) null); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     return getTypeFactory().constructSpecializedType(baseType, subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     return getTypeFactory().constructSpecializedType(baseType, subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     return getTypeFactory().constructSpecializedType(baseType, subclass); [EOL] }
public BeanDescription introspectClassAnnotations(Class<?> cls) { [EOL]     return introspectClassAnnotations(constructType(cls)); [EOL] }
public BeanDescription introspectClassAnnotations(Class<?> cls) { [EOL]     return introspectClassAnnotations(constructType(cls)); [EOL] }
private MapperFeature(boolean defaultState) { [EOL]     _defaultState = defaultState; [EOL] }
private MapperFeature(boolean defaultState) { [EOL]     _defaultState = defaultState; [EOL] }
@Override [EOL] public boolean enabledByDefault() { [EOL]     return _defaultState; [EOL] }
@Override [EOL] public boolean enabledByDefault() { [EOL]     return _defaultState; [EOL] }
@Override [EOL] public int getMask() { [EOL]     return (1 << ordinal()); [EOL] }
@Override [EOL] public int getMask() { [EOL]     return (1 << ordinal()); [EOL] }
@Override [EOL] public int getMask() { [EOL]     return (1 << ordinal()); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public <T extends JsonNode> T deepCopy() { [EOL]     return (T) this; [EOL] }
public StdTypeResolverBuilder() { [EOL] }
@Override [EOL] public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes) { [EOL]     if (idType == null) { [EOL]         throw new IllegalArgumentException("idType can not be null"); [EOL]     } [EOL]     _idType = idType; [EOL]     _customIdResolver = idRes; [EOL]     _typeProperty = idType.getDefaultPropertyName(); [EOL]     return this; [EOL] }
@Override [EOL] public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes) { [EOL]     if (idType == null) { [EOL]         throw new IllegalArgumentException("idType can not be null"); [EOL]     } [EOL]     _idType = idType; [EOL]     _customIdResolver = idRes; [EOL]     _typeProperty = idType.getDefaultPropertyName(); [EOL]     return this; [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) { [EOL]     if (includeAs == null) { [EOL]         throw new IllegalArgumentException("includeAs can not be null"); [EOL]     } [EOL]     _includeAs = includeAs; [EOL]     return this; [EOL] }
@Override [EOL] public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) { [EOL]     if (includeAs == null) { [EOL]         throw new IllegalArgumentException("includeAs can not be null"); [EOL]     } [EOL]     _includeAs = includeAs; [EOL]     return this; [EOL] }
@Override [EOL] public StdTypeResolverBuilder typeProperty(String typeIdPropName) { [EOL]     if (typeIdPropName == null || typeIdPropName.length() == 0) { [EOL]         typeIdPropName = _idType.getDefaultPropertyName(); [EOL]     } [EOL]     _typeProperty = typeIdPropName; [EOL]     return this; [EOL] }
@Override [EOL] public StdTypeResolverBuilder typeProperty(String typeIdPropName) { [EOL]     if (typeIdPropName == null || typeIdPropName.length() == 0) { [EOL]         typeIdPropName = _idType.getDefaultPropertyName(); [EOL]     } [EOL]     _typeProperty = typeIdPropName; [EOL]     return this; [EOL] }
@Override [EOL] public StdTypeResolverBuilder typeProperty(String typeIdPropName) { [EOL]     if (typeIdPropName == null || typeIdPropName.length() == 0) { [EOL]         typeIdPropName = _idType.getDefaultPropertyName(); [EOL]     } [EOL]     _typeProperty = typeIdPropName; [EOL]     return this; [EOL] }
@Override [EOL] public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) { [EOL]     _typeIdVisible = isVisible; [EOL]     return this; [EOL] }
@Override [EOL] public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) { [EOL]     _typeIdVisible = isVisible; [EOL]     return this; [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
@Override [EOL] public ArrayType withContentTypeHandler(Object h) { [EOL]     if (h == _componentType.<Object>getTypeHandler()) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType.withTypeHandler(h), _emptyArray, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public ArrayType withContentTypeHandler(Object h) { [EOL]     if (h == _componentType.<Object>getTypeHandler()) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType.withTypeHandler(h), _emptyArray, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] protected JavaType _narrow(Class<?> subclass) { [EOL]     if (!subclass.isArray()) { [EOL]         throw new IllegalArgumentException("Incompatible narrowing operation: trying to narrow " + toString() + " to class " + subclass.getName()); [EOL]     } [EOL]     Class<?> newCompClass = subclass.getComponentType(); [EOL]     JavaType newCompType = TypeFactory.defaultInstance().constructType(newCompClass); [EOL]     return construct(newCompType, _valueHandler, _typeHandler); [EOL] }
@Override [EOL] protected JavaType _narrow(Class<?> subclass) { [EOL]     if (!subclass.isArray()) { [EOL]         throw new IllegalArgumentException("Incompatible narrowing operation: trying to narrow " + toString() + " to class " + subclass.getName()); [EOL]     } [EOL]     Class<?> newCompClass = subclass.getComponentType(); [EOL]     JavaType newCompType = TypeFactory.defaultInstance().constructType(newCompClass); [EOL]     return construct(newCompType, _valueHandler, _typeHandler); [EOL] }
public FailingDeserializer(String m) { [EOL]     super(Object.class); [EOL]     _message = m; [EOL] }
public FailingDeserializer(String m) { [EOL]     super(Object.class); [EOL]     _message = m; [EOL] }
public FailingDeserializer(String m) { [EOL]     super(Object.class); [EOL]     _message = m; [EOL] }
public static void addAll(Map<String, JsonSerializer<?>> allDeserializers) { [EOL]     final JsonSerializer<?> intS = new IntegerSerializer(); [EOL]     allDeserializers.put(Integer.class.getName(), intS); [EOL]     allDeserializers.put(Integer.TYPE.getName(), intS); [EOL]     allDeserializers.put(Long.class.getName(), LongSerializer.instance); [EOL]     allDeserializers.put(Long.TYPE.getName(), LongSerializer.instance); [EOL]     allDeserializers.put(Byte.class.getName(), IntLikeSerializer.instance); [EOL]     allDeserializers.put(Byte.TYPE.getName(), IntLikeSerializer.instance); [EOL]     allDeserializers.put(Short.class.getName(), ShortSerializer.instance); [EOL]     allDeserializers.put(Short.TYPE.getName(), ShortSerializer.instance); [EOL]     allDeserializers.put(Float.class.getName(), FloatSerializer.instance); [EOL]     allDeserializers.put(Float.TYPE.getName(), FloatSerializer.instance); [EOL]     allDeserializers.put(Double.class.getName(), DoubleSerializer.instance); [EOL]     allDeserializers.put(Double.TYPE.getName(), DoubleSerializer.instance); [EOL] }
public ShortSerializer() { [EOL]     super(Short.class); [EOL] }
public IntegerSerializer() { [EOL]     super(Integer.class); [EOL] }
@Override [EOL] public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.intValue()); [EOL] }
@Override [EOL] public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.intValue()); [EOL] }
public IntLikeSerializer() { [EOL]     super(Number.class); [EOL] }
public LongSerializer() { [EOL]     super(Long.class); [EOL] }
@Override [EOL] public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.longValue()); [EOL] }
@Override [EOL] public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.longValue()); [EOL] }
public FloatSerializer() { [EOL]     super(Float.class); [EOL] }
public DoubleSerializer() { [EOL]     super(Double.class); [EOL] }
public NumberSerializer() { [EOL]     super(Number.class); [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     if (_value != null) { [EOL]         if ("true".equals(_value.trim())) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     if (_value != null) { [EOL]         if ("true".equals(_value.trim())) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     if (_value != null) { [EOL]         if ("true".equals(_value.trim())) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     if (_value != null) { [EOL]         if ("true".equals(_value.trim())) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     if (_value != null) { [EOL]         if ("true".equals(_value.trim())) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]             String str = jp.getText(); [EOL]             if (str.length() == 0) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) }; [EOL] }
private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]             String str = jp.getText(); [EOL]             if (str.length() == 0) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) }; [EOL] }
private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]             String str = jp.getText(); [EOL]             if (str.length() == 0) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) }; [EOL] }
private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]             String str = jp.getText(); [EOL]             if (str.length() == 0) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) }; [EOL] }
public BeanDeserializerBuilder(BeanDescription beanDesc, DeserializationConfig config) { [EOL]     _beanDesc = beanDesc; [EOL]     _defaultViewInclusion = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION); [EOL] }
public BeanDeserializerBuilder(BeanDescription beanDesc, DeserializationConfig config) { [EOL]     _beanDesc = beanDesc; [EOL]     _defaultViewInclusion = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION); [EOL] }
public void addOrReplaceProperty(SettableBeanProperty prop, boolean allowOverride) { [EOL]     _properties.put(prop.getName(), prop); [EOL] }
public void addOrReplaceProperty(SettableBeanProperty prop, boolean allowOverride) { [EOL]     _properties.put(prop.getName(), prop); [EOL] }
public void addProperty(SettableBeanProperty prop) { [EOL]     SettableBeanProperty old = _properties.put(prop.getName(), prop); [EOL]     if (old != null && old != prop) { [EOL]         throw new IllegalArgumentException("Duplicate property '" + prop.getName() + "' for " + _beanDesc.getType()); [EOL]     } [EOL] }
public void addProperty(SettableBeanProperty prop) { [EOL]     SettableBeanProperty old = _properties.put(prop.getName(), prop); [EOL]     if (old != null && old != prop) { [EOL]         throw new IllegalArgumentException("Duplicate property '" + prop.getName() + "' for " + _beanDesc.getType()); [EOL]     } [EOL] }
public void addProperty(SettableBeanProperty prop) { [EOL]     SettableBeanProperty old = _properties.put(prop.getName(), prop); [EOL]     if (old != null && old != prop) { [EOL]         throw new IllegalArgumentException("Duplicate property '" + prop.getName() + "' for " + _beanDesc.getType()); [EOL]     } [EOL] }
public void addIgnorable(String propName) { [EOL]     if (_ignorableProps == null) { [EOL]         _ignorableProps = new HashSet<String>(); [EOL]     } [EOL]     _ignorableProps.add(propName); [EOL] }
public void addIgnorable(String propName) { [EOL]     if (_ignorableProps == null) { [EOL]         _ignorableProps = new HashSet<String>(); [EOL]     } [EOL]     _ignorableProps.add(propName); [EOL] }
public void addCreatorProperty(SettableBeanProperty prop) { [EOL]     addProperty(prop); [EOL] }
public void addCreatorProperty(SettableBeanProperty prop) { [EOL]     addProperty(prop); [EOL] }
public void setAnySetter(SettableAnyProperty s) { [EOL]     if (_anySetter != null && s != null) { [EOL]         throw new IllegalStateException("_anySetter already set to non-null"); [EOL]     } [EOL]     _anySetter = s; [EOL] }
public void setAnySetter(SettableAnyProperty s) { [EOL]     if (_anySetter != null && s != null) { [EOL]         throw new IllegalStateException("_anySetter already set to non-null"); [EOL]     } [EOL]     _anySetter = s; [EOL] }
public void setAnySetter(SettableAnyProperty s) { [EOL]     if (_anySetter != null && s != null) { [EOL]         throw new IllegalStateException("_anySetter already set to non-null"); [EOL]     } [EOL]     _anySetter = s; [EOL] }
public void setIgnoreUnknownProperties(boolean ignore) { [EOL]     _ignoreAllUnknown = ignore; [EOL] }
public void setIgnoreUnknownProperties(boolean ignore) { [EOL]     _ignoreAllUnknown = ignore; [EOL] }
public void setValueInstantiator(ValueInstantiator inst) { [EOL]     _valueInstantiator = inst; [EOL] }
public SettableBeanProperty findProperty(String propertyName) { [EOL]     return _properties.get(propertyName); [EOL] }
public SettableBeanProperty findProperty(String propertyName) { [EOL]     return _properties.get(propertyName); [EOL] }
public SettableAnyProperty getAnySetter() { [EOL]     return _anySetter; [EOL] }
public ValueInstantiator getValueInstantiator() { [EOL]     return _valueInstantiator; [EOL] }
public List<ValueInjector> getInjectables() { [EOL]     return _injectables; [EOL] }
public List<ValueInjector> getInjectables() { [EOL]     return _injectables; [EOL] }
public ObjectIdReader getObjectIdReader() { [EOL]     return _objectIdReader; [EOL] }
public ObjectIdReader getObjectIdReader() { [EOL]     return _objectIdReader; [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public AbstractDeserializer buildAbstract() { [EOL]     return new AbstractDeserializer(this, _beanDesc, _backRefProperties); [EOL] }
public ClassDeserializer() { [EOL]     super(Class.class); [EOL] }
public final T appendCompletedChunk(T fullChunk, int fullChunkLength) { [EOL]     Node<T> next = new Node<T>(fullChunk, fullChunkLength); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     _bufferedEntryCount += fullChunkLength; [EOL]     int nextLen = fullChunkLength; [EOL]     if (nextLen < SMALL_CHUNK_SIZE) { [EOL]         nextLen += nextLen; [EOL]     } else { [EOL]         nextLen += (nextLen >> 2); [EOL]     } [EOL]     return _constructArray(nextLen); [EOL] }
public final T appendCompletedChunk(T fullChunk, int fullChunkLength) { [EOL]     Node<T> next = new Node<T>(fullChunk, fullChunkLength); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     _bufferedEntryCount += fullChunkLength; [EOL]     int nextLen = fullChunkLength; [EOL]     if (nextLen < SMALL_CHUNK_SIZE) { [EOL]         nextLen += nextLen; [EOL]     } else { [EOL]         nextLen += (nextLen >> 2); [EOL]     } [EOL]     return _constructArray(nextLen); [EOL] }
public final T appendCompletedChunk(T fullChunk, int fullChunkLength) { [EOL]     Node<T> next = new Node<T>(fullChunk, fullChunkLength); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     _bufferedEntryCount += fullChunkLength; [EOL]     int nextLen = fullChunkLength; [EOL]     if (nextLen < SMALL_CHUNK_SIZE) { [EOL]         nextLen += nextLen; [EOL]     } else { [EOL]         nextLen += (nextLen >> 2); [EOL]     } [EOL]     return _constructArray(nextLen); [EOL] }
public HierarchicType(Type type) { [EOL]     this._actualType = type; [EOL]     if (type instanceof Class<?>) { [EOL]         _rawClass = (Class<?>) type; [EOL]         _genericType = null; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         _genericType = (ParameterizedType) type; [EOL]         _rawClass = (Class<?>) _genericType.getRawType(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type " + type.getClass().getName() + " can not be used to construct HierarchicType"); [EOL]     } [EOL] }
public HierarchicType(Type type) { [EOL]     this._actualType = type; [EOL]     if (type instanceof Class<?>) { [EOL]         _rawClass = (Class<?>) type; [EOL]         _genericType = null; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         _genericType = (ParameterizedType) type; [EOL]         _rawClass = (Class<?>) _genericType.getRawType(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type " + type.getClass().getName() + " can not be used to construct HierarchicType"); [EOL]     } [EOL] }
public HierarchicType(Type type) { [EOL]     this._actualType = type; [EOL]     if (type instanceof Class<?>) { [EOL]         _rawClass = (Class<?>) type; [EOL]         _genericType = null; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         _genericType = (ParameterizedType) type; [EOL]         _rawClass = (Class<?>) _genericType.getRawType(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type " + type.getClass().getName() + " can not be used to construct HierarchicType"); [EOL]     } [EOL] }
public void setSuperType(HierarchicType sup) { [EOL]     _superType = sup; [EOL] }
public void setSuperType(HierarchicType sup) { [EOL]     _superType = sup; [EOL] }
public final HierarchicType getSuperType() { [EOL]     return _superType; [EOL] }
public void setSubType(HierarchicType sub) { [EOL]     _subType = sub; [EOL] }
public void setSubType(HierarchicType sub) { [EOL]     _subType = sub; [EOL] }
public final boolean isGeneric() { [EOL]     return _genericType != null; [EOL] }
public final boolean isGeneric() { [EOL]     return _genericType != null; [EOL] }
public final ParameterizedType asGeneric() { [EOL]     return _genericType; [EOL] }
public final ParameterizedType asGeneric() { [EOL]     return _genericType; [EOL] }
public final Class<?> getRawClass() { [EOL]     return _rawClass; [EOL] }
public DOMSerializer() { [EOL]     super(Node.class); [EOL]     DOMImplementationRegistry registry; [EOL]     try { [EOL]         registry = DOMImplementationRegistry.newInstance(); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalStateException("Could not instantiate DOMImplementationRegistry: " + e.getMessage(), e); [EOL]     } [EOL]     _domImpl = (DOMImplementationLS) registry.getDOMImplementation("LS"); [EOL] }
public DOMSerializer() { [EOL]     super(Node.class); [EOL]     DOMImplementationRegistry registry; [EOL]     try { [EOL]         registry = DOMImplementationRegistry.newInstance(); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalStateException("Could not instantiate DOMImplementationRegistry: " + e.getMessage(), e); [EOL]     } [EOL]     _domImpl = (DOMImplementationLS) registry.getDOMImplementation("LS"); [EOL] }
@Override [EOL] public void serialize(Node value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_domImpl == null) [EOL]         throw new IllegalStateException("Could not find DOM LS"); [EOL]     LSSerializer writer = _domImpl.createLSSerializer(); [EOL]     jgen.writeString(writer.writeToString(value)); [EOL] }
@Override [EOL] public void serialize(Node value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_domImpl == null) [EOL]         throw new IllegalStateException("Could not find DOM LS"); [EOL]     LSSerializer writer = _domImpl.createLSSerializer(); [EOL]     jgen.writeString(writer.writeToString(value)); [EOL] }
public BeanAsArraySerializer(BeanSerializerBase src) { [EOL]     super(src, (ObjectIdWriter) null); [EOL]     _defaultSerializer = src; [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(provider)) { [EOL]         serializeAsArray(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeAsArray(bean, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(provider)) { [EOL]         serializeAsArray(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeAsArray(bean, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(provider)) { [EOL]         serializeAsArray(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeAsArray(bean, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
private boolean hasSingleElement(SerializerProvider provider) { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     return props.length == 1; [EOL] }
private boolean hasSingleElement(SerializerProvider provider) { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     return props.length == 1; [EOL] }
private boolean hasSingleElement(SerializerProvider provider) { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     return props.length == 1; [EOL] }
private boolean hasSingleElement(SerializerProvider provider) { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     return props.length == 1; [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop == null) { [EOL]                 jgen.writeNull(); [EOL]             } else { [EOL]                 prop.serializeAsColumn(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected MapLikeType(Class<?> mapType, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(mapType, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler, asStatic); [EOL]     _keyType = keyT; [EOL]     _valueType = valueT; [EOL] }
protected MapLikeType(Class<?> mapType, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(mapType, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler, asStatic); [EOL]     _keyType = keyT; [EOL]     _valueType = valueT; [EOL] }
@Override [EOL] public boolean isContainerType() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean isMapLikeType() { [EOL]     return true; [EOL] }
@Override [EOL] public JavaType getKeyType() { [EOL]     return _keyType; [EOL] }
@Override [EOL] public JavaType getContentType() { [EOL]     return _valueType; [EOL] }
@Override [EOL] public JavaType getContentType() { [EOL]     return _valueType; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index == 0) [EOL]         return _keyType; [EOL]     if (index == 1) [EOL]         return _valueType; [EOL]     return null; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index == 0) [EOL]         return _keyType; [EOL]     if (index == 1) [EOL]         return _valueType; [EOL]     return null; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index == 0) [EOL]         return _keyType; [EOL]     if (index == 1) [EOL]         return _valueType; [EOL]     return null; [EOL] }
public boolean isTrueMapType() { [EOL]     return Map.class.isAssignableFrom(_class); [EOL] }
public boolean isTrueMapType() { [EOL]     return Map.class.isAssignableFrom(_class); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
public SimpleModule(String name) { [EOL]     this(name, Version.unknownVersion()); [EOL] }
public SimpleModule setDeserializerModifier(BeanDeserializerModifier mod) { [EOL]     _deserializerModifier = mod; [EOL]     return this; [EOL] }
public SimpleModule setDeserializerModifier(BeanDeserializerModifier mod) { [EOL]     _deserializerModifier = mod; [EOL]     return this; [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
public AsWrapperTypeSerializer(TypeIdResolver idRes, BeanProperty property) { [EOL]     super(idRes, property); [EOL] }
@Override [EOL] public AsWrapperTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsWrapperTypeSerializer(this._idResolver, prop); [EOL] }
@Override [EOL] public AsWrapperTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsWrapperTypeSerializer(this._idResolver, prop); [EOL] }
@Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeObjectFieldStart(idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeObjectFieldStart(idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndObject(); [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndObject(); [EOL]     jgen.writeEndObject(); [EOL] }
protected SimpleType(Class<?> cls) { [EOL]     this(cls, null, null, null, null, false); [EOL] }
protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(cls, 0, valueHandler, typeHandler, asStatic); [EOL]     if (typeNames == null || typeNames.length == 0) { [EOL]         _typeNames = null; [EOL]         _typeParameters = null; [EOL]     } else { [EOL]         _typeNames = typeNames; [EOL]         _typeParameters = typeParams; [EOL]     } [EOL] }
protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(cls, 0, valueHandler, typeHandler, asStatic); [EOL]     if (typeNames == null || typeNames.length == 0) { [EOL]         _typeNames = null; [EOL]         _typeParameters = null; [EOL]     } else { [EOL]         _typeNames = typeNames; [EOL]         _typeParameters = typeParams; [EOL]     } [EOL] }
protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(cls, 0, valueHandler, typeHandler, asStatic); [EOL]     if (typeNames == null || typeNames.length == 0) { [EOL]         _typeNames = null; [EOL]         _typeParameters = null; [EOL]     } else { [EOL]         _typeNames = typeNames; [EOL]         _typeParameters = typeParams; [EOL]     } [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
@Override [EOL] public boolean isContainerType() { [EOL]     return false; [EOL] }
@Override [EOL] public int containedTypeCount() { [EOL]     return (_typeParameters == null) ? 0 : _typeParameters.length; [EOL] }
@Override [EOL] public int containedTypeCount() { [EOL]     return (_typeParameters == null) ? 0 : _typeParameters.length; [EOL] }
@Override [EOL] public int containedTypeCount() { [EOL]     return (_typeParameters == null) ? 0 : _typeParameters.length; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == expType) { [EOL]         int count = type.containedTypeCount(); [EOL]         if (count == 0) [EOL]             return null; [EOL]         JavaType[] result = new JavaType[count]; [EOL]         for (int i = 0; i < count; ++i) { [EOL]             result[i] = type.containedType(i); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return findTypeParameters(raw, expType, new TypeBindings(this, type)); [EOL] }
public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == expType) { [EOL]         int count = type.containedTypeCount(); [EOL]         if (count == 0) [EOL]             return null; [EOL]         JavaType[] result = new JavaType[count]; [EOL]         for (int i = 0; i < count; ++i) { [EOL]             result[i] = type.containedType(i); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return findTypeParameters(raw, expType, new TypeBindings(this, type)); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { [EOL]     HierarchicType subType = _findSuperTypeChain(clz, expType); [EOL]     if (subType == null) { [EOL]         throw new IllegalArgumentException("Class " + clz.getName() + " is not a subtype of " + expType.getName()); [EOL]     } [EOL]     HierarchicType superType = subType; [EOL]     while (superType.getSuperType() != null) { [EOL]         superType = superType.getSuperType(); [EOL]         Class<?> raw = superType.getRawClass(); [EOL]         TypeBindings newBindings = new TypeBindings(this, raw); [EOL]         if (superType.isGeneric()) { [EOL]             ParameterizedType pt = superType.asGeneric(); [EOL]             Type[] actualTypes = pt.getActualTypeArguments(); [EOL]             TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]             int len = actualTypes.length; [EOL]             for (int i = 0; i < len; ++i) { [EOL]                 String name = vars[i].getName(); [EOL]                 JavaType type = _constructType(actualTypes[i], bindings); [EOL]                 newBindings.addBinding(name, type); [EOL]             } [EOL]         } [EOL]         bindings = newBindings; [EOL]     } [EOL]     if (!superType.isGeneric()) { [EOL]         return null; [EOL]     } [EOL]     return bindings.typesAsArray(); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { [EOL]     HierarchicType subType = _findSuperTypeChain(clz, expType); [EOL]     if (subType == null) { [EOL]         throw new IllegalArgumentException("Class " + clz.getName() + " is not a subtype of " + expType.getName()); [EOL]     } [EOL]     HierarchicType superType = subType; [EOL]     while (superType.getSuperType() != null) { [EOL]         superType = superType.getSuperType(); [EOL]         Class<?> raw = superType.getRawClass(); [EOL]         TypeBindings newBindings = new TypeBindings(this, raw); [EOL]         if (superType.isGeneric()) { [EOL]             ParameterizedType pt = superType.asGeneric(); [EOL]             Type[] actualTypes = pt.getActualTypeArguments(); [EOL]             TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]             int len = actualTypes.length; [EOL]             for (int i = 0; i < len; ++i) { [EOL]                 String name = vars[i].getName(); [EOL]                 JavaType type = _constructType(actualTypes[i], bindings); [EOL]                 newBindings.addBinding(name, type); [EOL]             } [EOL]         } [EOL]         bindings = newBindings; [EOL]     } [EOL]     if (!superType.isGeneric()) { [EOL]         return null; [EOL]     } [EOL]     return bindings.typesAsArray(); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { [EOL]     HierarchicType subType = _findSuperTypeChain(clz, expType); [EOL]     if (subType == null) { [EOL]         throw new IllegalArgumentException("Class " + clz.getName() + " is not a subtype of " + expType.getName()); [EOL]     } [EOL]     HierarchicType superType = subType; [EOL]     while (superType.getSuperType() != null) { [EOL]         superType = superType.getSuperType(); [EOL]         Class<?> raw = superType.getRawClass(); [EOL]         TypeBindings newBindings = new TypeBindings(this, raw); [EOL]         if (superType.isGeneric()) { [EOL]             ParameterizedType pt = superType.asGeneric(); [EOL]             Type[] actualTypes = pt.getActualTypeArguments(); [EOL]             TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]             int len = actualTypes.length; [EOL]             for (int i = 0; i < len; ++i) { [EOL]                 String name = vars[i].getName(); [EOL]                 JavaType type = _constructType(actualTypes[i], bindings); [EOL]                 newBindings.addBinding(name, type); [EOL]             } [EOL]         } [EOL]         bindings = newBindings; [EOL]     } [EOL]     if (!superType.isGeneric()) { [EOL]         return null; [EOL]     } [EOL]     return bindings.typesAsArray(); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { [EOL]     HierarchicType subType = _findSuperTypeChain(clz, expType); [EOL]     if (subType == null) { [EOL]         throw new IllegalArgumentException("Class " + clz.getName() + " is not a subtype of " + expType.getName()); [EOL]     } [EOL]     HierarchicType superType = subType; [EOL]     while (superType.getSuperType() != null) { [EOL]         superType = superType.getSuperType(); [EOL]         Class<?> raw = superType.getRawClass(); [EOL]         TypeBindings newBindings = new TypeBindings(this, raw); [EOL]         if (superType.isGeneric()) { [EOL]             ParameterizedType pt = superType.asGeneric(); [EOL]             Type[] actualTypes = pt.getActualTypeArguments(); [EOL]             TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]             int len = actualTypes.length; [EOL]             for (int i = 0; i < len; ++i) { [EOL]                 String name = vars[i].getName(); [EOL]                 JavaType type = _constructType(actualTypes[i], bindings); [EOL]                 newBindings.addBinding(name, type); [EOL]             } [EOL]         } [EOL]         bindings = newBindings; [EOL]     } [EOL]     if (!superType.isGeneric()) { [EOL]         return null; [EOL]     } [EOL]     return bindings.typesAsArray(); [EOL] }
public JavaType constructType(Type type, TypeBindings bindings) { [EOL]     return _constructType(type, bindings); [EOL] }
public JavaType constructType(Type type, TypeBindings bindings) { [EOL]     return _constructType(type, bindings); [EOL] }
public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { [EOL]     return CollectionType.construct(collectionClass, constructType(elementClass)); [EOL] }
public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { [EOL]     return CollectionType.construct(collectionClass, constructType(elementClass)); [EOL] }
public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { [EOL]     return CollectionType.construct(collectionClass, constructType(elementClass)); [EOL] }
public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { [EOL]     return CollectionType.construct(collectionClass, elementType); [EOL] }
public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { [EOL]     return CollectionType.construct(collectionClass, elementType); [EOL] }
public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { [EOL]     return CollectionType.construct(collectionClass, elementType); [EOL] }
public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapType.construct(mapClass, keyType, valueType); [EOL] }
public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapType.construct(mapClass, keyType, valueType); [EOL] }
public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapType.construct(mapClass, keyType, valueType); [EOL] }
public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapType.construct(mapClass, keyType, valueType); [EOL] }
public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapLikeType.construct(mapClass, keyType, valueType); [EOL] }
public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapLikeType.construct(mapClass, keyType, valueType); [EOL] }
public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapLikeType.construct(mapClass, keyType, valueType); [EOL] }
public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapLikeType.construct(mapClass, keyType, valueType); [EOL] }
public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { [EOL]     TypeVariable<?>[] typeVars = rawType.getTypeParameters(); [EOL]     if (typeVars.length != parameterTypes.length) { [EOL]         throw new IllegalArgumentException("Parameter type mismatch for " + rawType.getName() + ": expected " + typeVars.length + " parameters, was given " + parameterTypes.length); [EOL]     } [EOL]     String[] names = new String[typeVars.length]; [EOL]     for (int i = 0, len = typeVars.length; i < len; ++i) { [EOL]         names[i] = typeVars[i].getName(); [EOL]     } [EOL]     JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false); [EOL]     return resultType; [EOL] }
public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { [EOL]     TypeVariable<?>[] typeVars = rawType.getTypeParameters(); [EOL]     if (typeVars.length != parameterTypes.length) { [EOL]         throw new IllegalArgumentException("Parameter type mismatch for " + rawType.getName() + ": expected " + typeVars.length + " parameters, was given " + parameterTypes.length); [EOL]     } [EOL]     String[] names = new String[typeVars.length]; [EOL]     for (int i = 0, len = typeVars.length; i < len; ++i) { [EOL]         names[i] = typeVars[i].getName(); [EOL]     } [EOL]     JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false); [EOL]     return resultType; [EOL] }
public JavaType uncheckedSimpleType(Class<?> cls) { [EOL]     return new SimpleType(cls); [EOL] }
public JavaType uncheckedSimpleType(Class<?> cls) { [EOL]     return new SimpleType(cls); [EOL] }
public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { [EOL]     int len = parameterClasses.length; [EOL]     JavaType[] pt = new JavaType[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         pt[i] = _fromClass(parameterClasses[i], null); [EOL]     } [EOL]     return constructParametricType(parametrized, pt); [EOL] }
public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { [EOL]     int len = parameterClasses.length; [EOL]     JavaType[] pt = new JavaType[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         pt[i] = _fromClass(parameterClasses[i], null); [EOL]     } [EOL]     return constructParametricType(parametrized, pt); [EOL] }
public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { [EOL]     int len = parameterClasses.length; [EOL]     JavaType[] pt = new JavaType[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         pt[i] = _fromClass(parameterClasses[i], null); [EOL]     } [EOL]     return constructParametricType(parametrized, pt); [EOL] }
public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for arrays (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException("Need exactly 2 parameter types for Map types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] }
public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for arrays (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException("Need exactly 2 parameter types for Map types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] }
public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for arrays (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException("Need exactly 2 parameter types for Map types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] }
public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for arrays (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException("Need exactly 2 parameter types for Map types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] }
public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for arrays (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException("Need exactly 2 parameter types for Map types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] }
public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for arrays (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException("Need exactly 2 parameter types for Map types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] }
public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for arrays (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException("Need exactly 2 parameter types for Map types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL]     Class<?> rawType = (Class<?>) type.getRawType(); [EOL]     Type[] args = type.getActualTypeArguments(); [EOL]     int paramCount = (args == null) ? 0 : args.length; [EOL]     JavaType[] pt; [EOL]     if (paramCount == 0) { [EOL]         pt = NO_TYPES; [EOL]     } else { [EOL]         pt = new JavaType[paramCount]; [EOL]         for (int i = 0; i < paramCount; ++i) { [EOL]             pt[i] = _constructType(args[i], context); [EOL]         } [EOL]     } [EOL]     if (Map.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL]         if (mapParams.length != 2) { [EOL]             throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL]         } [EOL]         return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL]         if (collectionParams.length != 1) { [EOL]             throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL]         } [EOL]         return CollectionType.construct(rawType, collectionParams[0]); [EOL]     } [EOL]     if (paramCount == 0) { [EOL]         return new SimpleType(rawType); [EOL]     } [EOL]     return constructSimpleType(rawType, pt); [EOL] }
protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) { [EOL]     if (context == null) { [EOL]         return _unknownType(); [EOL]     } [EOL]     String name = type.getName(); [EOL]     JavaType actualType = context.findType(name); [EOL]     if (actualType != null) { [EOL]         return actualType; [EOL]     } [EOL]     Type[] bounds = type.getBounds(); [EOL]     context._addPlaceholder(name); [EOL]     return _constructType(bounds[0], context); [EOL] }
protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) { [EOL]     if (context == null) { [EOL]         return _unknownType(); [EOL]     } [EOL]     String name = type.getName(); [EOL]     JavaType actualType = context.findType(name); [EOL]     if (actualType != null) { [EOL]         return actualType; [EOL]     } [EOL]     Type[] bounds = type.getBounds(); [EOL]     context._addPlaceholder(name); [EOL]     return _constructType(bounds[0], context); [EOL] }
protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) { [EOL]     if (context == null) { [EOL]         return _unknownType(); [EOL]     } [EOL]     String name = type.getName(); [EOL]     JavaType actualType = context.findType(name); [EOL]     if (actualType != null) { [EOL]         return actualType; [EOL]     } [EOL]     Type[] bounds = type.getBounds(); [EOL]     context._addPlaceholder(name); [EOL]     return _constructType(bounds[0], context); [EOL] }
private JavaType _mapType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Map.class); [EOL]     if (typeParams == null) { [EOL]         return MapType.construct(rawClass, _unknownType(), _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 2) { [EOL]         throw new IllegalArgumentException("Strange Map type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return MapType.construct(rawClass, typeParams[0], typeParams[1]); [EOL] }
private JavaType _mapType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Map.class); [EOL]     if (typeParams == null) { [EOL]         return MapType.construct(rawClass, _unknownType(), _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 2) { [EOL]         throw new IllegalArgumentException("Strange Map type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return MapType.construct(rawClass, typeParams[0], typeParams[1]); [EOL] }
private JavaType _mapType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Map.class); [EOL]     if (typeParams == null) { [EOL]         return MapType.construct(rawClass, _unknownType(), _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 2) { [EOL]         throw new IllegalArgumentException("Strange Map type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return MapType.construct(rawClass, typeParams[0], typeParams[1]); [EOL] }
protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype) { [EOL]     if (supertype.isInterface()) { [EOL]         return _findSuperInterfaceChain(subtype, supertype); [EOL]     } [EOL]     return _findSuperClassChain(subtype, supertype); [EOL] }
protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target) { [EOL]     HierarchicType current = new HierarchicType(currentType); [EOL]     Class<?> raw = current.getRawClass(); [EOL]     if (raw == target) { [EOL]         return current; [EOL]     } [EOL]     Type parent = raw.getGenericSuperclass(); [EOL]     if (parent != null) { [EOL]         HierarchicType sup = _findSuperClassChain(parent, target); [EOL]         if (sup != null) { [EOL]             sup.setSubType(current); [EOL]             current.setSuperType(sup); [EOL]             return current; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target) { [EOL]     HierarchicType current = new HierarchicType(currentType); [EOL]     Class<?> raw = current.getRawClass(); [EOL]     if (raw == target) { [EOL]         return new HierarchicType(currentType); [EOL]     } [EOL]     if (raw == HashMap.class) { [EOL]         if (target == Map.class) { [EOL]             return _hashMapSuperInterfaceChain(current); [EOL]         } [EOL]     } [EOL]     if (raw == ArrayList.class) { [EOL]         if (target == List.class) { [EOL]             return _arrayListSuperInterfaceChain(current); [EOL]         } [EOL]     } [EOL]     return _doFindSuperInterfaceChain(current, target); [EOL] }
protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target) { [EOL]     Class<?> raw = current.getRawClass(); [EOL]     Type[] parents = raw.getGenericInterfaces(); [EOL]     if (parents != null) { [EOL]         for (Type parent : parents) { [EOL]             HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL]             if (sup != null) { [EOL]                 sup.setSubType(current); [EOL]                 current.setSuperType(sup); [EOL]                 return current; [EOL]             } [EOL]         } [EOL]     } [EOL]     Type parent = raw.getGenericSuperclass(); [EOL]     if (parent != null) { [EOL]         HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL]         if (sup != null) { [EOL]             sup.setSubType(current); [EOL]             current.setSuperType(sup); [EOL]             return current; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target) { [EOL]     Class<?> raw = current.getRawClass(); [EOL]     Type[] parents = raw.getGenericInterfaces(); [EOL]     if (parents != null) { [EOL]         for (Type parent : parents) { [EOL]             HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL]             if (sup != null) { [EOL]                 sup.setSubType(current); [EOL]                 current.setSuperType(sup); [EOL]                 return current; [EOL]             } [EOL]         } [EOL]     } [EOL]     Type parent = raw.getGenericSuperclass(); [EOL]     if (parent != null) { [EOL]         HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL]         if (sup != null) { [EOL]             sup.setSubType(current); [EOL]             current.setSuperType(sup); [EOL]             return current; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] }
public AsPropertyTypeDeserializer(AsPropertyTypeDeserializer src, BeanProperty property) { [EOL]     super(src, property); [EOL] }
public AsPropertyTypeDeserializer(AsPropertyTypeDeserializer src, BeanProperty property) { [EOL]     super(src, property); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsPropertyTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsPropertyTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public As getTypeInclusion() { [EOL]     return As.PROPERTY; [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected MapperConfigBase(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins) { [EOL]     super(base, DEFAULT_MAPPER_FEATURES); [EOL]     _mixInAnnotations = mixins; [EOL]     _subtypeResolver = str; [EOL]     _rootName = null; [EOL]     _view = null; [EOL] }
protected MapperConfigBase(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins) { [EOL]     super(base, DEFAULT_MAPPER_FEATURES); [EOL]     _mixInAnnotations = mixins; [EOL]     _subtypeResolver = str; [EOL]     _rootName = null; [EOL]     _view = null; [EOL] }
protected MapperConfigBase(MapperConfigBase<CFG, T> src, BaseSettings base) { [EOL]     super(base, src._mapperFeatures); [EOL]     _mixInAnnotations = src._mixInAnnotations; [EOL]     _subtypeResolver = src._subtypeResolver; [EOL]     _rootName = src._rootName; [EOL]     _view = src._view; [EOL] }
protected MapperConfigBase(MapperConfigBase<CFG, T> src, int mapperFeatures) { [EOL]     super(src._base, mapperFeatures); [EOL]     _mixInAnnotations = src._mixInAnnotations; [EOL]     _subtypeResolver = src._subtypeResolver; [EOL]     _rootName = src._rootName; [EOL]     _view = src._view; [EOL] }
protected MapperConfigBase(MapperConfigBase<CFG, T> src, String rootName) { [EOL]     super(src); [EOL]     _mixInAnnotations = src._mixInAnnotations; [EOL]     _subtypeResolver = src._subtypeResolver; [EOL]     _rootName = rootName; [EOL]     _view = src._view; [EOL] }
protected MapperConfigBase(MapperConfigBase<CFG, T> src, String rootName) { [EOL]     super(src); [EOL]     _mixInAnnotations = src._mixInAnnotations; [EOL]     _subtypeResolver = src._subtypeResolver; [EOL]     _rootName = rootName; [EOL]     _view = src._view; [EOL] }
protected MapperConfigBase(MapperConfigBase<CFG, T> src, Class<?> view) { [EOL]     super(src); [EOL]     _mixInAnnotations = src._mixInAnnotations; [EOL]     _subtypeResolver = src._subtypeResolver; [EOL]     _rootName = src._rootName; [EOL]     _view = view; [EOL] }
protected MapperConfigBase(MapperConfigBase<CFG, T> src, Map<ClassKey, Class<?>> mixins) { [EOL]     super(src); [EOL]     _mixInAnnotations = mixins; [EOL]     _subtypeResolver = src._subtypeResolver; [EOL]     _rootName = src._rootName; [EOL]     _view = src._view; [EOL] }
public final String getRootName() { [EOL]     return _rootName; [EOL] }
public final String getRootName() { [EOL]     return _rootName; [EOL] }
@Override [EOL] public final Class<?> getActiveView() { [EOL]     return _view; [EOL] }
@Override [EOL] public final Class<?> getActiveView() { [EOL]     return _view; [EOL] }
@Override [EOL] public final Class<?> findMixInClassFor(Class<?> cls) { [EOL]     return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls)); [EOL] }
@Override [EOL] public final Class<?> findMixInClassFor(Class<?> cls) { [EOL]     return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls)); [EOL] }
public final int mixInCount() { [EOL]     return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size(); [EOL] }
public final int mixInCount() { [EOL]     return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size(); [EOL] }
@Override [EOL] public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { [EOL]     if (v == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         _append(JsonToken.VALUE_NUMBER_INT, v); [EOL]     } [EOL] }
@Override [EOL] public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { [EOL]     if (v == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         _append(JsonToken.VALUE_NUMBER_INT, v); [EOL]     } [EOL] }
@Override [EOL] public JsonLocation getTokenLocation() { [EOL]     return getCurrentLocation(); [EOL] }
@Override [EOL] public JsonLocation getCurrentLocation() { [EOL]     return (_location == null) ? JsonLocation.NA : _location; [EOL] }
@Override [EOL] public long getLongValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().longValue(); [EOL] }
@Override [EOL] public long getLongValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().longValue(); [EOL] }
protected JavaType(Class<?> raw, int additionalHash, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     _class = raw; [EOL]     _hashCode = raw.getName().hashCode() + additionalHash; [EOL]     _valueHandler = valueHandler; [EOL]     _typeHandler = typeHandler; [EOL]     _asStatic = asStatic; [EOL] }
public JavaType narrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(subclass, _class); [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType narrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(subclass, _class); [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType narrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(subclass, _class); [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType narrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(subclass, _class); [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType widenBy(Class<?> superclass) { [EOL]     if (superclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(_class, superclass); [EOL]     return _widen(superclass); [EOL] }
public JavaType widenBy(Class<?> superclass) { [EOL]     if (superclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(_class, superclass); [EOL]     return _widen(superclass); [EOL] }
public JavaType widenBy(Class<?> superclass) { [EOL]     if (superclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(_class, superclass); [EOL]     return _widen(superclass); [EOL] }
protected JavaType _widen(Class<?> superclass) { [EOL]     return _narrow(superclass); [EOL] }
@Override [EOL] public final Class<?> getRawClass() { [EOL]     return _class; [EOL] }
@Override [EOL] public final boolean hasRawClass(Class<?> clz) { [EOL]     return _class == clz; [EOL] }
@Override [EOL] public final boolean hasRawClass(Class<?> clz) { [EOL]     return _class == clz; [EOL] }
@Override [EOL] public boolean isConcrete() { [EOL]     int mod = _class.getModifiers(); [EOL]     if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) { [EOL]         return true; [EOL]     } [EOL]     if (_class.isPrimitive()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean isConcrete() { [EOL]     int mod = _class.getModifiers(); [EOL]     if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) { [EOL]         return true; [EOL]     } [EOL]     if (_class.isPrimitive()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean isConcrete() { [EOL]     int mod = _class.getModifiers(); [EOL]     if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) { [EOL]         return true; [EOL]     } [EOL]     if (_class.isPrimitive()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean isArrayType() { [EOL]     return false; [EOL] }
@Override [EOL] public final boolean isEnumType() { [EOL]     return _class.isEnum(); [EOL] }
@Override [EOL] public final boolean isEnumType() { [EOL]     return _class.isEnum(); [EOL] }
@Override [EOL] public final boolean isInterface() { [EOL]     return _class.isInterface(); [EOL] }
@Override [EOL] public final boolean isInterface() { [EOL]     return _class.isInterface(); [EOL] }
@Override [EOL] public final boolean isPrimitive() { [EOL]     return _class.isPrimitive(); [EOL] }
@Override [EOL] public final boolean isPrimitive() { [EOL]     return _class.isPrimitive(); [EOL] }
@Override [EOL] public final boolean isFinal() { [EOL]     return Modifier.isFinal(_class.getModifiers()); [EOL] }
@Override [EOL] public final boolean isFinal() { [EOL]     return Modifier.isFinal(_class.getModifiers()); [EOL] }
public final boolean useStaticType() { [EOL]     return _asStatic; [EOL] }
public final boolean useStaticType() { [EOL]     return _asStatic; [EOL] }
@Override [EOL] public JavaType getContentType() { [EOL]     return null; [EOL] }
protected void _assertSubclass(Class<?> subclass, Class<?> superClass) { [EOL]     if (!_class.isAssignableFrom(subclass)) { [EOL]         throw new IllegalArgumentException("Class " + subclass.getName() + " is not assignable to " + _class.getName()); [EOL]     } [EOL] }
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     if (_value != null && _value instanceof Boolean) { [EOL]         return ((Boolean) _value).booleanValue(); [EOL]     } [EOL]     return defaultValue; [EOL] }
protected ContainerSerializer(Class<T> t) { [EOL]     super(t); [EOL] }
protected ContainerSerializer(Class<?> t, boolean dummy) { [EOL]     super(t, dummy); [EOL] }
protected ContainerSerializer(ContainerSerializer<?> src) { [EOL]     super(src._handledType, false); [EOL] }
protected boolean hasContentTypeAnnotation(SerializerProvider provider, BeanProperty property) { [EOL]     if (property != null) { [EOL]         AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]         if (intr != null) { [EOL]             if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected boolean hasContentTypeAnnotation(SerializerProvider provider, BeanProperty property) { [EOL]     if (property != null) { [EOL]         AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]         if (intr != null) { [EOL]             if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public PropertyBasedObjectIdGenerator(Class<?> scope) { [EOL]     super(scope); [EOL] }
@Override [EOL] public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key) { [EOL]     return new IdKey(getClass(), _scope, key); [EOL] }
@Override [EOL] public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key) { [EOL]     return new IdKey(getClass(), _scope, key); [EOL] }
public DefaultTypeResolverBuilder(DefaultTyping t) { [EOL]     _appliesFor = t; [EOL] }
public DefaultTypeResolverBuilder(DefaultTyping t) { [EOL]     _appliesFor = t; [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null; [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null; [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
public ObjectMapper(JsonFactory jf) { [EOL]     this(jf, null, null); [EOL] }
public ObjectMapper(JsonFactory jf) { [EOL]     this(jf, null, null); [EOL] }
protected ObjectMapper(ObjectMapper src) { [EOL]     _jsonFactory = src._jsonFactory.copy(); [EOL]     _jsonFactory.setCodec(this); [EOL]     _subtypeResolver = src._subtypeResolver; [EOL]     _rootNames = new RootNameLookup(); [EOL]     _typeFactory = src._typeFactory; [EOL]     _serializationConfig = src._serializationConfig; [EOL]     HashMap<ClassKey, Class<?>> mixins = new HashMap<ClassKey, Class<?>>(src._mixInAnnotations); [EOL]     _serializationConfig = new SerializationConfig(src._serializationConfig, mixins); [EOL]     _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins); [EOL]     _serializerProvider = src._serializerProvider; [EOL]     _deserializationContext = src._deserializationContext; [EOL]     _serializerFactory = src._serializerFactory; [EOL] }
public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) { [EOL]     if (jf == null) { [EOL]         _jsonFactory = new MappingJsonFactory(this); [EOL]     } else { [EOL]         _jsonFactory = jf; [EOL]         if (jf.getCodec() == null) { [EOL]             _jsonFactory.setCodec(this); [EOL]         } [EOL]     } [EOL]     _subtypeResolver = new StdSubtypeResolver(); [EOL]     _rootNames = new RootNameLookup(); [EOL]     _typeFactory = TypeFactory.defaultInstance(); [EOL]     _serializationConfig = new SerializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _deserializationConfig = new DeserializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; [EOL]     _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; [EOL]     _serializerFactory = BeanSerializerFactory.instance; [EOL] }
public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) { [EOL]     if (jf == null) { [EOL]         _jsonFactory = new MappingJsonFactory(this); [EOL]     } else { [EOL]         _jsonFactory = jf; [EOL]         if (jf.getCodec() == null) { [EOL]             _jsonFactory.setCodec(this); [EOL]         } [EOL]     } [EOL]     _subtypeResolver = new StdSubtypeResolver(); [EOL]     _rootNames = new RootNameLookup(); [EOL]     _typeFactory = TypeFactory.defaultInstance(); [EOL]     _serializationConfig = new SerializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _deserializationConfig = new DeserializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; [EOL]     _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; [EOL]     _serializerFactory = BeanSerializerFactory.instance; [EOL] }
public ObjectMapper(JsonFactory jf, DefaultSerializerProvider sp, DefaultDeserializationContext dc) { [EOL]     if (jf == null) { [EOL]         _jsonFactory = new MappingJsonFactory(this); [EOL]     } else { [EOL]         _jsonFactory = jf; [EOL]         if (jf.getCodec() == null) { [EOL]             _jsonFactory.setCodec(this); [EOL]         } [EOL]     } [EOL]     _subtypeResolver = new StdSubtypeResolver(); [EOL]     _rootNames = new RootNameLookup(); [EOL]     _typeFactory = TypeFactory.defaultInstance(); [EOL]     _serializationConfig = new SerializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _deserializationConfig = new DeserializationConfig(DEFAULT_BASE, _subtypeResolver, _mixInAnnotations); [EOL]     _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp; [EOL]     _deserializationContext = (dc == null) ? new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc; [EOL]     _serializerFactory = BeanSerializerFactory.instance; [EOL] }
public ObjectMapper copy() { [EOL]     _checkInvalidCopy(ObjectMapper.class); [EOL]     return new ObjectMapper(this); [EOL] }
public ObjectMapper copy() { [EOL]     _checkInvalidCopy(ObjectMapper.class); [EOL]     return new ObjectMapper(this); [EOL] }
protected void _checkInvalidCopy(Class<?> exp) { [EOL]     if (getClass() != exp) { [EOL]         throw new IllegalStateException("Failed copy(): " + getClass().getName() + " (version: " + version() + ") does not override copy(); it has to"); [EOL]     } [EOL] }
protected void _checkInvalidCopy(Class<?> exp) { [EOL]     if (getClass() != exp) { [EOL]         throw new IllegalStateException("Failed copy(): " + getClass().getName() + " (version: " + version() + ") does not override copy(); it has to"); [EOL]     } [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper setSerializerFactory(SerializerFactory f) { [EOL]     _serializerFactory = f; [EOL]     return this; [EOL] }
public ObjectMapper setSerializerFactory(SerializerFactory f) { [EOL]     _serializerFactory = f; [EOL]     return this; [EOL] }
public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]     _mixInAnnotations.put(new ClassKey(target), mixinSource); [EOL] }
public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]     _mixInAnnotations.put(new ClassKey(target), mixinSource); [EOL] }
public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]     _mixInAnnotations.put(new ClassKey(target), mixinSource); [EOL] }
public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]     _serializationConfig = _serializationConfig.with(ai); [EOL]     _deserializationConfig = _deserializationConfig.with(ai); [EOL]     return this; [EOL] }
public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]     _serializationConfig = _serializationConfig.with(ai); [EOL]     _deserializationConfig = _deserializationConfig.with(ai); [EOL]     return this; [EOL] }
public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) { [EOL]     _serializationConfig = _serializationConfig.with(s); [EOL]     _deserializationConfig = _deserializationConfig.with(s); [EOL]     return this; [EOL] }
public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) { [EOL]     _serializationConfig = _serializationConfig.with(s); [EOL]     _deserializationConfig = _deserializationConfig.with(s); [EOL]     return this; [EOL] }
public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName) { [EOL]     TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability); [EOL]     typer = typer.init(JsonTypeInfo.Id.CLASS, null); [EOL]     typer = typer.inclusion(JsonTypeInfo.As.PROPERTY); [EOL]     typer = typer.typeProperty(propertyName); [EOL]     return setDefaultTyping(typer); [EOL] }
public ObjectMapper disableDefaultTyping() { [EOL]     return setDefaultTyping(null); [EOL] }
public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) { [EOL]     _deserializationConfig = _deserializationConfig.with(typer); [EOL]     _serializationConfig = _serializationConfig.with(typer); [EOL]     return this; [EOL] }
public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) { [EOL]     _deserializationConfig = _deserializationConfig.with(typer); [EOL]     _serializationConfig = _serializationConfig.with(typer); [EOL]     return this; [EOL] }
public void setFilters(FilterProvider filterProvider) { [EOL]     _serializationConfig = _serializationConfig.withFilters(filterProvider); [EOL] }
public Object setHandlerInstantiator(HandlerInstantiator hi) { [EOL]     _deserializationConfig = _deserializationConfig.with(hi); [EOL]     _serializationConfig = _serializationConfig.with(hi); [EOL]     return this; [EOL] }
public Object setHandlerInstantiator(HandlerInstantiator hi) { [EOL]     _deserializationConfig = _deserializationConfig.with(hi); [EOL]     _serializationConfig = _serializationConfig.with(hi); [EOL]     return this; [EOL] }
public ObjectMapper configure(MapperFeature f, boolean state) { [EOL]     _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f); [EOL]     _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); [EOL]     return this; [EOL] }
public ObjectMapper configure(MapperFeature f, boolean state) { [EOL]     _serializationConfig = state ? _serializationConfig.with(f) : _serializationConfig.without(f); [EOL]     _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); [EOL]     return this; [EOL] }
public ObjectMapper configure(DeserializationFeature f, boolean state) { [EOL]     _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); [EOL]     return this; [EOL] }
public ObjectMapper configure(DeserializationFeature f, boolean state) { [EOL]     _deserializationConfig = state ? _deserializationConfig.with(f) : _deserializationConfig.without(f); [EOL]     return this; [EOL] }
public ObjectMapper enable(MapperFeature... f) { [EOL]     _deserializationConfig = _deserializationConfig.with(f); [EOL]     _serializationConfig = _serializationConfig.with(f); [EOL]     return this; [EOL] }
public ObjectMapper enable(MapperFeature... f) { [EOL]     _deserializationConfig = _deserializationConfig.with(f); [EOL]     _serializationConfig = _serializationConfig.with(f); [EOL]     return this; [EOL] }
public ObjectMapper enable(MapperFeature... f) { [EOL]     _deserializationConfig = _deserializationConfig.with(f); [EOL]     _serializationConfig = _serializationConfig.with(f); [EOL]     return this; [EOL] }
public ObjectMapper enable(MapperFeature... f) { [EOL]     _deserializationConfig = _deserializationConfig.with(f); [EOL]     _serializationConfig = _serializationConfig.with(f); [EOL]     return this; [EOL] }
public ObjectMapper enable(DeserializationFeature feature) { [EOL]     _deserializationConfig = _deserializationConfig.with(feature); [EOL]     return this; [EOL] }
public ObjectMapper enable(DeserializationFeature feature) { [EOL]     _deserializationConfig = _deserializationConfig.with(feature); [EOL]     return this; [EOL] }
public ObjectMapper disable(DeserializationFeature feature) { [EOL]     _deserializationConfig = _deserializationConfig.without(feature); [EOL]     return this; [EOL] }
public ObjectMapper disable(DeserializationFeature feature) { [EOL]     _deserializationConfig = _deserializationConfig.without(feature); [EOL]     return this; [EOL] }
public ObjectMapper enable(SerializationFeature f) { [EOL]     _serializationConfig = _serializationConfig.with(f); [EOL]     return this; [EOL] }
public boolean isEnabled(MapperFeature f) { [EOL]     return _serializationConfig.isEnabled(f); [EOL] }
public boolean isEnabled(MapperFeature f) { [EOL]     return _serializationConfig.isEnabled(f); [EOL] }
public boolean isEnabled(DeserializationFeature f) { [EOL]     return _deserializationConfig.isEnabled(f); [EOL] }
public boolean isEnabled(DeserializationFeature f) { [EOL]     return _deserializationConfig.isEnabled(f); [EOL] }
public JsonNode readTree(InputStream in) throws IOException, JsonProcessingException { [EOL]     JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE); [EOL]     return (n == null) ? NullNode.instance : n; [EOL] }
public JsonNode readTree(Reader r) throws IOException, JsonProcessingException { [EOL]     JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE); [EOL]     return (n == null) ? NullNode.instance : n; [EOL] }
public JsonNode readTree(Reader r) throws IOException, JsonProcessingException { [EOL]     JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE); [EOL]     return (n == null) ? NullNode.instance : n; [EOL] }
public JsonNode readTree(Reader r) throws IOException, JsonProcessingException { [EOL]     JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE); [EOL]     return (n == null) ? NullNode.instance : n; [EOL] }
public JsonNode readTree(String content) throws IOException, JsonProcessingException { [EOL]     JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); [EOL]     return (n == null) ? NullNode.instance : n; [EOL] }
public JsonNode readTree(String content) throws IOException, JsonProcessingException { [EOL]     JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); [EOL]     return (n == null) ? NullNode.instance : n; [EOL] }
public JsonNode readTree(String content) throws IOException, JsonProcessingException { [EOL]     JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE); [EOL]     return (n == null) ? NullNode.instance : n; [EOL] }
public boolean canSerialize(Class<?> type) { [EOL]     return _serializerProvider(getSerializationConfig()).hasSerializerFor(type); [EOL] }
public boolean canSerialize(Class<?> type) { [EOL]     return _serializerProvider(getSerializationConfig()).hasSerializerFor(type); [EOL] }
public boolean canDeserialize(JavaType type) { [EOL]     return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type); [EOL] }
public boolean canDeserialize(JavaType type) { [EOL]     return createDeserializationContext(null, getDeserializationConfig()).hasValueDeserializerFor(type); [EOL] }
public ObjectWriter writerWithView(Class<?> serializationView) { [EOL]     return new ObjectWriter(this, getSerializationConfig().withView(serializationView)); [EOL] }
public ObjectWriter writerWithView(Class<?> serializationView) { [EOL]     return new ObjectWriter(this, getSerializationConfig().withView(serializationView)); [EOL] }
public ObjectWriter writer(FilterProvider filterProvider) { [EOL]     return new ObjectWriter(this, getSerializationConfig().withFilters(filterProvider)); [EOL] }
public ObjectWriter writer(FilterProvider filterProvider) { [EOL]     return new ObjectWriter(this, getSerializationConfig().withFilters(filterProvider)); [EOL] }
public ObjectReader readerWithView(Class<?> view) { [EOL]     return new ObjectReader(this, getDeserializationConfig().withView(view)); [EOL] }
public ObjectReader readerWithView(Class<?> view) { [EOL]     return new ObjectReader(this, getDeserializationConfig().withView(view)); [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
public boolean canCreateUsingDelegate() { [EOL]     return false; [EOL] }
public BeanAsArrayBuilderDeserializer(BeanDeserializerBase delegate, SettableBeanProperty[] ordered, AnnotatedMethod buildMethod) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _orderedProperties = ordered; [EOL]     _buildMethod = buildMethod; [EOL] }
public BeanAsArrayBuilderDeserializer(BeanDeserializerBase delegate, SettableBeanProperty[] ordered, AnnotatedMethod buildMethod) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _orderedProperties = ordered; [EOL]     _buildMethod = buildMethod; [EOL] }
protected final Object finishBuild(DeserializationContext ctxt, Object builder) throws IOException { [EOL]     try { [EOL]         return _buildMethod.getMember().invoke(builder); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL] }
protected final Object finishBuild(DeserializationContext ctxt, Object builder) throws IOException { [EOL]     try { [EOL]         return _buildMethod.getMember().invoke(builder); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL] }
protected final Object finishBuild(DeserializationContext ctxt, Object builder) throws IOException { [EOL]     try { [EOL]         return _buildMethod.getMember().invoke(builder); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt)); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt)); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return finishBuild(ctxt, builder); [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return finishBuild(ctxt, builder); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt)); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt)); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return finishBuild(ctxt, builder); [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return finishBuild(ctxt, builder); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt)); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt)); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return finishBuild(ctxt, builder); [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return finishBuild(ctxt, builder); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt)); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt)); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return finishBuild(ctxt, builder); [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return finishBuild(ctxt, builder); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt)); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt)); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return finishBuild(ctxt, builder); [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return finishBuild(ctxt, builder); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt)); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt)); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return finishBuild(ctxt, builder); [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return finishBuild(ctxt, builder); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_ARRAY) { [EOL]         return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt)); [EOL]     } [EOL]     if (!_vanillaProcessing) { [EOL]         return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt)); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return finishBuild(ctxt, builder); [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]             } [EOL]         } else { [EOL]             jp.skipChildren(); [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return finishBuild(ctxt, builder); [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return builder; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return builder; [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return builder; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return builder; [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return builder; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return builder; [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return builder; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return builder; [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     Object builder = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return builder; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, builder, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return builder; [EOL] }
@Override [EOL] public boolean asBoolean() { [EOL]     return _value; [EOL] }
@Override [EOL] public boolean asBoolean() { [EOL]     return _value; [EOL] }
@Override [EOL] public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     serialize(value, jgen, provider); [EOL] }
@Override [EOL] public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     serialize(value, jgen, provider); [EOL] }
protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser) { [EOL]     return (keyDeser != null && keyDeser.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser) { [EOL]     return (keyDeser != null && keyDeser.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser) { [EOL]     return (keyDeser != null && keyDeser.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     int value = _parseIntPrimitive(jp, ctxt); [EOL]     if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]         throw ctxt.weirdStringException(String.valueOf(value), _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]     } [EOL]     return (short) value; [EOL] }
protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     int value = _parseIntPrimitive(jp, ctxt); [EOL]     if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]         throw ctxt.weirdStringException(String.valueOf(value), _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]     } [EOL]     return (short) value; [EOL] }
protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     int value = _parseIntPrimitive(jp, ctxt); [EOL]     if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]         throw ctxt.weirdStringException(String.valueOf(value), _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]     } [EOL]     return (short) value; [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getLongValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Long) getEmptyValue(); [EOL]         } [EOL]         try { [EOL]             return Long.valueOf(NumberInput.parseLong(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Long) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findDeserializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             if (existingDeserializer == null) { [EOL]                 existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer); [EOL]         } [EOL]     } [EOL]     return existingDeserializer; [EOL] }
@Override [EOL] public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures) { [EOL]     super(src, mapperFeatures); [EOL]     _serFeatures = serFeatures; [EOL]     _serializationInclusion = src._serializationInclusion; [EOL]     _filterProvider = src._filterProvider; [EOL] }
private SerializationConfig(SerializationConfig src, BaseSettings base) { [EOL]     super(src, base); [EOL]     _serFeatures = src._serFeatures; [EOL]     _serializationInclusion = src._serializationInclusion; [EOL]     _filterProvider = src._filterProvider; [EOL] }
private SerializationConfig(SerializationConfig src, FilterProvider filters) { [EOL]     super(src); [EOL]     _serFeatures = src._serFeatures; [EOL]     _serializationInclusion = src._serializationInclusion; [EOL]     _filterProvider = filters; [EOL] }
private SerializationConfig(SerializationConfig src, FilterProvider filters) { [EOL]     super(src); [EOL]     _serFeatures = src._serFeatures; [EOL]     _serializationInclusion = src._serializationInclusion; [EOL]     _filterProvider = filters; [EOL] }
private SerializationConfig(SerializationConfig src, Class<?> view) { [EOL]     super(src, view); [EOL]     _serFeatures = src._serFeatures; [EOL]     _serializationInclusion = src._serializationInclusion; [EOL]     _filterProvider = src._filterProvider; [EOL] }
private SerializationConfig(SerializationConfig src, String rootName) { [EOL]     super(src, rootName); [EOL]     _serFeatures = src._serFeatures; [EOL]     _serializationInclusion = src._serializationInclusion; [EOL]     _filterProvider = src._filterProvider; [EOL] }
protected SerializationConfig(SerializationConfig src, Map<ClassKey, Class<?>> mixins) { [EOL]     super(src, mixins); [EOL]     _serFeatures = src._serFeatures; [EOL]     _serializationInclusion = src._serializationInclusion; [EOL]     _filterProvider = src._filterProvider; [EOL] }
@Override [EOL] public SerializationConfig without(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags &= ~f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new SerializationConfig(this, newMapperFlags, _serFeatures); [EOL] }
@Override [EOL] public SerializationConfig without(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags &= ~f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new SerializationConfig(this, newMapperFlags, _serFeatures); [EOL] }
@Override [EOL] public SerializationConfig without(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags &= ~f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new SerializationConfig(this, newMapperFlags, _serFeatures); [EOL] }
@Override [EOL] public SerializationConfig with(AnnotationIntrospector ai) { [EOL]     return _withBase(_base.withAnnotationIntrospector(ai)); [EOL] }
@Override [EOL] public SerializationConfig with(HandlerInstantiator hi) { [EOL]     return _withBase(_base.withHandlerInstantiator(hi)); [EOL] }
@Override [EOL] public SerializationConfig withRootName(String rootName) { [EOL]     if (rootName == null) { [EOL]         if (_rootName == null) { [EOL]             return this; [EOL]         } [EOL]     } else if (rootName.equals(_rootName)) { [EOL]         return this; [EOL]     } [EOL]     return new SerializationConfig(this, rootName); [EOL] }
@Override [EOL] public SerializationConfig withRootName(String rootName) { [EOL]     if (rootName == null) { [EOL]         if (_rootName == null) { [EOL]             return this; [EOL]         } [EOL]     } else if (rootName.equals(_rootName)) { [EOL]         return this; [EOL]     } [EOL]     return new SerializationConfig(this, rootName); [EOL] }
@Override [EOL] public SerializationConfig withRootName(String rootName) { [EOL]     if (rootName == null) { [EOL]         if (_rootName == null) { [EOL]             return this; [EOL]         } [EOL]     } else if (rootName.equals(_rootName)) { [EOL]         return this; [EOL]     } [EOL]     return new SerializationConfig(this, rootName); [EOL] }
@Override [EOL] public SerializationConfig withRootName(String rootName) { [EOL]     if (rootName == null) { [EOL]         if (_rootName == null) { [EOL]             return this; [EOL]         } [EOL]     } else if (rootName.equals(_rootName)) { [EOL]         return this; [EOL]     } [EOL]     return new SerializationConfig(this, rootName); [EOL] }
@Override [EOL] public SerializationConfig with(TypeFactory tf) { [EOL]     return _withBase(_base.withTypeFactory(tf)); [EOL] }
@Override [EOL] public SerializationConfig withView(Class<?> view) { [EOL]     return (_view == view) ? this : new SerializationConfig(this, view); [EOL] }
@Override [EOL] public SerializationConfig withView(Class<?> view) { [EOL]     return (_view == view) ? this : new SerializationConfig(this, view); [EOL] }
private final SerializationConfig _withBase(BaseSettings newBase) { [EOL]     return (_base == newBase) ? this : new SerializationConfig(this, newBase); [EOL] }
private final SerializationConfig _withBase(BaseSettings newBase) { [EOL]     return (_base == newBase) ? this : new SerializationConfig(this, newBase); [EOL] }
public SerializationConfig with(SerializationFeature feature) { [EOL]     int newSerFeatures = _serFeatures | feature.getMask(); [EOL]     return (newSerFeatures == _serFeatures) ? this : new SerializationConfig(this, _mapperFeatures, newSerFeatures); [EOL] }
public SerializationConfig with(SerializationFeature feature) { [EOL]     int newSerFeatures = _serFeatures | feature.getMask(); [EOL]     return (newSerFeatures == _serFeatures) ? this : new SerializationConfig(this, _mapperFeatures, newSerFeatures); [EOL] }
public SerializationConfig withFilters(FilterProvider filterProvider) { [EOL]     return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider); [EOL] }
public SerializationConfig withFilters(FilterProvider filterProvider) { [EOL]     return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider); [EOL] }
@Override [EOL] public AnnotationIntrospector getAnnotationIntrospector() { [EOL]     if (isEnabled(MapperFeature.USE_ANNOTATIONS)) { [EOL]         return super.getAnnotationIntrospector(); [EOL]     } [EOL]     return AnnotationIntrospector.nopInstance(); [EOL] }
@Override [EOL] public AnnotationIntrospector getAnnotationIntrospector() { [EOL]     if (isEnabled(MapperFeature.USE_ANNOTATIONS)) { [EOL]         return super.getAnnotationIntrospector(); [EOL]     } [EOL]     return AnnotationIntrospector.nopInstance(); [EOL] }
@Override [EOL] public BeanDescription introspectClassAnnotations(JavaType type) { [EOL]     return getClassIntrospector().forClassAnnotations(this, type, this); [EOL] }
@Override [EOL] public BeanDescription introspectClassAnnotations(JavaType type) { [EOL]     return getClassIntrospector().forClassAnnotations(this, type, this); [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
public final boolean isEnabled(SerializationFeature f) { [EOL]     return (_serFeatures & f.getMask()) != 0; [EOL] }
public final boolean isEnabled(SerializationFeature f) { [EOL]     return (_serFeatures & f.getMask()) != 0; [EOL] }
public JsonInclude.Include getSerializationInclusion() { [EOL]     if (_serializationInclusion != null) { [EOL]         return _serializationInclusion; [EOL]     } [EOL]     return JsonInclude.Include.ALWAYS; [EOL] }
public JsonInclude.Include getSerializationInclusion() { [EOL]     if (_serializationInclusion != null) { [EOL]         return _serializationInclusion; [EOL]     } [EOL]     return JsonInclude.Include.ALWAYS; [EOL] }
public FilterProvider getFilterProvider() { [EOL]     return _filterProvider; [EOL] }
public FilterProvider getFilterProvider() { [EOL]     return _filterProvider; [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T extends BeanDescription> T introspect(JavaType type) { [EOL]     return (T) getClassIntrospector().forSerialization(this, type, this); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T extends BeanDescription> T introspect(JavaType type) { [EOL]     return (T) getClassIntrospector().forSerialization(this, type, this); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public UUIDDeserializer() { [EOL]     super(UUID.class); [EOL] }
@Override [EOL] protected UUID _deserialize(String value, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return UUID.fromString(value); [EOL] }
@Override [EOL] protected UUID _deserialize(String value, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return UUID.fromString(value); [EOL] }
public LocaleDeserializer() { [EOL]     super(Locale.class); [EOL] }
@Override [EOL] protected Locale _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     int ix = value.indexOf('_'); [EOL]     if (ix < 0) { [EOL]         return new Locale(value); [EOL]     } [EOL]     String first = value.substring(0, ix); [EOL]     value = value.substring(ix + 1); [EOL]     ix = value.indexOf('_'); [EOL]     if (ix < 0) { [EOL]         return new Locale(first, value); [EOL]     } [EOL]     String second = value.substring(0, ix); [EOL]     return new Locale(first, second, value.substring(ix + 1)); [EOL] }
@Override [EOL] protected Locale _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     int ix = value.indexOf('_'); [EOL]     if (ix < 0) { [EOL]         return new Locale(value); [EOL]     } [EOL]     String first = value.substring(0, ix); [EOL]     value = value.substring(ix + 1); [EOL]     ix = value.indexOf('_'); [EOL]     if (ix < 0) { [EOL]         return new Locale(first, value); [EOL]     } [EOL]     String second = value.substring(0, ix); [EOL]     return new Locale(first, second, value.substring(ix + 1)); [EOL] }
@Override [EOL] protected Locale _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     int ix = value.indexOf('_'); [EOL]     if (ix < 0) { [EOL]         return new Locale(value); [EOL]     } [EOL]     String first = value.substring(0, ix); [EOL]     value = value.substring(ix + 1); [EOL]     ix = value.indexOf('_'); [EOL]     if (ix < 0) { [EOL]         return new Locale(first, value); [EOL]     } [EOL]     String second = value.substring(0, ix); [EOL]     return new Locale(first, second, value.substring(ix + 1)); [EOL] }
@Override [EOL] public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         String className = "", methodName = "", fileName = ""; [EOL]         int lineNumber = -1; [EOL]         while ((t = jp.nextValue()) != JsonToken.END_OBJECT) { [EOL]             String propName = jp.getCurrentName(); [EOL]             if ("className".equals(propName)) { [EOL]                 className = jp.getText(); [EOL]             } else if ("fileName".equals(propName)) { [EOL]                 fileName = jp.getText(); [EOL]             } else if ("lineNumber".equals(propName)) { [EOL]                 if (t.isNumeric()) { [EOL]                     lineNumber = jp.getIntValue(); [EOL]                 } else { [EOL]                     throw JsonMappingException.from(jp, "Non-numeric token (" + t + ") for property 'lineNumber'"); [EOL]                 } [EOL]             } else if ("methodName".equals(propName)) { [EOL]                 methodName = jp.getText(); [EOL]             } else if ("nativeMethod".equals(propName)) { [EOL]             } else { [EOL]                 handleUnknownProperty(jp, ctxt, _valueClass, propName); [EOL]             } [EOL]         } [EOL]         return new StackTraceElement(className, methodName, fileName, lineNumber); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         String className = "", methodName = "", fileName = ""; [EOL]         int lineNumber = -1; [EOL]         while ((t = jp.nextValue()) != JsonToken.END_OBJECT) { [EOL]             String propName = jp.getCurrentName(); [EOL]             if ("className".equals(propName)) { [EOL]                 className = jp.getText(); [EOL]             } else if ("fileName".equals(propName)) { [EOL]                 fileName = jp.getText(); [EOL]             } else if ("lineNumber".equals(propName)) { [EOL]                 if (t.isNumeric()) { [EOL]                     lineNumber = jp.getIntValue(); [EOL]                 } else { [EOL]                     throw JsonMappingException.from(jp, "Non-numeric token (" + t + ") for property 'lineNumber'"); [EOL]                 } [EOL]             } else if ("methodName".equals(propName)) { [EOL]                 methodName = jp.getText(); [EOL]             } else if ("nativeMethod".equals(propName)) { [EOL]             } else { [EOL]                 handleUnknownProperty(jp, ctxt, _valueClass, propName); [EOL]             } [EOL]         } [EOL]         return new StackTraceElement(className, methodName, fileName, lineNumber); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         String className = "", methodName = "", fileName = ""; [EOL]         int lineNumber = -1; [EOL]         while ((t = jp.nextValue()) != JsonToken.END_OBJECT) { [EOL]             String propName = jp.getCurrentName(); [EOL]             if ("className".equals(propName)) { [EOL]                 className = jp.getText(); [EOL]             } else if ("fileName".equals(propName)) { [EOL]                 fileName = jp.getText(); [EOL]             } else if ("lineNumber".equals(propName)) { [EOL]                 if (t.isNumeric()) { [EOL]                     lineNumber = jp.getIntValue(); [EOL]                 } else { [EOL]                     throw JsonMappingException.from(jp, "Non-numeric token (" + t + ") for property 'lineNumber'"); [EOL]                 } [EOL]             } else if ("methodName".equals(propName)) { [EOL]                 methodName = jp.getText(); [EOL]             } else if ("nativeMethod".equals(propName)) { [EOL]             } else { [EOL]                 handleUnknownProperty(jp, ctxt, _valueClass, propName); [EOL]             } [EOL]         } [EOL]         return new StackTraceElement(className, methodName, fileName, lineNumber); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         String className = "", methodName = "", fileName = ""; [EOL]         int lineNumber = -1; [EOL]         while ((t = jp.nextValue()) != JsonToken.END_OBJECT) { [EOL]             String propName = jp.getCurrentName(); [EOL]             if ("className".equals(propName)) { [EOL]                 className = jp.getText(); [EOL]             } else if ("fileName".equals(propName)) { [EOL]                 fileName = jp.getText(); [EOL]             } else if ("lineNumber".equals(propName)) { [EOL]                 if (t.isNumeric()) { [EOL]                     lineNumber = jp.getIntValue(); [EOL]                 } else { [EOL]                     throw JsonMappingException.from(jp, "Non-numeric token (" + t + ") for property 'lineNumber'"); [EOL]                 } [EOL]             } else if ("methodName".equals(propName)) { [EOL]                 methodName = jp.getText(); [EOL]             } else if ("nativeMethod".equals(propName)) { [EOL]             } else { [EOL]                 handleUnknownProperty(jp, ctxt, _valueClass, propName); [EOL]             } [EOL]         } [EOL]         return new StackTraceElement(className, methodName, fileName, lineNumber); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
public AsPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName) { [EOL]     super(idRes, property); [EOL]     _typePropertyName = propName; [EOL] }
public AsPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName) { [EOL]     super(idRes, property); [EOL]     _typePropertyName = propName; [EOL] }
public FieldProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedField field) { [EOL]     super(propDef, type, typeDeser, contextAnnotations); [EOL]     _annotated = field; [EOL]     _field = field.getAnnotated(); [EOL] }
public FieldProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedField field) { [EOL]     super(propDef, type, typeDeser, contextAnnotations); [EOL]     _annotated = field; [EOL]     _field = field.getAnnotated(); [EOL] }
protected FieldProperty(FieldProperty src, JsonDeserializer<?> deser) { [EOL]     super(src, deser); [EOL]     _annotated = src._annotated; [EOL]     _field = src._field; [EOL] }
@Override [EOL] public FieldProperty withValueDeserializer(JsonDeserializer<?> deser) { [EOL]     return new FieldProperty(this, deser); [EOL] }
@Override [EOL] public FieldProperty withValueDeserializer(JsonDeserializer<?> deser) { [EOL]     return new FieldProperty(this, deser); [EOL] }
@Override [EOL] public AnnotatedMember getMember() { [EOL]     return _annotated; [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     set(instance, deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     set(instance, deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public final void set(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         _field.set(instance, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]     } [EOL] }
protected BeanDeserializerBase(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews) { [EOL]     super(beanDesc.getType()); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     _classAnnotations = ac.getAnnotations(); [EOL]     _beanType = beanDesc.getType(); [EOL]     _valueInstantiator = builder.getValueInstantiator(); [EOL]     _beanProperties = properties; [EOL]     _backRefs = backRefs; [EOL]     _ignorableProps = ignorableProps; [EOL]     _ignoreAllUnknown = ignoreAllUnknown; [EOL]     _anySetter = builder.getAnySetter(); [EOL]     List<ValueInjector> injectables = builder.getInjectables(); [EOL]     _injectables = (injectables == null || injectables.isEmpty()) ? null : injectables.toArray(new ValueInjector[injectables.size()]); [EOL]     _objectIdReader = builder.getObjectIdReader(); [EOL]     _nonStandardCreation = (_unwrappedPropertyHandler != null) || _valueInstantiator.canCreateUsingDelegate() || _valueInstantiator.canCreateFromObjectWith() || !_valueInstantiator.canCreateUsingDefault(); [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     _serializationShape = (format == null) ? null : format.getShape(); [EOL]     _needViewProcesing = hasViews; [EOL]     _vanillaProcessing = !_nonStandardCreation && (_injectables == null) && !_needViewProcesing && (_objectIdReader != null); [EOL] }
protected BeanDeserializerBase(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews) { [EOL]     super(beanDesc.getType()); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     _classAnnotations = ac.getAnnotations(); [EOL]     _beanType = beanDesc.getType(); [EOL]     _valueInstantiator = builder.getValueInstantiator(); [EOL]     _beanProperties = properties; [EOL]     _backRefs = backRefs; [EOL]     _ignorableProps = ignorableProps; [EOL]     _ignoreAllUnknown = ignoreAllUnknown; [EOL]     _anySetter = builder.getAnySetter(); [EOL]     List<ValueInjector> injectables = builder.getInjectables(); [EOL]     _injectables = (injectables == null || injectables.isEmpty()) ? null : injectables.toArray(new ValueInjector[injectables.size()]); [EOL]     _objectIdReader = builder.getObjectIdReader(); [EOL]     _nonStandardCreation = (_unwrappedPropertyHandler != null) || _valueInstantiator.canCreateUsingDelegate() || _valueInstantiator.canCreateFromObjectWith() || !_valueInstantiator.canCreateUsingDefault(); [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     _serializationShape = (format == null) ? null : format.getShape(); [EOL]     _needViewProcesing = hasViews; [EOL]     _vanillaProcessing = !_nonStandardCreation && (_injectables == null) && !_needViewProcesing && (_objectIdReader != null); [EOL] }
protected BeanDeserializerBase(BeanDeserializerBase src, boolean ignoreAllUnknown) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _beanProperties = src._beanProperties; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = src._ignorableProps; [EOL]     _ignoreAllUnknown = ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _objectIdReader = src._objectIdReader; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = src._vanillaProcessing; [EOL] }
protected BeanDeserializerBase(BeanDeserializerBase src, boolean ignoreAllUnknown) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _beanProperties = src._beanProperties; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = src._ignorableProps; [EOL]     _ignoreAllUnknown = ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _objectIdReader = src._objectIdReader; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = src._vanillaProcessing; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, SettableBeanProperty prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findDeserializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             JsonDeserializer<?> ser = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, SettableBeanProperty prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findDeserializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             JsonDeserializer<?> ser = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, SettableBeanProperty prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findDeserializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             JsonDeserializer<?> ser = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     AnnotatedMember am = prop.getMember(); [EOL]     if (am != null) { [EOL]         NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am); [EOL]         if (unwrapper != null) { [EOL]             JsonDeserializer<Object> orig = prop.getValueDeserializer(); [EOL]             JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper); [EOL]             if (unwrapping != orig && unwrapping != null) { [EOL]                 return prop.withValueDeserializer(unwrapping); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     AnnotatedMember am = prop.getMember(); [EOL]     if (am != null) { [EOL]         NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am); [EOL]         if (unwrapper != null) { [EOL]             JsonDeserializer<Object> orig = prop.getValueDeserializer(); [EOL]             JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper); [EOL]             if (unwrapping != orig && unwrapping != null) { [EOL]                 return prop.withValueDeserializer(unwrapping); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     AnnotatedMember am = prop.getMember(); [EOL]     if (am != null) { [EOL]         NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am); [EOL]         if (unwrapper != null) { [EOL]             JsonDeserializer<Object> orig = prop.getValueDeserializer(); [EOL]             JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper); [EOL]             if (unwrapping != orig && unwrapping != null) { [EOL]                 return prop.withValueDeserializer(unwrapping); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     AnnotatedMember am = prop.getMember(); [EOL]     if (am != null) { [EOL]         NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am); [EOL]         if (unwrapper != null) { [EOL]             JsonDeserializer<Object> orig = prop.getValueDeserializer(); [EOL]             JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper); [EOL]             if (unwrapping != orig && unwrapping != null) { [EOL]                 return prop.withValueDeserializer(unwrapping); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]     if (deser instanceof BeanDeserializerBase) { [EOL]         BeanDeserializerBase bd = (BeanDeserializerBase) deser; [EOL]         ValueInstantiator vi = bd.getValueInstantiator(); [EOL]         if (!vi.canCreateUsingDefault()) { [EOL]             Class<?> valueClass = prop.getType().getRawClass(); [EOL]             Class<?> enclosing = ClassUtil.getOuterClass(valueClass); [EOL]             if (enclosing != null && enclosing == _beanType.getRawClass()) { [EOL]                 for (Constructor<?> ctor : valueClass.getConstructors()) { [EOL]                     Class<?>[] paramTypes = ctor.getParameterTypes(); [EOL]                     if (paramTypes.length == 1 && paramTypes[0] == enclosing) { [EOL]                         if (ctxt.getConfig().canOverrideAccessModifiers()) { [EOL]                             ClassUtil.checkAndFixAccess(ctor); [EOL]                         } [EOL]                         return new InnerClassProperty(prop, ctor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return prop; [EOL] }
protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]     if (deser instanceof BeanDeserializerBase) { [EOL]         BeanDeserializerBase bd = (BeanDeserializerBase) deser; [EOL]         ValueInstantiator vi = bd.getValueInstantiator(); [EOL]         if (!vi.canCreateUsingDefault()) { [EOL]             Class<?> valueClass = prop.getType().getRawClass(); [EOL]             Class<?> enclosing = ClassUtil.getOuterClass(valueClass); [EOL]             if (enclosing != null && enclosing == _beanType.getRawClass()) { [EOL]                 for (Constructor<?> ctor : valueClass.getConstructors()) { [EOL]                     Class<?>[] paramTypes = ctor.getParameterTypes(); [EOL]                     if (paramTypes.length == 1 && paramTypes[0] == enclosing) { [EOL]                         if (ctxt.getConfig().canOverrideAccessModifiers()) { [EOL]                             ClassUtil.checkAndFixAccess(ctor); [EOL]                         } [EOL]                         return new InnerClassProperty(prop, ctor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return prop; [EOL] }
protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]     if (deser instanceof BeanDeserializerBase) { [EOL]         BeanDeserializerBase bd = (BeanDeserializerBase) deser; [EOL]         ValueInstantiator vi = bd.getValueInstantiator(); [EOL]         if (!vi.canCreateUsingDefault()) { [EOL]             Class<?> valueClass = prop.getType().getRawClass(); [EOL]             Class<?> enclosing = ClassUtil.getOuterClass(valueClass); [EOL]             if (enclosing != null && enclosing == _beanType.getRawClass()) { [EOL]                 for (Constructor<?> ctor : valueClass.getConstructors()) { [EOL]                     Class<?>[] paramTypes = ctor.getParameterTypes(); [EOL]                     if (paramTypes.length == 1 && paramTypes[0] == enclosing) { [EOL]                         if (ctxt.getConfig().canOverrideAccessModifiers()) { [EOL]                             ClassUtil.checkAndFixAccess(ctor); [EOL]                         } [EOL]                         return new InnerClassProperty(prop, ctor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return prop; [EOL] }
protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]     if (deser instanceof BeanDeserializerBase) { [EOL]         BeanDeserializerBase bd = (BeanDeserializerBase) deser; [EOL]         ValueInstantiator vi = bd.getValueInstantiator(); [EOL]         if (!vi.canCreateUsingDefault()) { [EOL]             Class<?> valueClass = prop.getType().getRawClass(); [EOL]             Class<?> enclosing = ClassUtil.getOuterClass(valueClass); [EOL]             if (enclosing != null && enclosing == _beanType.getRawClass()) { [EOL]                 for (Constructor<?> ctor : valueClass.getConstructors()) { [EOL]                     Class<?>[] paramTypes = ctor.getParameterTypes(); [EOL]                     if (paramTypes.length == 1 && paramTypes[0] == enclosing) { [EOL]                         if (ctxt.getConfig().canOverrideAccessModifiers()) { [EOL]                             ClassUtil.checkAndFixAccess(ctor); [EOL]                         } [EOL]                         return new InnerClassProperty(prop, ctor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return prop; [EOL] }
protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]     if (deser instanceof BeanDeserializerBase) { [EOL]         BeanDeserializerBase bd = (BeanDeserializerBase) deser; [EOL]         ValueInstantiator vi = bd.getValueInstantiator(); [EOL]         if (!vi.canCreateUsingDefault()) { [EOL]             Class<?> valueClass = prop.getType().getRawClass(); [EOL]             Class<?> enclosing = ClassUtil.getOuterClass(valueClass); [EOL]             if (enclosing != null && enclosing == _beanType.getRawClass()) { [EOL]                 for (Constructor<?> ctor : valueClass.getConstructors()) { [EOL]                     Class<?>[] paramTypes = ctor.getParameterTypes(); [EOL]                     if (paramTypes.length == 1 && paramTypes[0] == enclosing) { [EOL]                         if (ctxt.getConfig().canOverrideAccessModifiers()) { [EOL]                             ClassUtil.checkAndFixAccess(ctor); [EOL]                         } [EOL]                         return new InnerClassProperty(prop, ctor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return prop; [EOL] }
@Override [EOL] public boolean isCachable() { [EOL]     return true; [EOL] }
@Override [EOL] public Collection<Object> getKnownPropertyNames() { [EOL]     ArrayList<Object> names = new ArrayList<Object>(); [EOL]     for (SettableBeanProperty prop : _beanProperties) { [EOL]         names.add(prop.getName()); [EOL]     } [EOL]     return names; [EOL] }
@Override [EOL] public Collection<Object> getKnownPropertyNames() { [EOL]     ArrayList<Object> names = new ArrayList<Object>(); [EOL]     for (SettableBeanProperty prop : _beanProperties) { [EOL]         names.add(prop.getName()); [EOL]     } [EOL]     return names; [EOL] }
public SettableBeanProperty findProperty(String propertyName) { [EOL]     SettableBeanProperty prop = (_beanProperties == null) ? null : _beanProperties.find(propertyName); [EOL]     if (prop == null && _propertyBasedCreator != null) { [EOL]         prop = _propertyBasedCreator.findCreatorProperty(propertyName); [EOL]     } [EOL]     return prop; [EOL] }
public SettableBeanProperty findProperty(String propertyName) { [EOL]     SettableBeanProperty prop = (_beanProperties == null) ? null : _beanProperties.find(propertyName); [EOL]     if (prop == null && _propertyBasedCreator != null) { [EOL]         prop = _propertyBasedCreator.findCreatorProperty(propertyName); [EOL]     } [EOL]     return prop; [EOL] }
public SettableBeanProperty findProperty(String propertyName) { [EOL]     SettableBeanProperty prop = (_beanProperties == null) ? null : _beanProperties.find(propertyName); [EOL]     if (prop == null && _propertyBasedCreator != null) { [EOL]         prop = _propertyBasedCreator.findCreatorProperty(propertyName); [EOL]     } [EOL]     return prop; [EOL] }
public SettableBeanProperty findProperty(String propertyName) { [EOL]     SettableBeanProperty prop = (_beanProperties == null) ? null : _beanProperties.find(propertyName); [EOL]     if (prop == null && _propertyBasedCreator != null) { [EOL]         prop = _propertyBasedCreator.findCreatorProperty(propertyName); [EOL]     } [EOL]     return prop; [EOL] }
public SettableBeanProperty findProperty(String propertyName) { [EOL]     SettableBeanProperty prop = (_beanProperties == null) ? null : _beanProperties.find(propertyName); [EOL]     if (prop == null && _propertyBasedCreator != null) { [EOL]         prop = _propertyBasedCreator.findCreatorProperty(propertyName); [EOL]     } [EOL]     return prop; [EOL] }
@Override [EOL] public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object id = _objectIdReader.deserializer.deserialize(jp, ctxt); [EOL]     ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator); [EOL]     Object pojo = roid.item; [EOL]     if (pojo == null) { [EOL]         throw new IllegalStateException("Could not resolve Object Id [" + id + "] (for " + _beanType + ") -- unresolved forward-reference?"); [EOL]     } [EOL]     return pojo; [EOL] }
protected Object deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object id = _objectIdReader.deserializer.deserialize(jp, ctxt); [EOL]     ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator); [EOL]     Object pojo = roid.item; [EOL]     if (pojo == null) { [EOL]         throw new IllegalStateException("Could not resolve Object Id [" + id + "] (for " + _beanType + ") -- unresolved forward-reference?"); [EOL]     } [EOL]     return pojo; [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromString()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     return _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL] }
public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromString()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     return _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL] }
public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromString()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     return _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getNumberType()) { [EOL]         case FLOAT: [EOL]         case DOUBLE: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromDouble()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON floating-point number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getNumberType()) { [EOL]         case FLOAT: [EOL]         case DOUBLE: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromDouble()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON floating-point number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getNumberType()) { [EOL]         case FLOAT: [EOL]         case DOUBLE: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromDouble()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON floating-point number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getNumberType()) { [EOL]         case FLOAT: [EOL]         case DOUBLE: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromDouble()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON floating-point number"); [EOL] }
public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromBoolean()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE); [EOL]     return _valueInstantiator.createFromBoolean(ctxt, value); [EOL] }
public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromBoolean()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE); [EOL]     return _valueInstantiator.createFromBoolean(ctxt, value); [EOL] }
public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromBoolean()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE); [EOL]     return _valueInstantiator.createFromBoolean(ctxt, value); [EOL] }
public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         try { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } catch (Exception e) { [EOL]             wrapInstantiationProblem(e, ctxt); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(getBeanClass()); [EOL] }
public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         try { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } catch (Exception e) { [EOL]             wrapInstantiationProblem(e, ctxt); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(getBeanClass()); [EOL] }
public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         try { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } catch (Exception e) { [EOL]             wrapInstantiationProblem(e, ctxt); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(getBeanClass()); [EOL] }
@Override [EOL] protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (_ignoreAllUnknown || (_ignorableProps != null && _ignorableProps.contains(propName))) { [EOL]         jp.skipChildren(); [EOL]         return; [EOL]     } [EOL]     super.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] }
@Override [EOL] protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (_ignoreAllUnknown || (_ignorableProps != null && _ignorableProps.contains(propName))) { [EOL]         jp.skipChildren(); [EOL]         return; [EOL]     } [EOL]     super.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] }
@Override [EOL] protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (_ignoreAllUnknown || (_ignorableProps != null && _ignorableProps.contains(propName))) { [EOL]         jp.skipChildren(); [EOL]         return; [EOL]     } [EOL]     super.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] }
@Override [EOL] protected BeanAsArrayBuilderDeserializer asArrayDeserializer() { [EOL]     SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder(); [EOL]     return new BeanAsArrayBuilderDeserializer(this, props, _buildMethod); [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, Object builder) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, builder); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, builder); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, builder); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, builder, view); [EOL]         } [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 builder = prop.deserializeSetAndReturn(jp, ctxt, builder); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, builder, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, builder, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, builder, propName); [EOL]         } [EOL]     } [EOL]     return builder; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return _deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return _deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return _deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return _deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return _deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
public static ViewMatcher construct(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         return Empty.instance; [EOL]     } [EOL]     switch(views.length) { [EOL]         case 0: [EOL]             return Empty.instance; [EOL]         case 1: [EOL]             return new Single(views[0]); [EOL]     } [EOL]     return new Multi(views); [EOL] }
public static ViewMatcher construct(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         return Empty.instance; [EOL]     } [EOL]     switch(views.length) { [EOL]         case 0: [EOL]             return Empty.instance; [EOL]         case 1: [EOL]             return new Single(views[0]); [EOL]     } [EOL]     return new Multi(views); [EOL] }
public static ViewMatcher construct(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         return Empty.instance; [EOL]     } [EOL]     switch(views.length) { [EOL]         case 0: [EOL]             return Empty.instance; [EOL]         case 1: [EOL]             return new Single(views[0]); [EOL]     } [EOL]     return new Multi(views); [EOL] }
public static ViewMatcher construct(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         return Empty.instance; [EOL]     } [EOL]     switch(views.length) { [EOL]         case 0: [EOL]             return Empty.instance; [EOL]         case 1: [EOL]             return new Single(views[0]); [EOL]     } [EOL]     return new Multi(views); [EOL] }
public Multi(Class<?>[] v) { [EOL]     _views = v; [EOL] }
public Multi(Class<?>[] v) { [EOL]     _views = v; [EOL] }
public Multi(Class<?>[] v) { [EOL]     _views = v; [EOL] }
@Override [EOL] public boolean isVisibleForView(Class<?> activeView) { [EOL]     for (int i = 0, len = _views.length; i < len; ++i) { [EOL]         Class<?> view = _views[i]; [EOL]         if ((activeView == view) || view.isAssignableFrom(activeView)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public BeanDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     super(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@Override [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return custom; [EOL]     } [EOL]     if (type.isThrowable()) { [EOL]         return buildThrowableDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isAbstract()) { [EOL]         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc); [EOL]         if (concreteType != null) { [EOL]             beanDesc = config.introspect(concreteType); [EOL]             return buildBeanDeserializer(ctxt, concreteType, beanDesc); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         return null; [EOL]     } [EOL]     return buildBeanDeserializer(ctxt, type, beanDesc); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL]     builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc)); [EOL]     addBeanProps(ctxt, beanDesc, builder); [EOL]     AnnotatedMethod am = beanDesc.findMethod("initCause", INIT_CAUSE_PARAMS); [EOL]     if (am != null) { [EOL]         SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am, "cause"); [EOL]         SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef, am.getGenericParameterType(0)); [EOL]         if (prop != null) { [EOL]             builder.addOrReplaceProperty(prop, true); [EOL]         } [EOL]     } [EOL]     builder.addIgnorable("localizedMessage"); [EOL]     builder.addIgnorable("suppressed"); [EOL]     builder.addIgnorable("message"); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> deserializer = builder.build(); [EOL]     if (deserializer instanceof BeanDeserializer) { [EOL]         deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer); [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer); [EOL]         } [EOL]     } [EOL]     return (JsonDeserializer<Object>) deserializer; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL]     builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc)); [EOL]     addBeanProps(ctxt, beanDesc, builder); [EOL]     AnnotatedMethod am = beanDesc.findMethod("initCause", INIT_CAUSE_PARAMS); [EOL]     if (am != null) { [EOL]         SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am, "cause"); [EOL]         SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef, am.getGenericParameterType(0)); [EOL]         if (prop != null) { [EOL]             builder.addOrReplaceProperty(prop, true); [EOL]         } [EOL]     } [EOL]     builder.addIgnorable("localizedMessage"); [EOL]     builder.addIgnorable("suppressed"); [EOL]     builder.addIgnorable("message"); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> deserializer = builder.build(); [EOL]     if (deserializer instanceof BeanDeserializer) { [EOL]         deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer); [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer); [EOL]         } [EOL]     } [EOL]     return (JsonDeserializer<Object>) deserializer; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL]     builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc)); [EOL]     addBeanProps(ctxt, beanDesc, builder); [EOL]     AnnotatedMethod am = beanDesc.findMethod("initCause", INIT_CAUSE_PARAMS); [EOL]     if (am != null) { [EOL]         SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am, "cause"); [EOL]         SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef, am.getGenericParameterType(0)); [EOL]         if (prop != null) { [EOL]             builder.addOrReplaceProperty(prop, true); [EOL]         } [EOL]     } [EOL]     builder.addIgnorable("localizedMessage"); [EOL]     builder.addIgnorable("suppressed"); [EOL]     builder.addIgnorable("message"); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> deserializer = builder.build(); [EOL]     if (deserializer instanceof BeanDeserializer) { [EOL]         deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer); [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer); [EOL]         } [EOL]     } [EOL]     return (JsonDeserializer<Object>) deserializer; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     boolean ignoreAny = false; [EOL]     { [EOL]         Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); [EOL]         if (B != null) { [EOL]             ignoreAny = B.booleanValue(); [EOL]             builder.setIgnoreUnknownProperties(ignoreAny); [EOL]         } [EOL]     } [EOL]     Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]     for (String propName : ignored) { [EOL]         builder.addIgnorable(propName); [EOL]     } [EOL]     AnnotatedMethod anySetter = beanDesc.findAnySetter(); [EOL]     if (anySetter != null) { [EOL]         builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); [EOL]     } [EOL]     if (anySetter == null) { [EOL]         Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); [EOL]         if (ignored2 != null) { [EOL]             for (String propName : ignored2) { [EOL]                 builder.addIgnorable(propName); [EOL]             } [EOL]         } [EOL]     } [EOL]     final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS)); [EOL]     List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); [EOL]         } [EOL]     } [EOL]     for (BeanPropertyDefinition propDef : propDefs) { [EOL]         SettableBeanProperty prop = null; [EOL]         if (propDef.hasConstructorParameter()) { [EOL]             final String name = propDef.getName(); [EOL]             if (creatorProps != null) { [EOL]                 for (SettableBeanProperty cp : creatorProps) { [EOL]                     if (name.equals(cp.getName())) { [EOL]                         prop = cp; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (prop == null) { [EOL]                 throw ctxt.mappingException("Could not find creator property with name '" + name + "' (in class " + beanDesc.getBeanClass().getName() + ")"); [EOL]             } [EOL]             builder.addCreatorProperty(prop); [EOL]             continue; [EOL]         } [EOL]         if (propDef.hasSetter()) { [EOL]             Type propertyType = propDef.getSetter().getGenericParameterType(0); [EOL]             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL]         } else if (propDef.hasField()) { [EOL]             Type propertyType = propDef.getField().getGenericType(); [EOL]             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL]         } else if (useGettersAsSetters && propDef.hasGetter()) { [EOL]             AnnotatedMethod getter = propDef.getGetter(); [EOL]             Class<?> rawPropertyType = getter.getRawType(); [EOL]             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { [EOL]                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef); [EOL]             } [EOL]         } [EOL]         if (prop != null) { [EOL]             Class<?>[] views = propDef.findViews(); [EOL]             if (views == null) { [EOL]                 if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) { [EOL]                     views = NO_VIEWS; [EOL]                 } [EOL]             } [EOL]             prop.setViews(views); [EOL]             builder.addProperty(prop); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException { [EOL]     ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(Math.max(4, propDefsIn.size())); [EOL]     HashMap<Class<?>, Boolean> ignoredTypes = new HashMap<Class<?>, Boolean>(); [EOL]     for (BeanPropertyDefinition property : propDefsIn) { [EOL]         String name = property.getName(); [EOL]         if (ignored.contains(name)) { [EOL]             continue; [EOL]         } [EOL]         if (!property.hasConstructorParameter()) { [EOL]             Class<?> rawPropertyType = null; [EOL]             if (property.hasSetter()) { [EOL]                 rawPropertyType = property.getSetter().getRawParameterType(0); [EOL]             } else if (property.hasField()) { [EOL]                 rawPropertyType = property.getField().getRawType(); [EOL]             } [EOL]             if ((rawPropertyType != null) && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) { [EOL]                 builder.addIgnorable(name); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         result.add(property); [EOL]     } [EOL]     return result; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException { [EOL]     if (ctxt.canOverrideAccessModifiers()) { [EOL]         setter.fixAccess(); [EOL]     } [EOL]     JavaType type = beanDesc.bindingsForBeanType().resolveType(setter.getGenericParameterType(1)); [EOL]     BeanProperty.Std property = new BeanProperty.Std(setter.getName(), type, null, beanDesc.getClassAnnotations(), setter, false); [EOL]     type = resolveType(ctxt, beanDesc, type, setter); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter); [EOL]     if (deser != null) { [EOL]         return new SettableAnyProperty(property, setter, type, deser); [EOL]     } [EOL]     type = modifyTypeByAnnotation(ctxt, setter, type); [EOL]     return new SettableAnyProperty(property, setter, type, null); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException { [EOL]     AnnotatedMember mutator = propDef.getMutator(); [EOL]     if (ctxt.canOverrideAccessModifiers()) { [EOL]         mutator.fixAccess(); [EOL]     } [EOL]     JavaType t0 = beanDesc.resolveType(jdkType); [EOL]     BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.isRequired()); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, mutator); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator); [EOL]     type = modifyTypeByAnnotation(ctxt, mutator, type); [EOL]     TypeDeserializer typeDeser = type.getTypeHandler(); [EOL]     SettableBeanProperty prop; [EOL]     if (mutator instanceof AnnotatedMethod) { [EOL]         prop = new MethodProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator); [EOL]     } else { [EOL]         prop = new FieldProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedField) mutator); [EOL]     } [EOL]     if (propDeser != null) { [EOL]         prop = prop.withValueDeserializer(propDeser); [EOL]     } [EOL]     AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType(); [EOL]     if (ref != null && ref.isManagedReference()) { [EOL]         prop.setManagedReferenceName(ref.getName()); [EOL]     } [EOL]     return prop; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public SimpleFilterProvider setFailOnUnknownId(boolean state) { [EOL]     _cfgFailOnUnknownId = state; [EOL]     return this; [EOL] }
public SimpleFilterProvider setFailOnUnknownId(boolean state) { [EOL]     _cfgFailOnUnknownId = state; [EOL]     return this; [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return (_member == null) ? null : _member.getAnnotation(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return (_member == null) ? null : _member.getAnnotation(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return (_member == null) ? null : _member.getAnnotation(acls); [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     return _wrapperName; [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     return _wrapperName; [EOL] }
@Override [EOL] public boolean isRequired() { [EOL]     return _isRequired; [EOL] }
@Override [EOL] public AnnotatedMember getMember() { [EOL]     return _member; [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value.toString()); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value.toString()); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected ObjectIdWriter(JavaType t, SerializedString propName, ObjectIdGenerator<?> gen, JsonSerializer<?> ser, boolean alwaysAsId) { [EOL]     idType = t; [EOL]     propertyName = propName; [EOL]     generator = gen; [EOL]     serializer = (JsonSerializer<Object>) ser; [EOL]     this.alwaysAsId = alwaysAsId; [EOL] }
public static ObjectIdWriter construct(JavaType idType, String propName, ObjectIdGenerator<?> generator, boolean alwaysAsId) { [EOL]     SerializedString serName = (propName == null) ? null : new SerializedString(propName); [EOL]     return new ObjectIdWriter(idType, serName, generator, null, alwaysAsId); [EOL] }
public static ObjectIdWriter construct(JavaType idType, String propName, ObjectIdGenerator<?> generator, boolean alwaysAsId) { [EOL]     SerializedString serName = (propName == null) ? null : new SerializedString(propName); [EOL]     return new ObjectIdWriter(idType, serName, generator, null, alwaysAsId); [EOL] }
public ObjectIdWriter withSerializer(JsonSerializer<?> ser) { [EOL]     return new ObjectIdWriter(idType, propertyName, generator, ser, alwaysAsId); [EOL] }
public ObjectIdWriter withSerializer(JsonSerializer<?> ser) { [EOL]     return new ObjectIdWriter(idType, propertyName, generator, ser, alwaysAsId); [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config, BeanDescription beanDesc, boolean staticTyping) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     String clsName = raw.getName(); [EOL]     JsonSerializer<?> ser = _concrete.get(clsName); [EOL]     if (ser == null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName); [EOL]         if (serClass != null) { [EOL]             try { [EOL]                 return serClass.newInstance(); [EOL]             } catch (Exception e) { [EOL]                 throw new IllegalStateException("Failed to instantiate standard serializer (of type " + serClass.getName() + "): " + e.getMessage(), e); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (JsonSerializable.class.isAssignableFrom(raw)) { [EOL]         return SerializableSerializer.instance; [EOL]     } [EOL]     AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); [EOL]     if (valueMethod != null) { [EOL]         Method m = valueMethod.getAnnotated(); [EOL]         if (prov.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); [EOL]         return new JsonValueSerializer(m, ser); [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (JsonSerializable.class.isAssignableFrom(raw)) { [EOL]         return SerializableSerializer.instance; [EOL]     } [EOL]     AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); [EOL]     if (valueMethod != null) { [EOL]         Method m = valueMethod.getAnnotated(); [EOL]         if (prov.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); [EOL]         return new JsonValueSerializer(m, ser); [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (JsonSerializable.class.isAssignableFrom(raw)) { [EOL]         return SerializableSerializer.instance; [EOL]     } [EOL]     AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); [EOL]     if (valueMethod != null) { [EOL]         Method m = valueMethod.getAnnotated(); [EOL]         if (prov.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); [EOL]         return new JsonValueSerializer(m, ser); [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     Object serDef = prov.getAnnotationIntrospector().findSerializer(a); [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); [EOL]     return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     Object serDef = prov.getAnnotationIntrospector().findSerializer(a); [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<Object> ser = prov.serializerInstance(a, serDef); [EOL]     return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser); [EOL] }
protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { [EOL]     Converter<Object, Object> conv = findConverter(prov, a); [EOL]     if (conv == null) { [EOL]         return ser; [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, ser); [EOL] }
protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov, Annotated a, JsonSerializer<?> ser) throws JsonMappingException { [EOL]     Converter<Object, Object> conv = findConverter(prov, a); [EOL]     if (conv == null) { [EOL]         return ser; [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, ser); [EOL] }
protected Converter<Object, Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); [EOL]     if (convDef == null) { [EOL]         return null; [EOL]     } [EOL]     return prov.converterInstance(a, convDef); [EOL] }
protected Converter<Object, Object> findConverter(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a); [EOL]     if (convDef == null) { [EOL]         return null; [EOL]     } [EOL]     return prov.converterInstance(a, convDef); [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected boolean isIndexedList(Class<?> cls) { [EOL]     return RandomAccess.class.isAssignableFrom(cls); [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL]             JavaType keyType = type.getKeyType(); [EOL]             EnumValues enums = null; [EOL]             if (keyType.isEnumType()) { [EOL]                 @SuppressWarnings("unchecked") [EOL]                 Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL]                 enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL]             } [EOL]             ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL]         } else { [EOL]             ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]             if (String[].class == raw) { [EOL]                 ser = StringArraySerializer.instance; [EOL]             } else { [EOL]                 ser = StdArraySerializers.findStandardImpl(raw); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyArraySerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iterableSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iterableSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL]     Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); [EOL]     if (superclass != null) { [EOL]         try { [EOL]             type = (T) type.widenBy(superclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new IllegalArgumentException("Failed to widen type " + type + " with concrete-type annotation (value " + superclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage()); [EOL]         } [EOL]     } [EOL]     return modifySecondaryTypesByAnnotation(config, a, type); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapType)) { [EOL]                 throw new IllegalArgumentException("Illegal key-type annotation: type " + type + " is not a Map type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapType) type).widenKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage()); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.widenContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapType)) { [EOL]                 throw new IllegalArgumentException("Illegal key-type annotation: type " + type + " is not a Map type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapType) type).widenKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage()); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.widenContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapType)) { [EOL]                 throw new IllegalArgumentException("Illegal key-type annotation: type " + type + " is not a Map type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapType) type).widenKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage()); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.widenContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapType)) { [EOL]                 throw new IllegalArgumentException("Illegal key-type annotation: type " + type + " is not a Map type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapType) type).widenKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage()); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findSerializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.widenContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new IllegalArgumentException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = prov.getAnnotationIntrospector(); [EOL]     Object serDef = intr.findContentSerializer(a); [EOL]     if (serDef != null) { [EOL]         return prov.serializerInstance(a, serDef); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = prov.getAnnotationIntrospector(); [EOL]     Object serDef = intr.findContentSerializer(a); [EOL]     if (serDef != null) { [EOL]         return prov.serializerInstance(a, serDef); [EOL]     } [EOL]     return null; [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc, TypeSerializer typeSer) { [EOL]     if (typeSer != null) { [EOL]         return false; [EOL]     } [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo()); [EOL]     if (t != null) { [EOL]         return (t == JsonSerialize.Typing.STATIC); [EOL]     } [EOL]     return config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL] }
protected AnnotatedMember(AnnotationMap annotations) { [EOL]     super(); [EOL]     _annotations = annotations; [EOL] }
protected AnnotatedMember(AnnotationMap annotations) { [EOL]     super(); [EOL]     _annotations = annotations; [EOL] }
@Override [EOL] protected AnnotationMap getAllAnnotations() { [EOL]     return _annotations; [EOL] }
public final void addIfNotPresent(Annotation a) { [EOL]     _annotations.addIfNotPresent(a); [EOL] }
public final void addIfNotPresent(Annotation a) { [EOL]     _annotations.addIfNotPresent(a); [EOL] }
public final void fixAccess() { [EOL]     ClassUtil.checkAndFixAccess(getMember()); [EOL] }
public final void fixAccess() { [EOL]     ClassUtil.checkAndFixAccess(getMember()); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonMappingException { [EOL]     if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) { [EOL]         failForEmpty(value); [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonMappingException { [EOL]     if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) { [EOL]         failForEmpty(value); [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public final void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) { [EOL]         failForEmpty(value); [EOL]     } [EOL]     typeSer.writeTypePrefixForObject(value, jgen); [EOL]     typeSer.writeTypeSuffixForObject(value, jgen); [EOL] }
@Override [EOL] public final void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) { [EOL]         failForEmpty(value); [EOL]     } [EOL]     typeSer.writeTypePrefixForObject(value, jgen); [EOL]     typeSer.writeTypeSuffixForObject(value, jgen); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations.get(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations.get(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations.get(acls); [EOL] }
public Annotations getAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations; [EOL] }
public Annotations getAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations; [EOL] }
public AnnotatedConstructor getDefaultConstructor() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _defaultConstructor; [EOL] }
public AnnotatedConstructor getDefaultConstructor() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _defaultConstructor; [EOL] }
public List<AnnotatedConstructor> getConstructors() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _constructors; [EOL] }
public List<AnnotatedConstructor> getConstructors() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _constructors; [EOL] }
public List<AnnotatedMethod> getStaticMethods() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _creatorMethods; [EOL] }
public List<AnnotatedMethod> getStaticMethods() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _creatorMethods; [EOL] }
public Iterable<AnnotatedMethod> memberMethods() { [EOL]     if (_memberMethods == null) { [EOL]         resolveMemberMethods(); [EOL]     } [EOL]     return _memberMethods; [EOL] }
public Iterable<AnnotatedMethod> memberMethods() { [EOL]     if (_memberMethods == null) { [EOL]         resolveMemberMethods(); [EOL]     } [EOL]     return _memberMethods; [EOL] }
public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     if (_memberMethods == null) { [EOL]         resolveMemberMethods(); [EOL]     } [EOL]     return _memberMethods.find(name, paramTypes); [EOL] }
public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     if (_memberMethods == null) { [EOL]         resolveMemberMethods(); [EOL]     } [EOL]     return _memberMethods.find(name, paramTypes); [EOL] }
public Iterable<AnnotatedField> fields() { [EOL]     if (_fields == null) { [EOL]         resolveFields(); [EOL]     } [EOL]     return _fields; [EOL] }
public Iterable<AnnotatedField> fields() { [EOL]     if (_fields == null) { [EOL]         resolveFields(); [EOL]     } [EOL]     return _fields; [EOL] }
private void resolveClassAnnotations() { [EOL]     _classAnnotations = new AnnotationMap(); [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_primaryMixIn != null) { [EOL]             _addClassMixIns(_classAnnotations, _class, _primaryMixIn); [EOL]         } [EOL]         _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations()); [EOL]         for (Class<?> cls : _superTypes) { [EOL]             _addClassMixIns(_classAnnotations, cls); [EOL]             _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations()); [EOL]         } [EOL]         _addClassMixIns(_classAnnotations, Object.class); [EOL]     } [EOL] }
private void resolveClassAnnotations() { [EOL]     _classAnnotations = new AnnotationMap(); [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_primaryMixIn != null) { [EOL]             _addClassMixIns(_classAnnotations, _class, _primaryMixIn); [EOL]         } [EOL]         _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations()); [EOL]         for (Class<?> cls : _superTypes) { [EOL]             _addClassMixIns(_classAnnotations, cls); [EOL]             _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations()); [EOL]         } [EOL]         _addClassMixIns(_classAnnotations, Object.class); [EOL]     } [EOL] }
private void resolveClassAnnotations() { [EOL]     _classAnnotations = new AnnotationMap(); [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_primaryMixIn != null) { [EOL]             _addClassMixIns(_classAnnotations, _class, _primaryMixIn); [EOL]         } [EOL]         _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations()); [EOL]         for (Class<?> cls : _superTypes) { [EOL]             _addClassMixIns(_classAnnotations, cls); [EOL]             _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations()); [EOL]         } [EOL]         _addClassMixIns(_classAnnotations, Object.class); [EOL]     } [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask) { [EOL]     if (_mixInResolver != null) { [EOL]         _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask)); [EOL]     } [EOL] }
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) { [EOL]     if (mixin == null) { [EOL]         return; [EOL]     } [EOL]     _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations()); [EOL]     for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) { [EOL]         _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations()); [EOL]     } [EOL] }
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) { [EOL]     if (mixin == null) { [EOL]         return; [EOL]     } [EOL]     _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations()); [EOL]     for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) { [EOL]         _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations()); [EOL]     } [EOL] }
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) { [EOL]     if (mixin == null) { [EOL]         return; [EOL]     } [EOL]     _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations()); [EOL]     for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) { [EOL]         _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations()); [EOL]     } [EOL] }
protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     if (mixInCls != null) { [EOL]         _addMethodMixIns(cls, methods, mixInCls, mixIns); [EOL]     } [EOL]     if (cls == null) { [EOL]         return; [EOL]     } [EOL]     for (Method m : cls.getDeclaredMethods()) { [EOL]         if (!_isIncludableMemberMethod(m)) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedMethod old = methods.find(m); [EOL]         if (old == null) { [EOL]             AnnotatedMethod newM = _constructMethod(m); [EOL]             methods.add(newM); [EOL]             old = mixIns.remove(m); [EOL]             if (old != null) { [EOL]                 _addMixOvers(old.getAnnotated(), newM, false); [EOL]             } [EOL]         } else { [EOL]             _addMixUnders(m, old); [EOL]             if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) { [EOL]                 methods.add(old.withMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] }
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] }
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] }
protected AnnotatedMethod _constructMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), null); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null); [EOL] }
protected AnnotatedMethod _constructMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), null); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedMethod _constructCreatorMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length)); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), _collectRelevantAnnotations(m.getParameterAnnotations())); [EOL] }
protected AnnotatedMethod _constructCreatorMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length)); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), _collectRelevantAnnotations(m.getParameterAnnotations())); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
private boolean _isIncludableField(Field f) { [EOL]     if (f.isSynthetic()) { [EOL]         return false; [EOL]     } [EOL]     int mods = f.getModifiers(); [EOL]     if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean _isIncludableField(Field f) { [EOL]     if (f.isSynthetic()) { [EOL]         return false; [EOL]     } [EOL]     int mods = f.getModifiers(); [EOL]     if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns) { [EOL]     int len = anns.length; [EOL]     AnnotationMap[] result = new AnnotationMap[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         result[i] = _collectRelevantAnnotations(anns[i]); [EOL]     } [EOL]     return result; [EOL] }
protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns) { [EOL]     int len = anns.length; [EOL]     AnnotationMap[] result = new AnnotationMap[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         result[i] = _collectRelevantAnnotations(anns[i]); [EOL]     } [EOL]     return result; [EOL] }
protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns) { [EOL]     int len = anns.length; [EOL]     AnnotationMap[] result = new AnnotationMap[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         result[i] = _collectRelevantAnnotations(anns[i]); [EOL]     } [EOL]     return result; [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public String toString() { [EOL]     return "[AnnotedClass " + _class.getName() + "]"; [EOL] }
protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     _baseType = baseType; [EOL]     _idResolver = idRes; [EOL]     _typePropertyName = typePropertyName; [EOL]     _typeIdVisible = typeIdVisible; [EOL]     _deserializers = new HashMap<String, JsonDeserializer<Object>>(); [EOL]     if (defaultImpl == null) { [EOL]         _defaultImpl = null; [EOL]     } else { [EOL]         _defaultImpl = baseType.forcedNarrowBy(defaultImpl); [EOL]     } [EOL]     _property = null; [EOL] }
protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     _baseType = baseType; [EOL]     _idResolver = idRes; [EOL]     _typePropertyName = typePropertyName; [EOL]     _typeIdVisible = typeIdVisible; [EOL]     _deserializers = new HashMap<String, JsonDeserializer<Object>>(); [EOL]     if (defaultImpl == null) { [EOL]         _defaultImpl = null; [EOL]     } else { [EOL]         _defaultImpl = baseType.forcedNarrowBy(defaultImpl); [EOL]     } [EOL]     _property = null; [EOL] }
protected TypeDeserializerBase(TypeDeserializerBase src, BeanProperty property) { [EOL]     _baseType = src._baseType; [EOL]     _idResolver = src._idResolver; [EOL]     _typePropertyName = src._typePropertyName; [EOL]     _typeIdVisible = src._typeIdVisible; [EOL]     _deserializers = src._deserializers; [EOL]     _defaultImpl = src._defaultImpl; [EOL]     _defaultImplDeserializer = src._defaultImplDeserializer; [EOL]     _property = property; [EOL] }
@Override [EOL] public final String getPropertyName() { [EOL]     return _typePropertyName; [EOL] }
@Override [EOL] public final String getPropertyName() { [EOL]     return _typePropertyName; [EOL] }
protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     synchronized (_deserializers) { [EOL]         deser = _deserializers.get(typeId); [EOL]         if (deser == null) { [EOL]             JavaType type = _idResolver.typeFromId(typeId); [EOL]             if (type == null) { [EOL]                 if (_defaultImpl == null) { [EOL]                     throw ctxt.unknownTypeException(_baseType, typeId); [EOL]                 } [EOL]                 deser = _findDefaultImplDeserializer(ctxt); [EOL]             } else { [EOL]                 if (_baseType != null && _baseType.getClass() == type.getClass()) { [EOL]                     type = _baseType.narrowBy(type.getRawClass()); [EOL]                 } [EOL]                 deser = ctxt.findContextualValueDeserializer(type, _property); [EOL]             } [EOL]             _deserializers.put(typeId, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config, Class<?> enumClass, AnnotatedMethod factory) { [EOL]     Class<?> paramClass = factory.getRawParameterType(0); [EOL]     if (paramClass == String.class) { [EOL]         paramClass = null; [EOL]     } else if (paramClass == Integer.TYPE || paramClass == Integer.class) { [EOL]         paramClass = Integer.class; [EOL]     } else if (paramClass == Long.TYPE || paramClass == Long.class) { [EOL]         paramClass = Long.class; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String or int/Integer/long/Long"); [EOL]     } [EOL]     if (config.canOverrideAccessModifiers()) { [EOL]         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]     } [EOL]     return new FactoryBasedDeserializer(enumClass, factory, paramClass); [EOL] }
public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config, Class<?> enumClass, AnnotatedMethod factory) { [EOL]     Class<?> paramClass = factory.getRawParameterType(0); [EOL]     if (paramClass == String.class) { [EOL]         paramClass = null; [EOL]     } else if (paramClass == Integer.TYPE || paramClass == Integer.class) { [EOL]         paramClass = Integer.class; [EOL]     } else if (paramClass == Long.TYPE || paramClass == Long.class) { [EOL]         paramClass = Long.class; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String or int/Integer/long/Long"); [EOL]     } [EOL]     if (config.canOverrideAccessModifiers()) { [EOL]         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]     } [EOL]     return new FactoryBasedDeserializer(enumClass, factory, paramClass); [EOL] }
public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config, Class<?> enumClass, AnnotatedMethod factory) { [EOL]     Class<?> paramClass = factory.getRawParameterType(0); [EOL]     if (paramClass == String.class) { [EOL]         paramClass = null; [EOL]     } else if (paramClass == Integer.TYPE || paramClass == Integer.class) { [EOL]         paramClass = Integer.class; [EOL]     } else if (paramClass == Long.TYPE || paramClass == Long.class) { [EOL]         paramClass = Long.class; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String or int/Integer/long/Long"); [EOL]     } [EOL]     if (config.canOverrideAccessModifiers()) { [EOL]         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]     } [EOL]     return new FactoryBasedDeserializer(enumClass, factory, paramClass); [EOL] }
public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config, Class<?> enumClass, AnnotatedMethod factory) { [EOL]     Class<?> paramClass = factory.getRawParameterType(0); [EOL]     if (paramClass == String.class) { [EOL]         paramClass = null; [EOL]     } else if (paramClass == Integer.TYPE || paramClass == Integer.class) { [EOL]         paramClass = Integer.class; [EOL]     } else if (paramClass == Long.TYPE || paramClass == Long.class) { [EOL]         paramClass = Long.class; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String or int/Integer/long/Long"); [EOL]     } [EOL]     if (config.canOverrideAccessModifiers()) { [EOL]         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]     } [EOL]     return new FactoryBasedDeserializer(enumClass, factory, paramClass); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f, Class<?> inputType) { [EOL]     super(Enum.class); [EOL]     _enumClass = cls; [EOL]     _factory = f.getAnnotated(); [EOL]     _inputType = inputType; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
public BasicClassIntrospector() { [EOL] }
@Override [EOL] public BasicBeanDescription forSerialization(SerializationConfig cfg, JavaType type, MixInResolver r) { [EOL]     BasicBeanDescription desc = _findCachedDesc(type); [EOL]     if (desc == null) { [EOL]         desc = BasicBeanDescription.forSerialization(collectProperties(cfg, type, r, true, "set")); [EOL]     } [EOL]     return desc; [EOL] }
@Override [EOL] public BasicBeanDescription forSerialization(SerializationConfig cfg, JavaType type, MixInResolver r) { [EOL]     BasicBeanDescription desc = _findCachedDesc(type); [EOL]     if (desc == null) { [EOL]         desc = BasicBeanDescription.forSerialization(collectProperties(cfg, type, r, true, "set")); [EOL]     } [EOL]     return desc; [EOL] }
@Override [EOL] public BasicBeanDescription forCreation(DeserializationConfig cfg, JavaType type, MixInResolver r) { [EOL]     BasicBeanDescription desc = _findCachedDesc(type); [EOL]     if (desc == null) { [EOL]         desc = BasicBeanDescription.forDeserialization(collectProperties(cfg, type, r, false, "set")); [EOL]     } [EOL]     return desc; [EOL] }
@Override [EOL] public BasicBeanDescription forCreation(DeserializationConfig cfg, JavaType type, MixInResolver r) { [EOL]     BasicBeanDescription desc = _findCachedDesc(type); [EOL]     if (desc == null) { [EOL]         desc = BasicBeanDescription.forDeserialization(collectProperties(cfg, type, r, false, "set")); [EOL]     } [EOL]     return desc; [EOL] }
@Override [EOL] public BasicBeanDescription forClassAnnotations(MapperConfig<?> cfg, JavaType type, MixInResolver r) { [EOL]     boolean useAnnotations = cfg.isAnnotationProcessingEnabled(); [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? cfg.getAnnotationIntrospector() : null), r); [EOL]     return BasicBeanDescription.forOtherUse(cfg, type, ac); [EOL] }
@Override [EOL] public BasicBeanDescription forClassAnnotations(MapperConfig<?> cfg, JavaType type, MixInResolver r) { [EOL]     boolean useAnnotations = cfg.isAnnotationProcessingEnabled(); [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? cfg.getAnnotationIntrospector() : null), r); [EOL]     return BasicBeanDescription.forOtherUse(cfg, type, ac); [EOL] }
protected POJOPropertiesCollector collectProperties(MapperConfig<?> config, JavaType type, MixInResolver r, boolean forSerialization, String mutatorPrefix) { [EOL]     boolean useAnnotations = config.isAnnotationProcessingEnabled(); [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? config.getAnnotationIntrospector() : null), r); [EOL]     return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect(); [EOL] }
protected POJOPropertiesCollector collectProperties(MapperConfig<?> config, JavaType type, MixInResolver r, boolean forSerialization, String mutatorPrefix) { [EOL]     boolean useAnnotations = config.isAnnotationProcessingEnabled(); [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? config.getAnnotationIntrospector() : null), r); [EOL]     return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect(); [EOL] }
protected POJOPropertiesCollector collectProperties(MapperConfig<?> config, JavaType type, MixInResolver r, boolean forSerialization, String mutatorPrefix) { [EOL]     boolean useAnnotations = config.isAnnotationProcessingEnabled(); [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? config.getAnnotationIntrospector() : null), r); [EOL]     return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect(); [EOL] }
protected POJOPropertiesCollector collectProperties(MapperConfig<?> config, JavaType type, MixInResolver r, boolean forSerialization, String mutatorPrefix) { [EOL]     boolean useAnnotations = config.isAnnotationProcessingEnabled(); [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? config.getAnnotationIntrospector() : null), r); [EOL]     return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect(); [EOL] }
protected POJOPropertiesCollector constructPropertyCollector(MapperConfig<?> config, AnnotatedClass ac, JavaType type, boolean forSerialization, String mutatorPrefix) { [EOL]     return new POJOPropertiesCollector(config, forSerialization, type, ac, mutatorPrefix); [EOL] }
protected POJOPropertiesCollector constructPropertyCollector(MapperConfig<?> config, AnnotatedClass ac, JavaType type, boolean forSerialization, String mutatorPrefix) { [EOL]     return new POJOPropertiesCollector(config, forSerialization, type, ac, mutatorPrefix); [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) { [EOL]     super(baseType, typeFactory); [EOL] }
public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) { [EOL]     super(baseType, typeFactory); [EOL] }
public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) { [EOL]     super(baseType, typeFactory); [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     return _idFrom(value, value.getClass()); [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     return _idFrom(value, value.getClass()); [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.indexOf('<') > 0) { [EOL]         JavaType t = _typeFactory.constructFromCanonical(id); [EOL]         return t; [EOL]     } [EOL]     try { [EOL]         Class<?> cls = ClassUtil.findClass(id); [EOL]         return _typeFactory.constructSpecializedType(_baseType, cls); [EOL]     } catch (ClassNotFoundException e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): no such class found"); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.indexOf('<') > 0) { [EOL]         JavaType t = _typeFactory.constructFromCanonical(id); [EOL]         return t; [EOL]     } [EOL]     try { [EOL]         Class<?> cls = ClassUtil.findClass(id); [EOL]         return _typeFactory.constructSpecializedType(_baseType, cls); [EOL]     } catch (ClassNotFoundException e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): no such class found"); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.indexOf('<') > 0) { [EOL]         JavaType t = _typeFactory.constructFromCanonical(id); [EOL]         return t; [EOL]     } [EOL]     try { [EOL]         Class<?> cls = ClassUtil.findClass(id); [EOL]         return _typeFactory.constructSpecializedType(_baseType, cls); [EOL]     } catch (ClassNotFoundException e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): no such class found"); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): " + e.getMessage(), e); [EOL]     } [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
public PropertyBuilder(SerializationConfig config, BeanDescription beanDesc) { [EOL]     _config = config; [EOL]     _beanDesc = beanDesc; [EOL]     _outputProps = beanDesc.findSerializationInclusion(config.getSerializationInclusion()); [EOL]     _annotationIntrospector = _config.getAnnotationIntrospector(); [EOL] }
public Annotations getClassAnnotations() { [EOL]     return _beanDesc.getClassAnnotations(); [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) { [EOL]     Class<?> serClass = _annotationIntrospector.findSerializationType(a); [EOL]     if (serClass != null) { [EOL]         Class<?> rawDeclared = declaredType.getRawClass(); [EOL]         if (serClass.isAssignableFrom(rawDeclared)) { [EOL]             declaredType = declaredType.widenBy(serClass); [EOL]         } else { [EOL]             if (!rawDeclared.isAssignableFrom(serClass)) { [EOL]                 throw new IllegalArgumentException("Illegal concrete-type annotation for method '" + a.getName() + "': class " + serClass.getName() + " not a super-type of (declared) class " + rawDeclared.getName()); [EOL]             } [EOL]             declaredType = _config.constructSpecializedType(declaredType, serClass); [EOL]         } [EOL]         useStaticTyping = true; [EOL]     } [EOL]     JavaType secondary = BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType); [EOL]     if (secondary != declaredType) { [EOL]         useStaticTyping = true; [EOL]         declaredType = secondary; [EOL]     } [EOL]     if (!useStaticTyping) { [EOL]         JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a); [EOL]         if (typing != null) { [EOL]             useStaticTyping = (typing == JsonSerialize.Typing.STATIC); [EOL]         } [EOL]     } [EOL]     return useStaticTyping ? declaredType : null; [EOL] }
protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) { [EOL]     Class<?> serClass = _annotationIntrospector.findSerializationType(a); [EOL]     if (serClass != null) { [EOL]         Class<?> rawDeclared = declaredType.getRawClass(); [EOL]         if (serClass.isAssignableFrom(rawDeclared)) { [EOL]             declaredType = declaredType.widenBy(serClass); [EOL]         } else { [EOL]             if (!rawDeclared.isAssignableFrom(serClass)) { [EOL]                 throw new IllegalArgumentException("Illegal concrete-type annotation for method '" + a.getName() + "': class " + serClass.getName() + " not a super-type of (declared) class " + rawDeclared.getName()); [EOL]             } [EOL]             declaredType = _config.constructSpecializedType(declaredType, serClass); [EOL]         } [EOL]         useStaticTyping = true; [EOL]     } [EOL]     JavaType secondary = BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType); [EOL]     if (secondary != declaredType) { [EOL]         useStaticTyping = true; [EOL]         declaredType = secondary; [EOL]     } [EOL]     if (!useStaticTyping) { [EOL]         JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a); [EOL]         if (typing != null) { [EOL]             useStaticTyping = (typing == JsonSerialize.Typing.STATIC); [EOL]         } [EOL]     } [EOL]     return useStaticTyping ? declaredType : null; [EOL] }
protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) { [EOL]     Class<?> serClass = _annotationIntrospector.findSerializationType(a); [EOL]     if (serClass != null) { [EOL]         Class<?> rawDeclared = declaredType.getRawClass(); [EOL]         if (serClass.isAssignableFrom(rawDeclared)) { [EOL]             declaredType = declaredType.widenBy(serClass); [EOL]         } else { [EOL]             if (!rawDeclared.isAssignableFrom(serClass)) { [EOL]                 throw new IllegalArgumentException("Illegal concrete-type annotation for method '" + a.getName() + "': class " + serClass.getName() + " not a super-type of (declared) class " + rawDeclared.getName()); [EOL]             } [EOL]             declaredType = _config.constructSpecializedType(declaredType, serClass); [EOL]         } [EOL]         useStaticTyping = true; [EOL]     } [EOL]     JavaType secondary = BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType); [EOL]     if (secondary != declaredType) { [EOL]         useStaticTyping = true; [EOL]         declaredType = secondary; [EOL]     } [EOL]     if (!useStaticTyping) { [EOL]         JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a); [EOL]         if (typing != null) { [EOL]             useStaticTyping = (typing == JsonSerialize.Typing.STATIC); [EOL]         } [EOL]     } [EOL]     return useStaticTyping ? declaredType : null; [EOL] }
protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) { [EOL]     Class<?> serClass = _annotationIntrospector.findSerializationType(a); [EOL]     if (serClass != null) { [EOL]         Class<?> rawDeclared = declaredType.getRawClass(); [EOL]         if (serClass.isAssignableFrom(rawDeclared)) { [EOL]             declaredType = declaredType.widenBy(serClass); [EOL]         } else { [EOL]             if (!rawDeclared.isAssignableFrom(serClass)) { [EOL]                 throw new IllegalArgumentException("Illegal concrete-type annotation for method '" + a.getName() + "': class " + serClass.getName() + " not a super-type of (declared) class " + rawDeclared.getName()); [EOL]             } [EOL]             declaredType = _config.constructSpecializedType(declaredType, serClass); [EOL]         } [EOL]         useStaticTyping = true; [EOL]     } [EOL]     JavaType secondary = BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType); [EOL]     if (secondary != declaredType) { [EOL]         useStaticTyping = true; [EOL]         declaredType = secondary; [EOL]     } [EOL]     if (!useStaticTyping) { [EOL]         JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a); [EOL]         if (typing != null) { [EOL]             useStaticTyping = (typing == JsonSerialize.Typing.STATIC); [EOL]         } [EOL]     } [EOL]     return useStaticTyping ? declaredType : null; [EOL] }
protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) { [EOL]     Class<?> serClass = _annotationIntrospector.findSerializationType(a); [EOL]     if (serClass != null) { [EOL]         Class<?> rawDeclared = declaredType.getRawClass(); [EOL]         if (serClass.isAssignableFrom(rawDeclared)) { [EOL]             declaredType = declaredType.widenBy(serClass); [EOL]         } else { [EOL]             if (!rawDeclared.isAssignableFrom(serClass)) { [EOL]                 throw new IllegalArgumentException("Illegal concrete-type annotation for method '" + a.getName() + "': class " + serClass.getName() + " not a super-type of (declared) class " + rawDeclared.getName()); [EOL]             } [EOL]             declaredType = _config.constructSpecializedType(declaredType, serClass); [EOL]         } [EOL]         useStaticTyping = true; [EOL]     } [EOL]     JavaType secondary = BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType); [EOL]     if (secondary != declaredType) { [EOL]         useStaticTyping = true; [EOL]         declaredType = secondary; [EOL]     } [EOL]     if (!useStaticTyping) { [EOL]         JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a); [EOL]         if (typing != null) { [EOL]             useStaticTyping = (typing == JsonSerialize.Typing.STATIC); [EOL]         } [EOL]     } [EOL]     return useStaticTyping ? declaredType : null; [EOL] }
protected Object getDefaultBean() { [EOL]     if (_defaultBean == null) { [EOL]         _defaultBean = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers()); [EOL]         if (_defaultBean == null) { [EOL]             Class<?> cls = _beanDesc.getClassInfo().getAnnotated(); [EOL]             throw new IllegalArgumentException("Class " + cls.getName() + " has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation"); [EOL]         } [EOL]     } [EOL]     return _defaultBean; [EOL] }
protected Object getDefaultBean() { [EOL]     if (_defaultBean == null) { [EOL]         _defaultBean = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers()); [EOL]         if (_defaultBean == null) { [EOL]             Class<?> cls = _beanDesc.getClassInfo().getAnnotated(); [EOL]             throw new IllegalArgumentException("Class " + cls.getName() + " has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation"); [EOL]         } [EOL]     } [EOL]     return _defaultBean; [EOL] }
protected Object getDefaultBean() { [EOL]     if (_defaultBean == null) { [EOL]         _defaultBean = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers()); [EOL]         if (_defaultBean == null) { [EOL]             Class<?> cls = _beanDesc.getClassInfo().getAnnotated(); [EOL]             throw new IllegalArgumentException("Class " + cls.getName() + " has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation"); [EOL]         } [EOL]     } [EOL]     return _defaultBean; [EOL] }
protected Object getDefaultBean() { [EOL]     if (_defaultBean == null) { [EOL]         _defaultBean = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers()); [EOL]         if (_defaultBean == null) { [EOL]             Class<?> cls = _beanDesc.getClassInfo().getAnnotated(); [EOL]             throw new IllegalArgumentException("Class " + cls.getName() + " has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation"); [EOL]         } [EOL]     } [EOL]     return _defaultBean; [EOL] }
protected Object getDefaultValue(String name, AnnotatedMember member) { [EOL]     Object defaultBean = getDefaultBean(); [EOL]     try { [EOL]         return member.getValue(defaultBean); [EOL]     } catch (Exception e) { [EOL]         return _throwWrapped(e, name, defaultBean); [EOL]     } [EOL] }
protected Object getDefaultValue(String name, AnnotatedMember member) { [EOL]     Object defaultBean = getDefaultBean(); [EOL]     try { [EOL]         return member.getValue(defaultBean); [EOL]     } catch (Exception e) { [EOL]         return _throwWrapped(e, name, defaultBean); [EOL]     } [EOL] }
public BaseSettings(ClassIntrospector ci, AnnotationIntrospector ai, VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf, TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi, Locale locale, TimeZone tz, Base64Variant defaultBase64) { [EOL]     _classIntrospector = ci; [EOL]     _annotationIntrospector = ai; [EOL]     _visibilityChecker = vc; [EOL]     _propertyNamingStrategy = pns; [EOL]     _typeFactory = tf; [EOL]     _typeResolverBuilder = typer; [EOL]     _dateFormat = dateFormat; [EOL]     _handlerInstantiator = hi; [EOL]     _locale = locale; [EOL]     _timeZone = tz; [EOL]     _defaultBase64 = defaultBase64; [EOL] }
public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]     if (_annotationIntrospector == ai) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]     if (_annotationIntrospector == ai) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns) { [EOL]     if (_propertyNamingStrategy == pns) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns) { [EOL]     if (_propertyNamingStrategy == pns) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer) { [EOL]     if (_typeResolverBuilder == typer) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, typer, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer) { [EOL]     if (_typeResolverBuilder == typer) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, typer, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) { [EOL]     if (_handlerInstantiator == hi) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, hi, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) { [EOL]     if (_handlerInstantiator == hi) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, hi, _locale, _timeZone, _defaultBase64); [EOL] }
public ClassIntrospector getClassIntrospector() { [EOL]     return _classIntrospector; [EOL] }
public AnnotationIntrospector getAnnotationIntrospector() { [EOL]     return _annotationIntrospector; [EOL] }
public VisibilityChecker<?> getVisibilityChecker() { [EOL]     return _visibilityChecker; [EOL] }
public PropertyNamingStrategy getPropertyNamingStrategy() { [EOL]     return _propertyNamingStrategy; [EOL] }
public TypeFactory getTypeFactory() { [EOL]     return _typeFactory; [EOL] }
public TypeResolverBuilder<?> getTypeResolverBuilder() { [EOL]     return _typeResolverBuilder; [EOL] }
public HandlerInstantiator getHandlerInstantiator() { [EOL]     return _handlerInstantiator; [EOL] }
public HandlerInstantiator getHandlerInstantiator() { [EOL]     return _handlerInstantiator; [EOL] }
public BooleanBuilder getBooleanBuilder() { [EOL]     if (_booleanBuilder == null) { [EOL]         _booleanBuilder = new BooleanBuilder(); [EOL]     } [EOL]     return _booleanBuilder; [EOL] }
public BooleanBuilder getBooleanBuilder() { [EOL]     if (_booleanBuilder == null) { [EOL]         _booleanBuilder = new BooleanBuilder(); [EOL]     } [EOL]     return _booleanBuilder; [EOL] }
public BooleanBuilder() { [EOL] }
@Override [EOL] public final boolean[] _constructArray(int len) { [EOL]     return new boolean[len]; [EOL] }
@Override [EOL] public final boolean[] _constructArray(int len) { [EOL]     return new boolean[len]; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> Iterable<T> arrayAsIterable(T[] array) { [EOL]     return new ArrayIterator<T>(array); [EOL] }
public ArrayIterator(T[] array) { [EOL]     _array = array; [EOL]     _index = 0; [EOL] }
public ArrayIterator(T[] array) { [EOL]     _array = array; [EOL]     _index = 0; [EOL] }
public ArrayIterator(T[] array) { [EOL]     _array = array; [EOL]     _index = 0; [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     return _index < _array.length; [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     return _index < _array.length; [EOL] }
@Override [EOL] public T next() { [EOL]     if (_index >= _array.length) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     return _array[_index++]; [EOL] }
@Override [EOL] public T next() { [EOL]     if (_index >= _array.length) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     return _array[_index++]; [EOL] }
@Override [EOL] public Iterator<T> iterator() { [EOL]     return this; [EOL] }
public DeserializerFactoryConfig() { [EOL]     this(null, null, null, null, null); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig() { [EOL]     this(null, null, null, null, null); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig() { [EOL]     this(null, null, null, null, null); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig() { [EOL]     this(null, null, null, null, null); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig() { [EOL]     this(null, null, null, null, null); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig() { [EOL]     this(null, null, null, null, null); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi) { [EOL]     _additionalDeserializers = (allAdditionalDeserializers == null) ? NO_DESERIALIZERS : allAdditionalDeserializers; [EOL]     _additionalKeyDeserializers = (allAdditionalKeyDeserializers == null) ? DEFAULT_KEY_DESERIALIZERS : allAdditionalKeyDeserializers; [EOL]     _modifiers = (modifiers == null) ? NO_MODIFIERS : modifiers; [EOL]     _abstractTypeResolvers = (atr == null) ? NO_ABSTRACT_TYPE_RESOLVERS : atr; [EOL]     _valueInstantiators = (vi == null) ? NO_VALUE_INSTANTIATORS : vi; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi) { [EOL]     _additionalDeserializers = (allAdditionalDeserializers == null) ? NO_DESERIALIZERS : allAdditionalDeserializers; [EOL]     _additionalKeyDeserializers = (allAdditionalKeyDeserializers == null) ? DEFAULT_KEY_DESERIALIZERS : allAdditionalKeyDeserializers; [EOL]     _modifiers = (modifiers == null) ? NO_MODIFIERS : modifiers; [EOL]     _abstractTypeResolvers = (atr == null) ? NO_ABSTRACT_TYPE_RESOLVERS : atr; [EOL]     _valueInstantiators = (vi == null) ? NO_VALUE_INSTANTIATORS : vi; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional) { [EOL]     if (additional == null) { [EOL]         throw new IllegalArgumentException("Can not pass null KeyDeserializers"); [EOL]     } [EOL]     KeyDeserializers[] all = ArrayBuilders.insertInListNoDup(_additionalKeyDeserializers, additional); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, all, _modifiers, _abstractTypeResolvers, _valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional) { [EOL]     if (additional == null) { [EOL]         throw new IllegalArgumentException("Can not pass null KeyDeserializers"); [EOL]     } [EOL]     KeyDeserializers[] all = ArrayBuilders.insertInListNoDup(_additionalKeyDeserializers, additional); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, all, _modifiers, _abstractTypeResolvers, _valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators) { [EOL]     if (instantiators == null) { [EOL]         throw new IllegalArgumentException("Can not pass null resolver"); [EOL]     } [EOL]     ValueInstantiators[] all = ArrayBuilders.insertInListNoDup(_valueInstantiators, instantiators); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, _additionalKeyDeserializers, _modifiers, _abstractTypeResolvers, all); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators) { [EOL]     if (instantiators == null) { [EOL]         throw new IllegalArgumentException("Can not pass null resolver"); [EOL]     } [EOL]     ValueInstantiators[] all = ArrayBuilders.insertInListNoDup(_valueInstantiators, instantiators); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, _additionalKeyDeserializers, _modifiers, _abstractTypeResolvers, all); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasKeyDeserializers() { [EOL]     return _additionalKeyDeserializers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasKeyDeserializers() { [EOL]     return _additionalKeyDeserializers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<KeyDeserializers> keyDeserializers() { [EOL]     return ArrayBuilders.arrayAsIterable(_additionalKeyDeserializers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<KeyDeserializers> keyDeserializers() { [EOL]     return ArrayBuilders.arrayAsIterable(_additionalKeyDeserializers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<ValueInstantiators> valueInstantiators() { [EOL]     return ArrayBuilders.arrayAsIterable(_valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<ValueInstantiators> valueInstantiators() { [EOL]     return ArrayBuilders.arrayAsIterable(_valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<ValueInstantiators> valueInstantiators() { [EOL]     return ArrayBuilders.arrayAsIterable(_valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<ValueInstantiators> valueInstantiators() { [EOL]     return ArrayBuilders.arrayAsIterable(_valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<ValueInstantiators> valueInstantiators() { [EOL]     return ArrayBuilders.arrayAsIterable(_valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
protected TypeIdResolverBase(JavaType baseType, TypeFactory typeFactory) { [EOL]     _baseType = baseType; [EOL]     _typeFactory = typeFactory; [EOL] }
protected TypeIdResolverBase(JavaType baseType, TypeFactory typeFactory) { [EOL]     _baseType = baseType; [EOL]     _typeFactory = typeFactory; [EOL] }
protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties) { [EOL]     super(type); [EOL]     _props = properties; [EOL]     _filteredProps = filteredProperties; [EOL]     if (builder == null) { [EOL]         _typeId = null; [EOL]         _anyGetterWriter = null; [EOL]         _propertyFilterId = null; [EOL]         _objectIdWriter = null; [EOL]         _serializationShape = null; [EOL]     } else { [EOL]         _typeId = builder.getTypeId(); [EOL]         _anyGetterWriter = builder.getAnyGetter(); [EOL]         _propertyFilterId = builder.getFilterId(); [EOL]         _objectIdWriter = builder.getObjectIdWriter(); [EOL]         JsonFormat.Value format = builder.getBeanDescription().findExpectedFormat(null); [EOL]         _serializationShape = (format == null) ? null : format.getShape(); [EOL]     } [EOL] }
protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties) { [EOL]     super(type); [EOL]     _props = properties; [EOL]     _filteredProps = filteredProperties; [EOL]     if (builder == null) { [EOL]         _typeId = null; [EOL]         _anyGetterWriter = null; [EOL]         _propertyFilterId = null; [EOL]         _objectIdWriter = null; [EOL]         _serializationShape = null; [EOL]     } else { [EOL]         _typeId = builder.getTypeId(); [EOL]         _anyGetterWriter = builder.getAnyGetter(); [EOL]         _propertyFilterId = builder.getFilterId(); [EOL]         _objectIdWriter = builder.getObjectIdWriter(); [EOL]         JsonFormat.Value format = builder.getBeanDescription().findExpectedFormat(null); [EOL]         _serializationShape = (format == null) ? null : format.getShape(); [EOL]     } [EOL] }
protected BeanSerializerBase(BeanSerializerBase src, ObjectIdWriter objectIdWriter) { [EOL]     super(src._handledType); [EOL]     _props = src._props; [EOL]     _filteredProps = src._filteredProps; [EOL]     _typeId = src._typeId; [EOL]     _anyGetterWriter = src._anyGetterWriter; [EOL]     _objectIdWriter = objectIdWriter; [EOL]     _propertyFilterId = src._propertyFilterId; [EOL]     _serializationShape = src._serializationShape; [EOL] }
protected BeanSerializerBase(BeanSerializerBase src, ObjectIdWriter objectIdWriter) { [EOL]     super(src._handledType); [EOL]     _props = src._props; [EOL]     _filteredProps = src._filteredProps; [EOL]     _typeId = src._typeId; [EOL]     _anyGetterWriter = src._anyGetterWriter; [EOL]     _objectIdWriter = objectIdWriter; [EOL]     _propertyFilterId = src._propertyFilterId; [EOL]     _serializationShape = src._serializationShape; [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length; [EOL]     for (int i = 0, len = _props.length; i < len; ++i) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) { [EOL]             JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop); [EOL]             if (nullSer != null) { [EOL]                 prop.assignNullSerializer(nullSer); [EOL]                 if (i < filteredCount) { [EOL]                     BeanPropertyWriter w2 = _filteredProps[i]; [EOL]                     if (w2 != null) { [EOL]                         w2.assignNullSerializer(nullSer); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (prop.hasSerializer()) { [EOL]             continue; [EOL]         } [EOL]         JsonSerializer<Object> ser = findConvertingSerializer(provider, prop); [EOL]         if (ser == null) { [EOL]             JavaType type = prop.getSerializationType(); [EOL]             if (type == null) { [EOL]                 type = provider.constructType(prop.getGenericPropertyType()); [EOL]                 if (!type.isFinal()) { [EOL]                     if (type.isContainerType() || type.containedTypeCount() > 0) { [EOL]                         prop.setNonTrivialBaseType(type); [EOL]                     } [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             ser = provider.findValueSerializer(type, prop); [EOL]             if (type.isContainerType()) { [EOL]                 TypeSerializer typeSer = type.getContentType().getTypeHandler(); [EOL]                 if (typeSer != null) { [EOL]                     if (ser instanceof ContainerSerializer<?>) { [EOL]                         @SuppressWarnings("unchecked") [EOL]                         JsonSerializer<Object> ser2 = (JsonSerializer<Object>) ((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer); [EOL]                         ser = ser2; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop.assignSerializer(ser); [EOL]         if (i < filteredCount) { [EOL]             BeanPropertyWriter w2 = _filteredProps[i]; [EOL]             if (w2 != null) { [EOL]                 w2.assignSerializer(ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anyGetterWriter != null) { [EOL]         _anyGetterWriter.resolve(provider); [EOL]     } [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length; [EOL]     for (int i = 0, len = _props.length; i < len; ++i) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (!prop.willSuppressNulls() && !prop.hasNullSerializer()) { [EOL]             JsonSerializer<Object> nullSer = provider.findNullValueSerializer(prop); [EOL]             if (nullSer != null) { [EOL]                 prop.assignNullSerializer(nullSer); [EOL]                 if (i < filteredCount) { [EOL]                     BeanPropertyWriter w2 = _filteredProps[i]; [EOL]                     if (w2 != null) { [EOL]                         w2.assignNullSerializer(nullSer); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (prop.hasSerializer()) { [EOL]             continue; [EOL]         } [EOL]         JsonSerializer<Object> ser = findConvertingSerializer(provider, prop); [EOL]         if (ser == null) { [EOL]             JavaType type = prop.getSerializationType(); [EOL]             if (type == null) { [EOL]                 type = provider.constructType(prop.getGenericPropertyType()); [EOL]                 if (!type.isFinal()) { [EOL]                     if (type.isContainerType() || type.containedTypeCount() > 0) { [EOL]                         prop.setNonTrivialBaseType(type); [EOL]                     } [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             ser = provider.findValueSerializer(type, prop); [EOL]             if (type.isContainerType()) { [EOL]                 TypeSerializer typeSer = type.getContentType().getTypeHandler(); [EOL]                 if (typeSer != null) { [EOL]                     if (ser instanceof ContainerSerializer<?>) { [EOL]                         @SuppressWarnings("unchecked") [EOL]                         JsonSerializer<Object> ser2 = (JsonSerializer<Object>) ((ContainerSerializer<?>) ser).withValueTypeSerializer(typeSer); [EOL]                         ser = ser2; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop.assignSerializer(ser); [EOL]         if (i < filteredCount) { [EOL]             BeanPropertyWriter w2 = _filteredProps[i]; [EOL]             if (w2 != null) { [EOL]                 w2.assignSerializer(ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anyGetterWriter != null) { [EOL]         _anyGetterWriter.resolve(provider); [EOL]     } [EOL] }
protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findSerializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); [EOL]             return new StdDelegatingSerializer(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findSerializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); [EOL]             return new StdDelegatingSerializer(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findSerializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); [EOL]             return new StdDelegatingSerializer(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public boolean usesObjectId() { [EOL]     return (_objectIdWriter != null); [EOL] }
@Override [EOL] public boolean usesObjectId() { [EOL]     return (_objectIdWriter != null); [EOL] }
protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 prop.serializeAsField(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 prop.serializeAsField(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 prop.serializeAsField(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 prop.serializeAsField(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 prop.serializeAsField(bean, jgen, provider); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException { [EOL]     final Object filterId = _propertyFilterId; [EOL]     FilterProvider filters = provider.getFilterProvider(); [EOL]     if (filters == null) { [EOL]         throw new JsonMappingException("Can not resolve BeanPropertyFilter with id '" + filterId + "'; no FilterProvider configured"); [EOL]     } [EOL]     BeanPropertyFilter filter = filters.findFilter(filterId); [EOL]     return filter; [EOL] }
protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException { [EOL]     final Object filterId = _propertyFilterId; [EOL]     FilterProvider filters = provider.getFilterProvider(); [EOL]     if (filters == null) { [EOL]         throw new JsonMappingException("Can not resolve BeanPropertyFilter with id '" + filterId + "'; no FilterProvider configured"); [EOL]     } [EOL]     BeanPropertyFilter filter = filters.findFilter(filterId); [EOL]     return filter; [EOL] }
public static BeanPropertyWriter constructViewBased(BeanPropertyWriter base, Class<?>[] viewsToIncludeIn) { [EOL]     if (viewsToIncludeIn.length == 1) { [EOL]         return new SingleView(base, viewsToIncludeIn[0]); [EOL]     } [EOL]     return new MultiView(base, viewsToIncludeIn); [EOL] }
public static BeanPropertyWriter constructViewBased(BeanPropertyWriter base, Class<?>[] viewsToIncludeIn) { [EOL]     if (viewsToIncludeIn.length == 1) { [EOL]         return new SingleView(base, viewsToIncludeIn[0]); [EOL]     } [EOL]     return new MultiView(base, viewsToIncludeIn); [EOL] }
protected MultiView(BeanPropertyWriter delegate, Class<?>[] views) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _views = views; [EOL] }
protected MultiView(BeanPropertyWriter delegate, Class<?>[] views) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _views = views; [EOL] }
protected MultiView(BeanPropertyWriter delegate, Class<?>[] views) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _views = views; [EOL] }
@Override [EOL] public void assignSerializer(JsonSerializer<Object> ser) { [EOL]     _delegate.assignSerializer(ser); [EOL] }
@Override [EOL] public void assignSerializer(JsonSerializer<Object> ser) { [EOL]     _delegate.assignSerializer(ser); [EOL] }
@Override [EOL] public void assignNullSerializer(JsonSerializer<Object> nullSer) { [EOL]     _delegate.assignNullSerializer(nullSer); [EOL] }
@Override [EOL] public void assignNullSerializer(JsonSerializer<Object> nullSer) { [EOL]     _delegate.assignNullSerializer(nullSer); [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     final Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView != null) { [EOL]         int i = 0, len = _views.length; [EOL]         for (; i < len; ++i) { [EOL]             if (_views[i].isAssignableFrom(activeView)) [EOL]                 break; [EOL]         } [EOL]         if (i == len) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     _delegate.serializeAsField(bean, jgen, prov); [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     final Class<?> activeView = prov.getActiveView(); [EOL]     if (activeView != null) { [EOL]         int i = 0, len = _views.length; [EOL]         for (; i < len; ++i) { [EOL]             if (_views[i].isAssignableFrom(activeView)) [EOL]                 break; [EOL]         } [EOL]         if (i == len) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     _delegate.serializeAsField(bean, jgen, prov); [EOL] }
public AnnotatedMember getAnyGetter() { [EOL]     if (_anyGetters != null) { [EOL]         if (_anyGetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-getters' defined (" + _anyGetters.get(0) + " vs " + _anyGetters.get(1) + ")"); [EOL]         } [EOL]         return _anyGetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMember getAnyGetter() { [EOL]     if (_anyGetters != null) { [EOL]         if (_anyGetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-getters' defined (" + _anyGetters.get(0) + " vs " + _anyGetters.get(1) + ")"); [EOL]         } [EOL]         return _anyGetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMember getAnyGetter() { [EOL]     if (_anyGetters != null) { [EOL]         if (_anyGetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-getters' defined (" + _anyGetters.get(0) + " vs " + _anyGetters.get(1) + ")"); [EOL]         } [EOL]         return _anyGetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMember getAnyGetter() { [EOL]     if (_anyGetters != null) { [EOL]         if (_anyGetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-getters' defined (" + _anyGetters.get(0) + " vs " + _anyGetters.get(1) + ")"); [EOL]         } [EOL]         return _anyGetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getAnySetterMethod() { [EOL]     if (_anySetters != null) { [EOL]         if (_anySetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-setters' defined (" + _anySetters.get(0) + " vs " + _anySetters.get(1) + ")"); [EOL]         } [EOL]         return _anySetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getAnySetterMethod() { [EOL]     if (_anySetters != null) { [EOL]         if (_anySetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-setters' defined (" + _anySetters.get(0) + " vs " + _anySetters.get(1) + ")"); [EOL]         } [EOL]         return _anySetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getAnySetterMethod() { [EOL]     if (_anySetters != null) { [EOL]         if (_anySetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-setters' defined (" + _anySetters.get(0) + " vs " + _anySetters.get(1) + ")"); [EOL]         } [EOL]         return _anySetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public POJOPropertiesCollector collect() { [EOL]     _properties.clear(); [EOL]     _addFields(); [EOL]     _addMethods(); [EOL]     _addCreators(); [EOL]     _addInjectables(); [EOL]     _removeUnwantedProperties(); [EOL]     _renameProperties(); [EOL]     PropertyNamingStrategy naming = _findNamingStrategy(); [EOL]     if (naming != null) { [EOL]         _renameUsing(naming); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.trimByVisibility(); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.mergeAnnotations(_forSerialization); [EOL]     } [EOL]     if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) { [EOL]         _renameWithWrappers(); [EOL]     } [EOL]     _sortProperties(); [EOL]     return this; [EOL] }
public POJOPropertiesCollector collect() { [EOL]     _properties.clear(); [EOL]     _addFields(); [EOL]     _addMethods(); [EOL]     _addCreators(); [EOL]     _addInjectables(); [EOL]     _removeUnwantedProperties(); [EOL]     _renameProperties(); [EOL]     PropertyNamingStrategy naming = _findNamingStrategy(); [EOL]     if (naming != null) { [EOL]         _renameUsing(naming); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.trimByVisibility(); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.mergeAnnotations(_forSerialization); [EOL]     } [EOL]     if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) { [EOL]         _renameWithWrappers(); [EOL]     } [EOL]     _sortProperties(); [EOL]     return this; [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethods() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         int argCount = m.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             _addGetterMethod(m, ai); [EOL]         } else if (argCount == 1) { [EOL]             _addSetterMethod(m, ai); [EOL]         } else if (argCount == 2) { [EOL]             if (ai != null && ai.hasAnySetterAnnotation(m)) { [EOL]                 if (_anySetters == null) { [EOL]                     _anySetters = new LinkedList<AnnotatedMethod>(); [EOL]                 } [EOL]                 _anySetters.add(m); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethods() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         int argCount = m.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             _addGetterMethod(m, ai); [EOL]         } else if (argCount == 1) { [EOL]             _addSetterMethod(m, ai); [EOL]         } else if (argCount == 2) { [EOL]             if (ai != null && ai.hasAnySetterAnnotation(m)) { [EOL]                 if (_anySetters == null) { [EOL]                     _anySetters = new LinkedList<AnnotatedMethod>(); [EOL]                 } [EOL]                 _anySetters.add(m); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethods() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         int argCount = m.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             _addGetterMethod(m, ai); [EOL]         } else if (argCount == 1) { [EOL]             _addSetterMethod(m, ai); [EOL]         } else if (argCount == 2) { [EOL]             if (ai != null && ai.hasAnySetterAnnotation(m)) { [EOL]                 if (_anySetters == null) { [EOL]                     _anySetters = new LinkedList<AnnotatedMethod>(); [EOL]                 } [EOL]                 _anySetters.add(m); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethods() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         int argCount = m.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             _addGetterMethod(m, ai); [EOL]         } else if (argCount == 1) { [EOL]             _addSetterMethod(m, ai); [EOL]         } else if (argCount == 2) { [EOL]             if (ai != null && ai.hasAnySetterAnnotation(m)) { [EOL]                 if (_anySetters == null) { [EOL]                     _anySetters = new LinkedList<AnnotatedMethod>(); [EOL]                 } [EOL]                 _anySetters.add(m); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _doAddInjectable(Object id, AnnotatedMember m) { [EOL]     if (id == null) { [EOL]         return; [EOL]     } [EOL]     if (_injectables == null) { [EOL]         _injectables = new LinkedHashMap<Object, AnnotatedMember>(); [EOL]     } [EOL]     AnnotatedMember prev = _injectables.put(id, m); [EOL]     if (prev != null) { [EOL]         String type = (id == null) ? "[null]" : id.getClass().getName(); [EOL]         throw new IllegalArgumentException("Duplicate injectable value with id '" + String.valueOf(id) + "' (of type " + type + ")"); [EOL]     } [EOL] }
protected void _doAddInjectable(Object id, AnnotatedMember m) { [EOL]     if (id == null) { [EOL]         return; [EOL]     } [EOL]     if (_injectables == null) { [EOL]         _injectables = new LinkedHashMap<Object, AnnotatedMember>(); [EOL]     } [EOL]     AnnotatedMember prev = _injectables.put(id, m); [EOL]     if (prev != null) { [EOL]         String type = (id == null) ? "[null]" : id.getClass().getName(); [EOL]         throw new IllegalArgumentException("Duplicate injectable value with id '" + String.valueOf(id) + "' (of type " + type + ")"); [EOL]     } [EOL] }
protected void _doAddInjectable(Object id, AnnotatedMember m) { [EOL]     if (id == null) { [EOL]         return; [EOL]     } [EOL]     if (_injectables == null) { [EOL]         _injectables = new LinkedHashMap<Object, AnnotatedMember>(); [EOL]     } [EOL]     AnnotatedMember prev = _injectables.put(id, m); [EOL]     if (prev != null) { [EOL]         String type = (id == null) ? "[null]" : id.getClass().getName(); [EOL]         throw new IllegalArgumentException("Duplicate injectable value with id '" + String.valueOf(id) + "' (of type " + type + ")"); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
private void _addIgnored(String name) { [EOL]     if (!_forSerialization) { [EOL]         if (_ignoredPropertyNames == null) { [EOL]             _ignoredPropertyNames = new HashSet<String>(); [EOL]         } [EOL]         _ignoredPropertyNames.add(name); [EOL]     } [EOL] }
private void _addIgnored(String name) { [EOL]     if (!_forSerialization) { [EOL]         if (_ignoredPropertyNames == null) { [EOL]             _ignoredPropertyNames = new HashSet<String>(); [EOL]         } [EOL]         _ignoredPropertyNames.add(name); [EOL]     } [EOL] }
private void _addIgnored(String name) { [EOL]     if (!_forSerialization) { [EOL]         if (_ignoredPropertyNames == null) { [EOL]             _ignoredPropertyNames = new HashSet<String>(); [EOL]         } [EOL]         _ignoredPropertyNames.add(name); [EOL]     } [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void reportProblem(String msg) { [EOL]     throw new IllegalArgumentException("Problem with definition of " + _classDef + ": " + msg); [EOL] }
protected EnumResolver(Class<T> enumClass, T[] enums, HashMap<String, T> map) { [EOL]     _enumClass = enumClass; [EOL]     _enums = enums; [EOL]     _enumsById = map; [EOL] }
protected EnumResolver(Class<T> enumClass, T[] enums, HashMap<String, T> map) { [EOL]     _enumClass = enumClass; [EOL]     _enums = enums; [EOL]     _enumsById = map; [EOL] }
public static <ET extends Enum<ET>> EnumResolver<ET> constructFor(Class<ET> enumCls, AnnotationIntrospector ai) { [EOL]     ET[] enumValues = enumCls.getEnumConstants(); [EOL]     if (enumValues == null) { [EOL]         throw new IllegalArgumentException("No enum constants for class " + enumCls.getName()); [EOL]     } [EOL]     HashMap<String, ET> map = new HashMap<String, ET>(); [EOL]     for (ET e : enumValues) { [EOL]         map.put(ai.findEnumValue(e), e); [EOL]     } [EOL]     return new EnumResolver<ET>(enumCls, enumValues, map); [EOL] }
public static <ET extends Enum<ET>> EnumResolver<ET> constructFor(Class<ET> enumCls, AnnotationIntrospector ai) { [EOL]     ET[] enumValues = enumCls.getEnumConstants(); [EOL]     if (enumValues == null) { [EOL]         throw new IllegalArgumentException("No enum constants for class " + enumCls.getName()); [EOL]     } [EOL]     HashMap<String, ET> map = new HashMap<String, ET>(); [EOL]     for (ET e : enumValues) { [EOL]         map.put(ai.findEnumValue(e), e); [EOL]     } [EOL]     return new EnumResolver<ET>(enumCls, enumValues, map); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public static EnumResolver<?> constructUnsafe(Class<?> rawEnumCls, AnnotationIntrospector ai) { [EOL]     Class<Enum> enumCls = (Class<Enum>) rawEnumCls; [EOL]     return constructFor(enumCls, ai); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public static EnumResolver<?> constructUnsafe(Class<?> rawEnumCls, AnnotationIntrospector ai) { [EOL]     Class<Enum> enumCls = (Class<Enum>) rawEnumCls; [EOL]     return constructFor(enumCls, ai); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public static EnumResolver<?> constructUnsafe(Class<?> rawEnumCls, AnnotationIntrospector ai) { [EOL]     Class<Enum> enumCls = (Class<Enum>) rawEnumCls; [EOL]     return constructFor(enumCls, ai); [EOL] }
public T findEnum(String key) { [EOL]     return _enumsById.get(key); [EOL] }
public AbstractDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, Map<String, SettableBeanProperty> backRefProps) { [EOL]     _baseType = beanDesc.getType(); [EOL]     _objectIdReader = builder.getObjectIdReader(); [EOL]     _backRefProperties = backRefProps; [EOL]     Class<?> cls = _baseType.getRawClass(); [EOL]     _acceptString = cls.isAssignableFrom(String.class); [EOL]     _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class); [EOL]     _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class); [EOL]     _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class); [EOL] }
public AbstractDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, Map<String, SettableBeanProperty> backRefProps) { [EOL]     _baseType = beanDesc.getType(); [EOL]     _objectIdReader = builder.getObjectIdReader(); [EOL]     _backRefProperties = backRefProps; [EOL]     Class<?> cls = _baseType.getRawClass(); [EOL]     _acceptString = cls.isAssignableFrom(String.class); [EOL]     _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class); [EOL]     _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class); [EOL]     _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class); [EOL] }
public AbstractDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, Map<String, SettableBeanProperty> backRefProps) { [EOL]     _baseType = beanDesc.getType(); [EOL]     _objectIdReader = builder.getObjectIdReader(); [EOL]     _backRefProperties = backRefProps; [EOL]     Class<?> cls = _baseType.getRawClass(); [EOL]     _acceptString = cls.isAssignableFrom(String.class); [EOL]     _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class); [EOL]     _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class); [EOL]     _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class); [EOL] }
public AbstractDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, Map<String, SettableBeanProperty> backRefProps) { [EOL]     _baseType = beanDesc.getType(); [EOL]     _objectIdReader = builder.getObjectIdReader(); [EOL]     _backRefProperties = backRefProps; [EOL]     Class<?> cls = _baseType.getRawClass(); [EOL]     _acceptString = cls.isAssignableFrom(String.class); [EOL]     _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class); [EOL]     _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class); [EOL]     _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class); [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return _deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     Object result = _deserializeIfNatural(jp, ctxt); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return _deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     Object result = _deserializeIfNatural(jp, ctxt); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return _deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     Object result = _deserializeIfNatural(jp, ctxt); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     throw ctxt.instantiationException(_baseType.getRawClass(), "abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
public SetterlessProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedMethod method) { [EOL]     super(propDef, type, typeDeser, contextAnnotations); [EOL]     _annotated = method; [EOL]     _getter = method.getAnnotated(); [EOL] }
protected SetterlessProperty(SetterlessProperty src, JsonDeserializer<?> deser) { [EOL]     super(src, deser); [EOL]     _annotated = src._annotated; [EOL]     _getter = src._getter; [EOL] }
@Override [EOL] public SetterlessProperty withValueDeserializer(JsonDeserializer<?> deser) { [EOL]     return new SetterlessProperty(this, deser); [EOL] }
@Override [EOL] public SetterlessProperty withValueDeserializer(JsonDeserializer<?> deser) { [EOL]     return new SetterlessProperty(this, deser); [EOL] }
@Override [EOL] public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return; [EOL]     } [EOL]     Object toModify; [EOL]     try { [EOL]         toModify = _getter.invoke(instance); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e); [EOL]         return; [EOL]     } [EOL]     if (toModify == null) { [EOL]         throw new JsonMappingException("Problem deserializing 'setterless' property '" + getName() + "': get method returned null"); [EOL]     } [EOL]     _valueDeserializer.deserialize(jp, ctxt, toModify); [EOL] }
@Override [EOL] public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return; [EOL]     } [EOL]     Object toModify; [EOL]     try { [EOL]         toModify = _getter.invoke(instance); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e); [EOL]         return; [EOL]     } [EOL]     if (toModify == null) { [EOL]         throw new JsonMappingException("Problem deserializing 'setterless' property '" + getName() + "': get method returned null"); [EOL]     } [EOL]     _valueDeserializer.deserialize(jp, ctxt, toModify); [EOL] }
@Override [EOL] public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return; [EOL]     } [EOL]     Object toModify; [EOL]     try { [EOL]         toModify = _getter.invoke(instance); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e); [EOL]         return; [EOL]     } [EOL]     if (toModify == null) { [EOL]         throw new JsonMappingException("Problem deserializing 'setterless' property '" + getName() + "': get method returned null"); [EOL]     } [EOL]     _valueDeserializer.deserialize(jp, ctxt, toModify); [EOL] }
@Override [EOL] public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return; [EOL]     } [EOL]     Object toModify; [EOL]     try { [EOL]         toModify = _getter.invoke(instance); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e); [EOL]         return; [EOL]     } [EOL]     if (toModify == null) { [EOL]         throw new JsonMappingException("Problem deserializing 'setterless' property '" + getName() + "': get method returned null"); [EOL]     } [EOL]     _valueDeserializer.deserialize(jp, ctxt, toModify); [EOL] }
public ObjectReader with(DeserializationFeature feature) { [EOL]     return _with(_config.with(feature)); [EOL] }
public ObjectReader with(DeserializationFeature feature) { [EOL]     return _with(_config.with(feature)); [EOL] }
public ObjectReader withRootName(String rootName) { [EOL]     return _with(_config.withRootName(rootName)); [EOL] }
public ObjectReader withRootName(String rootName) { [EOL]     return _with(_config.withRootName(rootName)); [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser == null) { [EOL]         try { [EOL]             DeserializationContext ctxt = createDeserializationContext(null, _config); [EOL]             deser = ctxt.findRootValueDeserializer(valueType); [EOL]             if (deser != null) { [EOL]                 _rootDeserializers.put(valueType, deser); [EOL]             } [EOL]             return deser; [EOL]         } catch (JsonProcessingException e) { [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser == null) { [EOL]         try { [EOL]             DeserializationContext ctxt = createDeserializationContext(null, _config); [EOL]             deser = ctxt.findRootValueDeserializer(valueType); [EOL]             if (deser != null) { [EOL]                 _rootDeserializers.put(valueType, deser); [EOL]             } [EOL]             return deser; [EOL]         } catch (JsonProcessingException e) { [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser == null) { [EOL]         try { [EOL]             DeserializationContext ctxt = createDeserializationContext(null, _config); [EOL]             deser = ctxt.findRootValueDeserializer(valueType); [EOL]             if (deser != null) { [EOL]                 _rootDeserializers.put(valueType, deser); [EOL]             } [EOL]             return deser; [EOL]         } catch (JsonProcessingException e) { [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser == null) { [EOL]         try { [EOL]             DeserializationContext ctxt = createDeserializationContext(null, _config); [EOL]             deser = ctxt.findRootValueDeserializer(valueType); [EOL]             if (deser != null) { [EOL]                 _rootDeserializers.put(valueType, deser); [EOL]             } [EOL]             return deser; [EOL]         } catch (JsonProcessingException e) { [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser == null) { [EOL]         try { [EOL]             DeserializationContext ctxt = createDeserializationContext(null, _config); [EOL]             deser = ctxt.findRootValueDeserializer(valueType); [EOL]             if (deser != null) { [EOL]                 _rootDeserializers.put(valueType, deser); [EOL]             } [EOL]             return deser; [EOL]         } catch (JsonProcessingException e) { [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = _config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, _config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result; [EOL]     if (_valueToUpdate == null) { [EOL]         result = deser.deserialize(jp, ctxt); [EOL]     } else { [EOL]         deser.deserialize(jp, ctxt, _valueToUpdate); [EOL]         result = _valueToUpdate; [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = _config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, _config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result; [EOL]     if (_valueToUpdate == null) { [EOL]         result = deser.deserialize(jp, ctxt); [EOL]     } else { [EOL]         deser.deserialize(jp, ctxt, _valueToUpdate); [EOL]         result = _valueToUpdate; [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = _config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, _config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result; [EOL]     if (_valueToUpdate == null) { [EOL]         result = deser.deserialize(jp, ctxt); [EOL]     } else { [EOL]         deser.deserialize(jp, ctxt, _valueToUpdate); [EOL]         result = _valueToUpdate; [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = _config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, _config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result; [EOL]     if (_valueToUpdate == null) { [EOL]         result = deser.deserialize(jp, ctxt); [EOL]     } else { [EOL]         deser.deserialize(jp, ctxt, _valueToUpdate); [EOL]         result = _valueToUpdate; [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = _config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, _config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result; [EOL]     if (_valueToUpdate == null) { [EOL]         result = deser.deserialize(jp, ctxt); [EOL]     } else { [EOL]         deser.deserialize(jp, ctxt, _valueToUpdate); [EOL]         result = _valueToUpdate; [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
public PropertyName(String simpleName) { [EOL]     this(simpleName, null); [EOL] }
public PropertyName(String simpleName, String namespace) { [EOL]     _simpleName = (simpleName == null) ? "" : simpleName; [EOL]     _namespace = namespace; [EOL] }
public PropertyName(String simpleName, String namespace) { [EOL]     _simpleName = (simpleName == null) ? "" : simpleName; [EOL]     _namespace = namespace; [EOL] }
public PropertyName(String simpleName, String namespace) { [EOL]     _simpleName = (simpleName == null) ? "" : simpleName; [EOL]     _namespace = namespace; [EOL] }
public PropertyName(String simpleName, String namespace) { [EOL]     _simpleName = (simpleName == null) ? "" : simpleName; [EOL]     _namespace = namespace; [EOL] }
public String getSimpleName() { [EOL]     return _simpleName; [EOL] }
public String getSimpleName() { [EOL]     return _simpleName; [EOL] }
public boolean hasSimpleName() { [EOL]     return _simpleName.length() > 0; [EOL] }
public boolean hasSimpleName() { [EOL]     return _simpleName.length() > 0; [EOL] }
protected CollectionLikeType(Class<?> collT, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(collT, elemT.hashCode(), valueHandler, typeHandler, asStatic); [EOL]     _elementType = elemT; [EOL] }
protected CollectionLikeType(Class<?> collT, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(collT, elemT.hashCode(), valueHandler, typeHandler, asStatic); [EOL]     _elementType = elemT; [EOL] }
protected CollectionLikeType(Class<?> collT, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(collT, elemT.hashCode(), valueHandler, typeHandler, asStatic); [EOL]     _elementType = elemT; [EOL] }
protected CollectionLikeType(Class<?> collT, JavaType elemT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(collT, elemT.hashCode(), valueHandler, typeHandler, asStatic); [EOL]     _elementType = elemT; [EOL] }
@Override [EOL] public boolean isCollectionLikeType() { [EOL]     return true; [EOL] }
@Override [EOL] public JavaType getContentType() { [EOL]     return _elementType; [EOL] }
@Override [EOL] public JavaType getContentType() { [EOL]     return _elementType; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     return (index == 0) ? _elementType : null; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     return (index == 0) ? _elementType : null; [EOL] }
public boolean isTrueCollectionType() { [EOL]     return Collection.class.isAssignableFrom(_class); [EOL] }
public boolean isTrueCollectionType() { [EOL]     return Collection.class.isAssignableFrom(_class); [EOL] }
protected TypeBase(Class<?> raw, int hash, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(raw, hash, valueHandler, typeHandler, asStatic); [EOL] }
public ObjectWriter withRootName(String rootName) { [EOL]     SerializationConfig newConfig = _config.withRootName(rootName); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public ObjectWriter withRootName(String rootName) { [EOL]     SerializationConfig newConfig = _config.withRootName(rootName); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public ObjectWriter withRootName(String rootName) { [EOL]     SerializationConfig newConfig = _config.withRootName(rootName); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configAndWriteValue(_jsonFactory.createGenerator(w), value); [EOL] }
public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configAndWriteValue(_jsonFactory.createGenerator(w), value); [EOL] }
public void writeValue(Writer w, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configAndWriteValue(_jsonFactory.createGenerator(w), value); [EOL] }
@Override [EOL] public JsonNode path(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.get(index); [EOL]     } [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public JsonNode path(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.get(index); [EOL]     } [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public JsonNode path(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.get(index); [EOL]     } [EOL]     return MissingNode.getInstance(); [EOL] }
public ArrayNode addNull() { [EOL]     _add(nullNode()); [EOL]     return this; [EOL] }
public ArrayNode insertNull(int index) { [EOL]     _insert(index, nullNode()); [EOL]     return this; [EOL] }
public ArrayNode insertNull(int index) { [EOL]     _insert(index, nullNode()); [EOL]     return this; [EOL] }
public ArrayNode insertNull(int index) { [EOL]     _insert(index, nullNode()); [EOL]     return this; [EOL] }
public DeserializerCache() { [EOL] }
public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType); [EOL]     if (deser == null) { [EOL]         deser = _handleUnknownValueDeserializer(propertyType); [EOL]     } [EOL]     return deser; [EOL] }
public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType); [EOL]     if (deser == null) { [EOL]         deser = _handleUnknownValueDeserializer(propertyType); [EOL]     } [EOL]     return deser; [EOL] }
public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType); [EOL]     if (deser == null) { [EOL]         deser = _handleUnknownValueDeserializer(propertyType); [EOL]     } [EOL]     return deser; [EOL] }
public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type); [EOL]     if (kd == null) { [EOL]         return _handleUnknownKeyDeserializer(type); [EOL]     } [EOL]     if (kd instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) kd).resolve(ctxt); [EOL]     } [EOL]     return kd; [EOL] }
public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type); [EOL]     if (kd == null) { [EOL]         return _handleUnknownKeyDeserializer(type); [EOL]     } [EOL]     if (kd instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) kd).resolve(ctxt); [EOL]     } [EOL]     return kd; [EOL] }
public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type); [EOL]     if (kd == null) { [EOL]         return _handleUnknownKeyDeserializer(type); [EOL]     } [EOL]     if (kd instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) kd).resolve(ctxt); [EOL]     } [EOL]     return kd; [EOL] }
public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]     if (deser == null) { [EOL]         try { [EOL]             deser = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL]         } catch (Exception e) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return (deser != null); [EOL] }
public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]     if (deser == null) { [EOL]         try { [EOL]             deser = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL]         } catch (Exception e) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return (deser != null); [EOL] }
public boolean hasValueDeserializerFor(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]     if (deser == null) { [EOL]         try { [EOL]             deser = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL]         } catch (Exception e) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return (deser != null); [EOL] }
protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     synchronized (_incompleteDeserializers) { [EOL]         JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]         int count = _incompleteDeserializers.size(); [EOL]         if (count > 0) { [EOL]             deser = _incompleteDeserializers.get(type); [EOL]             if (deser != null) { [EOL]                 return deser; [EOL]             } [EOL]         } [EOL]         try { [EOL]             return _createAndCache2(ctxt, factory, type); [EOL]         } finally { [EOL]             if (count == 0 && _incompleteDeserializers.size() > 0) { [EOL]                 _incompleteDeserializers.clear(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     synchronized (_incompleteDeserializers) { [EOL]         JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]         int count = _incompleteDeserializers.size(); [EOL]         if (count > 0) { [EOL]             deser = _incompleteDeserializers.get(type); [EOL]             if (deser != null) { [EOL]                 return deser; [EOL]             } [EOL]         } [EOL]         try { [EOL]             return _createAndCache2(ctxt, factory, type); [EOL]         } finally { [EOL]             if (count == 0 && _incompleteDeserializers.size() > 0) { [EOL]                 _incompleteDeserializers.clear(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     synchronized (_incompleteDeserializers) { [EOL]         JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]         int count = _incompleteDeserializers.size(); [EOL]         if (count > 0) { [EOL]             deser = _incompleteDeserializers.get(type); [EOL]             if (deser != null) { [EOL]                 return deser; [EOL]             } [EOL]         } [EOL]         try { [EOL]             return _createAndCache2(ctxt, factory, type); [EOL]         } finally { [EOL]             if (count == 0 && _incompleteDeserializers.size() > 0) { [EOL]                 _incompleteDeserializers.clear(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     try { [EOL]         deser = _createDeserializer(ctxt, factory, type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     boolean isResolvable = (deser instanceof ResolvableDeserializer); [EOL]     boolean addToCache = deser.isCachable(); [EOL]     if (isResolvable) { [EOL]         _incompleteDeserializers.put(type, deser); [EOL]         ((ResolvableDeserializer) deser).resolve(ctxt); [EOL]         _incompleteDeserializers.remove(type); [EOL]     } [EOL]     if (addToCache) { [EOL]         _cachedDeserializers.put(type, deser); [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     try { [EOL]         deser = _createDeserializer(ctxt, factory, type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     boolean isResolvable = (deser instanceof ResolvableDeserializer); [EOL]     boolean addToCache = deser.isCachable(); [EOL]     if (isResolvable) { [EOL]         _incompleteDeserializers.put(type, deser); [EOL]         ((ResolvableDeserializer) deser).resolve(ctxt); [EOL]         _incompleteDeserializers.remove(type); [EOL]     } [EOL]     if (addToCache) { [EOL]         _cachedDeserializers.put(type, deser); [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     try { [EOL]         deser = _createDeserializer(ctxt, factory, type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     boolean isResolvable = (deser instanceof ResolvableDeserializer); [EOL]     boolean addToCache = deser.isCachable(); [EOL]     if (isResolvable) { [EOL]         _incompleteDeserializers.put(type, deser); [EOL]         ((ResolvableDeserializer) deser).resolve(ctxt); [EOL]         _incompleteDeserializers.remove(type); [EOL]     } [EOL]     if (addToCache) { [EOL]         _cachedDeserializers.put(type, deser); [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     try { [EOL]         deser = _createDeserializer(ctxt, factory, type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     boolean isResolvable = (deser instanceof ResolvableDeserializer); [EOL]     boolean addToCache = deser.isCachable(); [EOL]     if (isResolvable) { [EOL]         _incompleteDeserializers.put(type, deser); [EOL]         ((ResolvableDeserializer) deser).resolve(ctxt); [EOL]         _incompleteDeserializers.remove(type); [EOL]     } [EOL]     if (addToCache) { [EOL]         _cachedDeserializers.put(type, deser); [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
public PropertyBasedObjectIdGenerator(ObjectIdInfo oid, BeanPropertyWriter prop) { [EOL]     this(oid.getScope(), prop); [EOL] }
public PropertyBasedObjectIdGenerator(ObjectIdInfo oid, BeanPropertyWriter prop) { [EOL]     this(oid.getScope(), prop); [EOL] }
protected PropertyBasedObjectIdGenerator(Class<?> scope, BeanPropertyWriter prop) { [EOL]     super(scope); [EOL]     _property = prop; [EOL] }
protected PropertyBasedObjectIdGenerator(Class<?> scope, BeanPropertyWriter prop) { [EOL]     super(scope); [EOL]     _property = prop; [EOL] }
protected PropertyBasedObjectIdGenerator(Class<?> scope, BeanPropertyWriter prop) { [EOL]     super(scope); [EOL]     _property = prop; [EOL] }
@Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL]     if (gen.getClass() == getClass()) { [EOL]         PropertyBasedObjectIdGenerator other = (PropertyBasedObjectIdGenerator) gen; [EOL]         if (other.getScope() == _scope) { [EOL]             return (other._property == _property); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL]     if (gen.getClass() == getClass()) { [EOL]         PropertyBasedObjectIdGenerator other = (PropertyBasedObjectIdGenerator) gen; [EOL]         if (other.getScope() == _scope) { [EOL]             return (other._property == _property); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL]     if (gen.getClass() == getClass()) { [EOL]         PropertyBasedObjectIdGenerator other = (PropertyBasedObjectIdGenerator) gen; [EOL]         if (other.getScope() == _scope) { [EOL]             return (other._property == _property); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL]     if (gen.getClass() == getClass()) { [EOL]         PropertyBasedObjectIdGenerator other = (PropertyBasedObjectIdGenerator) gen; [EOL]         if (other.getScope() == _scope) { [EOL]             return (other._property == _property); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public Object generateId(Object forPojo) { [EOL]     try { [EOL]         return _property.get(forPojo); [EOL]     } catch (RuntimeException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         throw new IllegalStateException("Problem accessing property '" + _property.getName() + "': " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public Object generateId(Object forPojo) { [EOL]     try { [EOL]         return _property.get(forPojo); [EOL]     } catch (RuntimeException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         throw new IllegalStateException("Problem accessing property '" + _property.getName() + "': " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public Object generateId(Object forPojo) { [EOL]     try { [EOL]         return _property.get(forPojo); [EOL]     } catch (RuntimeException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         throw new IllegalStateException("Problem accessing property '" + _property.getName() + "': " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public ObjectIdGenerator<Object> newForSerialization(Object context) { [EOL]     return this; [EOL] }
public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList) { [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         for (int i = 0, len = curr.length; i < len; ++i) { [EOL]             resultList.add(curr[i]); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < lastChunkEntries; ++i) { [EOL]         resultList.add(lastChunk[i]); [EOL]     } [EOL] }
public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList) { [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         for (int i = 0, len = curr.length; i < len; ++i) { [EOL]             resultList.add(curr[i]); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < lastChunkEntries; ++i) { [EOL]         resultList.add(lastChunk[i]); [EOL]     } [EOL] }
public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList) { [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         for (int i = 0, len = curr.length; i < len; ++i) { [EOL]             resultList.add(curr[i]); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < lastChunkEntries; ++i) { [EOL]         resultList.add(lastChunk[i]); [EOL]     } [EOL] }
public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList) { [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         for (int i = 0, len = curr.length; i < len; ++i) { [EOL]             resultList.add(curr[i]); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < lastChunkEntries; ++i) { [EOL]         resultList.add(lastChunk[i]); [EOL]     } [EOL] }
public UntypedObjectDeserializer() { [EOL]     super(Object.class); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected BeanDescription(JavaType type) { [EOL]     _type = type; [EOL] }
public JavaType getType() { [EOL]     return _type; [EOL] }
public Class<?> getBeanClass() { [EOL]     return _type.getRawClass(); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CalendarDeserializer(CalendarDeserializer src, DateFormat df, String formatString) { [EOL]     super(src, df, formatString); [EOL]     _calendarClass = src._calendarClass; [EOL] }
@Override [EOL] protected CalendarDeserializer withDateFormat(DateFormat df, String formatString) { [EOL]     return new CalendarDeserializer(this, df, formatString); [EOL] }
@Override [EOL] protected CalendarDeserializer withDateFormat(DateFormat df, String formatString) { [EOL]     return new CalendarDeserializer(this, df, formatString); [EOL] }
public DateDeserializer() { [EOL]     super(Date.class); [EOL] }
@Override [EOL] public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseDate(jp, ctxt); [EOL] }
@Override [EOL] public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseDate(jp, ctxt); [EOL] }
@Override [EOL] public Type getGenericType() { [EOL]     return _method.getGenericReturnType(); [EOL] }
@Override [EOL] public JavaType getType(TypeBindings bindings) { [EOL]     return getType(bindings, _method.getTypeParameters()); [EOL] }
@Override [EOL] public final Object call() throws Exception { [EOL]     return _method.invoke(null); [EOL] }
@Override [EOL] public Object getValue(Object pojo) throws IllegalArgumentException { [EOL]     try { [EOL]         return _method.invoke(pojo); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to getValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } catch (InvocationTargetException e) { [EOL]         throw new IllegalArgumentException("Failed to getValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public Object getValue(Object pojo) throws IllegalArgumentException { [EOL]     try { [EOL]         return _method.invoke(pojo); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to getValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } catch (InvocationTargetException e) { [EOL]         throw new IllegalArgumentException("Failed to getValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public Object getValue(Object pojo) throws IllegalArgumentException { [EOL]     try { [EOL]         return _method.invoke(pojo); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to getValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } catch (InvocationTargetException e) { [EOL]         throw new IllegalArgumentException("Failed to getValue() with method " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
public String getFullName() { [EOL]     return getDeclaringClass().getName() + "#" + getName() + "(" + getParameterCount() + " params)"; [EOL] }
@Override [EOL] public String toString() { [EOL]     return "[method " + getFullName() + "]"; [EOL] }
protected TypeSerializerBase(TypeIdResolver idRes, BeanProperty property) { [EOL]     _idResolver = idRes; [EOL]     _property = property; [EOL] }
protected String idFromValue(Object value) { [EOL]     return _idResolver.idFromValue(value); [EOL] }
protected String idFromValue(Object value) { [EOL]     return _idResolver.idFromValue(value); [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected ArraySerializerBase(Class<T> cls, BeanProperty property) { [EOL]     super(cls); [EOL]     _property = property; [EOL] }
protected ArraySerializerBase(Class<T> cls, BeanProperty property) { [EOL]     super(cls); [EOL]     _property = property; [EOL] }
protected ArraySerializerBase(ArraySerializerBase<?> src, BeanProperty property) { [EOL]     super(src._handledType, false); [EOL]     _property = property; [EOL] }
protected ArraySerializerBase(ArraySerializerBase<?> src, BeanProperty property) { [EOL]     super(src._handledType, false); [EOL]     _property = property; [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_NUMBER_INT; [EOL] }
@Override [EOL] public JsonParser.NumberType numberType() { [EOL]     return JsonParser.NumberType.LONG; [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return true; [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return BigInteger.valueOf(_value); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return BigInteger.valueOf(_value); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return BigInteger.valueOf(_value); [EOL] }
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     return _value != 0; [EOL] }
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     return _value != 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((LongNode) o)._value == _value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return ((int) _value) ^ (int) (_value >> 32); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return ((int) _value) ^ (int) (_value >> 32); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return ((int) _value) ^ (int) (_value >> 32); [EOL] }
public BeanSerializerBuilder(BeanDescription beanDesc) { [EOL]     _beanDesc = beanDesc; [EOL] }
public BeanSerializerBuilder(BeanDescription beanDesc) { [EOL]     _beanDesc = beanDesc; [EOL] }
protected void setConfig(SerializationConfig config) { [EOL]     _config = config; [EOL] }
public void setProperties(List<BeanPropertyWriter> properties) { [EOL]     _properties = properties; [EOL] }
public void setProperties(List<BeanPropertyWriter> properties) { [EOL]     _properties = properties; [EOL] }
public void setFilteredProperties(BeanPropertyWriter[] properties) { [EOL]     _filteredProperties = properties; [EOL] }
public void setFilteredProperties(BeanPropertyWriter[] properties) { [EOL]     _filteredProperties = properties; [EOL] }
public void setAnyGetter(AnyGetterWriter anyGetter) { [EOL]     _anyGetter = anyGetter; [EOL] }
public void setAnyGetter(AnyGetterWriter anyGetter) { [EOL]     _anyGetter = anyGetter; [EOL] }
public void setFilterId(Object filterId) { [EOL]     _filterId = filterId; [EOL] }
public void setFilterId(Object filterId) { [EOL]     _filterId = filterId; [EOL] }
public void setObjectIdWriter(ObjectIdWriter w) { [EOL]     _objectIdWriter = w; [EOL] }
public void setObjectIdWriter(ObjectIdWriter w) { [EOL]     _objectIdWriter = w; [EOL] }
public BeanDescription getBeanDescription() { [EOL]     return _beanDesc; [EOL] }
public List<BeanPropertyWriter> getProperties() { [EOL]     return _properties; [EOL] }
public AnyGetterWriter getAnyGetter() { [EOL]     return _anyGetter; [EOL] }
public AnyGetterWriter getAnyGetter() { [EOL]     return _anyGetter; [EOL] }
public Object getFilterId() { [EOL]     return _filterId; [EOL] }
public Object getFilterId() { [EOL]     return _filterId; [EOL] }
public AnnotatedMember getTypeId() { [EOL]     return _typeId; [EOL] }
public ObjectIdWriter getObjectIdWriter() { [EOL]     return _objectIdWriter; [EOL] }
public JsonSerializer<?> build() { [EOL]     BeanPropertyWriter[] properties; [EOL]     if (_properties == null || _properties.isEmpty()) { [EOL]         if (_anyGetter == null) { [EOL]             return null; [EOL]         } [EOL]         properties = NO_PROPERTIES; [EOL]     } else { [EOL]         properties = _properties.toArray(new BeanPropertyWriter[_properties.size()]); [EOL]     } [EOL]     return new BeanSerializer(_beanDesc.getType(), this, properties, _filteredProperties); [EOL] }
public JsonSerializer<?> build() { [EOL]     BeanPropertyWriter[] properties; [EOL]     if (_properties == null || _properties.isEmpty()) { [EOL]         if (_anyGetter == null) { [EOL]             return null; [EOL]         } [EOL]         properties = NO_PROPERTIES; [EOL]     } else { [EOL]         properties = _properties.toArray(new BeanPropertyWriter[_properties.size()]); [EOL]     } [EOL]     return new BeanSerializer(_beanDesc.getType(), this, properties, _filteredProperties); [EOL] }
public JsonSerializer<?> build() { [EOL]     BeanPropertyWriter[] properties; [EOL]     if (_properties == null || _properties.isEmpty()) { [EOL]         if (_anyGetter == null) { [EOL]             return null; [EOL]         } [EOL]         properties = NO_PROPERTIES; [EOL]     } else { [EOL]         properties = _properties.toArray(new BeanPropertyWriter[_properties.size()]); [EOL]     } [EOL]     return new BeanSerializer(_beanDesc.getType(), this, properties, _filteredProperties); [EOL] }
public LRUMap(int initialEntries, int maxEntries) { [EOL]     super(initialEntries, 0.8f, true); [EOL]     _maxEntries = maxEntries; [EOL] }
public LRUMap(int initialEntries, int maxEntries) { [EOL]     super(initialEntries, 0.8f, true); [EOL]     _maxEntries = maxEntries; [EOL] }
public LRUMap(int initialEntries, int maxEntries) { [EOL]     super(initialEntries, 0.8f, true); [EOL]     _maxEntries = maxEntries; [EOL] }
@Override [EOL] protected boolean removeEldestEntry(Map.Entry<K, V> eldest) { [EOL]     return size() > _maxEntries; [EOL] }
@Override [EOL] protected boolean removeEldestEntry(Map.Entry<K, V> eldest) { [EOL]     return size() > _maxEntries; [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private EnumValues(Class<Enum<?>> enumClass, Map<Enum<?>, SerializedString> v) { [EOL]     _enumClass = enumClass; [EOL]     _values = new EnumMap(v); [EOL] }
public static EnumValues construct(Class<Enum<?>> enumClass, AnnotationIntrospector intr) { [EOL]     return constructFromName(enumClass, intr); [EOL] }
public static EnumValues construct(Class<Enum<?>> enumClass, AnnotationIntrospector intr) { [EOL]     return constructFromName(enumClass, intr); [EOL] }
public static EnumValues constructFromName(Class<Enum<?>> enumClass, AnnotationIntrospector intr) { [EOL]     Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass); [EOL]     Enum<?>[] values = cls.getEnumConstants(); [EOL]     if (values != null) { [EOL]         Map<Enum<?>, SerializedString> map = new HashMap<Enum<?>, SerializedString>(); [EOL]         for (Enum<?> en : values) { [EOL]             String value = intr.findEnumValue(en); [EOL]             map.put(en, new SerializedString(value)); [EOL]         } [EOL]         return new EnumValues(enumClass, map); [EOL]     } [EOL]     throw new IllegalArgumentException("Can not determine enum constants for Class " + enumClass.getName()); [EOL] }
public static EnumValues constructFromName(Class<Enum<?>> enumClass, AnnotationIntrospector intr) { [EOL]     Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass); [EOL]     Enum<?>[] values = cls.getEnumConstants(); [EOL]     if (values != null) { [EOL]         Map<Enum<?>, SerializedString> map = new HashMap<Enum<?>, SerializedString>(); [EOL]         for (Enum<?> en : values) { [EOL]             String value = intr.findEnumValue(en); [EOL]             map.put(en, new SerializedString(value)); [EOL]         } [EOL]         return new EnumValues(enumClass, map); [EOL]     } [EOL]     throw new IllegalArgumentException("Can not determine enum constants for Class " + enumClass.getName()); [EOL] }
public SerializedString serializedValueFor(Enum<?> key) { [EOL]     return _values.get(key); [EOL] }
public SerializedString serializedValueFor(Enum<?> key) { [EOL]     return _values.get(key); [EOL] }
public JsonNodeFactory(boolean bigDecimalExact) { [EOL]     _cfgBigDecimalExact = bigDecimalExact; [EOL] }
public JsonNodeFactory(boolean bigDecimalExact) { [EOL]     _cfgBigDecimalExact = bigDecimalExact; [EOL] }
public BinaryNode binaryNode(byte[] data) { [EOL]     return BinaryNode.valueOf(data); [EOL] }
public BinaryNode binaryNode(byte[] data) { [EOL]     return BinaryNode.valueOf(data); [EOL] }
public BinaryNode binaryNode(byte[] data) { [EOL]     return BinaryNode.valueOf(data); [EOL] }
public SerializedString findRootName(JavaType rootType, MapperConfig<?> config) { [EOL]     return findRootName(rootType.getRawClass(), config); [EOL] }
public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config) { [EOL]     ClassKey key = new ClassKey(rootType); [EOL]     if (_rootNames == null) { [EOL]         _rootNames = new LRUMap<ClassKey, SerializedString>(20, 200); [EOL]     } else { [EOL]         SerializedString name = _rootNames.get(key); [EOL]         if (name != null) { [EOL]             return name; [EOL]         } [EOL]     } [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(rootType); [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     PropertyName pname = intr.findRootName(ac); [EOL]     String nameStr; [EOL]     if (pname == null || !pname.hasSimpleName()) { [EOL]         nameStr = rootType.getSimpleName(); [EOL]     } else { [EOL]         nameStr = pname.getSimpleName(); [EOL]     } [EOL]     SerializedString name = new SerializedString(nameStr); [EOL]     _rootNames.put(key, name); [EOL]     return name; [EOL] }
public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config) { [EOL]     ClassKey key = new ClassKey(rootType); [EOL]     if (_rootNames == null) { [EOL]         _rootNames = new LRUMap<ClassKey, SerializedString>(20, 200); [EOL]     } else { [EOL]         SerializedString name = _rootNames.get(key); [EOL]         if (name != null) { [EOL]             return name; [EOL]         } [EOL]     } [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(rootType); [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     PropertyName pname = intr.findRootName(ac); [EOL]     String nameStr; [EOL]     if (pname == null || !pname.hasSimpleName()) { [EOL]         nameStr = rootType.getSimpleName(); [EOL]     } else { [EOL]         nameStr = pname.getSimpleName(); [EOL]     } [EOL]     SerializedString name = new SerializedString(nameStr); [EOL]     _rootNames.put(key, name); [EOL]     return name; [EOL] }
public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config) { [EOL]     ClassKey key = new ClassKey(rootType); [EOL]     if (_rootNames == null) { [EOL]         _rootNames = new LRUMap<ClassKey, SerializedString>(20, 200); [EOL]     } else { [EOL]         SerializedString name = _rootNames.get(key); [EOL]         if (name != null) { [EOL]             return name; [EOL]         } [EOL]     } [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(rootType); [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     PropertyName pname = intr.findRootName(ac); [EOL]     String nameStr; [EOL]     if (pname == null || !pname.hasSimpleName()) { [EOL]         nameStr = rootType.getSimpleName(); [EOL]     } else { [EOL]         nameStr = pname.getSimpleName(); [EOL]     } [EOL]     SerializedString name = new SerializedString(nameStr); [EOL]     _rootNames.put(key, name); [EOL]     return name; [EOL] }
protected ContainerDeserializerBase(Class<?> selfType) { [EOL]     super(selfType); [EOL] }
public TypeBindings(TypeFactory typeFactory, Class<?> cc) { [EOL]     this(typeFactory, null, cc, null); [EOL] }
public TypeBindings(TypeFactory typeFactory, Class<?> cc) { [EOL]     this(typeFactory, null, cc, null); [EOL] }
public TypeBindings childInstance() { [EOL]     return new TypeBindings(_typeFactory, this, _contextClass, _contextType); [EOL] }
public TypeBindings childInstance() { [EOL]     return new TypeBindings(_typeFactory, this, _contextClass, _contextType); [EOL] }
private TypeBindings(TypeFactory tf, TypeBindings parent, Class<?> cc, JavaType type) { [EOL]     _typeFactory = tf; [EOL]     _parentBindings = parent; [EOL]     _contextClass = cc; [EOL]     _contextType = type; [EOL] }
private TypeBindings(TypeFactory tf, TypeBindings parent, Class<?> cc, JavaType type) { [EOL]     _typeFactory = tf; [EOL]     _parentBindings = parent; [EOL]     _contextClass = cc; [EOL]     _contextType = type; [EOL] }
public int getBindingCount() { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     return _bindings.size(); [EOL] }
public int getBindingCount() { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     return _bindings.size(); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public void addBinding(String name, JavaType type) { [EOL]     if (_bindings == null || _bindings.size() == 0) { [EOL]         _bindings = new LinkedHashMap<String, JavaType>(); [EOL]     } [EOL]     _bindings.put(name, type); [EOL] }
public void addBinding(String name, JavaType type) { [EOL]     if (_bindings == null || _bindings.size() == 0) { [EOL]         _bindings = new LinkedHashMap<String, JavaType>(); [EOL]     } [EOL]     _bindings.put(name, type); [EOL] }
public JavaType[] typesAsArray() { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     if (_bindings.size() == 0) { [EOL]         return NO_TYPES; [EOL]     } [EOL]     return _bindings.values().toArray(new JavaType[_bindings.size()]); [EOL] }
public JavaType[] typesAsArray() { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     if (_bindings.size() == 0) { [EOL]         return NO_TYPES; [EOL]     } [EOL]     return _bindings.values().toArray(new JavaType[_bindings.size()]); [EOL] }
public JavaType[] typesAsArray() { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     if (_bindings.size() == 0) { [EOL]         return NO_TYPES; [EOL]     } [EOL]     return _bindings.values().toArray(new JavaType[_bindings.size()]); [EOL] }
protected void _resolve() { [EOL]     _resolveBindings(_contextClass); [EOL]     if (_contextType != null) { [EOL]         int count = _contextType.containedTypeCount(); [EOL]         if (count > 0) { [EOL]             for (int i = 0; i < count; ++i) { [EOL]                 String name = _contextType.containedTypeName(i); [EOL]                 JavaType type = _contextType.containedType(i); [EOL]                 addBinding(name, type); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_bindings == null) { [EOL]         _bindings = Collections.emptyMap(); [EOL]     } [EOL] }
protected void _resolve() { [EOL]     _resolveBindings(_contextClass); [EOL]     if (_contextType != null) { [EOL]         int count = _contextType.containedTypeCount(); [EOL]         if (count > 0) { [EOL]             for (int i = 0; i < count; ++i) { [EOL]                 String name = _contextType.containedTypeName(i); [EOL]                 JavaType type = _contextType.containedType(i); [EOL]                 addBinding(name, type); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_bindings == null) { [EOL]         _bindings = Collections.emptyMap(); [EOL]     } [EOL] }
protected void _resolve() { [EOL]     _resolveBindings(_contextClass); [EOL]     if (_contextType != null) { [EOL]         int count = _contextType.containedTypeCount(); [EOL]         if (count > 0) { [EOL]             for (int i = 0; i < count; ++i) { [EOL]                 String name = _contextType.containedTypeName(i); [EOL]                 JavaType type = _contextType.containedType(i); [EOL]                 addBinding(name, type); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_bindings == null) { [EOL]         _bindings = Collections.emptyMap(); [EOL]     } [EOL] }
public void _addPlaceholder(String name) { [EOL]     if (_placeholders == null) { [EOL]         _placeholders = new HashSet<String>(); [EOL]     } [EOL]     _placeholders.add(name); [EOL] }
public void _addPlaceholder(String name) { [EOL]     if (_placeholders == null) { [EOL]         _placeholders = new HashSet<String>(); [EOL]     } [EOL]     _placeholders.add(name); [EOL] }
protected void _resolveBindings(Type t) { [EOL]     if (t == null) [EOL]         return; [EOL]     Class<?> raw; [EOL]     if (t instanceof ParameterizedType) { [EOL]         ParameterizedType pt = (ParameterizedType) t; [EOL]         Type[] args = pt.getActualTypeArguments(); [EOL]         if (args != null && args.length > 0) { [EOL]             Class<?> rawType = (Class<?>) pt.getRawType(); [EOL]             TypeVariable<?>[] vars = rawType.getTypeParameters(); [EOL]             if (vars.length != args.length) { [EOL]                 throw new IllegalArgumentException("Strange parametrized type (in class " + rawType.getName() + "): number of type arguments != number of type parameters (" + args.length + " vs " + vars.length + ")"); [EOL]             } [EOL]             for (int i = 0, len = args.length; i < len; ++i) { [EOL]                 TypeVariable<?> var = vars[i]; [EOL]                 String name = var.getName(); [EOL]                 if (_bindings == null) { [EOL]                     _bindings = new LinkedHashMap<String, JavaType>(); [EOL]                 } else { [EOL]                     if (_bindings.containsKey(name)) [EOL]                         continue; [EOL]                 } [EOL]                 _addPlaceholder(name); [EOL]                 _bindings.put(name, _typeFactory._constructType(args[i], this)); [EOL]             } [EOL]         } [EOL]         raw = (Class<?>) pt.getRawType(); [EOL]     } else if (t instanceof Class<?>) { [EOL]         raw = (Class<?>) t; [EOL]         Class<?> decl = raw.getDeclaringClass(); [EOL]         if (decl != null && !decl.isAssignableFrom(raw)) { [EOL]             _resolveBindings(raw.getDeclaringClass()); [EOL]         } [EOL]         TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]         if (vars != null && vars.length > 0) { [EOL]             JavaType[] typeParams = null; [EOL]             if (_contextType != null && raw.isAssignableFrom(_contextType.getRawClass())) { [EOL]                 typeParams = _typeFactory.findTypeParameters(_contextType, raw); [EOL]             } [EOL]             for (int i = 0; i < vars.length; i++) { [EOL]                 TypeVariable<?> var = vars[i]; [EOL]                 String name = var.getName(); [EOL]                 Type varType = var.getBounds()[0]; [EOL]                 if (varType != null) { [EOL]                     if (_bindings == null) { [EOL]                         _bindings = new LinkedHashMap<String, JavaType>(); [EOL]                     } else { [EOL]                         if (_bindings.containsKey(name)) [EOL]                             continue; [EOL]                     } [EOL]                     _addPlaceholder(name); [EOL]                     if (typeParams != null) { [EOL]                         _bindings.put(name, typeParams[i]); [EOL]                     } else { [EOL]                         _bindings.put(name, _typeFactory._constructType(varType, this)); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return; [EOL]     } [EOL]     _resolveBindings(raw.getGenericSuperclass()); [EOL]     for (Type intType : raw.getGenericInterfaces()) { [EOL]         _resolveBindings(intType); [EOL]     } [EOL] }
protected StdSerializer(Class<T> t) { [EOL]     _handledType = t; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StdSerializer(JavaType type) { [EOL]     _handledType = (Class<T>) type.getRawClass(); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StdSerializer(JavaType type) { [EOL]     _handledType = (Class<T>) type.getRawClass(); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StdSerializer(Class<?> t, boolean dummy) { [EOL]     _handledType = (Class<T>) t; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StdSerializer(Class<?> t, boolean dummy) { [EOL]     _handledType = (Class<T>) t; [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, String fieldName) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, String fieldName) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, String fieldName) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, String fieldName) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, String fieldName) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, String fieldName) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findSerializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             if (existingSerializer == null) { [EOL]                 existingSerializer = provider.findValueSerializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingSerializer(conv, delegateType, existingSerializer); [EOL]         } [EOL]     } [EOL]     return existingSerializer; [EOL] }
protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findSerializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             if (existingSerializer == null) { [EOL]                 existingSerializer = provider.findValueSerializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingSerializer(conv, delegateType, existingSerializer); [EOL]         } [EOL]     } [EOL]     return existingSerializer; [EOL] }
protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findSerializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             if (existingSerializer == null) { [EOL]                 existingSerializer = provider.findValueSerializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingSerializer(conv, delegateType, existingSerializer); [EOL]         } [EOL]     } [EOL]     return existingSerializer; [EOL] }
protected BasicDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     _factoryConfig = config; [EOL] }
@Override [EOL] public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) { [EOL]     return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional)); [EOL] }
@Override [EOL] public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) { [EOL]     return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional)); [EOL] }
@Override [EOL] public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) { [EOL]     return withConfig(_factoryConfig.withValueInstantiators(instantiators)); [EOL] }
@Override [EOL] public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) { [EOL]     return withConfig(_factoryConfig.withValueInstantiators(instantiators)); [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> mapClass = type.getRawClass(); [EOL]         if (EnumMap.class.isAssignableFrom(mapClass)) { [EOL]             Class<?> kt = keyType.getRawClass(); [EOL]             if (kt == null || !kt.isEnum()) { [EOL]                 throw new IllegalArgumentException("Can not construct EnumMap; generic (key) type not available"); [EOL]             } [EOL]             deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser); [EOL]         } [EOL]         if (deser == null) { [EOL]             if (type.isInterface() || type.isAbstract()) { [EOL]                 @SuppressWarnings("rawtypes") [EOL]                 Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName()); [EOL]                 if (fallback == null) { [EOL]                     throw new IllegalArgumentException("Can not find a deserializer for non-concrete Map type " + type); [EOL]                 } [EOL]                 mapClass = fallback; [EOL]                 type = (MapType) config.constructSpecializedType(type, mapClass); [EOL]                 beanDesc = config.introspectForCreation(type); [EOL]             } [EOL]             ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]             MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser); [EOL]             md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]             deser = md; [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyMapDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> mapClass = type.getRawClass(); [EOL]         if (EnumMap.class.isAssignableFrom(mapClass)) { [EOL]             Class<?> kt = keyType.getRawClass(); [EOL]             if (kt == null || !kt.isEnum()) { [EOL]                 throw new IllegalArgumentException("Can not construct EnumMap; generic (key) type not available"); [EOL]             } [EOL]             deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser); [EOL]         } [EOL]         if (deser == null) { [EOL]             if (type.isInterface() || type.isAbstract()) { [EOL]                 @SuppressWarnings("rawtypes") [EOL]                 Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName()); [EOL]                 if (fallback == null) { [EOL]                     throw new IllegalArgumentException("Can not find a deserializer for non-concrete Map type " + type); [EOL]                 } [EOL]                 mapClass = fallback; [EOL]                 type = (MapType) config.constructSpecializedType(type, mapClass); [EOL]                 beanDesc = config.introspectForCreation(type); [EOL]             } [EOL]             ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]             MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser); [EOL]             md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]             deser = md; [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyMapDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> mapClass = type.getRawClass(); [EOL]         if (EnumMap.class.isAssignableFrom(mapClass)) { [EOL]             Class<?> kt = keyType.getRawClass(); [EOL]             if (kt == null || !kt.isEnum()) { [EOL]                 throw new IllegalArgumentException("Can not construct EnumMap; generic (key) type not available"); [EOL]             } [EOL]             deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser); [EOL]         } [EOL]         if (deser == null) { [EOL]             if (type.isInterface() || type.isAbstract()) { [EOL]                 @SuppressWarnings("rawtypes") [EOL]                 Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName()); [EOL]                 if (fallback == null) { [EOL]                     throw new IllegalArgumentException("Can not find a deserializer for non-concrete Map type " + type); [EOL]                 } [EOL]                 mapClass = fallback; [EOL]                 type = (MapType) config.constructSpecializedType(type, mapClass); [EOL]                 beanDesc = config.introspectForCreation(type); [EOL]             } [EOL]             ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]             MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser); [EOL]             md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]             deser = md; [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyMapDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> mapClass = type.getRawClass(); [EOL]         if (EnumMap.class.isAssignableFrom(mapClass)) { [EOL]             Class<?> kt = keyType.getRawClass(); [EOL]             if (kt == null || !kt.isEnum()) { [EOL]                 throw new IllegalArgumentException("Can not construct EnumMap; generic (key) type not available"); [EOL]             } [EOL]             deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser); [EOL]         } [EOL]         if (deser == null) { [EOL]             if (type.isInterface() || type.isAbstract()) { [EOL]                 @SuppressWarnings("rawtypes") [EOL]                 Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName()); [EOL]                 if (fallback == null) { [EOL]                     throw new IllegalArgumentException("Can not find a deserializer for non-concrete Map type " + type); [EOL]                 } [EOL]                 mapClass = fallback; [EOL]                 type = (MapType) config.constructSpecializedType(type, mapClass); [EOL]                 beanDesc = config.introspectForCreation(type); [EOL]             } [EOL]             ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]             MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser); [EOL]             md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]             deser = md; [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyMapDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType); [EOL]     JavaType contentType = containerType.getContentType(); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, contentType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(propertyEntity, config, ai, contentType); [EOL]     return b.buildTypeDeserializer(config, contentType, subtypes); [EOL] }
public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType); [EOL]     JavaType contentType = containerType.getContentType(); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, contentType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(propertyEntity, config, ai, contentType); [EOL]     return b.buildTypeDeserializer(config, contentType, subtypes); [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected DefaultSerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f) { [EOL]     super(src, config, f); [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("A class must be provided"); [EOL]     } [EOL]     JsonSerializer<Object> ser = findValueSerializer(type, null); [EOL]     JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     if (!(schemaNode instanceof ObjectNode)) { [EOL]         throw new IllegalArgumentException("Class " + type.getName() + " would not be serialized as a JSON object and therefore has no schema"); [EOL]     } [EOL]     return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode); [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("A class must be provided"); [EOL]     } [EOL]     JsonSerializer<Object> ser = findValueSerializer(type, null); [EOL]     JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     if (!(schemaNode instanceof ObjectNode)) { [EOL]         throw new IllegalArgumentException("Class " + type.getName() + " would not be serialized as a JSON object and therefore has no schema"); [EOL]     } [EOL]     return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode); [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("A class must be provided"); [EOL]     } [EOL]     JsonSerializer<Object> ser = findValueSerializer(type, null); [EOL]     JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     if (!(schemaNode instanceof ObjectNode)) { [EOL]         throw new IllegalArgumentException("Class " + type.getName() + " would not be serialized as a JSON object and therefore has no schema"); [EOL]     } [EOL]     return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
protected Impl(SerializerProvider src, SerializationConfig config, SerializerFactory f) { [EOL]     super(src, config, f); [EOL] }
@Override [EOL] public Impl createInstance(SerializationConfig config, SerializerFactory jsf) { [EOL]     return new Impl(this, config, jsf); [EOL] }
protected BeanDeserializer(BeanDeserializerBase src) { [EOL]     super(src, src._ignoreAllUnknown); [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_unwrappedPropertyHandler != null) { [EOL]         return deserializeWithUnwrapped(jp, ctxt, bean); [EOL]     } [EOL]     if (_externalTypeIdHandler != null) { [EOL]         return deserializeWithExternalTypeId(jp, ctxt, bean); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     bean = null; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         bean = null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt); [EOL]     } [EOL]     return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@SuppressWarnings("resource") [EOL] protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final ExternalTypeHandler ext = _externalTypeIdHandler.start(); [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) { [EOL]                 ; [EOL]             } else { [EOL]                 Object value = creatorProp.deserialize(jp, ctxt); [EOL]                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                     t = jp.nextToken(); [EOL]                     Object bean; [EOL]                     try { [EOL]                         bean = creator.build(ctxt, buffer); [EOL]                     } catch (Exception e) { [EOL]                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                         continue; [EOL]                     } [EOL]                     while (t == JsonToken.FIELD_NAME) { [EOL]                         jp.nextToken(); [EOL]                         tokens.copyCurrentStructure(jp); [EOL]                         t = jp.nextToken(); [EOL]                     } [EOL]                     if (bean.getClass() != _beanType.getRawClass()) { [EOL]                         throw ctxt.mappingException("Can not create polymorphic instances with unwrapped values"); [EOL]                     } [EOL]                     return ext.complete(jp, ctxt, bean); [EOL]                 } [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (ext.handlePropertyValue(jp, ctxt, propName, null)) { [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return ext.complete(jp, ctxt, buffer, creator); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); [EOL]             if (serializeAsIndex != _serializeAsIndex) { [EOL]                 return new EnumSerializer(_values, serializeAsIndex); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); [EOL]             if (serializeAsIndex != _serializeAsIndex) { [EOL]                 return new EnumSerializer(_values, serializeAsIndex); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); [EOL]             if (serializeAsIndex != _serializeAsIndex) { [EOL]                 return new EnumSerializer(_values, serializeAsIndex); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); [EOL]             if (serializeAsIndex != _serializeAsIndex) { [EOL]                 return new EnumSerializer(_values, serializeAsIndex); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializeAsIndex(provider)) { [EOL]         jgen.writeNumber(en.ordinal()); [EOL]         return; [EOL]     } [EOL]     jgen.writeString(_values.serializedValueFor(en)); [EOL] }
@Override [EOL] public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializeAsIndex(provider)) { [EOL]         jgen.writeNumber(en.ordinal()); [EOL]         return; [EOL]     } [EOL]     jgen.writeString(_values.serializedValueFor(en)); [EOL] }
protected final boolean _serializeAsIndex(SerializerProvider provider) { [EOL]     if (_serializeAsIndex != null) { [EOL]         return _serializeAsIndex.booleanValue(); [EOL]     } [EOL]     return provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX); [EOL] }
protected final boolean _serializeAsIndex(SerializerProvider provider) { [EOL]     if (_serializeAsIndex != null) { [EOL]         return _serializeAsIndex.booleanValue(); [EOL]     } [EOL]     return provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
public ReadOnlyClassToSerializerMap getReadOnlyLookupMap() { [EOL]     ReadOnlyClassToSerializerMap m; [EOL]     synchronized (this) { [EOL]         m = _readOnlyMap; [EOL]         if (m == null) { [EOL]             _readOnlyMap = m = ReadOnlyClassToSerializerMap.from(_sharedMap); [EOL]         } [EOL]     } [EOL]     return m.instance(); [EOL] }
public ReadOnlyClassToSerializerMap getReadOnlyLookupMap() { [EOL]     ReadOnlyClassToSerializerMap m; [EOL]     synchronized (this) { [EOL]         m = _readOnlyMap; [EOL]         if (m == null) { [EOL]             _readOnlyMap = m = ReadOnlyClassToSerializerMap.from(_sharedMap); [EOL]         } [EOL]     } [EOL]     return m.instance(); [EOL] }
public JsonSerializer<Object> untypedValueSerializer(Class<?> type) { [EOL]     synchronized (this) { [EOL]         return _sharedMap.get(new TypeKey(type, false)); [EOL]     } [EOL] }
public JsonSerializer<Object> untypedValueSerializer(Class<?> type) { [EOL]     synchronized (this) { [EOL]         return _sharedMap.get(new TypeKey(type, false)); [EOL]     } [EOL] }
public JsonSerializer<Object> untypedValueSerializer(JavaType type) { [EOL]     synchronized (this) { [EOL]         return _sharedMap.get(new TypeKey(type, false)); [EOL]     } [EOL] }
public JsonSerializer<Object> untypedValueSerializer(JavaType type) { [EOL]     synchronized (this) { [EOL]         return _sharedMap.get(new TypeKey(type, false)); [EOL]     } [EOL] }
public JsonSerializer<Object> typedValueSerializer(Class<?> cls) { [EOL]     synchronized (this) { [EOL]         return _sharedMap.get(new TypeKey(cls, true)); [EOL]     } [EOL] }
public JsonSerializer<Object> typedValueSerializer(Class<?> cls) { [EOL]     synchronized (this) { [EOL]         return _sharedMap.get(new TypeKey(cls, true)); [EOL]     } [EOL] }
public void addTypedSerializer(Class<?> cls, JsonSerializer<Object> ser) { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(cls, true), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]     } [EOL] }
public void addTypedSerializer(Class<?> cls, JsonSerializer<Object> ser) { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(cls, true), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]     } [EOL] }
public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser, SerializerProvider provider) throws JsonMappingException { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(type, false), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]         if (ser instanceof ResolvableSerializer) { [EOL]             ((ResolvableSerializer) ser).resolve(provider); [EOL]         } [EOL]     } [EOL] }
public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser, SerializerProvider provider) throws JsonMappingException { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(type, false), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]         if (ser instanceof ResolvableSerializer) { [EOL]             ((ResolvableSerializer) ser).resolve(provider); [EOL]         } [EOL]     } [EOL] }
public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser, SerializerProvider provider) throws JsonMappingException { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(type, false), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]         if (ser instanceof ResolvableSerializer) { [EOL]             ((ResolvableSerializer) ser).resolve(provider); [EOL]         } [EOL]     } [EOL] }
public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser, SerializerProvider provider) throws JsonMappingException { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(type, false), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]         if (ser instanceof ResolvableSerializer) { [EOL]             ((ResolvableSerializer) ser).resolve(provider); [EOL]         } [EOL]     } [EOL] }
public TypeKey(Class<?> key, boolean typed) { [EOL]     _class = key; [EOL]     _type = null; [EOL]     _isTyped = typed; [EOL]     _hashCode = hash(key, typed); [EOL] }
public TypeKey(JavaType key, boolean typed) { [EOL]     _type = key; [EOL]     _class = null; [EOL]     _isTyped = typed; [EOL]     _hashCode = hash(key, typed); [EOL] }
public TypeKey(JavaType key, boolean typed) { [EOL]     _type = key; [EOL]     _class = null; [EOL]     _isTyped = typed; [EOL]     _hashCode = hash(key, typed); [EOL] }
private final static int hash(Class<?> cls, boolean typed) { [EOL]     int hash = cls.getName().hashCode(); [EOL]     if (typed) { [EOL]         ++hash; [EOL]     } [EOL]     return hash; [EOL] }
private final static int hash(JavaType type, boolean typed) { [EOL]     int hash = type.hashCode() - 1; [EOL]     if (typed) { [EOL]         --hash; [EOL]     } [EOL]     return hash; [EOL] }
private final static int hash(JavaType type, boolean typed) { [EOL]     int hash = type.hashCode() - 1; [EOL]     if (typed) { [EOL]         --hash; [EOL]     } [EOL]     return hash; [EOL] }
public void resetUntyped(Class<?> cls) { [EOL]     _type = null; [EOL]     _class = cls; [EOL]     _isTyped = false; [EOL]     _hashCode = hash(cls, false); [EOL] }
public void resetUntyped(JavaType type) { [EOL]     _type = type; [EOL]     _class = null; [EOL]     _isTyped = false; [EOL]     _hashCode = hash(type, false); [EOL] }
public void resetUntyped(JavaType type) { [EOL]     _type = type; [EOL]     _class = null; [EOL]     _isTyped = false; [EOL]     _hashCode = hash(type, false); [EOL] }
@Override [EOL] public final int hashCode() { [EOL]     return _hashCode; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
public BeanPropertyMap(Collection<SettableBeanProperty> properties) { [EOL]     _size = properties.size(); [EOL]     int bucketCount = findSize(_size); [EOL]     _hashMask = bucketCount - 1; [EOL]     Bucket[] buckets = new Bucket[bucketCount]; [EOL]     for (SettableBeanProperty property : properties) { [EOL]         String key = property.getName(); [EOL]         int index = key.hashCode() & _hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, property, _nextBucketIndex++); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
public BeanPropertyMap(Collection<SettableBeanProperty> properties) { [EOL]     _size = properties.size(); [EOL]     int bucketCount = findSize(_size); [EOL]     _hashMask = bucketCount - 1; [EOL]     Bucket[] buckets = new Bucket[bucketCount]; [EOL]     for (SettableBeanProperty property : properties) { [EOL]         String key = property.getName(); [EOL]         int index = key.hashCode() & _hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, property, _nextBucketIndex++); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
public BeanPropertyMap(Collection<SettableBeanProperty> properties) { [EOL]     _size = properties.size(); [EOL]     int bucketCount = findSize(_size); [EOL]     _hashMask = bucketCount - 1; [EOL]     Bucket[] buckets = new Bucket[bucketCount]; [EOL]     for (SettableBeanProperty property : properties) { [EOL]         String key = property.getName(); [EOL]         int index = key.hashCode() & _hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, property, _nextBucketIndex++); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
public BeanPropertyMap(Collection<SettableBeanProperty> properties) { [EOL]     _size = properties.size(); [EOL]     int bucketCount = findSize(_size); [EOL]     _hashMask = bucketCount - 1; [EOL]     Bucket[] buckets = new Bucket[bucketCount]; [EOL]     for (SettableBeanProperty property : properties) { [EOL]         String key = property.getName(); [EOL]         int index = key.hashCode() & _hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, property, _nextBucketIndex++); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
public BeanPropertyMap withProperty(SettableBeanProperty newProperty) { [EOL]     final int bcount = _buckets.length; [EOL]     Bucket[] newBuckets = new Bucket[bcount]; [EOL]     System.arraycopy(_buckets, 0, newBuckets, 0, bcount); [EOL]     final String propName = newProperty.getName(); [EOL]     SettableBeanProperty oldProp = find(newProperty.getName()); [EOL]     if (oldProp == null) { [EOL]         int index = propName.hashCode() & _hashMask; [EOL]         newBuckets[index] = new Bucket(newBuckets[index], propName, newProperty, _nextBucketIndex++); [EOL]         return new BeanPropertyMap(newBuckets, _size + 1, _nextBucketIndex); [EOL]     } [EOL]     BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex); [EOL]     newMap.replace(newProperty); [EOL]     return newMap; [EOL] }
public BeanPropertyMap withProperty(SettableBeanProperty newProperty) { [EOL]     final int bcount = _buckets.length; [EOL]     Bucket[] newBuckets = new Bucket[bcount]; [EOL]     System.arraycopy(_buckets, 0, newBuckets, 0, bcount); [EOL]     final String propName = newProperty.getName(); [EOL]     SettableBeanProperty oldProp = find(newProperty.getName()); [EOL]     if (oldProp == null) { [EOL]         int index = propName.hashCode() & _hashMask; [EOL]         newBuckets[index] = new Bucket(newBuckets[index], propName, newProperty, _nextBucketIndex++); [EOL]         return new BeanPropertyMap(newBuckets, _size + 1, _nextBucketIndex); [EOL]     } [EOL]     BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex); [EOL]     newMap.replace(newProperty); [EOL]     return newMap; [EOL] }
public BeanPropertyMap assignIndexes() { [EOL]     int index = 0; [EOL]     for (Bucket bucket : _buckets) { [EOL]         while (bucket != null) { [EOL]             bucket.value.assignIndex(index++); [EOL]             bucket = bucket.next; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public BeanPropertyMap assignIndexes() { [EOL]     int index = 0; [EOL]     for (Bucket bucket : _buckets) { [EOL]         while (bucket != null) { [EOL]             bucket.value.assignIndex(index++); [EOL]             bucket = bucket.next; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 32) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 2; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 32) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 2; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 32) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 2; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Iterator<SettableBeanProperty> iterator() { [EOL]     return new IteratorImpl(_buckets); [EOL] }
@Override [EOL] public Iterator<SettableBeanProperty> iterator() { [EOL]     return new IteratorImpl(_buckets); [EOL] }
@Override [EOL] public Iterator<SettableBeanProperty> iterator() { [EOL]     return new IteratorImpl(_buckets); [EOL] }
public SettableBeanProperty find(String key) { [EOL]     int index = key.hashCode() & _hashMask; [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (bucket.key == key) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (bucket.key == key) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return _findWithEquals(key, index); [EOL] }
public SettableBeanProperty find(String key) { [EOL]     int index = key.hashCode() & _hashMask; [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (bucket.key == key) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (bucket.key == key) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return _findWithEquals(key, index); [EOL] }
public SettableBeanProperty find(String key) { [EOL]     int index = key.hashCode() & _hashMask; [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (bucket.key == key) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (bucket.key == key) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return _findWithEquals(key, index); [EOL] }
public SettableBeanProperty find(String key) { [EOL]     int index = key.hashCode() & _hashMask; [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (bucket.key == key) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (bucket.key == key) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return _findWithEquals(key, index); [EOL] }
public void replace(SettableBeanProperty property) { [EOL]     String name = property.getName(); [EOL]     int index = name.hashCode() & (_buckets.length - 1); [EOL]     Bucket tail = null; [EOL]     int foundIndex = -1; [EOL]     for (Bucket bucket = _buckets[index]; bucket != null; bucket = bucket.next) { [EOL]         if (foundIndex < 0 && bucket.key.equals(name)) { [EOL]             foundIndex = bucket.index; [EOL]         } else { [EOL]             tail = new Bucket(tail, bucket.key, bucket.value, bucket.index); [EOL]         } [EOL]     } [EOL]     if (foundIndex < 0) { [EOL]         throw new NoSuchElementException("No entry '" + property + "' found, can't replace"); [EOL]     } [EOL]     _buckets[index] = new Bucket(tail, name, property, foundIndex); [EOL] }
public void replace(SettableBeanProperty property) { [EOL]     String name = property.getName(); [EOL]     int index = name.hashCode() & (_buckets.length - 1); [EOL]     Bucket tail = null; [EOL]     int foundIndex = -1; [EOL]     for (Bucket bucket = _buckets[index]; bucket != null; bucket = bucket.next) { [EOL]         if (foundIndex < 0 && bucket.key.equals(name)) { [EOL]             foundIndex = bucket.index; [EOL]         } else { [EOL]             tail = new Bucket(tail, bucket.key, bucket.value, bucket.index); [EOL]         } [EOL]     } [EOL]     if (foundIndex < 0) { [EOL]         throw new NoSuchElementException("No entry '" + property + "' found, can't replace"); [EOL]     } [EOL]     _buckets[index] = new Bucket(tail, name, property, foundIndex); [EOL] }
public void remove(SettableBeanProperty property) { [EOL]     String name = property.getName(); [EOL]     int index = name.hashCode() & (_buckets.length - 1); [EOL]     Bucket tail = null; [EOL]     boolean found = false; [EOL]     for (Bucket bucket = _buckets[index]; bucket != null; bucket = bucket.next) { [EOL]         if (!found && bucket.key.equals(name)) { [EOL]             found = true; [EOL]         } else { [EOL]             tail = new Bucket(tail, bucket.key, bucket.value, bucket.index); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new NoSuchElementException("No entry '" + property + "' found, can't remove"); [EOL]     } [EOL]     _buckets[index] = tail; [EOL] }
public void remove(SettableBeanProperty property) { [EOL]     String name = property.getName(); [EOL]     int index = name.hashCode() & (_buckets.length - 1); [EOL]     Bucket tail = null; [EOL]     boolean found = false; [EOL]     for (Bucket bucket = _buckets[index]; bucket != null; bucket = bucket.next) { [EOL]         if (!found && bucket.key.equals(name)) { [EOL]             found = true; [EOL]         } else { [EOL]             tail = new Bucket(tail, bucket.key, bucket.value, bucket.index); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new NoSuchElementException("No entry '" + property + "' found, can't remove"); [EOL]     } [EOL]     _buckets[index] = tail; [EOL] }
public Bucket(Bucket next, String key, SettableBeanProperty value, int index) { [EOL]     this.next = next; [EOL]     this.key = key; [EOL]     this.value = value; [EOL]     this.index = index; [EOL] }
public Bucket(Bucket next, String key, SettableBeanProperty value, int index) { [EOL]     this.next = next; [EOL]     this.key = key; [EOL]     this.value = value; [EOL]     this.index = index; [EOL] }
public IteratorImpl(Bucket[] buckets) { [EOL]     _buckets = buckets; [EOL]     int i = 0; [EOL]     for (int len = _buckets.length; i < len; ) { [EOL]         Bucket b = _buckets[i++]; [EOL]         if (b != null) { [EOL]             _currentBucket = b; [EOL]             break; [EOL]         } [EOL]     } [EOL]     _nextBucketIndex = i; [EOL] }
public IteratorImpl(Bucket[] buckets) { [EOL]     _buckets = buckets; [EOL]     int i = 0; [EOL]     for (int len = _buckets.length; i < len; ) { [EOL]         Bucket b = _buckets[i++]; [EOL]         if (b != null) { [EOL]             _currentBucket = b; [EOL]             break; [EOL]         } [EOL]     } [EOL]     _nextBucketIndex = i; [EOL] }
public IteratorImpl(Bucket[] buckets) { [EOL]     _buckets = buckets; [EOL]     int i = 0; [EOL]     for (int len = _buckets.length; i < len; ) { [EOL]         Bucket b = _buckets[i++]; [EOL]         if (b != null) { [EOL]             _currentBucket = b; [EOL]             break; [EOL]         } [EOL]     } [EOL]     _nextBucketIndex = i; [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     return _currentBucket != null; [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     return _currentBucket != null; [EOL] }
@Override [EOL] public SettableBeanProperty next() { [EOL]     Bucket curr = _currentBucket; [EOL]     if (curr == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     Bucket b = curr.next; [EOL]     while (b == null && _nextBucketIndex < _buckets.length) { [EOL]         b = _buckets[_nextBucketIndex++]; [EOL]     } [EOL]     _currentBucket = b; [EOL]     return curr.value; [EOL] }
@Override [EOL] public SettableBeanProperty next() { [EOL]     Bucket curr = _currentBucket; [EOL]     if (curr == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     Bucket b = curr.next; [EOL]     while (b == null && _nextBucketIndex < _buckets.length) { [EOL]         b = _buckets[_nextBucketIndex++]; [EOL]     } [EOL]     _currentBucket = b; [EOL]     return curr.value; [EOL] }
@Override [EOL] public SettableBeanProperty next() { [EOL]     Bucket curr = _currentBucket; [EOL]     if (curr == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     Bucket b = curr.next; [EOL]     while (b == null && _nextBucketIndex < _buckets.length) { [EOL]         b = _buckets[_nextBucketIndex++]; [EOL]     } [EOL]     _currentBucket = b; [EOL]     return curr.value; [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public BooleanDeser() { [EOL]     super(boolean[].class); [EOL] }
@Override [EOL] public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.BooleanBuilder builder = ctxt.getArrayBuilders().getBooleanBuilder(); [EOL]     boolean[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         boolean value = _parseBooleanPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.BooleanBuilder builder = ctxt.getArrayBuilders().getBooleanBuilder(); [EOL]     boolean[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         boolean value = _parseBooleanPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.BooleanBuilder builder = ctxt.getArrayBuilders().getBooleanBuilder(); [EOL]     boolean[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         boolean value = _parseBooleanPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.BooleanBuilder builder = ctxt.getArrayBuilders().getBooleanBuilder(); [EOL]     boolean[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         boolean value = _parseBooleanPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL]     short[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         short value = _parseShortPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL]     short[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         short value = _parseShortPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL]     short[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         short value = _parseShortPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL]     short[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         short value = _parseShortPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL]     int[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         int value = _parseIntPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL]     int[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         int value = _parseIntPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL]     int[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         int value = _parseIntPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL]     int[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         int value = _parseIntPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         if (jp.getText().length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new int[] { _parseIntPrimitive(jp, ctxt) }; [EOL] }
private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         if (jp.getText().length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new int[] { _parseIntPrimitive(jp, ctxt) }; [EOL] }
private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         if (jp.getText().length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new int[] { _parseIntPrimitive(jp, ctxt) }; [EOL] }
private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         if (jp.getText().length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new int[] { _parseIntPrimitive(jp, ctxt) }; [EOL] }
public IndexedListSerializer(IndexedListSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
public IndexedListSerializer(IndexedListSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
@Override [EOL] public IndexedListSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     return new IndexedListSerializer(this, property, vts, elementSerializer); [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public AsArrayTypeSerializer(TypeIdResolver idRes, BeanProperty property) { [EOL]     super(idRes, property); [EOL] }
public AsArrayTypeSerializer(TypeIdResolver idRes, BeanProperty property) { [EOL]     super(idRes, property); [EOL] }
public AsArrayTypeSerializer(TypeIdResolver idRes, BeanProperty property) { [EOL]     super(idRes, property); [EOL] }
@Override [EOL] public AsArrayTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsArrayTypeSerializer(this._idResolver, prop); [EOL] }
@Override [EOL] public AsArrayTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsArrayTypeSerializer(this._idResolver, prop); [EOL] }
@Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValue(value)); [EOL]     jgen.writeStartObject(); [EOL] }
@Override [EOL] public void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValue(value)); [EOL] }
@Override [EOL] public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndObject(); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndArray(); [EOL] }
public final NullNode nullNode() { [EOL]     return _nodeFactory.nullNode(); [EOL] }
public final NumericNode numberNode(int v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(int v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(int v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(double v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(double v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(double v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final BinaryNode binaryNode(byte[] data) { [EOL]     return _nodeFactory.binaryNode(data); [EOL] }
public final BinaryNode binaryNode(byte[] data) { [EOL]     return _nodeFactory.binaryNode(data); [EOL] }
public StringSerializer() { [EOL]     super(String.class); [EOL] }
@Override [EOL] public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value); [EOL] }
@Override [EOL] public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value); [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     deserializeSetAndReturn(jp, ctxt, instance); [EOL] }
@Override [EOL] public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     Object id = _valueDeserializer.deserialize(jp, ctxt); [EOL]     ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator); [EOL]     roid.bindItem(instance); [EOL]     SettableBeanProperty idProp = _objectIdReader.idProperty; [EOL]     if (idProp != null) { [EOL]         return idProp.setAndReturn(instance, id); [EOL]     } [EOL]     return instance; [EOL] }
@Override [EOL] public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     Object id = _valueDeserializer.deserialize(jp, ctxt); [EOL]     ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator); [EOL]     roid.bindItem(instance); [EOL]     SettableBeanProperty idProp = _objectIdReader.idProperty; [EOL]     if (idProp != null) { [EOL]         return idProp.setAndReturn(instance, id); [EOL]     } [EOL]     return instance; [EOL] }
public CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator) { [EOL]     this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null); [EOL] }
public CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator) { [EOL]     this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null); [EOL] }
protected CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator, JsonDeserializer<Object> delegateDeser) { [EOL]     super(collectionType.getRawClass()); [EOL]     _collectionType = collectionType; [EOL]     _valueDeserializer = valueDeser; [EOL]     _valueTypeDeserializer = valueTypeDeser; [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _delegateDeserializer = delegateDeser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
private SerializationFeature(boolean defaultState) { [EOL]     _defaultState = defaultState; [EOL] }
private SerializationFeature(boolean defaultState) { [EOL]     _defaultState = defaultState; [EOL] }
public NamedType(Class<?> c, String name) { [EOL]     _class = c; [EOL]     _hashCode = c.getName().hashCode(); [EOL]     setName(name); [EOL] }
public NamedType(Class<?> c, String name) { [EOL]     _class = c; [EOL]     _hashCode = c.getName().hashCode(); [EOL]     setName(name); [EOL] }
public void setName(String name) { [EOL]     _name = (name == null || name.length() == 0) ? null : name; [EOL] }
public void setName(String name) { [EOL]     _name = (name == null || name.length() == 0) ? null : name; [EOL] }
public void setName(String name) { [EOL]     _name = (name == null || name.length() == 0) ? null : name; [EOL] }
public boolean hasName() { [EOL]     return _name != null; [EOL] }
public boolean hasName() { [EOL]     return _name != null; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _hashCode; [EOL] }
public ObjectArraySerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> elementSerializer) { [EOL]     super(Object[].class, null); [EOL]     _elementType = elemType; [EOL]     _staticTyping = staticTyping; [EOL]     _valueTypeSerializer = vts; [EOL]     _dynamicSerializers = PropertySerializerMap.emptyMap(); [EOL]     _elementSerializer = elementSerializer; [EOL] }
public ObjectArraySerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> elementSerializer) { [EOL]     super(Object[].class, null); [EOL]     _elementType = elemType; [EOL]     _staticTyping = staticTyping; [EOL]     _valueTypeSerializer = vts; [EOL]     _dynamicSerializers = PropertySerializerMap.emptyMap(); [EOL]     _elementSerializer = elementSerializer; [EOL] }
public ObjectArraySerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> elementSerializer) { [EOL]     super(Object[].class, null); [EOL]     _elementType = elemType; [EOL]     _staticTyping = staticTyping; [EOL]     _valueTypeSerializer = vts; [EOL]     _dynamicSerializers = PropertySerializerMap.emptyMap(); [EOL]     _elementSerializer = elementSerializer; [EOL] }
@SuppressWarnings("unchecked") [EOL] public ObjectArraySerializer(ObjectArraySerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     super(src, property); [EOL]     _elementType = src._elementType; [EOL]     _valueTypeSerializer = vts; [EOL]     _staticTyping = src._staticTyping; [EOL]     _dynamicSerializers = src._dynamicSerializers; [EOL]     _elementSerializer = (JsonSerializer<Object>) elementSerializer; [EOL] }
@SuppressWarnings("unchecked") [EOL] public ObjectArraySerializer(ObjectArraySerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     super(src, property); [EOL]     _elementType = src._elementType; [EOL]     _valueTypeSerializer = vts; [EOL]     _staticTyping = src._staticTyping; [EOL]     _dynamicSerializers = src._dynamicSerializers; [EOL]     _elementSerializer = (JsonSerializer<Object>) elementSerializer; [EOL] }
@Override [EOL] public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new ObjectArraySerializer(_elementType, _staticTyping, vts, _elementSerializer); [EOL] }
@Override [EOL] public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new ObjectArraySerializer(_elementType, _staticTyping, vts, _elementSerializer); [EOL] }
public ObjectArraySerializer withResolved(BeanProperty prop, TypeSerializer vts, JsonSerializer<?> ser) { [EOL]     if (_property == prop && ser == _elementSerializer && _valueTypeSerializer == vts) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectArraySerializer(this, prop, vts, ser); [EOL] }
public ObjectArraySerializer withResolved(BeanProperty prop, TypeSerializer vts, JsonSerializer<?> ser) { [EOL]     if (_property == prop && ser == _elementSerializer && _valueTypeSerializer == vts) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectArraySerializer(this, prop, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer vts = _valueTypeSerializer; [EOL]     if (vts != null) { [EOL]         vts = vts.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_elementType != null) { [EOL]             if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                 ser = provider.findValueSerializer(_elementType, property); [EOL]             } [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     return withResolved(property, vts, ser); [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_elementType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]             } [EOL]             serializer.serialize(elem, jgen, provider); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeTypedContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]             } [EOL]             serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeTypedContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]             } [EOL]             serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeTypedContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]             } [EOL]             serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
public void serializeTypedContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     Object elem = null; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             elem = value[i]; [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]                 continue; [EOL]             } [EOL]             Class<?> cc = elem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]             } [EOL]             serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, elem, i); [EOL]     } [EOL] }
protected StdScalarDeserializer(Class<?> vc) { [EOL]     super(vc); [EOL] }
private ReadOnlyClassToSerializerMap(JsonSerializerMap map) { [EOL]     _map = map; [EOL] }
public ReadOnlyClassToSerializerMap instance() { [EOL]     return new ReadOnlyClassToSerializerMap(_map); [EOL] }
public ReadOnlyClassToSerializerMap instance() { [EOL]     return new ReadOnlyClassToSerializerMap(_map); [EOL] }
public static ReadOnlyClassToSerializerMap from(HashMap<TypeKey, JsonSerializer<Object>> src) { [EOL]     return new ReadOnlyClassToSerializerMap(new JsonSerializerMap(src)); [EOL] }
public static ReadOnlyClassToSerializerMap from(HashMap<TypeKey, JsonSerializer<Object>> src) { [EOL]     return new ReadOnlyClassToSerializerMap(new JsonSerializerMap(src)); [EOL] }
public JsonSerializer<Object> typedValueSerializer(Class<?> cls) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(cls, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(cls); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> typedValueSerializer(Class<?> cls) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(cls, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(cls); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> untypedValueSerializer(JavaType type) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(type, false); [EOL]     } else { [EOL]         _cacheKey.resetUntyped(type); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> untypedValueSerializer(JavaType type) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(type, false); [EOL]     } else { [EOL]         _cacheKey.resetUntyped(type); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> untypedValueSerializer(Class<?> cls) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(cls, false); [EOL]     } else { [EOL]         _cacheKey.resetUntyped(cls); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> untypedValueSerializer(Class<?> cls) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(cls, false); [EOL]     } else { [EOL]         _cacheKey.resetUntyped(cls); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JSONPObject(String function, Object value, JavaType asType) { [EOL]     _function = function; [EOL]     _value = value; [EOL]     _serializationType = asType; [EOL] }
public JSONPObject(String function, Object value, JavaType asType) { [EOL]     _function = function; [EOL]     _value = value; [EOL]     _serializationType = asType; [EOL] }
@Override [EOL] public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jgen.writeRaw(_function); [EOL]     jgen.writeRaw('('); [EOL]     if (_value == null) { [EOL]         provider.defaultSerializeNull(jgen); [EOL]     } else if (_serializationType != null) { [EOL]         provider.findTypedValueSerializer(_serializationType, true, null).serialize(_value, jgen, provider); [EOL]     } else { [EOL]         Class<?> cls = _value.getClass(); [EOL]         provider.findTypedValueSerializer(cls, true, null).serialize(_value, jgen, provider); [EOL]     } [EOL]     jgen.writeRaw(')'); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jgen.writeRaw(_function); [EOL]     jgen.writeRaw('('); [EOL]     if (_value == null) { [EOL]         provider.defaultSerializeNull(jgen); [EOL]     } else if (_serializationType != null) { [EOL]         provider.findTypedValueSerializer(_serializationType, true, null).serialize(_value, jgen, provider); [EOL]     } else { [EOL]         Class<?> cls = _value.getClass(); [EOL]         provider.findTypedValueSerializer(cls, true, null).serialize(_value, jgen, provider); [EOL]     } [EOL]     jgen.writeRaw(')'); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jgen.writeRaw(_function); [EOL]     jgen.writeRaw('('); [EOL]     if (_value == null) { [EOL]         provider.defaultSerializeNull(jgen); [EOL]     } else if (_serializationType != null) { [EOL]         provider.findTypedValueSerializer(_serializationType, true, null).serialize(_value, jgen, provider); [EOL]     } else { [EOL]         Class<?> cls = _value.getClass(); [EOL]         provider.findTypedValueSerializer(cls, true, null).serialize(_value, jgen, provider); [EOL]     } [EOL]     jgen.writeRaw(')'); [EOL] }
@Override [EOL] protected Iterable<Serializers> customSerializers() { [EOL]     return _factoryConfig.serializers(); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         if (!type.isEnumType()) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return constructBeanSerializer(prov, beanDesc); [EOL] }
public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         if (!type.isEnumType()) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return constructBeanSerializer(prov, beanDesc); [EOL] }
public JsonSerializer<Object> findBeanSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         if (!type.isEnumType()) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return constructBeanSerializer(prov, beanDesc); [EOL] }
public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType); [EOL]     if (b == null) { [EOL]         return createTypeSerializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai, baseType); [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType); [EOL]     if (b == null) { [EOL]         return createTypeSerializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai, baseType); [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { [EOL]     JavaType contentType = containerType.getContentType(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType); [EOL]     if (b == null) { [EOL]         return createTypeSerializer(config, contentType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai, contentType); [EOL]     return b.buildTypeSerializer(config, contentType, subtypes); [EOL] }
public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { [EOL]     JavaType contentType = containerType.getContentType(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType); [EOL]     if (b == null) { [EOL]         return createTypeSerializer(config, contentType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai, contentType); [EOL]     return b.buildTypeSerializer(config, contentType, subtypes); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews) { [EOL]     return FilteredBeanPropertyWriter.constructViewBased(writer, inViews); [EOL] }
protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews) { [EOL]     return FilteredBeanPropertyWriter.constructViewBased(writer, inViews); [EOL] }
protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews) { [EOL]     return FilteredBeanPropertyWriter.constructViewBased(writer, inViews); [EOL] }
protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc) { [EOL]     return new PropertyBuilder(config, beanDesc); [EOL] }
protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) { [EOL]     return new BeanSerializerBuilder(beanDesc); [EOL] }
protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { [EOL]     return config.getAnnotationIntrospector().findFilterId(beanDesc.getClassInfo()); [EOL] }
protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { [EOL]     return config.getAnnotationIntrospector().findFilterId(beanDesc.getClassInfo()); [EOL] }
protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) { [EOL]     return config.getAnnotationIntrospector().findFilterId(beanDesc.getClassInfo()); [EOL] }
protected boolean isPotentialBeanType(Class<?> type) { [EOL]     return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type); [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     String[] ignored = intr.findPropertiesToIgnore(ac); [EOL]     if (ignored != null && ignored.length > 0) { [EOL]         HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored); [EOL]         Iterator<BeanPropertyWriter> it = props.iterator(); [EOL]         while (it.hasNext()) { [EOL]             if (ignoredSet.contains(it.next().getName())) { [EOL]                 it.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return props; [EOL] }
protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> props) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     String[] ignored = intr.findPropertiesToIgnore(ac); [EOL]     if (ignored != null && ignored.length > 0) { [EOL]         HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored); [EOL]         Iterator<BeanPropertyWriter> it = props.iterator(); [EOL]         while (it.hasNext()) { [EOL]             if (ignoredSet.contains(it.next().getName())) { [EOL]                 it.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return props; [EOL] }
protected void processViews(SerializationConfig config, BeanSerializerBuilder builder) { [EOL]     List<BeanPropertyWriter> props = builder.getProperties(); [EOL]     boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION); [EOL]     final int propCount = props.size(); [EOL]     int viewsFound = 0; [EOL]     BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount]; [EOL]     for (int i = 0; i < propCount; ++i) { [EOL]         BeanPropertyWriter bpw = props.get(i); [EOL]         Class<?>[] views = bpw.getViews(); [EOL]         if (views == null) { [EOL]             if (includeByDefault) { [EOL]                 filtered[i] = bpw; [EOL]             } [EOL]         } else { [EOL]             ++viewsFound; [EOL]             filtered[i] = constructFilteredBeanWriter(bpw, views); [EOL]         } [EOL]     } [EOL]     if (includeByDefault && viewsFound == 0) { [EOL]         return; [EOL]     } [EOL]     builder.setFilteredProperties(filtered); [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException { [EOL]     final String name = propDef.getName(); [EOL]     if (prov.canOverrideAccessModifiers()) { [EOL]         accessor.fixAccess(); [EOL]     } [EOL]     JavaType type = accessor.getType(typeContext); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(), pb.getClassAnnotations(), accessor, propDef.isRequired()); [EOL]     JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov, accessor); [EOL]     if (annotatedSerializer instanceof ResolvableSerializer) { [EOL]         ((ResolvableSerializer) annotatedSerializer).resolve(prov); [EOL]     } [EOL]     if (annotatedSerializer instanceof ContextualSerializer) { [EOL]         annotatedSerializer = ((ContextualSerializer) annotatedSerializer).createContextual(prov, property); [EOL]     } [EOL]     TypeSerializer contentTypeSer = null; [EOL]     if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) { [EOL]         contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor); [EOL]     } [EOL]     TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor); [EOL]     BeanPropertyWriter pbw = pb.buildWriter(propDef, type, annotatedSerializer, typeSer, contentTypeSer, accessor, staticTyping); [EOL]     return pbw; [EOL] }
protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException { [EOL]     final String name = propDef.getName(); [EOL]     if (prov.canOverrideAccessModifiers()) { [EOL]         accessor.fixAccess(); [EOL]     } [EOL]     JavaType type = accessor.getType(typeContext); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(), pb.getClassAnnotations(), accessor, propDef.isRequired()); [EOL]     JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov, accessor); [EOL]     if (annotatedSerializer instanceof ResolvableSerializer) { [EOL]         ((ResolvableSerializer) annotatedSerializer).resolve(prov); [EOL]     } [EOL]     if (annotatedSerializer instanceof ContextualSerializer) { [EOL]         annotatedSerializer = ((ContextualSerializer) annotatedSerializer).createContextual(prov, property); [EOL]     } [EOL]     TypeSerializer contentTypeSer = null; [EOL]     if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) { [EOL]         contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor); [EOL]     } [EOL]     TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor); [EOL]     BeanPropertyWriter pbw = pb.buildWriter(propDef, type, annotatedSerializer, typeSer, contentTypeSer, accessor, staticTyping); [EOL]     return pbw; [EOL] }
protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException { [EOL]     final String name = propDef.getName(); [EOL]     if (prov.canOverrideAccessModifiers()) { [EOL]         accessor.fixAccess(); [EOL]     } [EOL]     JavaType type = accessor.getType(typeContext); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(), pb.getClassAnnotations(), accessor, propDef.isRequired()); [EOL]     JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov, accessor); [EOL]     if (annotatedSerializer instanceof ResolvableSerializer) { [EOL]         ((ResolvableSerializer) annotatedSerializer).resolve(prov); [EOL]     } [EOL]     if (annotatedSerializer instanceof ContextualSerializer) { [EOL]         annotatedSerializer = ((ContextualSerializer) annotatedSerializer).createContextual(prov, property); [EOL]     } [EOL]     TypeSerializer contentTypeSer = null; [EOL]     if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) { [EOL]         contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor); [EOL]     } [EOL]     TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor); [EOL]     BeanPropertyWriter pbw = pb.buildWriter(propDef, type, annotatedSerializer, typeSer, contentTypeSer, accessor, staticTyping); [EOL]     return pbw; [EOL] }
protected BeanPropertyWriter _constructWriter(SerializerProvider prov, BeanPropertyDefinition propDef, TypeBindings typeContext, PropertyBuilder pb, boolean staticTyping, AnnotatedMember accessor) throws JsonMappingException { [EOL]     final String name = propDef.getName(); [EOL]     if (prov.canOverrideAccessModifiers()) { [EOL]         accessor.fixAccess(); [EOL]     } [EOL]     JavaType type = accessor.getType(typeContext); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(), pb.getClassAnnotations(), accessor, propDef.isRequired()); [EOL]     JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov, accessor); [EOL]     if (annotatedSerializer instanceof ResolvableSerializer) { [EOL]         ((ResolvableSerializer) annotatedSerializer).resolve(prov); [EOL]     } [EOL]     if (annotatedSerializer instanceof ContextualSerializer) { [EOL]         annotatedSerializer = ((ContextualSerializer) annotatedSerializer).createContextual(prov, property); [EOL]     } [EOL]     TypeSerializer contentTypeSer = null; [EOL]     if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) { [EOL]         contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor); [EOL]     } [EOL]     TypeSerializer typeSer = findPropertyTypeSerializer(type, prov.getConfig(), accessor); [EOL]     BeanPropertyWriter pbw = pb.buildWriter(propDef, type, annotatedSerializer, typeSer, contentTypeSer, accessor, staticTyping); [EOL]     return pbw; [EOL] }
public JavaType constructType(Type type) { [EOL]     return getTypeFactory().constructType(type); [EOL] }
public JavaType constructType(Type type) { [EOL]     return getTypeFactory().constructType(type); [EOL] }
public JavaType constructType(Type type) { [EOL]     return getTypeFactory().constructType(type); [EOL] }
public AnnotatedConstructor(Constructor<?> constructor, AnnotationMap classAnn, AnnotationMap[] paramAnn) { [EOL]     super(classAnn, paramAnn); [EOL]     if (constructor == null) { [EOL]         throw new IllegalArgumentException("Null constructor not allowed"); [EOL]     } [EOL]     _constructor = constructor; [EOL] }
public AnnotatedConstructor(Constructor<?> constructor, AnnotationMap classAnn, AnnotationMap[] paramAnn) { [EOL]     super(classAnn, paramAnn); [EOL]     if (constructor == null) { [EOL]         throw new IllegalArgumentException("Null constructor not allowed"); [EOL]     } [EOL]     _constructor = constructor; [EOL] }
@Override [EOL] public Constructor<?> getAnnotated() { [EOL]     return _constructor; [EOL] }
@Override [EOL] public String getName() { [EOL]     return _constructor.getName(); [EOL] }
@Override [EOL] public int getParameterCount() { [EOL]     return _constructor.getParameterTypes().length; [EOL] }
@Override [EOL] public int getParameterCount() { [EOL]     return _constructor.getParameterTypes().length; [EOL] }
@Override [EOL] public Class<?> getRawParameterType(int index) { [EOL]     Class<?>[] types = _constructor.getParameterTypes(); [EOL]     return (index >= types.length) ? null : types[index]; [EOL] }
@Override [EOL] public Class<?> getRawParameterType(int index) { [EOL]     Class<?>[] types = _constructor.getParameterTypes(); [EOL]     return (index >= types.length) ? null : types[index]; [EOL] }
@Override [EOL] public Type getGenericParameterType(int index) { [EOL]     Type[] types = _constructor.getGenericParameterTypes(); [EOL]     return (index >= types.length) ? null : types[index]; [EOL] }
@Override [EOL] public Type getGenericParameterType(int index) { [EOL]     Type[] types = _constructor.getGenericParameterTypes(); [EOL]     return (index >= types.length) ? null : types[index]; [EOL] }
@Override [EOL] public final Object call(Object[] args) throws Exception { [EOL]     return _constructor.newInstance(args); [EOL] }
@Override [EOL] public final Object call(Object[] args) throws Exception { [EOL]     return _constructor.newInstance(args); [EOL] }
@Override [EOL] public final Object call(Object[] args) throws Exception { [EOL]     return _constructor.newInstance(args); [EOL] }
@Override [EOL] public Member getMember() { [EOL]     return _constructor; [EOL] }
@Override [EOL] public String toString() { [EOL]     return "[constructor for " + getName() + ", annotations: " + _annotations + "]"; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property); [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     return withResolved(kd, vd, vtd); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property); [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     return withResolved(kd, vd, vtd); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property); [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     return withResolved(kd, vd, vtd); [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeRawValue(value.toString()); [EOL] }
@Override [EOL] public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeRawValue(value.toString()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl) { [EOL]     super(vc); [EOL]     _nullValue = nvl; [EOL] }
protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl) { [EOL]     super(vc); [EOL]     _nullValue = nvl; [EOL] }
public BooleanDeserializer(Class<Boolean> cls, Boolean nvl) { [EOL]     super(cls, nvl); [EOL] }
public BooleanDeserializer(Class<Boolean> cls, Boolean nvl) { [EOL]     super(cls, nvl); [EOL] }
public BooleanDeserializer(Class<Boolean> cls, Boolean nvl) { [EOL]     super(cls, nvl); [EOL] }
@Override [EOL] public Boolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseBoolean(jp, ctxt); [EOL] }
@Override [EOL] public Boolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseBoolean(jp, ctxt); [EOL] }
@Override [EOL] public Boolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseBoolean(jp, ctxt); [EOL] }
@Override [EOL] public Boolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseBoolean(jp, ctxt); [EOL] }
public ByteDeserializer(Class<Byte> cls, Byte nvl) { [EOL]     super(cls, nvl); [EOL] }
public ByteDeserializer(Class<Byte> cls, Byte nvl) { [EOL]     super(cls, nvl); [EOL] }
@Override [EOL] public Byte deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseByte(jp, ctxt); [EOL] }
@Override [EOL] public Byte deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseByte(jp, ctxt); [EOL] }
@Override [EOL] public Byte deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseByte(jp, ctxt); [EOL] }
public ShortDeserializer(Class<Short> cls, Short nvl) { [EOL]     super(cls, nvl); [EOL] }
public ShortDeserializer(Class<Short> cls, Short nvl) { [EOL]     super(cls, nvl); [EOL] }
@Override [EOL] public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseShort(jp, ctxt); [EOL] }
@Override [EOL] public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseShort(jp, ctxt); [EOL] }
@Override [EOL] public Short deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseShort(jp, ctxt); [EOL] }
public CharacterDeserializer(Class<Character> cls, Character nvl) { [EOL]     super(cls, nvl); [EOL] }
public CharacterDeserializer(Class<Character> cls, Character nvl) { [EOL]     super(cls, nvl); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Character deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     int value; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         value = jp.getIntValue(); [EOL]         if (value >= 0 && value <= 0xFFFF) { [EOL]             return Character.valueOf((char) value); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText(); [EOL]         if (text.length() == 1) { [EOL]             return Character.valueOf(text.charAt(0)); [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Character) getEmptyValue(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
public IntegerDeserializer(Class<Integer> cls, Integer nvl) { [EOL]     super(cls, nvl); [EOL] }
public IntegerDeserializer(Class<Integer> cls, Integer nvl) { [EOL]     super(cls, nvl); [EOL] }
@Override [EOL] public Integer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseInteger(jp, ctxt); [EOL] }
@Override [EOL] public Integer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseInteger(jp, ctxt); [EOL] }
public LongDeserializer(Class<Long> cls, Long nvl) { [EOL]     super(cls, nvl); [EOL] }
public LongDeserializer(Class<Long> cls, Long nvl) { [EOL]     super(cls, nvl); [EOL] }
@Override [EOL] public Long deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseLong(jp, ctxt); [EOL] }
@Override [EOL] public Long deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseLong(jp, ctxt); [EOL] }
public FloatDeserializer(Class<Float> cls, Float nvl) { [EOL]     super(cls, nvl); [EOL] }
public FloatDeserializer(Class<Float> cls, Float nvl) { [EOL]     super(cls, nvl); [EOL] }
@Override [EOL] public Float deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseFloat(jp, ctxt); [EOL] }
@Override [EOL] public Float deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseFloat(jp, ctxt); [EOL] }
public NumberDeserializer() { [EOL]     super(Number.class); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
public BigDecimalDeserializer() { [EOL]     super(BigDecimal.class); [EOL] }
@Override [EOL] public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             return new BigDecimal(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             return new BigDecimal(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             return new BigDecimal(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             return new BigDecimal(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             return new BigDecimal(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             return new BigDecimal(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
public static StringKD forType(Class<?> nominalType) { [EOL]     if (nominalType == String.class) { [EOL]         return sString; [EOL]     } [EOL]     if (nominalType == Object.class) { [EOL]         return sObject; [EOL]     } [EOL]     return new StringKD(nominalType); [EOL] }
public static StringKD forType(Class<?> nominalType) { [EOL]     if (nominalType == String.class) { [EOL]         return sString; [EOL]     } [EOL]     if (nominalType == Object.class) { [EOL]         return sObject; [EOL]     } [EOL]     return new StringKD(nominalType); [EOL] }
public static StringKD forType(Class<?> nominalType) { [EOL]     if (nominalType == String.class) { [EOL]         return sString; [EOL]     } [EOL]     if (nominalType == Object.class) { [EOL]         return sObject; [EOL]     } [EOL]     return new StringKD(nominalType); [EOL] }
public StringCtorKeyDeserializer(Constructor<?> ctor) { [EOL]     super(ctor.getDeclaringClass()); [EOL]     _ctor = ctor; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws Exception { [EOL]     return _ctor.newInstance(key); [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws Exception { [EOL]     return _ctor.newInstance(key); [EOL] }
public final SerializerAndMapResult findAndAddSerializer(Class<?> type, SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> serializer = provider.findValueSerializer(type, property); [EOL]     return new SerializerAndMapResult(serializer, newWith(type, serializer)); [EOL] }
public final SerializerAndMapResult findAndAddSerializer(Class<?> type, SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> serializer = provider.findValueSerializer(type, property); [EOL]     return new SerializerAndMapResult(serializer, newWith(type, serializer)); [EOL] }
public static PropertySerializerMap emptyMap() { [EOL]     return Empty.instance; [EOL] }
public SerializerAndMapResult(JsonSerializer<Object> serializer, PropertySerializerMap map) { [EOL]     this.serializer = serializer; [EOL]     this.map = map; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     return null; [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     return new Single(type, serializer); [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     return new Single(type, serializer); [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     return new Single(type, serializer); [EOL] }
public Single(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     _type = type; [EOL]     _serializer = serializer; [EOL] }
public Single(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     _type = type; [EOL]     _serializer = serializer; [EOL] }
public Single(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     _type = type; [EOL]     _serializer = serializer; [EOL] }
public Single(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     _type = type; [EOL]     _serializer = serializer; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     for (int i = 0, len = _entries.length; i < len; ++i) { [EOL]         TypeAndSerializer entry = _entries[i]; [EOL]         if (entry.type == type) { [EOL]             return entry.serializer; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type) { [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     Constructor<?> ctor = beanDesc.findSingleArgConstructor(String.class); [EOL]     if (ctor != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(ctor); [EOL]         } [EOL]         return new StdKeyDeserializer.StringCtorKeyDeserializer(ctor); [EOL]     } [EOL]     Method m = beanDesc.findFactoryMethod(String.class); [EOL]     if (m != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         return new StdKeyDeserializer.StringFactoryKeyDeserializer(m); [EOL]     } [EOL]     return null; [EOL] }
public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type) { [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     Constructor<?> ctor = beanDesc.findSingleArgConstructor(String.class); [EOL]     if (ctor != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(ctor); [EOL]         } [EOL]         return new StdKeyDeserializer.StringCtorKeyDeserializer(ctor); [EOL]     } [EOL]     Method m = beanDesc.findFactoryMethod(String.class); [EOL]     if (m != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         return new StdKeyDeserializer.StringFactoryKeyDeserializer(m); [EOL]     } [EOL]     return null; [EOL] }
public CollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> valueSerializer) { [EOL]     super(Collection.class, elemType, staticTyping, vts, property, valueSerializer); [EOL] }
public CollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property, JsonSerializer<Object> valueSerializer) { [EOL]     super(Collection.class, elemType, staticTyping, vts, property, valueSerializer); [EOL] }
public CollectionSerializer(CollectionSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
public CollectionSerializer(CollectionSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
@Override [EOL] public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new CollectionSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer); [EOL] }
@Override [EOL] public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new CollectionSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer); [EOL] }
@Override [EOL] public CollectionSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     return new CollectionSerializer(this, property, vts, elementSerializer); [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
private DeserializationFeature(boolean defaultState) { [EOL]     _defaultState = defaultState; [EOL] }
private DeserializationFeature(boolean defaultState) { [EOL]     _defaultState = defaultState; [EOL] }
public SimpleKeyDeserializers() { [EOL] }
public SimpleKeyDeserializers addDeserializer(Class<?> forClass, KeyDeserializer deser) { [EOL]     if (_classMappings == null) { [EOL]         _classMappings = new HashMap<ClassKey, KeyDeserializer>(); [EOL]     } [EOL]     _classMappings.put(new ClassKey(forClass), deser); [EOL]     return this; [EOL] }
public SimpleKeyDeserializers addDeserializer(Class<?> forClass, KeyDeserializer deser) { [EOL]     if (_classMappings == null) { [EOL]         _classMappings = new HashMap<ClassKey, KeyDeserializer>(); [EOL]     } [EOL]     _classMappings.put(new ClassKey(forClass), deser); [EOL]     return this; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     if (_classMappings == null) { [EOL]         return null; [EOL]     } [EOL]     return _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     if (_classMappings == null) { [EOL]         return null; [EOL]     } [EOL]     return _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
public AtomicReferenceSerializer() { [EOL]     super(AtomicReference.class, false); [EOL] }
@Override [EOL] public void serialize(AtomicReference<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     provider.defaultSerializeValue(value.get(), jgen); [EOL] }
@Override [EOL] public void serialize(AtomicReference<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     provider.defaultSerializeValue(value.get(), jgen); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public ObjectNode deepCopy() { [EOL]     ObjectNode ret = new ObjectNode(_nodeFactory); [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) ret._children.put(entry.getKey(), entry.getValue().deepCopy()); [EOL]     return ret; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public ObjectNode deepCopy() { [EOL]     ObjectNode ret = new ObjectNode(_nodeFactory); [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) ret._children.put(entry.getKey(), entry.getValue().deepCopy()); [EOL]     return ret; [EOL] }
public ObjectNode put(String fieldName, double v) { [EOL]     _children.put(fieldName, numberNode(v)); [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, byte[] v) { [EOL]     if (v == null) { [EOL]         _children.put(fieldName, nullNode()); [EOL]     } else { [EOL]         _children.put(fieldName, binaryNode(v)); [EOL]     } [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, byte[] v) { [EOL]     if (v == null) { [EOL]         _children.put(fieldName, nullNode()); [EOL]     } else { [EOL]         _children.put(fieldName, binaryNode(v)); [EOL]     } [EOL]     return this; [EOL] }
public JavaType getType(TypeBindings context) { [EOL]     return context.resolveType(getGenericType()); [EOL] }
public JavaType getType(TypeBindings context) { [EOL]     return context.resolveType(getGenericType()); [EOL] }
public static String okNameForGetter(AnnotatedMethod am) { [EOL]     String name = am.getName(); [EOL]     String str = okNameForIsGetter(am, name); [EOL]     if (str == null) { [EOL]         str = okNameForRegularGetter(am, name); [EOL]     } [EOL]     return str; [EOL] }
public static String okNameForGetter(AnnotatedMethod am) { [EOL]     String name = am.getName(); [EOL]     String str = okNameForIsGetter(am, name); [EOL]     if (str == null) { [EOL]         str = okNameForRegularGetter(am, name); [EOL]     } [EOL]     return str; [EOL] }
@Override [EOL] public JsonFactory copy() { [EOL]     _checkInvalidCopy(MappingJsonFactory.class); [EOL]     return new MappingJsonFactory(null); [EOL] }
public static IntNode valueOf(int i) { [EOL]     if (i > MAX_CANONICAL || i < MIN_CANONICAL) [EOL]         return new IntNode(i); [EOL]     return CANONICALS[i - MIN_CANONICAL]; [EOL] }
public static IntNode valueOf(int i) { [EOL]     if (i > MAX_CANONICAL || i < MIN_CANONICAL) [EOL]         return new IntNode(i); [EOL]     return CANONICALS[i - MIN_CANONICAL]; [EOL] }
public static IntNode valueOf(int i) { [EOL]     if (i > MAX_CANONICAL || i < MIN_CANONICAL) [EOL]         return new IntNode(i); [EOL]     return CANONICALS[i - MIN_CANONICAL]; [EOL] }
@Override [EOL] public JsonParser.NumberType numberType() { [EOL]     return JsonParser.NumberType.INT; [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((IntNode) o)._value == _value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value; [EOL] }
public ValueInstantiator constructValueInstantiator(DeserializationConfig config) { [EOL]     StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType()); [EOL]     JavaType delegateType; [EOL]     if (_delegateCreator == null) { [EOL]         delegateType = null; [EOL]     } else { [EOL]         int ix = 0; [EOL]         if (_delegateArgs != null) { [EOL]             for (int i = 0, len = _delegateArgs.length; i < len; ++i) { [EOL]                 if (_delegateArgs[i] == null) { [EOL]                     ix = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         TypeBindings bindings = _beanDesc.bindingsForBeanType(); [EOL]         delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix)); [EOL]     } [EOL]     inst.configureFromObjectSettings(_defaultConstructor, _delegateCreator, delegateType, _delegateArgs, _propertyBasedCreator, _propertyBasedArgs); [EOL]     inst.configureFromStringCreator(_stringCreator); [EOL]     inst.configureFromIntCreator(_intCreator); [EOL]     inst.configureFromLongCreator(_longCreator); [EOL]     inst.configureFromDoubleCreator(_doubleCreator); [EOL]     inst.configureFromBooleanCreator(_booleanCreator); [EOL]     inst.configureIncompleteParameter(_incompleteParameter); [EOL]     return inst; [EOL] }
public ValueInstantiator constructValueInstantiator(DeserializationConfig config) { [EOL]     StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType()); [EOL]     JavaType delegateType; [EOL]     if (_delegateCreator == null) { [EOL]         delegateType = null; [EOL]     } else { [EOL]         int ix = 0; [EOL]         if (_delegateArgs != null) { [EOL]             for (int i = 0, len = _delegateArgs.length; i < len; ++i) { [EOL]                 if (_delegateArgs[i] == null) { [EOL]                     ix = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         TypeBindings bindings = _beanDesc.bindingsForBeanType(); [EOL]         delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix)); [EOL]     } [EOL]     inst.configureFromObjectSettings(_defaultConstructor, _delegateCreator, delegateType, _delegateArgs, _propertyBasedCreator, _propertyBasedArgs); [EOL]     inst.configureFromStringCreator(_stringCreator); [EOL]     inst.configureFromIntCreator(_intCreator); [EOL]     inst.configureFromLongCreator(_longCreator); [EOL]     inst.configureFromDoubleCreator(_doubleCreator); [EOL]     inst.configureFromBooleanCreator(_booleanCreator); [EOL]     inst.configureIncompleteParameter(_incompleteParameter); [EOL]     return inst; [EOL] }
public ValueInstantiator constructValueInstantiator(DeserializationConfig config) { [EOL]     StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType()); [EOL]     JavaType delegateType; [EOL]     if (_delegateCreator == null) { [EOL]         delegateType = null; [EOL]     } else { [EOL]         int ix = 0; [EOL]         if (_delegateArgs != null) { [EOL]             for (int i = 0, len = _delegateArgs.length; i < len; ++i) { [EOL]                 if (_delegateArgs[i] == null) { [EOL]                     ix = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         TypeBindings bindings = _beanDesc.bindingsForBeanType(); [EOL]         delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix)); [EOL]     } [EOL]     inst.configureFromObjectSettings(_defaultConstructor, _delegateCreator, delegateType, _delegateArgs, _propertyBasedCreator, _propertyBasedArgs); [EOL]     inst.configureFromStringCreator(_stringCreator); [EOL]     inst.configureFromIntCreator(_intCreator); [EOL]     inst.configureFromLongCreator(_longCreator); [EOL]     inst.configureFromDoubleCreator(_doubleCreator); [EOL]     inst.configureFromBooleanCreator(_booleanCreator); [EOL]     inst.configureIncompleteParameter(_incompleteParameter); [EOL]     return inst; [EOL] }
public void setDefaultCreator(AnnotatedWithParams creator) { [EOL]     if (creator instanceof AnnotatedConstructor) { [EOL]         setDefaultConstructor((AnnotatedConstructor) creator); [EOL]         return; [EOL]     } [EOL]     _defaultConstructor = _fixAccess(creator); [EOL] }
public void setDefaultCreator(AnnotatedWithParams creator) { [EOL]     if (creator instanceof AnnotatedConstructor) { [EOL]         setDefaultConstructor((AnnotatedConstructor) creator); [EOL]         return; [EOL]     } [EOL]     _defaultConstructor = _fixAccess(creator); [EOL] }
public void addStringCreator(AnnotatedWithParams creator) { [EOL]     _stringCreator = verifyNonDup(creator, _stringCreator, "String"); [EOL] }
public void addStringCreator(AnnotatedWithParams creator) { [EOL]     _stringCreator = verifyNonDup(creator, _stringCreator, "String"); [EOL] }
public void addStringCreator(AnnotatedWithParams creator) { [EOL]     _stringCreator = verifyNonDup(creator, _stringCreator, "String"); [EOL] }
public void addLongCreator(AnnotatedWithParams creator) { [EOL]     _longCreator = verifyNonDup(creator, _longCreator, "long"); [EOL] }
public void addLongCreator(AnnotatedWithParams creator) { [EOL]     _longCreator = verifyNonDup(creator, _longCreator, "long"); [EOL] }
public void addLongCreator(AnnotatedWithParams creator) { [EOL]     _longCreator = verifyNonDup(creator, _longCreator, "long"); [EOL] }
public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) { [EOL]     _delegateCreator = verifyNonDup(creator, _delegateCreator, "delegate"); [EOL]     _delegateArgs = injectables; [EOL] }
public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) { [EOL]     _delegateCreator = verifyNonDup(creator, _delegateCreator, "delegate"); [EOL]     _delegateArgs = injectables; [EOL] }
public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) { [EOL]     _delegateCreator = verifyNonDup(creator, _delegateCreator, "delegate"); [EOL]     _delegateArgs = injectables; [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
public void addIncompeteParameter(AnnotatedParameter parameter) { [EOL]     if (_incompleteParameter == null) { [EOL]         _incompleteParameter = parameter; [EOL]     } [EOL] }
public void addIncompeteParameter(AnnotatedParameter parameter) { [EOL]     if (_incompleteParameter == null) { [EOL]         _incompleteParameter = parameter; [EOL]     } [EOL] }
protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne, String type) { [EOL]     if (oldOne != null) { [EOL]         if (oldOne.getClass() == newOne.getClass()) { [EOL]             throw new IllegalArgumentException("Conflicting " + type + " creators: already had " + oldOne + ", encountered " + newOne); [EOL]         } [EOL]     } [EOL]     return _fixAccess(newOne); [EOL] }
protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne, String type) { [EOL]     if (oldOne != null) { [EOL]         if (oldOne.getClass() == newOne.getClass()) { [EOL]             throw new IllegalArgumentException("Conflicting " + type + " creators: already had " + oldOne + ", encountered " + newOne); [EOL]         } [EOL]     } [EOL]     return _fixAccess(newOne); [EOL] }
protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne, String type) { [EOL]     if (oldOne != null) { [EOL]         if (oldOne.getClass() == newOne.getClass()) { [EOL]             throw new IllegalArgumentException("Conflicting " + type + " creators: already had " + oldOne + ", encountered " + newOne); [EOL]         } [EOL]     } [EOL]     return _fixAccess(newOne); [EOL] }
@Override [EOL] public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(nodeType)); [EOL] }
@Override [EOL] public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(nodeType)); [EOL] }
@Override [EOL] public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(nodeType)); [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_NUMBER_FLOAT; [EOL] }
@Override [EOL] public JsonParser.NumberType numberType() { [EOL]     return JsonParser.NumberType.BIG_DECIMAL; [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value.intValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value.intValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value.intValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value.longValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value.longValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value.longValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value.longValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value.longValue(); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value.doubleValue(); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value.doubleValue(); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value.doubleValue(); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value.hashCode(); [EOL] }
protected AnnotatedWithParams(AnnotationMap annotations, AnnotationMap[] paramAnnotations) { [EOL]     super(annotations); [EOL]     _paramAnnotations = paramAnnotations; [EOL] }
protected AnnotatedWithParams(AnnotationMap annotations, AnnotationMap[] paramAnnotations) { [EOL]     super(annotations); [EOL]     _paramAnnotations = paramAnnotations; [EOL] }
protected AnnotatedWithParams(AnnotationMap annotations, AnnotationMap[] paramAnnotations) { [EOL]     super(annotations); [EOL]     _paramAnnotations = paramAnnotations; [EOL] }
protected JavaType getType(TypeBindings bindings, TypeVariable<?>[] typeParams) { [EOL]     if (typeParams != null && typeParams.length > 0) { [EOL]         bindings = bindings.childInstance(); [EOL]         for (TypeVariable<?> var : typeParams) { [EOL]             String name = var.getName(); [EOL]             bindings._addPlaceholder(name); [EOL]             Type lowerBound = var.getBounds()[0]; [EOL]             JavaType type = (lowerBound == null) ? TypeFactory.unknownType() : bindings.resolveType(lowerBound); [EOL]             bindings.addBinding(var.getName(), type); [EOL]         } [EOL]     } [EOL]     return bindings.resolveType(getGenericType()); [EOL] }
protected JavaType getType(TypeBindings bindings, TypeVariable<?>[] typeParams) { [EOL]     if (typeParams != null && typeParams.length > 0) { [EOL]         bindings = bindings.childInstance(); [EOL]         for (TypeVariable<?> var : typeParams) { [EOL]             String name = var.getName(); [EOL]             bindings._addPlaceholder(name); [EOL]             Type lowerBound = var.getBounds()[0]; [EOL]             JavaType type = (lowerBound == null) ? TypeFactory.unknownType() : bindings.resolveType(lowerBound); [EOL]             bindings.addBinding(var.getName(), type); [EOL]         } [EOL]     } [EOL]     return bindings.resolveType(getGenericType()); [EOL] }
protected JavaType getType(TypeBindings bindings, TypeVariable<?>[] typeParams) { [EOL]     if (typeParams != null && typeParams.length > 0) { [EOL]         bindings = bindings.childInstance(); [EOL]         for (TypeVariable<?> var : typeParams) { [EOL]             String name = var.getName(); [EOL]             bindings._addPlaceholder(name); [EOL]             Type lowerBound = var.getBounds()[0]; [EOL]             JavaType type = (lowerBound == null) ? TypeFactory.unknownType() : bindings.resolveType(lowerBound); [EOL]             bindings.addBinding(var.getName(), type); [EOL]         } [EOL]     } [EOL]     return bindings.resolveType(getGenericType()); [EOL] }
protected JavaType getType(TypeBindings bindings, TypeVariable<?>[] typeParams) { [EOL]     if (typeParams != null && typeParams.length > 0) { [EOL]         bindings = bindings.childInstance(); [EOL]         for (TypeVariable<?> var : typeParams) { [EOL]             String name = var.getName(); [EOL]             bindings._addPlaceholder(name); [EOL]             Type lowerBound = var.getBounds()[0]; [EOL]             JavaType type = (lowerBound == null) ? TypeFactory.unknownType() : bindings.resolveType(lowerBound); [EOL]             bindings.addBinding(var.getName(), type); [EOL]         } [EOL]     } [EOL]     return bindings.resolveType(getGenericType()); [EOL] }
@Override [EOL] public final <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return _annotations.get(acls); [EOL] }
@Override [EOL] public final <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return _annotations.get(acls); [EOL] }
public final AnnotationMap getParameterAnnotations(int index) { [EOL]     if (_paramAnnotations != null) { [EOL]         if (index >= 0 && index <= _paramAnnotations.length) { [EOL]             return _paramAnnotations[index]; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public final AnnotationMap getParameterAnnotations(int index) { [EOL]     if (_paramAnnotations != null) { [EOL]         if (index >= 0 && index <= _paramAnnotations.length) { [EOL]             return _paramAnnotations[index]; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public final AnnotationMap getParameterAnnotations(int index) { [EOL]     if (_paramAnnotations != null) { [EOL]         if (index >= 0 && index <= _paramAnnotations.length) { [EOL]             return _paramAnnotations[index]; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public final AnnotationMap getParameterAnnotations(int index) { [EOL]     if (_paramAnnotations != null) { [EOL]         if (index >= 0 && index <= _paramAnnotations.length) { [EOL]             return _paramAnnotations[index]; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public final AnnotatedParameter getParameter(int index) { [EOL]     return new AnnotatedParameter(this, getGenericParameterType(index), getParameterAnnotations(index), index); [EOL] }
protected BasicBeanDescription(MapperConfig<?> config, JavaType type, AnnotatedClass classDef, List<BeanPropertyDefinition> props) { [EOL]     super(type); [EOL]     _config = config; [EOL]     _annotationIntrospector = (config == null) ? null : config.getAnnotationIntrospector(); [EOL]     _classInfo = classDef; [EOL]     _properties = props; [EOL] }
protected BasicBeanDescription(MapperConfig<?> config, JavaType type, AnnotatedClass classDef, List<BeanPropertyDefinition> props) { [EOL]     super(type); [EOL]     _config = config; [EOL]     _annotationIntrospector = (config == null) ? null : config.getAnnotationIntrospector(); [EOL]     _classInfo = classDef; [EOL]     _properties = props; [EOL] }
protected BasicBeanDescription(POJOPropertiesCollector coll) { [EOL]     this(coll.getConfig(), coll.getType(), coll.getClassDef(), coll.getProperties()); [EOL]     _objectIdInfo = coll.getObjectIdInfo(); [EOL] }
protected BasicBeanDescription(POJOPropertiesCollector coll) { [EOL]     this(coll.getConfig(), coll.getType(), coll.getClassDef(), coll.getProperties()); [EOL]     _objectIdInfo = coll.getObjectIdInfo(); [EOL] }
public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll) { [EOL]     BasicBeanDescription desc = new BasicBeanDescription(coll); [EOL]     desc._jsonValueMethod = coll.getJsonValueMethod(); [EOL]     desc._anyGetter = coll.getAnyGetter(); [EOL]     return desc; [EOL] }
public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll) { [EOL]     BasicBeanDescription desc = new BasicBeanDescription(coll); [EOL]     desc._jsonValueMethod = coll.getJsonValueMethod(); [EOL]     desc._anyGetter = coll.getAnyGetter(); [EOL]     return desc; [EOL] }
public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll) { [EOL]     BasicBeanDescription desc = new BasicBeanDescription(coll); [EOL]     desc._jsonValueMethod = coll.getJsonValueMethod(); [EOL]     desc._anyGetter = coll.getAnyGetter(); [EOL]     return desc; [EOL] }
public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll) { [EOL]     BasicBeanDescription desc = new BasicBeanDescription(coll); [EOL]     desc._jsonValueMethod = coll.getJsonValueMethod(); [EOL]     desc._anyGetter = coll.getAnyGetter(); [EOL]     return desc; [EOL] }
public static BasicBeanDescription forOtherUse(MapperConfig<?> config, JavaType type, AnnotatedClass ac) { [EOL]     return new BasicBeanDescription(config, type, ac, Collections.<BeanPropertyDefinition>emptyList()); [EOL] }
@Override [EOL] public AnnotatedClass getClassInfo() { [EOL]     return _classInfo; [EOL] }
@Override [EOL] public ObjectIdInfo getObjectIdInfo() { [EOL]     return _objectIdInfo; [EOL] }
@Override [EOL] public List<BeanPropertyDefinition> findProperties() { [EOL]     return _properties; [EOL] }
@Override [EOL] public AnnotatedMethod findJsonValueMethod() { [EOL]     return _jsonValueMethod; [EOL] }
@Override [EOL] public AnnotatedMethod findJsonValueMethod() { [EOL]     return _jsonValueMethod; [EOL] }
@Override [EOL] public Set<String> getIgnoredPropertyNames() { [EOL]     if (_ignoredPropertyNames == null) { [EOL]         return Collections.emptySet(); [EOL]     } [EOL]     return _ignoredPropertyNames; [EOL] }
@Override [EOL] public Set<String> getIgnoredPropertyNames() { [EOL]     if (_ignoredPropertyNames == null) { [EOL]         return Collections.emptySet(); [EOL]     } [EOL]     return _ignoredPropertyNames; [EOL] }
@Override [EOL] public Annotations getClassAnnotations() { [EOL]     return _classInfo.getAnnotations(); [EOL] }
@Override [EOL] public TypeBindings bindingsForBeanType() { [EOL]     if (_bindings == null) { [EOL]         _bindings = new TypeBindings(_config.getTypeFactory(), _type); [EOL]     } [EOL]     return _bindings; [EOL] }
@Override [EOL] public JavaType resolveType(java.lang.reflect.Type jdkType) { [EOL]     if (jdkType == null) { [EOL]         return null; [EOL]     } [EOL]     return bindingsForBeanType().resolveType(jdkType); [EOL] }
@Override [EOL] public JavaType resolveType(java.lang.reflect.Type jdkType) { [EOL]     if (jdkType == null) { [EOL]         return null; [EOL]     } [EOL]     return bindingsForBeanType().resolveType(jdkType); [EOL] }
@Override [EOL] public AnnotatedConstructor findDefaultConstructor() { [EOL]     return _classInfo.getDefaultConstructor(); [EOL] }
@Override [EOL] public AnnotatedConstructor findDefaultConstructor() { [EOL]     return _classInfo.getDefaultConstructor(); [EOL] }
@Override [EOL] public AnnotatedMethod findAnySetter() throws IllegalArgumentException { [EOL]     if (_anySetterMethod != null) { [EOL]         Class<?> type = _anySetterMethod.getRawParameterType(0); [EOL]         if (type != String.class && type != Object.class) { [EOL]             throw new IllegalArgumentException("Invalid 'any-setter' annotation on method " + _anySetterMethod.getName() + "(): first argument not of type String or Object, but " + type.getName()); [EOL]         } [EOL]     } [EOL]     return _anySetterMethod; [EOL] }
@Override [EOL] public List<AnnotatedConstructor> getConstructors() { [EOL]     return _classInfo.getConstructors(); [EOL] }
@Override [EOL] public Object instantiateBean(boolean fixAccess) { [EOL]     AnnotatedConstructor ac = _classInfo.getDefaultConstructor(); [EOL]     if (ac == null) { [EOL]         return null; [EOL]     } [EOL]     if (fixAccess) { [EOL]         ac.fixAccess(); [EOL]     } [EOL]     try { [EOL]         return ac.getAnnotated().newInstance(); [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) [EOL]             throw (Error) t; [EOL]         if (t instanceof RuntimeException) [EOL]             throw (RuntimeException) t; [EOL]         throw new IllegalArgumentException("Failed to instantiate bean of type " + _classInfo.getAnnotated().getName() + ": (" + t.getClass().getName() + ") " + t.getMessage(), t); [EOL]     } [EOL] }
@Override [EOL] public Object instantiateBean(boolean fixAccess) { [EOL]     AnnotatedConstructor ac = _classInfo.getDefaultConstructor(); [EOL]     if (ac == null) { [EOL]         return null; [EOL]     } [EOL]     if (fixAccess) { [EOL]         ac.fixAccess(); [EOL]     } [EOL]     try { [EOL]         return ac.getAnnotated().newInstance(); [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) [EOL]             throw (Error) t; [EOL]         if (t instanceof RuntimeException) [EOL]             throw (RuntimeException) t; [EOL]         throw new IllegalArgumentException("Failed to instantiate bean of type " + _classInfo.getAnnotated().getName() + ": (" + t.getClass().getName() + ") " + t.getMessage(), t); [EOL]     } [EOL] }
@Override [EOL] public Object instantiateBean(boolean fixAccess) { [EOL]     AnnotatedConstructor ac = _classInfo.getDefaultConstructor(); [EOL]     if (ac == null) { [EOL]         return null; [EOL]     } [EOL]     if (fixAccess) { [EOL]         ac.fixAccess(); [EOL]     } [EOL]     try { [EOL]         return ac.getAnnotated().newInstance(); [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) [EOL]             throw (Error) t; [EOL]         if (t instanceof RuntimeException) [EOL]             throw (RuntimeException) t; [EOL]         throw new IllegalArgumentException("Failed to instantiate bean of type " + _classInfo.getAnnotated().getName() + ": (" + t.getClass().getName() + ") " + t.getMessage(), t); [EOL]     } [EOL] }
@Override [EOL] public Object instantiateBean(boolean fixAccess) { [EOL]     AnnotatedConstructor ac = _classInfo.getDefaultConstructor(); [EOL]     if (ac == null) { [EOL]         return null; [EOL]     } [EOL]     if (fixAccess) { [EOL]         ac.fixAccess(); [EOL]     } [EOL]     try { [EOL]         return ac.getAnnotated().newInstance(); [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) [EOL]             throw (Error) t; [EOL]         if (t instanceof RuntimeException) [EOL]             throw (RuntimeException) t; [EOL]         throw new IllegalArgumentException("Failed to instantiate bean of type " + _classInfo.getAnnotated().getName() + ": (" + t.getClass().getName() + ") " + t.getMessage(), t); [EOL]     } [EOL] }
@Override [EOL] public Object instantiateBean(boolean fixAccess) { [EOL]     AnnotatedConstructor ac = _classInfo.getDefaultConstructor(); [EOL]     if (ac == null) { [EOL]         return null; [EOL]     } [EOL]     if (fixAccess) { [EOL]         ac.fixAccess(); [EOL]     } [EOL]     try { [EOL]         return ac.getAnnotated().newInstance(); [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) [EOL]             throw (Error) t; [EOL]         if (t instanceof RuntimeException) [EOL]             throw (RuntimeException) t; [EOL]         throw new IllegalArgumentException("Failed to instantiate bean of type " + _classInfo.getAnnotated().getName() + ": (" + t.getClass().getName() + ") " + t.getMessage(), t); [EOL]     } [EOL] }
@Override [EOL] public Object instantiateBean(boolean fixAccess) { [EOL]     AnnotatedConstructor ac = _classInfo.getDefaultConstructor(); [EOL]     if (ac == null) { [EOL]         return null; [EOL]     } [EOL]     if (fixAccess) { [EOL]         ac.fixAccess(); [EOL]     } [EOL]     try { [EOL]         return ac.getAnnotated().newInstance(); [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) [EOL]             throw (Error) t; [EOL]         if (t instanceof RuntimeException) [EOL]             throw (RuntimeException) t; [EOL]         throw new IllegalArgumentException("Failed to instantiate bean of type " + _classInfo.getAnnotated().getName() + ": (" + t.getClass().getName() + ") " + t.getMessage(), t); [EOL]     } [EOL] }
@Override [EOL] public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     return _classInfo.findMethod(name, paramTypes); [EOL] }
@Override [EOL] public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     return _classInfo.findMethod(name, paramTypes); [EOL] }
@Override [EOL] public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     return _classInfo.findMethod(name, paramTypes); [EOL] }
@Override [EOL] public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     return _classInfo.findMethod(name, paramTypes); [EOL] }
@Override [EOL] public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     return _classInfo.findMethod(name, paramTypes); [EOL] }
@Override [EOL] public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue) { [EOL]     if (_annotationIntrospector != null) { [EOL]         JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo); [EOL]         if (v != null) { [EOL]             return v; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue) { [EOL]     if (_annotationIntrospector != null) { [EOL]         JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo); [EOL]         if (v != null) { [EOL]             return v; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue) { [EOL]     if (_annotationIntrospector != null) { [EOL]         JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo); [EOL]         if (v != null) { [EOL]             return v; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public Converter<Object, Object> findSerializationConverter() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     return _createConverter(_annotationIntrospector.findSerializationConverter(_classInfo)); [EOL] }
@Override [EOL] public Converter<Object, Object> findSerializationConverter() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     return _createConverter(_annotationIntrospector.findSerializationConverter(_classInfo)); [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return defValue; [EOL]     } [EOL]     return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue); [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return defValue; [EOL]     } [EOL]     return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue); [EOL] }
@Override [EOL] public AnnotatedMember findAnyGetter() throws IllegalArgumentException { [EOL]     if (_anyGetter != null) { [EOL]         Class<?> type = _anyGetter.getRawType(); [EOL]         if (!Map.class.isAssignableFrom(type)) { [EOL]             throw new IllegalArgumentException("Invalid 'any-getter' annotation on method " + _anyGetter.getName() + "(): return type is not instance of java.util.Map"); [EOL]         } [EOL]     } [EOL]     return _anyGetter; [EOL] }
@Override [EOL] public AnnotatedMember findAnyGetter() throws IllegalArgumentException { [EOL]     if (_anyGetter != null) { [EOL]         Class<?> type = _anyGetter.getRawType(); [EOL]         if (!Map.class.isAssignableFrom(type)) { [EOL]             throw new IllegalArgumentException("Invalid 'any-getter' annotation on method " + _anyGetter.getName() + "(): return type is not instance of java.util.Map"); [EOL]         } [EOL]     } [EOL]     return _anyGetter; [EOL] }
@Override [EOL] public AnnotatedMember findAnyGetter() throws IllegalArgumentException { [EOL]     if (_anyGetter != null) { [EOL]         Class<?> type = _anyGetter.getRawType(); [EOL]         if (!Map.class.isAssignableFrom(type)) { [EOL]             throw new IllegalArgumentException("Invalid 'any-getter' annotation on method " + _anyGetter.getName() + "(): return type is not instance of java.util.Map"); [EOL]         } [EOL]     } [EOL]     return _anyGetter; [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<AnnotatedMethod> getFactoryMethods() { [EOL]     List<AnnotatedMethod> candidates = _classInfo.getStaticMethods(); [EOL]     if (candidates.isEmpty()) { [EOL]         return candidates; [EOL]     } [EOL]     ArrayList<AnnotatedMethod> result = new ArrayList<AnnotatedMethod>(); [EOL]     for (AnnotatedMethod am : candidates) { [EOL]         if (isFactoryMethod(am)) { [EOL]             result.add(am); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<AnnotatedMethod> getFactoryMethods() { [EOL]     List<AnnotatedMethod> candidates = _classInfo.getStaticMethods(); [EOL]     if (candidates.isEmpty()) { [EOL]         return candidates; [EOL]     } [EOL]     ArrayList<AnnotatedMethod> result = new ArrayList<AnnotatedMethod>(); [EOL]     for (AnnotatedMethod am : candidates) { [EOL]         if (isFactoryMethod(am)) { [EOL]             result.add(am); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<AnnotatedMethod> getFactoryMethods() { [EOL]     List<AnnotatedMethod> candidates = _classInfo.getStaticMethods(); [EOL]     if (candidates.isEmpty()) { [EOL]         return candidates; [EOL]     } [EOL]     ArrayList<AnnotatedMethod> result = new ArrayList<AnnotatedMethod>(); [EOL]     for (AnnotatedMethod am : candidates) { [EOL]         if (isFactoryMethod(am)) { [EOL]             result.add(am); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) { [EOL]     for (AnnotatedConstructor ac : _classInfo.getConstructors()) { [EOL]         if (ac.getParameterCount() == 1) { [EOL]             Class<?> actArg = ac.getRawParameterType(0); [EOL]             for (Class<?> expArg : argTypes) { [EOL]                 if (expArg == actArg) { [EOL]                     return ac.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) { [EOL]     for (AnnotatedConstructor ac : _classInfo.getConstructors()) { [EOL]         if (ac.getParameterCount() == 1) { [EOL]             Class<?> actArg = ac.getRawParameterType(0); [EOL]             for (Class<?> expArg : argTypes) { [EOL]                 if (expArg == actArg) { [EOL]                     return ac.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) { [EOL]     for (AnnotatedConstructor ac : _classInfo.getConstructors()) { [EOL]         if (ac.getParameterCount() == 1) { [EOL]             Class<?> actArg = ac.getRawParameterType(0); [EOL]             for (Class<?> expArg : argTypes) { [EOL]                 if (expArg == actArg) { [EOL]                     return ac.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) { [EOL]     for (AnnotatedConstructor ac : _classInfo.getConstructors()) { [EOL]         if (ac.getParameterCount() == 1) { [EOL]             Class<?> actArg = ac.getRawParameterType(0); [EOL]             for (Class<?> expArg : argTypes) { [EOL]                 if (expArg == actArg) { [EOL]                     return ac.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public Converter<Object, Object> findDeserializationConverter() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     return _createConverter(_annotationIntrospector.findDeserializationConverter(_classInfo)); [EOL] }
@Override [EOL] public Converter<Object, Object> findDeserializationConverter() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     return _createConverter(_annotationIntrospector.findDeserializationConverter(_classInfo)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@Override [EOL] public JavaType getDelegateType(DeserializationConfig config) { [EOL]     return _delegateType; [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { [EOL]     if (_withArgsCreator == null) { [EOL]         throw new IllegalStateException("No with-args constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _withArgsCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { [EOL]     if (_withArgsCreator == null) { [EOL]         throw new IllegalStateException("No with-args constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _withArgsCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { [EOL]     if (_withArgsCreator == null) { [EOL]         throw new IllegalStateException("No with-args constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _withArgsCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException, JsonProcessingException { [EOL]     if (_withArgsCreator == null) { [EOL]         throw new IllegalStateException("No with-args constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _withArgsCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException, JsonProcessingException { [EOL]     if (_delegateCreator == null) { [EOL]         throw new IllegalStateException("No delegate constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         if (_delegateArguments == null) { [EOL]             return _delegateCreator.call1(delegate); [EOL]         } [EOL]         final int len = _delegateArguments.length; [EOL]         Object[] args = new Object[len]; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             CreatorProperty prop = _delegateArguments[i]; [EOL]             if (prop == null) { [EOL]                 args[i] = delegate; [EOL]             } else { [EOL]                 args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL]             } [EOL]         } [EOL]         return _delegateCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException, JsonProcessingException { [EOL]     if (_delegateCreator == null) { [EOL]         throw new IllegalStateException("No delegate constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         if (_delegateArguments == null) { [EOL]             return _delegateCreator.call1(delegate); [EOL]         } [EOL]         final int len = _delegateArguments.length; [EOL]         Object[] args = new Object[len]; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             CreatorProperty prop = _delegateArguments[i]; [EOL]             if (prop == null) { [EOL]                 args[i] = delegate; [EOL]             } else { [EOL]                 args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL]             } [EOL]         } [EOL]         return _delegateCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException, JsonProcessingException { [EOL]     if (_delegateCreator == null) { [EOL]         throw new IllegalStateException("No delegate constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         if (_delegateArguments == null) { [EOL]             return _delegateCreator.call1(delegate); [EOL]         } [EOL]         final int len = _delegateArguments.length; [EOL]         Object[] args = new Object[len]; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             CreatorProperty prop = _delegateArguments[i]; [EOL]             if (prop == null) { [EOL]                 args[i] = delegate; [EOL]             } else { [EOL]                 args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL]             } [EOL]         } [EOL]         return _delegateCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException, JsonProcessingException { [EOL]     if (_delegateCreator == null) { [EOL]         throw new IllegalStateException("No delegate constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         if (_delegateArguments == null) { [EOL]             return _delegateCreator.call1(delegate); [EOL]         } [EOL]         final int len = _delegateArguments.length; [EOL]         Object[] args = new Object[len]; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             CreatorProperty prop = _delegateArguments[i]; [EOL]             if (prop == null) { [EOL]                 args[i] = delegate; [EOL]             } else { [EOL]                 args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL]             } [EOL]         } [EOL]         return _delegateCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException, JsonProcessingException { [EOL]     if (_delegateCreator == null) { [EOL]         throw new IllegalStateException("No delegate constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         if (_delegateArguments == null) { [EOL]             return _delegateCreator.call1(delegate); [EOL]         } [EOL]         final int len = _delegateArguments.length; [EOL]         Object[] args = new Object[len]; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             CreatorProperty prop = _delegateArguments[i]; [EOL]             if (prop == null) { [EOL]                 args[i] = delegate; [EOL]             } else { [EOL]                 args[i] = ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL]             } [EOL]         } [EOL]         return _delegateCreator.call(args); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromInt(DeserializationContext ctxt, int value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromIntCreator != null) { [EOL]             return _fromIntCreator.call1(Integer.valueOf(value)); [EOL]         } [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Integral number; no single-int-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromInt(DeserializationContext ctxt, int value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromIntCreator != null) { [EOL]             return _fromIntCreator.call1(Integer.valueOf(value)); [EOL]         } [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Integral number; no single-int-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromInt(DeserializationContext ctxt, int value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromIntCreator != null) { [EOL]             return _fromIntCreator.call1(Integer.valueOf(value)); [EOL]         } [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Integral number; no single-int-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromInt(DeserializationContext ctxt, int value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromIntCreator != null) { [EOL]             return _fromIntCreator.call1(Integer.valueOf(value)); [EOL]         } [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Integral number; no single-int-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromInt(DeserializationContext ctxt, int value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromIntCreator != null) { [EOL]             return _fromIntCreator.call1(Integer.valueOf(value)); [EOL]         } [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Integral number; no single-int-arg constructor/factory method"); [EOL] }
@Override [EOL] public AnnotatedWithParams getDelegateCreator() { [EOL]     return _delegateCreator; [EOL] }
@Override [EOL] public AnnotatedWithParams getDelegateCreator() { [EOL]     return _delegateCreator; [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
@Override [EOL] public void serialize(char[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) { [EOL]         jgen.writeStartArray(); [EOL]         _writeArrayContents(jgen, value); [EOL]         jgen.writeEndArray(); [EOL]     } else { [EOL]         jgen.writeString(value, 0, value.length); [EOL]     } [EOL] }
@Override [EOL] public void serialize(char[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) { [EOL]         jgen.writeStartArray(); [EOL]         _writeArrayContents(jgen, value); [EOL]         jgen.writeEndArray(); [EOL]     } else { [EOL]         jgen.writeString(value, 0, value.length); [EOL]     } [EOL] }
private final void _writeArrayContents(JsonGenerator jgen, char[] value) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeString(value, i, 1); [EOL]     } [EOL] }
private final void _writeArrayContents(JsonGenerator jgen, char[] value) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeString(value, i, 1); [EOL]     } [EOL] }
private final void _writeArrayContents(JsonGenerator jgen, char[] value) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeString(value, i, 1); [EOL]     } [EOL] }
@Override [EOL] protected JavaType _narrow(Class<?> subclass) { [EOL]     return new MapType(subclass, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] protected JavaType _narrow(Class<?> subclass) { [EOL]     return new MapType(subclass, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public MapType withContentTypeHandler(Object h) { [EOL]     return new MapType(_class, _keyType, _valueType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public MapType withContentTypeHandler(Object h) { [EOL]     return new MapType(_class, _keyType, _valueType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "[map type; class " + _class.getName() + ", " + _keyType + " -> " + _valueType + "]"; [EOL] }
@SuppressWarnings("unchecked") [EOL] public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue) { [EOL]     _member = member; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _name = new SerializedString(propDef.getName()); [EOL]     _wrapperName = propDef.getWrapperName(); [EOL]     _declaredType = declaredType; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL]     _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null; [EOL]     _typeSerializer = typeSer; [EOL]     _cfgSerializationType = serType; [EOL]     _isRequired = propDef.isRequired(); [EOL]     if (member instanceof AnnotatedField) { [EOL]         _accessorMethod = null; [EOL]         _field = (Field) member.getMember(); [EOL]     } else if (member instanceof AnnotatedMethod) { [EOL]         _accessorMethod = (Method) member.getMember(); [EOL]         _field = null; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not pass member of type " + member.getClass().getName()); [EOL]     } [EOL]     _suppressNulls = suppressNulls; [EOL]     _suppressableValue = suppressableValue; [EOL]     _includeInViews = propDef.findViews(); [EOL]     _nullSerializer = null; [EOL] }
@SuppressWarnings("unchecked") [EOL] public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue) { [EOL]     _member = member; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _name = new SerializedString(propDef.getName()); [EOL]     _wrapperName = propDef.getWrapperName(); [EOL]     _declaredType = declaredType; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL]     _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null; [EOL]     _typeSerializer = typeSer; [EOL]     _cfgSerializationType = serType; [EOL]     _isRequired = propDef.isRequired(); [EOL]     if (member instanceof AnnotatedField) { [EOL]         _accessorMethod = null; [EOL]         _field = (Field) member.getMember(); [EOL]     } else if (member instanceof AnnotatedMethod) { [EOL]         _accessorMethod = (Method) member.getMember(); [EOL]         _field = null; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not pass member of type " + member.getClass().getName()); [EOL]     } [EOL]     _suppressNulls = suppressNulls; [EOL]     _suppressableValue = suppressableValue; [EOL]     _includeInViews = propDef.findViews(); [EOL]     _nullSerializer = null; [EOL] }
@SuppressWarnings("unchecked") [EOL] public BeanPropertyWriter(BeanPropertyDefinition propDef, AnnotatedMember member, Annotations contextAnnotations, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType, boolean suppressNulls, Object suppressableValue) { [EOL]     _member = member; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _name = new SerializedString(propDef.getName()); [EOL]     _wrapperName = propDef.getWrapperName(); [EOL]     _declaredType = declaredType; [EOL]     _serializer = (JsonSerializer<Object>) ser; [EOL]     _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null; [EOL]     _typeSerializer = typeSer; [EOL]     _cfgSerializationType = serType; [EOL]     _isRequired = propDef.isRequired(); [EOL]     if (member instanceof AnnotatedField) { [EOL]         _accessorMethod = null; [EOL]         _field = (Field) member.getMember(); [EOL]     } else if (member instanceof AnnotatedMethod) { [EOL]         _accessorMethod = (Method) member.getMember(); [EOL]         _field = null; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not pass member of type " + member.getClass().getName()); [EOL]     } [EOL]     _suppressNulls = suppressNulls; [EOL]     _suppressableValue = suppressableValue; [EOL]     _includeInViews = propDef.findViews(); [EOL]     _nullSerializer = null; [EOL] }
protected BeanPropertyWriter(BeanPropertyWriter base) { [EOL]     this(base, base._name); [EOL] }
protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) { [EOL]     _name = name; [EOL]     _wrapperName = base._wrapperName; [EOL]     _member = base._member; [EOL]     _contextAnnotations = base._contextAnnotations; [EOL]     _declaredType = base._declaredType; [EOL]     _accessorMethod = base._accessorMethod; [EOL]     _field = base._field; [EOL]     _serializer = base._serializer; [EOL]     _nullSerializer = base._nullSerializer; [EOL]     if (base._internalSettings != null) { [EOL]         _internalSettings = new HashMap<Object, Object>(base._internalSettings); [EOL]     } [EOL]     _cfgSerializationType = base._cfgSerializationType; [EOL]     _dynamicSerializers = base._dynamicSerializers; [EOL]     _suppressNulls = base._suppressNulls; [EOL]     _suppressableValue = base._suppressableValue; [EOL]     _includeInViews = base._includeInViews; [EOL]     _typeSerializer = base._typeSerializer; [EOL]     _nonTrivialBaseType = base._nonTrivialBaseType; [EOL]     _isRequired = base._isRequired; [EOL] }
public void assignSerializer(JsonSerializer<Object> ser) { [EOL]     if (_serializer != null && _serializer != ser) { [EOL]         throw new IllegalStateException("Can not override serializer"); [EOL]     } [EOL]     _serializer = ser; [EOL] }
public void assignSerializer(JsonSerializer<Object> ser) { [EOL]     if (_serializer != null && _serializer != ser) { [EOL]         throw new IllegalStateException("Can not override serializer"); [EOL]     } [EOL]     _serializer = ser; [EOL] }
public void assignSerializer(JsonSerializer<Object> ser) { [EOL]     if (_serializer != null && _serializer != ser) { [EOL]         throw new IllegalStateException("Can not override serializer"); [EOL]     } [EOL]     _serializer = ser; [EOL] }
public void assignNullSerializer(JsonSerializer<Object> nullSer) { [EOL]     if (_nullSerializer != null && _nullSerializer != nullSer) { [EOL]         throw new IllegalStateException("Can not override null serializer"); [EOL]     } [EOL]     _nullSerializer = nullSer; [EOL] }
public void assignNullSerializer(JsonSerializer<Object> nullSer) { [EOL]     if (_nullSerializer != null && _nullSerializer != nullSer) { [EOL]         throw new IllegalStateException("Can not override null serializer"); [EOL]     } [EOL]     _nullSerializer = nullSer; [EOL] }
public void assignNullSerializer(JsonSerializer<Object> nullSer) { [EOL]     if (_nullSerializer != null && _nullSerializer != nullSer) { [EOL]         throw new IllegalStateException("Can not override null serializer"); [EOL]     } [EOL]     _nullSerializer = nullSer; [EOL] }
public void assignNullSerializer(JsonSerializer<Object> nullSer) { [EOL]     if (_nullSerializer != null && _nullSerializer != nullSer) { [EOL]         throw new IllegalStateException("Can not override null serializer"); [EOL]     } [EOL]     _nullSerializer = nullSer; [EOL] }
@Override [EOL] public JavaType getType() { [EOL]     return _declaredType; [EOL] }
public boolean hasSerializer() { [EOL]     return _serializer != null; [EOL] }
public boolean hasSerializer() { [EOL]     return _serializer != null; [EOL] }
public boolean hasNullSerializer() { [EOL]     return _nullSerializer != null; [EOL] }
public boolean hasNullSerializer() { [EOL]     return _nullSerializer != null; [EOL] }
public boolean willSuppressNulls() { [EOL]     return _suppressNulls; [EOL] }
public boolean willSuppressNulls() { [EOL]     return _suppressNulls; [EOL] }
public JavaType getSerializationType() { [EOL]     return _cfgSerializationType; [EOL] }
public Type getGenericPropertyType() { [EOL]     if (_accessorMethod != null) { [EOL]         return _accessorMethod.getGenericReturnType(); [EOL]     } [EOL]     return _field.getGenericType(); [EOL] }
public Type getGenericPropertyType() { [EOL]     if (_accessorMethod != null) { [EOL]         return _accessorMethod.getGenericReturnType(); [EOL]     } [EOL]     return _field.getGenericType(); [EOL] }
public Class<?>[] getViews() { [EOL]     return _includeInViews; [EOL] }
public Class<?>[] getViews() { [EOL]     return _includeInViews; [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result; [EOL]     if (_nonTrivialBaseType != null) { [EOL]         JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type); [EOL]         result = map.findAndAddSerializer(t, provider, this); [EOL]     } else { [EOL]         result = map.findAndAddSerializer(type, provider, this); [EOL]     } [EOL]     if (map != result.map) { [EOL]         _dynamicSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result; [EOL]     if (_nonTrivialBaseType != null) { [EOL]         JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type); [EOL]         result = map.findAndAddSerializer(t, provider, this); [EOL]     } else { [EOL]         result = map.findAndAddSerializer(type, provider, this); [EOL]     } [EOL]     if (map != result.map) { [EOL]         _dynamicSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
public final Object get(Object bean) throws Exception { [EOL]     if (_accessorMethod != null) { [EOL]         return _accessorMethod.invoke(bean); [EOL]     } [EOL]     return _field.get(bean); [EOL] }
public final Object get(Object bean) throws Exception { [EOL]     if (_accessorMethod != null) { [EOL]         return _accessorMethod.invoke(bean); [EOL]     } [EOL]     return _field.get(bean); [EOL] }
protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException { [EOL]     if (ser.usesObjectId()) { [EOL]         return; [EOL]     } [EOL]     throw new JsonMappingException("Direct self-reference leading to cycle"); [EOL] }
protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) throws JsonMappingException { [EOL]     if (ser.usesObjectId()) { [EOL]         return; [EOL]     } [EOL]     throw new JsonMappingException("Direct self-reference leading to cycle"); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _elementTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = _elementDeserializer.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix); [EOL]     } else { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix, _elementClass); [EOL]     } [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _elementTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = _elementDeserializer.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix); [EOL]     } else { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix, _elementClass); [EOL]     } [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _elementTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = _elementDeserializer.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix); [EOL]     } else { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix, _elementClass); [EOL]     } [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _elementTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = _elementDeserializer.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix); [EOL]     } else { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix, _elementClass); [EOL]     } [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _elementTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = _elementDeserializer.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix); [EOL]     } else { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix, _elementClass); [EOL]     } [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _elementTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = _elementDeserializer.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix); [EOL]     } else { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix, _elementClass); [EOL]     } [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public Object[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _elementTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = _elementDeserializer.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix); [EOL]     } else { [EOL]         result = buffer.completeAndClearBuffer(chunk, ix, _elementClass); [EOL]     } [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if (jp.getCurrentToken() == JsonToken.VALUE_STRING && _elementClass == Byte.class) { [EOL]             return deserializeFromBase64(jp, ctxt); [EOL]         } [EOL]         throw ctxt.mappingException(_arrayType.getRawClass()); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (_elementTypeDeserializer == null) { [EOL]         value = _elementDeserializer.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer); [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = new Object[1]; [EOL]     } else { [EOL]         result = (Object[]) Array.newInstance(_elementClass, 1); [EOL]     } [EOL]     result[0] = value; [EOL]     return result; [EOL] }
private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if (jp.getCurrentToken() == JsonToken.VALUE_STRING && _elementClass == Byte.class) { [EOL]             return deserializeFromBase64(jp, ctxt); [EOL]         } [EOL]         throw ctxt.mappingException(_arrayType.getRawClass()); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (_elementTypeDeserializer == null) { [EOL]         value = _elementDeserializer.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer); [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = new Object[1]; [EOL]     } else { [EOL]         result = (Object[]) Array.newInstance(_elementClass, 1); [EOL]     } [EOL]     result[0] = value; [EOL]     return result; [EOL] }
private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if (jp.getCurrentToken() == JsonToken.VALUE_STRING && _elementClass == Byte.class) { [EOL]             return deserializeFromBase64(jp, ctxt); [EOL]         } [EOL]         throw ctxt.mappingException(_arrayType.getRawClass()); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (_elementTypeDeserializer == null) { [EOL]         value = _elementDeserializer.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer); [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = new Object[1]; [EOL]     } else { [EOL]         result = (Object[]) Array.newInstance(_elementClass, 1); [EOL]     } [EOL]     result[0] = value; [EOL]     return result; [EOL] }
private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if (jp.getCurrentToken() == JsonToken.VALUE_STRING && _elementClass == Byte.class) { [EOL]             return deserializeFromBase64(jp, ctxt); [EOL]         } [EOL]         throw ctxt.mappingException(_arrayType.getRawClass()); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (_elementTypeDeserializer == null) { [EOL]         value = _elementDeserializer.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer); [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = new Object[1]; [EOL]     } else { [EOL]         result = (Object[]) Array.newInstance(_elementClass, 1); [EOL]     } [EOL]     result[0] = value; [EOL]     return result; [EOL] }
public static AnnotationIntrospector nopInstance() { [EOL]     return NopAnnotationIntrospector.instance; [EOL] }
public String[] findPropertiesToIgnore(Annotated ac) { [EOL]     return null; [EOL] }
public Boolean isIgnorableType(AnnotatedClass ac) { [EOL]     return null; [EOL] }
public Object findFilterId(AnnotatedClass ac) { [EOL]     return null; [EOL] }
public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) { [EOL]     return checker; [EOL] }
public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) { [EOL]     return checker; [EOL] }
public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) { [EOL]     return null; [EOL] }
public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config, AnnotatedClass ac, JavaType baseType) { [EOL]     return null; [EOL] }
public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) { [EOL]     return null; [EOL] }
public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { [EOL]     return null; [EOL] }
public Object findInjectableValueId(AnnotatedMember m) { [EOL]     return null; [EOL] }
public JsonFormat.Value findFormat(Annotated memberOrClass) { [EOL]     if (memberOrClass instanceof AnnotatedMember) { [EOL]         return findFormat((AnnotatedMember) memberOrClass); [EOL]     } [EOL]     return null; [EOL] }
public JsonFormat.Value findFormat(Annotated memberOrClass) { [EOL]     if (memberOrClass instanceof AnnotatedMember) { [EOL]         return findFormat((AnnotatedMember) memberOrClass); [EOL]     } [EOL]     return null; [EOL] }
public Object findSerializer(Annotated am) { [EOL]     return null; [EOL] }
public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     return defValue; [EOL] }
public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     return defValue; [EOL] }
public Class<?> findSerializationType(Annotated a) { [EOL]     return null; [EOL] }
public JsonSerialize.Typing findSerializationTyping(Annotated a) { [EOL]     return null; [EOL] }
public Object findSerializationConverter(Annotated a) { [EOL]     return null; [EOL] }
public Object findDeserializer(Annotated am) { [EOL]     return null; [EOL] }
public Object findKeyDeserializer(Annotated am) { [EOL]     return null; [EOL] }
public Object findContentDeserializer(Annotated am) { [EOL]     return null; [EOL] }
public Class<?> findDeserializationType(Annotated am, JavaType baseType) { [EOL]     return null; [EOL] }
public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     return null; [EOL] }
public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { [EOL]     return null; [EOL] }
public Object findDeserializationConverter(Annotated a) { [EOL]     return null; [EOL] }
public Object findValueInstantiator(AnnotatedClass ac) { [EOL]     return null; [EOL] }
public Class<?> findPOJOBuilder(AnnotatedClass ac) { [EOL]     return null; [EOL] }
public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Deprecated [EOL] public String findDeserializationName(AnnotatedParameter param) { [EOL]     return null; [EOL] }
public boolean hasCreatorAnnotation(Annotated a) { [EOL]     return false; [EOL] }
public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, JavaType baseType) throws IOException, JsonProcessingException { [EOL]     return deserializeIfNatural(jp, ctxt, baseType.getRawClass()); [EOL] }
public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, JavaType baseType) throws IOException, JsonProcessingException { [EOL]     return deserializeIfNatural(jp, ctxt, baseType.getRawClass()); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             if (base.isAssignableFrom(String.class)) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (base.isAssignableFrom(Integer.class)) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (base.isAssignableFrom(Double.class)) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (base.isAssignableFrom(Boolean.class)) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethodMap() { [EOL] }
public void add(AnnotatedMethod am) { [EOL]     if (_methods == null) { [EOL]         _methods = new LinkedHashMap<MemberKey, AnnotatedMethod>(); [EOL]     } [EOL]     _methods.put(new MemberKey(am.getAnnotated()), am); [EOL] }
public void add(AnnotatedMethod am) { [EOL]     if (_methods == null) { [EOL]         _methods = new LinkedHashMap<MemberKey, AnnotatedMethod>(); [EOL]     } [EOL]     _methods.put(new MemberKey(am.getAnnotated()), am); [EOL] }
public AnnotatedMethod remove(Method m) { [EOL]     if (_methods != null) { [EOL]         return _methods.remove(new MemberKey(m)); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod remove(Method m) { [EOL]     if (_methods != null) { [EOL]         return _methods.remove(new MemberKey(m)); [EOL]     } [EOL]     return null; [EOL] }
public boolean isEmpty() { [EOL]     return (_methods == null || _methods.size() == 0); [EOL] }
public boolean isEmpty() { [EOL]     return (_methods == null || _methods.size() == 0); [EOL] }
public boolean isEmpty() { [EOL]     return (_methods == null || _methods.size() == 0); [EOL] }
public AnnotatedMethod find(String name, Class<?>[] paramTypes) { [EOL]     if (_methods == null) { [EOL]         return null; [EOL]     } [EOL]     return _methods.get(new MemberKey(name, paramTypes)); [EOL] }
public AnnotatedMethod find(String name, Class<?>[] paramTypes) { [EOL]     if (_methods == null) { [EOL]         return null; [EOL]     } [EOL]     return _methods.get(new MemberKey(name, paramTypes)); [EOL] }
public AnnotatedMethod find(String name, Class<?>[] paramTypes) { [EOL]     if (_methods == null) { [EOL]         return null; [EOL]     } [EOL]     return _methods.get(new MemberKey(name, paramTypes)); [EOL] }
public AnnotatedMethod find(Method m) { [EOL]     if (_methods == null) { [EOL]         return null; [EOL]     } [EOL]     return _methods.get(new MemberKey(m)); [EOL] }
public AnnotatedMethod find(Method m) { [EOL]     if (_methods == null) { [EOL]         return null; [EOL]     } [EOL]     return _methods.get(new MemberKey(m)); [EOL] }
public AnnotatedMethod find(Method m) { [EOL]     if (_methods == null) { [EOL]         return null; [EOL]     } [EOL]     return _methods.get(new MemberKey(m)); [EOL] }
@Override [EOL] public Iterator<AnnotatedMethod> iterator() { [EOL]     if (_methods != null) { [EOL]         return _methods.values().iterator(); [EOL]     } [EOL]     List<AnnotatedMethod> empty = Collections.emptyList(); [EOL]     return empty.iterator(); [EOL] }
@Override [EOL] public Iterator<AnnotatedMethod> iterator() { [EOL]     if (_methods != null) { [EOL]         return _methods.values().iterator(); [EOL]     } [EOL]     List<AnnotatedMethod> empty = Collections.emptyList(); [EOL]     return empty.iterator(); [EOL] }
protected DOMDeserializer(Class<T> cls) { [EOL]     super(cls); [EOL] }
protected final Document parse(String value) throws IllegalArgumentException { [EOL]     try { [EOL]         return _parserFactory.newDocumentBuilder().parse(new InputSource(new StringReader(value))); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Failed to parse JSON String as XML: " + e.getMessage(), e); [EOL]     } [EOL] }
protected final Document parse(String value) throws IllegalArgumentException { [EOL]     try { [EOL]         return _parserFactory.newDocumentBuilder().parse(new InputSource(new StringReader(value))); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Failed to parse JSON String as XML: " + e.getMessage(), e); [EOL]     } [EOL] }
public DocumentDeserializer() { [EOL]     super(Document.class); [EOL] }
@Override [EOL] public Document _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return parse(value); [EOL] }
@Override [EOL] public Document _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return parse(value); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser) { [EOL]     super(Map.class); [EOL]     _mapType = mapType; [EOL]     _keyDeserializer = keyDeser; [EOL]     _valueDeserializer = valueDeser; [EOL]     _valueTypeDeserializer = valueTypeDeser; [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _hasDefaultCreator = valueInstantiator.canCreateUsingDefault(); [EOL]     _delegateDeserializer = null; [EOL]     _propertyBasedCreator = null; [EOL]     _standardStringKey = _isStdKeyDeser(mapType, keyDeser); [EOL] }
public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser) { [EOL]     super(Map.class); [EOL]     _mapType = mapType; [EOL]     _keyDeserializer = keyDeser; [EOL]     _valueDeserializer = valueDeser; [EOL]     _valueTypeDeserializer = valueTypeDeser; [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _hasDefaultCreator = valueInstantiator.canCreateUsingDefault(); [EOL]     _delegateDeserializer = null; [EOL]     _propertyBasedCreator = null; [EOL]     _standardStringKey = _isStdKeyDeser(mapType, keyDeser); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
public void setIgnorableProperties(String[] ignorable) { [EOL]     _ignorableProperties = (ignorable == null || ignorable.length == 0) ? null : ArrayBuilders.arrayToSet(ignorable); [EOL] }
public void setIgnorableProperties(String[] ignorable) { [EOL]     _ignorableProperties = (ignorable == null || ignorable.length == 0) ? null : ArrayBuilders.arrayToSet(ignorable); [EOL] }
public void setIgnorableProperties(String[] ignorable) { [EOL]     _ignorableProperties = (ignorable == null || ignorable.length == 0) ? null : ArrayBuilders.arrayToSet(ignorable); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<Object> getContentDeserializer() { [EOL]     return _valueDeserializer; [EOL] }
@Override [EOL] public JsonDeserializer<Object> getContentDeserializer() { [EOL]     return _valueDeserializer; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final Class<?> getMapClass() { [EOL]     return (Class<Map<Object, Object>>) _mapType.getRawClass(); [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
public T getNullValue() { [EOL]     return null; [EOL] }
public T getEmptyValue() { [EOL]     return getNullValue(); [EOL] }
public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = SERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Serializers) ob).findSerializer(config, type, beanDesc); [EOL] }
public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = SERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Serializers) ob).findSerializer(config, type, beanDesc); [EOL] }
public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = SERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Serializers) ob).findSerializer(config, type, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterface(Class<?> type, String interfaceToImplement) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().equals(interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterface(iface, interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterface(Class<?> type, String interfaceToImplement) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().equals(interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterface(iface, interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterface(Class<?> type, String interfaceToImplement) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().equals(interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterface(iface, interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterface(Class<?> type, String interfaceToImplement) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().equals(interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterface(iface, interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterface(Class<?> type, String interfaceToImplement) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().equals(interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterface(iface, interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterfaceStartingWith(Class<?> type, String prefix) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterfaceStartingWith(iface, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static Std defaultInstance() { [EOL]     return DEFAULT; [EOL] }
public Std(JsonAutoDetect ann) { [EOL]     _getterMinLevel = ann.getterVisibility(); [EOL]     _isGetterMinLevel = ann.isGetterVisibility(); [EOL]     _setterMinLevel = ann.setterVisibility(); [EOL]     _creatorMinLevel = ann.creatorVisibility(); [EOL]     _fieldMinLevel = ann.fieldVisibility(); [EOL] }
@Override [EOL] public Std withIsGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._isGetterMinLevel; [EOL]     if (_isGetterMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, v, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withIsGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._isGetterMinLevel; [EOL]     if (_isGetterMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, v, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withCreatorVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._creatorMinLevel; [EOL]     if (_creatorMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withCreatorVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._creatorMinLevel; [EOL]     if (_creatorMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel); [EOL] }
@Override [EOL] public boolean isCreatorVisible(Member m) { [EOL]     return _creatorMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isCreatorVisible(Member m) { [EOL]     return _creatorMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isCreatorVisible(Member m) { [EOL]     return _creatorMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isCreatorVisible(AnnotatedMember m) { [EOL]     return isCreatorVisible(m.getMember()); [EOL] }
@Override [EOL] public boolean isCreatorVisible(AnnotatedMember m) { [EOL]     return isCreatorVisible(m.getMember()); [EOL] }
@Override [EOL] public boolean isFieldVisible(Field f) { [EOL]     return _fieldMinLevel.isVisible(f); [EOL] }
@Override [EOL] public boolean isFieldVisible(Field f) { [EOL]     return _fieldMinLevel.isVisible(f); [EOL] }
@Override [EOL] public boolean isFieldVisible(AnnotatedField f) { [EOL]     return isFieldVisible(f.getAnnotated()); [EOL] }
@Override [EOL] public boolean isFieldVisible(AnnotatedField f) { [EOL]     return isFieldVisible(f.getAnnotated()); [EOL] }
@Override [EOL] public boolean isGetterVisible(Method m) { [EOL]     return _getterMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isGetterVisible(Method m) { [EOL]     return _getterMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isGetterVisible(AnnotatedMethod m) { [EOL]     return isGetterVisible(m.getAnnotated()); [EOL] }
@Override [EOL] public boolean isGetterVisible(AnnotatedMethod m) { [EOL]     return isGetterVisible(m.getAnnotated()); [EOL] }
@Override [EOL] public boolean isIsGetterVisible(Method m) { [EOL]     return _isGetterMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isIsGetterVisible(Method m) { [EOL]     return _isGetterMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isIsGetterVisible(AnnotatedMethod m) { [EOL]     return isIsGetterVisible(m.getAnnotated()); [EOL] }
@Override [EOL] public boolean isIsGetterVisible(AnnotatedMethod m) { [EOL]     return isIsGetterVisible(m.getAnnotated()); [EOL] }
@Override [EOL] public boolean isSetterVisible(Method m) { [EOL]     return _setterMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isSetterVisible(Method m) { [EOL]     return _setterMinLevel.isVisible(m); [EOL] }
@Override [EOL] public boolean isSetterVisible(AnnotatedMethod m) { [EOL]     return isSetterVisible(m.getAnnotated()); [EOL] }
@Override [EOL] public boolean isSetterVisible(AnnotatedMethod m) { [EOL]     return isSetterVisible(m.getAnnotated()); [EOL] }
public static ValueInstantiator findValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) { [EOL]     if (beanDesc.getBeanClass() == JsonLocation.class) { [EOL]         return JsonLocationInstantiator.instance; [EOL]     } [EOL]     return null; [EOL] }
public static ValueInstantiator findValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) { [EOL]     if (beanDesc.getBeanClass() == JsonLocation.class) { [EOL]         return JsonLocationInstantiator.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public boolean canCreateFromObjectWith() { [EOL]     return true; [EOL] }
@Override [EOL] public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) { [EOL]     JavaType intType = config.constructType(Integer.TYPE); [EOL]     JavaType longType = config.constructType(Long.TYPE); [EOL]     return new CreatorProperty[] { creatorProp("sourceRef", config.constructType(Object.class), 0), creatorProp("byteOffset", longType, 1), creatorProp("charOffset", longType, 2), creatorProp("lineNr", intType, 3), creatorProp("columnNr", intType, 4) }; [EOL] }
private static CreatorProperty creatorProp(String name, JavaType type, int index) { [EOL]     return new CreatorProperty(name, type, null, null, null, null, index, null, true); [EOL] }
private static CreatorProperty creatorProp(String name, JavaType type, int index) { [EOL]     return new CreatorProperty(name, type, null, null, null, null, index, null, true); [EOL] }
private static CreatorProperty creatorProp(String name, JavaType type, int index) { [EOL]     return new CreatorProperty(name, type, null, null, null, null, index, null, true); [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) { [EOL]     return new JsonLocation(args[0], _long(args[1]), _long(args[2]), _int(args[3]), _int(args[4])); [EOL] }
@Override [EOL] public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) { [EOL]     return new JsonLocation(args[0], _long(args[1]), _long(args[2]), _int(args[3]), _int(args[4])); [EOL] }
private final static long _long(Object o) { [EOL]     return (o == null) ? 0L : ((Number) o).longValue(); [EOL] }
private final static long _long(Object o) { [EOL]     return (o == null) ? 0L : ((Number) o).longValue(); [EOL] }
private final static int _int(Object o) { [EOL]     return (o == null) ? 0 : ((Number) o).intValue(); [EOL] }
private final static int _int(Object o) { [EOL]     return (o == null) ? 0 : ((Number) o).intValue(); [EOL] }
public JsonMappingException(String msg) { [EOL]     super(msg); [EOL] }
@Override [EOL] public final Class<?> getActiveView() { [EOL]     return _serializationView; [EOL] }
public final boolean isEnabled(SerializationFeature feature) { [EOL]     return _config.isEnabled(feature); [EOL] }
public final boolean isEnabled(SerializationFeature feature) { [EOL]     return _config.isEnabled(feature); [EOL] }
public final FilterProvider getFilterProvider() { [EOL]     return _config.getFilterProvider(); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public final void defaultSerializeValue(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         getDefaultNullValueSerializer().serialize(null, jgen, this); [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         findTypedValueSerializer(cls, true, null).serialize(value, jgen, this); [EOL]     } [EOL] }
public final void defaultSerializeValue(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         getDefaultNullValueSerializer().serialize(null, jgen, this); [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         findTypedValueSerializer(cls, true, null).serialize(value, jgen, this); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> _handleResolvable(JsonSerializer<?> ser) throws JsonMappingException { [EOL]     if (ser instanceof ResolvableSerializer) { [EOL]         ((ResolvableSerializer) ser).resolve(this); [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> _handleResolvable(JsonSerializer<?> ser) throws JsonMappingException { [EOL]     if (ser instanceof ResolvableSerializer) { [EOL]         ((ResolvableSerializer) ser).resolve(this); [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> _handleContextual(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException { [EOL]     if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(this, property); [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> _handleContextual(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException { [EOL]     if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(this, property); [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
