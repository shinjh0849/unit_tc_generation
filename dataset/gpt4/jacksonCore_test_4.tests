public void testOriginalMesssage() { [EOL]     JsonProcessingException exc = new JsonParseException("Foobar", JsonLocation.NA); [EOL]     String msg = exc.getMessage(); [EOL]     String orig = exc.getOriginalMessage(); [EOL]     assertEquals("Foobar", orig); [EOL]     assertTrue(msg.length() > orig.length()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testLongBoundsChecks() throws Exception { [EOL]     String minLong = String.valueOf(Long.MIN_VALUE).substring(1); [EOL]     String maxLong = String.valueOf(Long.MAX_VALUE); [EOL]     final String VALUE_491 = "1323372036854775807"; [EOL]     final String OVERFLOW = "9999999999999999999"; [EOL]     assertTrue(NumberInput.inLongRange(minLong, true)); [EOL]     assertTrue(NumberInput.inLongRange(maxLong, false)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, true)); [EOL]     assertTrue(NumberInput.inLongRange(VALUE_491, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, false)); [EOL]     assertFalse(NumberInput.inLongRange(OVERFLOW, true)); [EOL]     char[] cbuf = minLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     cbuf = maxLong.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = VALUE_491.toCharArray(); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL]     cbuf = OVERFLOW.toCharArray(); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true)); [EOL]     assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false)); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testIssue34() throws Exception { [EOL]     _testIssue34(false); [EOL]     _testIssue34(true); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ ]"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ ]"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ ]"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ ]"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ ]"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ ]"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] }
public void testInterningWithReaders() throws Exception { [EOL]     _testIntern(false, true, "c"); [EOL]     _testIntern(false, false, "d"); [EOL] }
public void testInterningWithReaders() throws Exception { [EOL]     _testIntern(false, true, "c"); [EOL]     _testIntern(false, false, "d"); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testSimple() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(new char[] { 'X', 'b' }, 1, 1); [EOL]     tb.append("c", 0, 1); [EOL]     assertEquals(3, tb.contentsAsArray().length); [EOL]     assertEquals("abc", tb.toString()); [EOL]     assertNotNull(tb.expandCurrentSegment()); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "123 [ 1, null, [ false ] ]"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("123 [1,null,[false]]", sw.toString()); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "123 [ 1, null, [ false ] ]"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("123 [1,null,[false]]", sw.toString()); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "123 [ 1, null, [ false ] ]"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("123 [1,null,[false]]", sw.toString()); [EOL] }
public void testCopyArrayTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "123 [ 1, null, [ false ] ]"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     gen.copyCurrentEvent(jp); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(123, jp.getIntValue()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     gen.copyCurrentStructure(jp); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("123 [1,null,[false]]", sw.toString()); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = "Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = "Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = "Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = "Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = "Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = "Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = "Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testUtf8Issue462() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     IOContext ioc = new IOContext(new BufferRecycler(), bytes, true); [EOL]     JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes); [EOL]     String str = "Natuurlijk is alles gelukt en weer een tevreden klant\uD83D\uDE04"; [EOL]     int length = 4000 - 38; [EOL]     for (int i = 1; i <= length; ++i) { [EOL]         gen.writeNumber(1); [EOL]     } [EOL]     gen.writeString(str); [EOL]     gen.flush(); [EOL]     gen.close(); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testAboveAsciiEscapeWithUTF8Stream() throws Exception { [EOL]     _testEscapeAboveAscii(true); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
public void testSimpleInvalid() throws Exception { [EOL]     DataFormatDetector detector = new DataFormatDetector(new JsonFactory()); [EOL]     final String NON_JSON = "<root />"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes("UTF-8"))); [EOL]     assertFalse(matcher.hasMatch()); [EOL]     assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength()); [EOL]     assertNull(matcher.createParserWithMatch()); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testSimpleDocWithMinimal() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL]     String docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertEquals(-1, docStr.indexOf('\t')); [EOL]     gen = new JsonFactory().createGenerator(sw); [EOL]     gen.setPrettyPrinter(new MinimalPrettyPrinter() { [EOL]  [EOL]         @Override [EOL]         public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException { [EOL]             jg.writeRaw("\t"); [EOL]         } [EOL]     }); [EOL]     docStr = _verifyPrettyPrinter(gen, sw); [EOL]     assertEquals(-1, docStr.indexOf('\n')); [EOL]     assertTrue(docStr.indexOf('\t') >= 0); [EOL]     gen.close(); [EOL] }
public void testLocationSerializability() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser("  { }"); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     JsonLocation loc = jp.getCurrentLocation(); [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     ObjectOutputStream out = new ObjectOutputStream(bytes); [EOL]     out.writeObject(loc); [EOL]     out.close(); [EOL]     byte[] stuff = bytes.toByteArray(); [EOL]     ObjectInputStream obIn = new ObjectInputStream(new ByteArrayInputStream(stuff)); [EOL]     JsonLocation loc2 = (JsonLocation) obIn.readObject(); [EOL]     assertNotNull(loc2); [EOL]     assertEquals(loc.getLineNr(), loc2.getLineNr()); [EOL]     assertEquals(loc.getColumnNr(), loc2.getColumnNr()); [EOL]     jp.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testBase64UsingReader() throws Exception { [EOL]     _testBase64Text(false); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testMismatchArrayToObject() throws Exception { [EOL]     final String JSON = "[ 1, 2 }"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = (i == 0) ? createParserUsingReader(JSON) : createParserUsingStream(JSON, "UTF-8"); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         try { [EOL]             jp.nextToken(); [EOL]             fail("Expected an exception for incorrectly closed ARRAY"); [EOL]         } catch (JsonParseException jpe) { [EOL]             verifyException(jpe, "Unexpected close marker '}': expected ']'"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testTabsEnabled() throws Exception { [EOL]     _testTabsEnabled(false); [EOL]     _testTabsEnabled(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
public void testAllowInfinity() throws Exception { [EOL]     _testAllowInf(false); [EOL]     _testAllowInf(true); [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testAutoCloseArraysAndObjects() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator jg = f.createGenerator(sw); [EOL]     jg.writeStartArray(); [EOL]     jg.close(); [EOL]     assertEquals("[]", sw.toString()); [EOL]     sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.close(); [EOL]     assertEquals("{}", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testInArray() throws IOException { [EOL]     _testInArray(false); [EOL]     _testInArray(true); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testCopyRootTokens() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     final String DOC = "\"text\\non two lines\" true false 2.0"; [EOL]     JsonParser jp = jf.createParser(new StringReader(DOC)); [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = jf.createGenerator(sw); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != null) { [EOL]         gen.copyCurrentEvent(jp); [EOL]         assertToken(t, jp.getCurrentToken()); [EOL]     } [EOL]     jp.close(); [EOL]     gen.close(); [EOL]     assertEquals("\"text\\non two lines\" true false 2.0", sw.toString()); [EOL] }
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] }
public void testAppendQuoted0_31() { [EOL]     final String[] inputs = { "\u0000", "\u001F", "abcd", "\u0001ABCD\u0002", "WX\u000F\u0010YZ" }; [EOL]     final String[] expecteds = { "\\u0000", "\\u001F", "abcd", "\\u0001ABCD\\u0002", "WX\\u000F\\u0010YZ" }; [EOL]     assert inputs.length == expecteds.length; [EOL]     for (int i = 0; i < inputs.length; i++) { [EOL]         final String input = inputs[i]; [EOL]         final String expected = expecteds[i]; [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         CharTypes.appendQuoted(sb, input); [EOL]         final String actual = sb.toString(); [EOL]         assertEquals(expected, actual); [EOL]     } [EOL] }
public void testAppendQuoted0_31() { [EOL]     final String[] inputs = { "\u0000", "\u001F", "abcd", "\u0001ABCD\u0002", "WX\u000F\u0010YZ" }; [EOL]     final String[] expecteds = { "\\u0000", "\\u001F", "abcd", "\\u0001ABCD\\u0002", "WX\\u000F\\u0010YZ" }; [EOL]     assert inputs.length == expecteds.length; [EOL]     for (int i = 0; i < inputs.length; i++) { [EOL]         final String input = inputs[i]; [EOL]         final String expected = expecteds[i]; [EOL]         final StringBuilder sb = new StringBuilder(); [EOL]         CharTypes.appendQuoted(sb, input); [EOL]         final String actual = sb.toString(); [EOL]         assertEquals(expected, actual); [EOL]     } [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextFieldName() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     SerializedString id = new SerializedString("id"); [EOL]     ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL]     os.write('{'); [EOL]     for (int i = 0; i < 3994; i++) { [EOL]         os.write(' '); [EOL]     } [EOL]     os.write("\"id\":2".getBytes("UTF-8")); [EOL]     os.write('}'); [EOL]     JsonParser parser = f.createParser(new ByteArrayInputStream(os.toByteArray())); [EOL]     assertEquals(parser.nextToken(), JsonToken.START_OBJECT); [EOL]     assertTrue(parser.nextFieldName(id)); [EOL]     assertEquals(parser.nextToken(), JsonToken.VALUE_NUMBER_INT); [EOL]     assertEquals(parser.nextToken(), JsonToken.END_OBJECT); [EOL]     parser.close(); [EOL] }
public void testNextValueNested() throws IOException { [EOL]     _testNextValueNested(false); [EOL]     _testNextValueNested(true); [EOL] }
public void testNextValueNested() throws IOException { [EOL]     _testNextValueNested(false); [EOL]     _testNextValueNested(true); [EOL] }
public void testNonStandardAnyCharQuoting() throws Exception { [EOL]     _testNonStandarBackslashQuoting(false); [EOL]     _testNonStandarBackslashQuoting(true); [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
public void testIsClosed() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         boolean stream = ((i & 1) == 0); [EOL]         JsonGenerator jg = stream ? jf.createGenerator(new StringWriter()) : jf.createGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.writeStartArray(); [EOL]         jg.writeNumber(-1); [EOL]         jg.writeEndArray(); [EOL]         assertFalse(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]         jg.close(); [EOL]         assertTrue(jg.isClosed()); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals("567", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals("123", out.toString("UTF-8")); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals("567", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals("123", out.toString("UTF-8")); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testParserFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testBytesAsSource() throws Exception { [EOL]     String JSON = "[ 1, 2, 3, 4 ]"; [EOL]     byte[] b = JSON.getBytes("UTF-8"); [EOL]     int offset = 50; [EOL]     int len = b.length; [EOL]     byte[] src = new byte[offset + len + offset]; [EOL]     System.arraycopy(b, 0, src, offset, len); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(src, offset, len); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(2, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(3, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(4, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testBytesAsSource() throws Exception { [EOL]     String JSON = "[ 1, 2, 3, 4 ]"; [EOL]     byte[] b = JSON.getBytes("UTF-8"); [EOL]     int offset = 50; [EOL]     int len = b.length; [EOL]     byte[] src = new byte[offset + len + offset]; [EOL]     System.arraycopy(b, 0, src, offset, len); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(src, offset, len); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(2, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(3, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(4, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals("567", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals("123", out.toString("UTF-8")); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals("567", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals("123", out.toString("UTF-8")); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals("567", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals("123", out.toString("UTF-8")); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals("567", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals("123", out.toString("UTF-8")); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals("567", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals("123", out.toString("UTF-8")); [EOL] }
public void testOutputDecoration() throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.setOutputDecorator(new SimpleOutputDecorator()); [EOL]     JsonGenerator jg; [EOL]     StringWriter sw = new StringWriter(); [EOL]     jg = f.createGenerator(sw); [EOL]     jg.close(); [EOL]     assertEquals("567", sw.toString()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     jg = f.createGenerator(out, JsonEncoding.UTF8); [EOL]     jg.close(); [EOL]     assertEquals("123", out.toString("UTF-8")); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testJsonWithFiles() throws Exception { [EOL]     File file = File.createTempFile("jackson-test", null); [EOL]     file.deleteOnExit(); [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE); [EOL]     jg.writeStartObject(); [EOL]     jg.writeRaw("   "); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     JsonParser jp = f.createParser(file); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     jp = f.createParser(file.toURI().toURL()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL]     file.delete(); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
public void testAuxMethods() throws Exception { [EOL]     final int A_BYTES = 0x41414141; [EOL]     final int B_BYTES = 0x42424242; [EOL]     BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot().makeChild(true, true); [EOL]     assertNull(nc.findName(A_BYTES)); [EOL]     assertNull(nc.findName(A_BYTES, B_BYTES)); [EOL]     nc.addName("AAAA", new int[] { A_BYTES }, 1); [EOL]     Name n1 = nc.findName(A_BYTES); [EOL]     assertNotNull(n1); [EOL]     assertEquals("AAAA", n1.getName()); [EOL]     nc.addName("AAAABBBB", new int[] { A_BYTES, B_BYTES }, 2); [EOL]     Name n2 = nc.findName(A_BYTES, B_BYTES); [EOL]     assertEquals("AAAABBBB", n2.getName()); [EOL]     assertNotNull(n2); [EOL]     assertNotNull(nc.toString()); [EOL] }
