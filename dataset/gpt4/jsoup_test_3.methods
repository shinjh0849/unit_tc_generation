public Integer siblingIndex() { [EOL]     return indexInList(this, parent().childNodes); [EOL] }
public Integer siblingIndex() { [EOL]     return indexInList(this, parent().childNodes); [EOL] }
public Integer siblingIndex() { [EOL]     return indexInList(this, parent().childNodes); [EOL] }
public Integer siblingIndex() { [EOL]     return indexInList(this, parent().childNodes); [EOL] }
public boolean hasAttr(String attributeKey) { [EOL]     for (Element element : contents) { [EOL]         if (element.hasAttr(attributeKey)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean hasAttr(String attributeKey) { [EOL]     for (Element element : contents) { [EOL]         if (element.hasAttr(attributeKey)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean hasAttr(String attributeKey) { [EOL]     for (Element element : contents) { [EOL]         if (element.hasAttr(attributeKey)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
private Evaluator() { [EOL] }
Tag(String tagName) { [EOL]     this.tagName = tagName; [EOL] }
Tag(String tagName) { [EOL]     this.tagName = tagName; [EOL] }
Tag(String tagName) { [EOL]     this.tagName = tagName; [EOL] }
public boolean matches(Element element) { [EOL]     return (element.tagName().equals(tagName)); [EOL] }
public boolean matches(Element element) { [EOL]     return (element.tagName().equals(tagName)); [EOL] }
Class(String className) { [EOL]     this.className = className; [EOL] }
public boolean matches(Element element) { [EOL]     return (element.hasClass(className)); [EOL] }
public boolean matches(Element element) { [EOL]     return (element.hasClass(className)); [EOL] }
Attribute(String key) { [EOL]     this.key = key; [EOL] }
Attribute(String key) { [EOL]     this.key = key; [EOL] }
Attribute(String key) { [EOL]     this.key = key; [EOL] }
public boolean matches(Element element) { [EOL]     return (element.hasAttr(key)); [EOL] }
public boolean matches(Element element) { [EOL]     return (element.hasAttr(key)); [EOL] }
AttributeWithValue(String key, String value) { [EOL]     super(key, value); [EOL] }
public boolean matches(Element element) { [EOL]     return (value.equalsIgnoreCase(element.attr(key))); [EOL] }
public boolean matches(Element element) { [EOL]     return (value.equalsIgnoreCase(element.attr(key))); [EOL] }
public boolean matches(Element element) { [EOL]     return (value.equalsIgnoreCase(element.attr(key))); [EOL] }
AttributeWithValueContaining(String key, String value) { [EOL]     super(key, value); [EOL] }
AttributeWithValueContaining(String key, String value) { [EOL]     super(key, value); [EOL] }
AttributeWithValueContaining(String key, String value) { [EOL]     super(key, value); [EOL] }
AttributeWithValueContaining(String key, String value) { [EOL]     super(key, value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().contains(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().contains(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().contains(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().contains(value); [EOL] }
public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().contains(value); [EOL] }
AttributeKeyPair(String key, String value) { [EOL]     Validate.notEmpty(key); [EOL]     Validate.notEmpty(value); [EOL]     this.key = key.trim().toLowerCase(); [EOL]     this.value = value.trim().toLowerCase(); [EOL] }
AttributeKeyPair(String key, String value) { [EOL]     Validate.notEmpty(key); [EOL]     Validate.notEmpty(value); [EOL]     this.key = key.trim().toLowerCase(); [EOL]     this.value = value.trim().toLowerCase(); [EOL] }
AttributeKeyPair(String key, String value) { [EOL]     Validate.notEmpty(key); [EOL]     Validate.notEmpty(value); [EOL]     this.key = key.trim().toLowerCase(); [EOL]     this.value = value.trim().toLowerCase(); [EOL] }
AttributeKeyPair(String key, String value) { [EOL]     Validate.notEmpty(key); [EOL]     Validate.notEmpty(value); [EOL]     this.key = key.trim().toLowerCase(); [EOL]     this.value = value.trim().toLowerCase(); [EOL] }
AttributeKeyPair(String key, String value) { [EOL]     Validate.notEmpty(key); [EOL]     Validate.notEmpty(value); [EOL]     this.key = key.trim().toLowerCase(); [EOL]     this.value = value.trim().toLowerCase(); [EOL] }
IndexEquals(int index) { [EOL]     super(index); [EOL] }
public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() == index; [EOL] }
public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() == index; [EOL] }
public TokenQueue(String data) { [EOL]     Validate.notNull(data); [EOL]     queue = new LinkedList<Character>(); [EOL]     char[] chars = data.toCharArray(); [EOL]     for (char c : chars) { [EOL]         queue.add(c); [EOL]     } [EOL] }
public boolean isEmpty() { [EOL]     return queue.isEmpty(); [EOL] }
public boolean isEmpty() { [EOL]     return queue.isEmpty(); [EOL] }
public boolean matches(String seq) { [EOL]     int len = seq.length(); [EOL]     if (len > queue.size()) [EOL]         return false; [EOL]     List<Character> chars = queue.subList(0, len); [EOL]     char[] seqChars = seq.toCharArray(); [EOL]     for (int i = 0; i < len; i++) { [EOL]         Character found = Character.toLowerCase(chars.get(i)); [EOL]         Character check = Character.toLowerCase(seqChars[i]); [EOL]         if (!found.equals(check)) [EOL]             return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean matches(String seq) { [EOL]     int len = seq.length(); [EOL]     if (len > queue.size()) [EOL]         return false; [EOL]     List<Character> chars = queue.subList(0, len); [EOL]     char[] seqChars = seq.toCharArray(); [EOL]     for (int i = 0; i < len; i++) { [EOL]         Character found = Character.toLowerCase(chars.get(i)); [EOL]         Character check = Character.toLowerCase(seqChars[i]); [EOL]         if (!found.equals(check)) [EOL]             return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean matches(String seq) { [EOL]     int len = seq.length(); [EOL]     if (len > queue.size()) [EOL]         return false; [EOL]     List<Character> chars = queue.subList(0, len); [EOL]     char[] seqChars = seq.toCharArray(); [EOL]     for (int i = 0; i < len; i++) { [EOL]         Character found = Character.toLowerCase(chars.get(i)); [EOL]         Character check = Character.toLowerCase(seqChars[i]); [EOL]         if (!found.equals(check)) [EOL]             return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean matches(String seq) { [EOL]     int len = seq.length(); [EOL]     if (len > queue.size()) [EOL]         return false; [EOL]     List<Character> chars = queue.subList(0, len); [EOL]     char[] seqChars = seq.toCharArray(); [EOL]     for (int i = 0; i < len; i++) { [EOL]         Character found = Character.toLowerCase(chars.get(i)); [EOL]         Character check = Character.toLowerCase(seqChars[i]); [EOL]         if (!found.equals(check)) [EOL]             return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean matchesAny(String... seq) { [EOL]     for (String s : seq) { [EOL]         if (matches(s)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean matchesAny(String... seq) { [EOL]     for (String s : seq) { [EOL]         if (matches(s)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean matchesAny(String... seq) { [EOL]     for (String s : seq) { [EOL]         if (matches(s)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean matchesAny(String... seq) { [EOL]     for (String s : seq) { [EOL]         if (matches(s)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean matchChomp(String seq) { [EOL]     if (matches(seq)) { [EOL]         consume(seq); [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
public boolean matchChomp(String seq) { [EOL]     if (matches(seq)) { [EOL]         consume(seq); [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
public boolean matchesWhitespace() { [EOL]     return !queue.isEmpty() && Character.isWhitespace(queue.peek()); [EOL] }
public boolean matchesWhitespace() { [EOL]     return !queue.isEmpty() && Character.isWhitespace(queue.peek()); [EOL] }
public boolean matchesWhitespace() { [EOL]     return !queue.isEmpty() && Character.isWhitespace(queue.peek()); [EOL] }
public boolean matchesWord() { [EOL]     return !queue.isEmpty() && Character.isLetterOrDigit(queue.peek()); [EOL] }
public boolean matchesWord() { [EOL]     return !queue.isEmpty() && Character.isLetterOrDigit(queue.peek()); [EOL] }
public boolean matchesWord() { [EOL]     return !queue.isEmpty() && Character.isLetterOrDigit(queue.peek()); [EOL] }
public boolean matchesWord() { [EOL]     return !queue.isEmpty() && Character.isLetterOrDigit(queue.peek()); [EOL] }
public Character consume() { [EOL]     return queue.removeFirst(); [EOL] }
public Character consume() { [EOL]     return queue.removeFirst(); [EOL] }
public void consume(String seq) { [EOL]     if (!matches(seq)) [EOL]         throw new IllegalStateException("Queue did not match expected sequence"); [EOL]     int len = seq.length(); [EOL]     if (len > queue.size()) [EOL]         throw new IllegalStateException("Queue not long enough to consume sequence"); [EOL]     for (int i = 0; i < len; i++) { [EOL]         consume(); [EOL]     } [EOL] }
public void consume(String seq) { [EOL]     if (!matches(seq)) [EOL]         throw new IllegalStateException("Queue did not match expected sequence"); [EOL]     int len = seq.length(); [EOL]     if (len > queue.size()) [EOL]         throw new IllegalStateException("Queue not long enough to consume sequence"); [EOL]     for (int i = 0; i < len; i++) { [EOL]         consume(); [EOL]     } [EOL] }
public void consume(String seq) { [EOL]     if (!matches(seq)) [EOL]         throw new IllegalStateException("Queue did not match expected sequence"); [EOL]     int len = seq.length(); [EOL]     if (len > queue.size()) [EOL]         throw new IllegalStateException("Queue not long enough to consume sequence"); [EOL]     for (int i = 0; i < len; i++) { [EOL]         consume(); [EOL]     } [EOL] }
public String consumeTo(String seq) { [EOL]     return consumeToAny(seq); [EOL] }
public String consumeTo(String seq) { [EOL]     return consumeToAny(seq); [EOL] }
public String consumeTo(String seq) { [EOL]     return consumeToAny(seq); [EOL] }
public String consumeToAny(String... seq) { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && !matchesAny(seq)) accum.append(consume()); [EOL]     return accum.toString(); [EOL] }
public String consumeToAny(String... seq) { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && !matchesAny(seq)) accum.append(consume()); [EOL]     return accum.toString(); [EOL] }
public String consumeToAny(String... seq) { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && !matchesAny(seq)) accum.append(consume()); [EOL]     return accum.toString(); [EOL] }
public String consumeToAny(String... seq) { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && !matchesAny(seq)) accum.append(consume()); [EOL]     return accum.toString(); [EOL] }
public String consumeToAny(String... seq) { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && !matchesAny(seq)) accum.append(consume()); [EOL]     return accum.toString(); [EOL] }
public String chompTo(String seq) { [EOL]     String data = consumeTo(seq); [EOL]     matchChomp(seq); [EOL]     return data; [EOL] }
public boolean consumeWhitespace() { [EOL]     boolean seen = false; [EOL]     while (!queue.isEmpty() && Character.isWhitespace(queue.peek())) { [EOL]         consume(); [EOL]         seen = true; [EOL]     } [EOL]     return seen; [EOL] }
public String consumeWord() { [EOL]     StringBuilder wordAccum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && Character.isLetterOrDigit(queue.peek())) { [EOL]         wordAccum.append(queue.removeFirst()); [EOL]     } [EOL]     return wordAccum.toString(); [EOL] }
public String consumeWord() { [EOL]     StringBuilder wordAccum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && Character.isLetterOrDigit(queue.peek())) { [EOL]         wordAccum.append(queue.removeFirst()); [EOL]     } [EOL]     return wordAccum.toString(); [EOL] }
public String consumeWord() { [EOL]     StringBuilder wordAccum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && Character.isLetterOrDigit(queue.peek())) { [EOL]         wordAccum.append(queue.removeFirst()); [EOL]     } [EOL]     return wordAccum.toString(); [EOL] }
public String consumeWord() { [EOL]     StringBuilder wordAccum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && Character.isLetterOrDigit(queue.peek())) { [EOL]         wordAccum.append(queue.removeFirst()); [EOL]     } [EOL]     return wordAccum.toString(); [EOL] }
public String consumeWord() { [EOL]     StringBuilder wordAccum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && Character.isLetterOrDigit(queue.peek())) { [EOL]         wordAccum.append(queue.removeFirst()); [EOL]     } [EOL]     return wordAccum.toString(); [EOL] }
public String consumeCssIdentifier() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     Character c = queue.peek(); [EOL]     while (!queue.isEmpty() && (Character.isLetterOrDigit(c) || c.equals('-') || c.equals('_'))) { [EOL]         accum.append(queue.removeFirst()); [EOL]         c = queue.peek(); [EOL]     } [EOL]     return accum.toString(); [EOL] }
public String consumeCssIdentifier() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     Character c = queue.peek(); [EOL]     while (!queue.isEmpty() && (Character.isLetterOrDigit(c) || c.equals('-') || c.equals('_'))) { [EOL]         accum.append(queue.removeFirst()); [EOL]         c = queue.peek(); [EOL]     } [EOL]     return accum.toString(); [EOL] }
public String consumeCssIdentifier() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     Character c = queue.peek(); [EOL]     while (!queue.isEmpty() && (Character.isLetterOrDigit(c) || c.equals('-') || c.equals('_'))) { [EOL]         accum.append(queue.removeFirst()); [EOL]         c = queue.peek(); [EOL]     } [EOL]     return accum.toString(); [EOL] }
public String consumeCssIdentifier() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     Character c = queue.peek(); [EOL]     while (!queue.isEmpty() && (Character.isLetterOrDigit(c) || c.equals('-') || c.equals('_'))) { [EOL]         accum.append(queue.removeFirst()); [EOL]         c = queue.peek(); [EOL]     } [EOL]     return accum.toString(); [EOL] }
public String consumeCssIdentifier() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     Character c = queue.peek(); [EOL]     while (!queue.isEmpty() && (Character.isLetterOrDigit(c) || c.equals('-') || c.equals('_'))) { [EOL]         accum.append(queue.removeFirst()); [EOL]         c = queue.peek(); [EOL]     } [EOL]     return accum.toString(); [EOL] }
public String consumeAttributeKey() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     while (!queue.isEmpty() && (Character.isLetterOrDigit(queue.peek()) || matchesAny("-", "_", ":"))) { [EOL]         accum.append(queue.removeFirst()); [EOL]     } [EOL]     return accum.toString(); [EOL] }
public static Elements collect(Evaluator eval, Element root) { [EOL]     Elements elements = new Elements(); [EOL]     accumulateMatches(eval, elements, root); [EOL]     return elements; [EOL] }
public static Elements collect(Evaluator eval, Element root) { [EOL]     Elements elements = new Elements(); [EOL]     accumulateMatches(eval, elements, root); [EOL]     return elements; [EOL] }
public static Elements collect(Evaluator eval, Element root) { [EOL]     Elements elements = new Elements(); [EOL]     accumulateMatches(eval, elements, root); [EOL]     return elements; [EOL] }
private static void accumulateMatches(Evaluator eval, List<Element> elements, Element element) { [EOL]     if (eval.matches(element)) [EOL]         elements.add(element); [EOL]     for (Element child : element.children()) accumulateMatches(eval, elements, child); [EOL] }
private static void accumulateMatches(Evaluator eval, List<Element> elements, Element element) { [EOL]     if (eval.matches(element)) [EOL]         elements.add(element); [EOL]     for (Element child : element.children()) accumulateMatches(eval, elements, child); [EOL] }
private static void accumulateMatches(Evaluator eval, List<Element> elements, Element element) { [EOL]     if (eval.matches(element)) [EOL]         elements.add(element); [EOL]     for (Element child : element.children()) accumulateMatches(eval, elements, child); [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
@Override [EOL] public Element text(String text) { [EOL]     body().text(text); [EOL]     return this; [EOL] }
@Override [EOL] public Element text(String text) { [EOL]     body().text(text); [EOL]     return this; [EOL] }
@Override [EOL] public Element text(String text) { [EOL]     body().text(text); [EOL]     return this; [EOL] }
private Elements select() { [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchesAny(combinators)) { [EOL]         elements.add(root); [EOL]         combinator(tq.consume().toString()); [EOL]     } else { [EOL]         addElements(findElements()); [EOL]     } [EOL]     while (!tq.isEmpty()) { [EOL]         boolean seenWhite = tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(",")) { [EOL]             while (!tq.isEmpty()) { [EOL]                 String subQuery = tq.chompTo(","); [EOL]                 elements.addAll(select(subQuery, root)); [EOL]             } [EOL]         } else if (tq.matchesAny(combinators)) { [EOL]             combinator(tq.consume().toString()); [EOL]         } else if (seenWhite) { [EOL]             combinator(" "); [EOL]         } else { [EOL]             Elements candidates = findElements(); [EOL]             intersectElements(filterForSelf(elements, candidates)); [EOL]         } [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements indexEquals() { [EOL]     return root.getElementsByIndexEquals(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements output = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             int ePos = e.elementSiblingIndex(); [EOL]             int cPos = c.elementSiblingIndex(); [EOL]             if (cPos > ePos) { [EOL]                 output.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return output; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements output = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             int ePos = e.elementSiblingIndex(); [EOL]             int cPos = c.elementSiblingIndex(); [EOL]             if (cPos > ePos) { [EOL]                 output.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return output; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements output = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             int ePos = e.elementSiblingIndex(); [EOL]             int cPos = c.elementSiblingIndex(); [EOL]             if (cPos > ePos) { [EOL]                 output.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return output; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements output = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             int ePos = e.elementSiblingIndex(); [EOL]             int cPos = c.elementSiblingIndex(); [EOL]             if (cPos > ePos) { [EOL]                 output.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return output; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements output = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             int ePos = e.elementSiblingIndex(); [EOL]             int cPos = c.elementSiblingIndex(); [EOL]             if (cPos > ePos) { [EOL]                 output.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return output; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] }
static String stripLeadingWhitespace(String text) { [EOL]     return text.replaceFirst("^\\s+", ""); [EOL] }
static String stripLeadingWhitespace(String text) { [EOL]     return text.replaceFirst("^\\s+", ""); [EOL] }
static String stripLeadingWhitespace(String text) { [EOL]     return text.replaceFirst("^\\s+", ""); [EOL] }
static String stripLeadingWhitespace(String text) { [EOL]     return text.replaceFirst("^\\s+", ""); [EOL] }
static String stripLeadingWhitespace(String text) { [EOL]     return text.replaceFirst("^\\s+", ""); [EOL] }
static String stripLeadingWhitespace(String text) { [EOL]     return text.replaceFirst("^\\s+", ""); [EOL] }
static String stripLeadingWhitespace(String text) { [EOL]     return text.replaceFirst("^\\s+", ""); [EOL] }
static boolean lastCharIsWhitespace(StringBuilder sb) { [EOL]     if (sb.length() == 0) [EOL]         return false; [EOL]     String lastChar = sb.substring(sb.length() - 1, sb.length()); [EOL]     Validate.isTrue(lastChar.length() == 1); [EOL]     return lastChar.equals(" "); [EOL] }
public String id() { [EOL]     String id = attr("id"); [EOL]     return id == null ? "" : id; [EOL] }
public Element getElementById(String id) { [EOL]     Validate.notEmpty(id); [EOL]     Elements elements = Collector.collect(new Evaluator.Id(id), this); [EOL]     if (elements.size() > 0) [EOL]         return elements.get(0); [EOL]     else [EOL]         return null; [EOL] }
public Element getElementById(String id) { [EOL]     Validate.notEmpty(id); [EOL]     Elements elements = Collector.collect(new Evaluator.Id(id), this); [EOL]     if (elements.size() > 0) [EOL]         return elements.get(0); [EOL]     else [EOL]         return null; [EOL] }
public Element getElementById(String id) { [EOL]     Validate.notEmpty(id); [EOL]     Elements elements = Collector.collect(new Evaluator.Id(id), this); [EOL]     if (elements.size() > 0) [EOL]         return elements.get(0); [EOL]     else [EOL]         return null; [EOL] }
public Elements getElementsByAttribute(String key) { [EOL]     Validate.notEmpty(key); [EOL]     key = key.trim().toLowerCase(); [EOL]     return Collector.collect(new Evaluator.Attribute(key), this); [EOL] }
public Elements getElementsByAttribute(String key) { [EOL]     Validate.notEmpty(key); [EOL]     key = key.trim().toLowerCase(); [EOL]     return Collector.collect(new Evaluator.Attribute(key), this); [EOL] }
public Elements getElementsByAttribute(String key) { [EOL]     Validate.notEmpty(key); [EOL]     key = key.trim().toLowerCase(); [EOL]     return Collector.collect(new Evaluator.Attribute(key), this); [EOL] }
public Elements getElementsByAttributeValueContaining(String key, String match) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); [EOL] }
public Elements getElementsByAttributeValueContaining(String key, String match) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); [EOL] }
public Elements getElementsByAttributeValueContaining(String key, String match) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); [EOL] }
public Elements getElementsByAttributeValueContaining(String key, String match) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); [EOL] }
public Elements getElementsByAttributeValueContaining(String key, String match) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); [EOL] }
public Elements getElementsByIndexEquals(int index) { [EOL]     return Collector.collect(new Evaluator.IndexEquals(index), this); [EOL] }
public Elements getElementsByIndexEquals(int index) { [EOL]     return Collector.collect(new Evaluator.IndexEquals(index), this); [EOL] }
public Elements getElementsByIndexEquals(int index) { [EOL]     return Collector.collect(new Evaluator.IndexEquals(index), this); [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
private void text(StringBuilder accum) { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             String text = textNode.getWholeText(); [EOL]             if (!preserveWhitespace()) { [EOL]                 text = TextNode.normaliseWhitespace(text); [EOL]                 if (TextNode.lastCharIsWhitespace(accum)) [EOL]                     text = TextNode.stripLeadingWhitespace(text); [EOL]             } [EOL]             accum.append(text); [EOL]         } else if (child instanceof Element) { [EOL]             Element element = (Element) child; [EOL]             if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum)) [EOL]                 accum.append(" "); [EOL]             element.text(accum); [EOL]         } [EOL]     } [EOL] }
public boolean hasText() { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             if (!textNode.isBlank()) [EOL]                 return true; [EOL]         } else if (child instanceof Element) { [EOL]             Element el = (Element) child; [EOL]             if (el.hasText()) [EOL]                 return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean hasText() { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             if (!textNode.isBlank()) [EOL]                 return true; [EOL]         } else if (child instanceof Element) { [EOL]             Element el = (Element) child; [EOL]             if (el.hasText()) [EOL]                 return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean hasText() { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             if (!textNode.isBlank()) [EOL]                 return true; [EOL]         } else if (child instanceof Element) { [EOL]             Element el = (Element) child; [EOL]             if (el.hasText()) [EOL]                 return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean hasText() { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             if (!textNode.isBlank()) [EOL]                 return true; [EOL]         } else if (child instanceof Element) { [EOL]             Element el = (Element) child; [EOL]             if (el.hasText()) [EOL]                 return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean hasText() { [EOL]     for (Node child : childNodes) { [EOL]         if (child instanceof TextNode) { [EOL]             TextNode textNode = (TextNode) child; [EOL]             if (!textNode.isBlank()) [EOL]                 return true; [EOL]         } else if (child instanceof Element) { [EOL]             Element el = (Element) child; [EOL]             if (el.hasText()) [EOL]                 return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] }
private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] }
public static Document parseBodyFragment(String bodyHtml, String baseUri) { [EOL]     Parser parser = new Parser(bodyHtml, baseUri, true); [EOL]     return parser.parse(); [EOL] }
public static Document parseBodyFragment(String bodyHtml, String baseUri) { [EOL]     Parser parser = new Parser(bodyHtml, baseUri, true); [EOL]     return parser.parse(); [EOL] }
public static Document parseBodyFragment(String bodyHtml, String baseUri) { [EOL]     Parser parser = new Parser(bodyHtml, baseUri, true); [EOL]     return parser.parse(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] }
private void parseXmlDecl() { [EOL]     tq.consume("<"); [EOL]     Character firstChar = tq.consume(); [EOL]     boolean procInstr = firstChar.toString().equals("!"); [EOL]     String data = tq.chompTo(">"); [EOL]     XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr); [EOL]     last().appendChild(decl); [EOL] }
private void parseXmlDecl() { [EOL]     tq.consume("<"); [EOL]     Character firstChar = tq.consume(); [EOL]     boolean procInstr = firstChar.toString().equals("!"); [EOL]     String data = tq.chompTo(">"); [EOL]     XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr); [EOL]     last().appendChild(decl); [EOL] }
public void put(String key, String value) { [EOL]     Attribute attr = new Attribute(key, value); [EOL]     put(attr); [EOL] }
public void put(String key, String value) { [EOL]     Attribute attr = new Attribute(key, value); [EOL]     put(attr); [EOL] }
public void put(String key, String value) { [EOL]     Attribute attr = new Attribute(key, value); [EOL]     put(attr); [EOL] }
public static Document parse(String html, String baseUri) { [EOL]     return Parser.parse(html, baseUri); [EOL] }
public static Document parse(String html, String baseUri) { [EOL]     return Parser.parse(html, baseUri); [EOL] }
public static Document parse(String html, String baseUri) { [EOL]     return Parser.parse(html, baseUri); [EOL] }
public static Document parse(File in, String charsetName, String baseUri) throws IOException { [EOL]     String html = DataUtil.load(in, charsetName); [EOL]     return parse(html, baseUri); [EOL] }
public static Document parse(File in, String charsetName, String baseUri) throws IOException { [EOL]     String html = DataUtil.load(in, charsetName); [EOL]     return parse(html, baseUri); [EOL] }
public static Document parse(File in, String charsetName, String baseUri) throws IOException { [EOL]     String html = DataUtil.load(in, charsetName); [EOL]     return parse(html, baseUri); [EOL] }
public static Document parse(File in, String charsetName) throws IOException { [EOL]     String html = DataUtil.load(in, charsetName); [EOL]     return parse(html, in.getAbsolutePath()); [EOL] }
public static Document parse(File in, String charsetName) throws IOException { [EOL]     String html = DataUtil.load(in, charsetName); [EOL]     return parse(html, in.getAbsolutePath()); [EOL] }
public static Document parse(File in, String charsetName) throws IOException { [EOL]     String html = DataUtil.load(in, charsetName); [EOL]     return parse(html, in.getAbsolutePath()); [EOL] }
public static Document parseBodyFragment(String bodyHtml) { [EOL]     return Parser.parseBodyFragment(bodyHtml, ""); [EOL] }
public static Document parseBodyFragment(String bodyHtml) { [EOL]     return Parser.parseBodyFragment(bodyHtml, ""); [EOL] }
public static Document parseBodyFragment(String bodyHtml) { [EOL]     return Parser.parseBodyFragment(bodyHtml, ""); [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
public boolean isBlock() { [EOL]     return isBlock; [EOL] }
public boolean isBlock() { [EOL]     return isBlock; [EOL] }
public boolean canContainBlock() { [EOL]     return canContainBlock; [EOL] }
public boolean canContainBlock() { [EOL]     return canContainBlock; [EOL] }
static String load(File in, String charsetName) throws IOException { [EOL]     InputStream inStream = new FileInputStream(in); [EOL]     String data = readInputStream(inStream, charsetName); [EOL]     inStream.close(); [EOL]     return data; [EOL] }
static String load(File in, String charsetName) throws IOException { [EOL]     InputStream inStream = new FileInputStream(in); [EOL]     String data = readInputStream(inStream, charsetName); [EOL]     inStream.close(); [EOL]     return data; [EOL] }
static String load(File in, String charsetName) throws IOException { [EOL]     InputStream inStream = new FileInputStream(in); [EOL]     String data = readInputStream(inStream, charsetName); [EOL]     inStream.close(); [EOL]     return data; [EOL] }
private static String readInputStream(InputStream inStream, String charsetName) throws IOException { [EOL]     char[] buffer = new char[0x20000]; [EOL]     StringBuilder data = new StringBuilder(0x20000); [EOL]     Reader inReader = new InputStreamReader(inStream, charsetName); [EOL]     int read; [EOL]     do { [EOL]         read = inReader.read(buffer, 0, buffer.length); [EOL]         if (read > 0) { [EOL]             data.append(buffer, 0, read); [EOL]         } [EOL]     } while (read >= 0); [EOL]     return data.toString(); [EOL] }
private static String readInputStream(InputStream inStream, String charsetName) throws IOException { [EOL]     char[] buffer = new char[0x20000]; [EOL]     StringBuilder data = new StringBuilder(0x20000); [EOL]     Reader inReader = new InputStreamReader(inStream, charsetName); [EOL]     int read; [EOL]     do { [EOL]         read = inReader.read(buffer, 0, buffer.length); [EOL]         if (read > 0) { [EOL]             data.append(buffer, 0, read); [EOL]         } [EOL]     } while (read >= 0); [EOL]     return data.toString(); [EOL] }
private static String readInputStream(InputStream inStream, String charsetName) throws IOException { [EOL]     char[] buffer = new char[0x20000]; [EOL]     StringBuilder data = new StringBuilder(0x20000); [EOL]     Reader inReader = new InputStreamReader(inStream, charsetName); [EOL]     int read; [EOL]     do { [EOL]         read = inReader.read(buffer, 0, buffer.length); [EOL]         if (read > 0) { [EOL]             data.append(buffer, 0, read); [EOL]         } [EOL]     } while (read >= 0); [EOL]     return data.toString(); [EOL] }
private static String readInputStream(InputStream inStream, String charsetName) throws IOException { [EOL]     char[] buffer = new char[0x20000]; [EOL]     StringBuilder data = new StringBuilder(0x20000); [EOL]     Reader inReader = new InputStreamReader(inStream, charsetName); [EOL]     int read; [EOL]     do { [EOL]         read = inReader.read(buffer, 0, buffer.length); [EOL]         if (read > 0) { [EOL]             data.append(buffer, 0, read); [EOL]         } [EOL]     } while (read >= 0); [EOL]     return data.toString(); [EOL] }
