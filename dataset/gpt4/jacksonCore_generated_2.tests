public void testJsonProcessingExceptionWithMessageAndLocationAndCause() { [EOL] String message = "Test message"; [EOL] JsonLocation location = new JsonLocation(null, -1, -1, -1, -1); [EOL] Throwable cause = new Exception("Root cause"); [EOL] JsonProcessingException exception = new JsonProcessingException(message, location, cause); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(location, exception.getLocation()); [EOL] assertEquals(cause, exception.getCause()); [EOL] }
public void testJsonProcessingExceptionWithMessageAndLocationNoCause() { [EOL] String message = "Test message"; [EOL] JsonLocation location = new JsonLocation(null, -1, -1, -1, -1); [EOL] JsonProcessingException exception = new JsonProcessingException(message, location, null); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(location, exception.getLocation()); [EOL] assertNull(exception.getCause()); [EOL] }
public void testJsonProcessingExceptionWithMessageAndLocation() { [EOL] JsonLocation location = new JsonLocation(new Object(), 1L, 2, 3); [EOL] JsonProcessingException exception = new JsonProcessingException("error message", location); [EOL] assertEquals("error message", exception.getMessage()); [EOL] assertEquals(location, exception.getLocation()); [EOL] }
public void testJsonProcessingExceptionWithNullMessageAndLocation() { [EOL] JsonProcessingException exception = new JsonProcessingException(null, null); [EOL] assertNull(exception.getMessage()); [EOL] assertNull(exception.getLocation()); [EOL] }
public void testGetLocation() { [EOL] JsonLocation location = new JsonLocation(null, 1L, 2, 3, 4); [EOL] JsonParser parser = new JsonParser(location); [EOL] JsonLocation result = parser.getLocation(); [EOL] assertNotNull(result); [EOL] assertEquals(location, result); [EOL] }
protected String getMessageSuffix() { [EOL] return null; [EOL] }
public void testGetMessageWithNullSuperMessageAndNoLocationOrSuffix() { [EOL] Exception e = new Exception() { [EOL] @Override [EOL] public String getMessage() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonLocation getLocation() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public String getMessageSuffix() { [EOL] return null; [EOL] } [EOL] }; [EOL] String result = e.getMessage(); [EOL] assertEquals("N/A", result); [EOL] }
public void testGetMessageWithNonNullSuperMessageAndNoLocationOrSuffix() { [EOL] Exception e = new Exception("Super message") { [EOL] @Override [EOL] public JsonLocation getLocation() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public String getMessageSuffix() { [EOL] return null; [EOL] } [EOL] }; [EOL] String result = e.getMessage(); [EOL] assertEquals("Super message", result); [EOL] }
public void testGetMessageWithNullSuperMessageAndLocation() { [EOL] final JsonLocation mockLocation = new JsonLocation(new Object(), 1L, 2L, 3, 4); [EOL] Exception e = new Exception() { [EOL] @Override [EOL] public String getMessage() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonLocation getLocation() { [EOL] return mockLocation; [EOL] } [EOL] @Override [EOL] public String getMessageSuffix() { [EOL] return null; [EOL] } [EOL] }; [EOL] String result = e.getMessage(); [EOL] assertTrue(result.contains("N/A")); [EOL] assertTrue(result.contains(mockLocation.toString())); [EOL] }
public void testGetMessageWithNullSuperMessageAndSuffix() { [EOL] Exception e = new Exception() { [EOL] @Override [EOL] public String getMessage() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonLocation getLocation() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public String getMessageSuffix() { [EOL] return "Suffix"; [EOL] } [EOL] }; [EOL] String result = e.getMessage(); [EOL] assertTrue(result.contains("N/A")); [EOL] assertTrue(result.contains("Suffix")); [EOL] }
public void testGetMessageWithNonNullSuperMessageLocationAndSuffix() { [EOL] final JsonLocation mockLocation = new JsonLocation(new Object(), 1L, 2L, 3, 4); [EOL] Exception e = new Exception("Super message") { [EOL] @Override [EOL] public JsonLocation getLocation() { [EOL] return mockLocation; [EOL] } [EOL] @Override [EOL] public String getMessageSuffix() { [EOL] return "Suffix"; [EOL] } [EOL] }; [EOL] String result = e.getMessage(); [EOL] assertTrue(result.contains("Super message")); [EOL] assertTrue(result.contains("Suffix")); [EOL] assertTrue(result.contains(mockLocation.toString())); [EOL] }
public void testGetCurrentNameWithStartObjectToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_OBJECT); [EOL] assertEquals("ExpectedName", parser.getCurrentName()); [EOL] } [EOL] public void testGetCurrentNameWithStartArrayToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_ARRAY); [EOL] assertEquals("ExpectedName", parser.getCurrentName()); [EOL] } [EOL] public void testGetCurrentNameWithDifferentToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.FIELD_NAME); [EOL] assertEquals("ExpectedName", parser.getCurrentName()); [EOL] }

public void testOverrideCurrentNameWithStartObjectToken() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{ \"key\": \"value\" }"); [EOL] parser.nextToken(); // START_OBJECT [EOL] JsonReadContext parsingContext = (JsonReadContext) parser.getParsingContext(); [EOL] JsonToken currToken = parser.getCurrentToken(); [EOL] parser.overrideCurrentName("newName"); [EOL] assertEquals("newName", parsingContext.getCurrentName()); [EOL] }
public void testOverrideCurrentNameWithStartArrayToken() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("[ \"value\" ]"); [EOL] parser.nextToken(); // START_ARRAY [EOL] JsonReadContext parsingContext = (JsonReadContext) parser.getParsingContext(); [EOL] JsonToken currToken = parser.getCurrentToken(); [EOL] parser.overrideCurrentName("newName"); [EOL] assertEquals("newName", parsingContext.getParent().getCurrentName()); [EOL] }
public void testOverrideCurrentNameWithNonStructuralToken() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{ \"key\": \"value\" }"); [EOL] parser.nextToken(); // START_OBJECT [EOL] parser.nextToken(); // FIELD_NAME [EOL] JsonReadContext parsingContext = (JsonReadContext) parser.getParsingContext(); [EOL] JsonToken currToken = parser.getCurrentToken(); [EOL] parser.overrideCurrentName("newName"); [EOL] assertEquals("newName", parsingContext.getCurrentName()); [EOL] }
public void testResetAsNaNWithValidInput() { [EOL] JsonParser jp = new JsonParser(); // Assuming JsonParser has the method resetAsNaN [EOL] String valueStr = "NaN"; [EOL] double value = Double.NaN; [EOL] JsonToken result = jp.resetAsNaN(valueStr, value); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals(valueStr, jp.getText()); [EOL] assertEquals(value, jp.getDoubleValue(), 0.0); [EOL] assertEquals(JsonParser.NR_DOUBLE, jp.getNumberType()); [EOL] }
public void testGetNumberTypeWhenNumTypesValidIsUnknown() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_UNKNOWN; [EOL] _currToken = null; // Set to a non-numeric value [EOL] NumberType result = getNumberType(); [EOL] assertNotNull(result); [EOL] }
public void testGetNumberTypeWhenValueIsInt() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_INT; // Assuming NR_INT is a valid flag [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.INT, result); [EOL] }
public void testGetNumberTypeWhenValueIsLong() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; // Assuming NR_LONG is a valid flag [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.LONG, result); [EOL] }
public void testGetNumberTypeWhenValueIsBigInteger() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_INT | NR_LONG; // Neither INT nor LONG flags are set [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.BIG_INTEGER, result); [EOL] }
public void testGetNumberTypeWhenValueIsBigDecimal() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGDECIMAL; // Assuming NR_BIGDECIMAL is a valid flag [EOL] _currToken = null; // Set to a non-numeric value [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.BIG_DECIMAL, result); [EOL] }
public void testGetNumberTypeWhenValueIsDouble() throws IOException, JsonParseException { [EOL] _numTypesValid = 0; // No specific numeric type flags are set [EOL] _currToken = null; // Set to a non-numeric value [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.DOUBLE, result); [EOL] }
public void testGetIntValueWithNrIntValid() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_INT); [EOL] setNumberInt(10); [EOL] int result = getIntValue(); [EOL] assertEquals(10, result); [EOL] }
public void testGetIntValueWithNrUnknown() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_UNKNOWN); [EOL] setNumberInt(20); [EOL] int result = getIntValue(); [EOL] assertEquals(20, result); [EOL] }
public void testGetIntValueRequiresConversion() throws IOException, JsonParseException { [EOL] setNumTypesValid(0); [EOL] setNumberInt(30); [EOL] int result = getIntValue(); [EOL] assertEquals(30, result); [EOL] }
public void testGetDoubleValueWithUnknownType() throws IOException, JsonParseException { [EOL] setupWithUnknownType(); [EOL] double result = getDoubleValue(); [EOL] assertDoubleValue(result); [EOL] }
public void testGetDoubleValueWithNonDoubleType() throws IOException, JsonParseException { [EOL] setupWithNonDoubleType(); [EOL] double result = getDoubleValue(); [EOL] assertDoubleValue(result); [EOL] }
public void testGetDoubleValueWithDoubleType() throws IOException, JsonParseException { [EOL] setupWithDoubleType(); [EOL] double result = getDoubleValue(); [EOL] assertDoubleValue(result); [EOL] }
public void testGetDecimalValueWithUnknownNumType() throws IOException, JsonParseException { [EOL] this._numTypesValid = NR_UNKNOWN; [EOL] BigDecimal result = this.getDecimalValue(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof BigDecimal); [EOL] }
public void testGetDecimalValueWithBigDecimalNumType() throws IOException, JsonParseException { [EOL] this._numTypesValid = NR_BIGDECIMAL; [EOL] this._numberBigDecimal = new BigDecimal("123.456"); [EOL] BigDecimal result = this.getDecimalValue(); [EOL] assertEquals(this._numberBigDecimal, result); [EOL] }
public void testGetDecimalValueWithNonBigDecimalNumType() throws IOException, JsonParseException { [EOL] this._numTypesValid = NR_INT; // NR_INT is assumed to be a valid constant that does not include NR_BIGDECIMAL [EOL] BigDecimal result = this.getDecimalValue(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof BigDecimal); [EOL] }
public void testParseNumericValueWithIntTokenAndNegativeNumberWithinIntRange() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = true; [EOL] _intLength = 9; [EOL] _textBuffer.resetWithShared(new char[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8'}, 1, 10); [EOL] _parseNumericValue(NR_INT); [EOL] assertEquals(-214748364, _numberInt); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] }
public void testParseNumericValueWithIntTokenAndPositiveNumberWithinIntRange() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = false; [EOL] _intLength = 9; [EOL] _textBuffer.resetWithShared(new char[]{'2', '1', '4', '7', '4', '8', '3', '6', '4', '7'}, 0, 10); [EOL] _parseNumericValue(NR_INT); [EOL] assertEquals(2147483647, _numberInt); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] }
public void testParseNumericValueWithIntTokenAndNegativeLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = true; [EOL] _intLength = 18; [EOL] _textBuffer.resetWithShared(new char[]{'-', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '8'}, 1, 19); [EOL] _parseNumericValue(NR_INT); [EOL] assertEquals(-9223372036854775808L, _numberLong); [EOL] assertEquals(NR_LONG, _numTypesValid); [EOL] }
public void testParseNumericValueWithIntTokenAndPositiveLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = false; [EOL] _intLength = 18; [EOL] _textBuffer.resetWithShared(new char[]{'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '7'}, 0, 19); [EOL] _parseNumericValue(NR_INT); [EOL] assertEquals(9223372036854775807L, _numberLong); [EOL] assertEquals(NR_LONG, _numTypesValid); [EOL] }
public void testParseNumericValueWithIntTokenAndNumberExceedingLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = false; [EOL] _intLength = 19; [EOL] _textBuffer.resetWithShared(new char[]{'1', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '7'}, 0, 20); [EOL] _parseNumericValue(NR_INT); [EOL] }
public void testParseNumericValueWithFloatToken() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_FLOAT; [EOL] _parseNumericValue(NR_INT); [EOL] }
public void testParseNumericValueWithInvalidToken() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; [EOL] Exception exception = assertThrows(JsonParseException.class, () -> { [EOL] _parseNumericValue(NR_INT); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Current token (NOT_AVAILABLE) not numeric, can not use numeric value accessors")); [EOL] }
public void testParseSlowIntValueWithLongRange() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] char[] buffer = "1234567890".toCharArray(); [EOL] int offset = 0; [EOL] int length = buffer.length; [EOL] parser._numberNegative = false; // Assuming this is a field that indicates the sign of the number [EOL] parser._parseSlowIntValue(JsonParserImpl.NR_INT, buffer, offset, length); [EOL] assertEquals("The parsed long value is incorrect.", 1234567890L, parser._numberLong); [EOL] assertEquals("The number type valid flag is incorrect.", JsonParserImpl.NR_LONG, parser._numTypesValid); [EOL] }
public void testParseSlowIntValueWithBigInt() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] char[] buffer = "12345678901234567890".toCharArray(); [EOL] int offset = 0; [EOL] int length = buffer.length; [EOL] parser._numberNegative = false; // Assuming this is a field that indicates the sign of the number [EOL] parser._parseSlowIntValue(JsonParserImpl.NR_INT, buffer, offset, length); [EOL] assertEquals("The parsed BigInteger value is incorrect.", new BigInteger("12345678901234567890"), parser._numberBigInt); [EOL] assertEquals("The number type valid flag is incorrect.", JsonParserImpl.NR_BIGINT, parser._numTypesValid); [EOL] }
public void testParseSlowIntValueWithNumberFormatException() { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] char[] buffer = "notanumber".toCharArray(); [EOL] int offset = 0; [EOL] int length = buffer.length; [EOL] parser._numberNegative = false; // Assuming this is a field that indicates the sign of the number [EOL] try { [EOL] parser._parseSlowIntValue(JsonParserImpl.NR_INT, buffer, offset, length); [EOL] fail("Expected JsonParseException due to number format exception."); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, not IOException."); [EOL] } [EOL] }
public void testConvertNumberToIntWithLongWithinRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; [EOL] _numberLong = (long) Integer.MAX_VALUE; [EOL] convertNumberToInt(); [EOL] assertEquals(_numberInt, (int) _numberLong); [EOL] }
public void testConvertNumberToIntWithLongOutOfRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; [EOL] _numberLong = ((long) Integer.MAX_VALUE) + 1; [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown JsonParseException due to int overflow"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToIntWithBigIntWithinRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGINT; [EOL] _numberBigInt = BigInteger.valueOf(Integer.MAX_VALUE); [EOL] convertNumberToInt(); [EOL] assertEquals(_numberInt, _numberBigInt.intValue()); [EOL] }
public void testConvertNumberToIntWithBigIntOutOfRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGINT; [EOL] _numberBigInt = BigInteger.valueOf(((long) Integer.MAX_VALUE) + 1); [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown JsonParseException due to int overflow"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToIntWithDoubleWithinRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_DOUBLE; [EOL] _numberDouble = (double) Integer.MAX_VALUE; [EOL] convertNumberToInt(); [EOL] assertEquals(_numberInt, (int) _numberDouble); [EOL] }
public void testConvertNumberToIntWithDoubleOutOfRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_DOUBLE; [EOL] _numberDouble = (double) Integer.MAX_VALUE + 1.0; [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown JsonParseException due to int overflow"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToIntWithBigDecimalWithinRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGDECIMAL; [EOL] _numberBigDecimal = new BigDecimal(Integer.MAX_VALUE); [EOL] convertNumberToInt(); [EOL] assertEquals(_numberInt, _numberBigDecimal.intValue()); [EOL] }
public void testConvertNumberToIntWithBigDecimalOutOfRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGDECIMAL; [EOL] _numberBigDecimal = new BigDecimal(((long) Integer.MAX_VALUE) + 1); [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown JsonParseException due to int overflow"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToIntWithInvalidType() throws IOException, JsonParseException { [EOL] _numTypesValid = 0; // No valid types set [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown IOException due to invalid type"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testConvertNumberToBigDecimalWithDouble() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_DOUBLE; [EOL] when(getText()).thenReturn("123.456"); [EOL] convertNumberToBigDecimal(); [EOL] assertEquals(new BigDecimal("123.456"), _numberBigDecimal); [EOL] assertTrue((_numTypesValid & NR_BIGDECIMAL) != 0); [EOL] }
public void testConvertNumberToBigDecimalWithBigInt() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGINT; [EOL] _numberBigInt = new BigInteger("12345678901234567890"); [EOL] convertNumberToBigDecimal(); [EOL] assertEquals(new BigDecimal(_numberBigInt), _numberBigDecimal); [EOL] assertTrue((_numTypesValid & NR_BIGDECIMAL) != 0); [EOL] }
public void testConvertNumberToBigDecimalWithLong() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; [EOL] _numberLong = 1234567890123456789L; [EOL] convertNumberToBigDecimal(); [EOL] assertEquals(BigDecimal.valueOf(_numberLong), _numberBigDecimal); [EOL] assertTrue((_numTypesValid & NR_BIGDECIMAL) != 0); [EOL] }
public void testConvertNumberToBigDecimalWithInt() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_INT; [EOL] _numberInt = 1234567890; [EOL] convertNumberToBigDecimal(); [EOL] assertEquals(BigDecimal.valueOf(_numberInt), _numberBigDecimal); [EOL] assertTrue((_numTypesValid & NR_BIGDECIMAL) != 0); [EOL] }
public void testConvertNumberToBigDecimalThrowsException() throws IOException, JsonParseException { [EOL] _numTypesValid = 0; [EOL] try { [EOL] convertNumberToBigDecimal(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testMergeChildWithChildCountLessThanOrEqualToCurrentCount() { [EOL] TableInfo childState = new TableInfo(); [EOL] childState.count = 5; [EOL] AtomicReference<TableInfo> tableInfo = new AtomicReference<>(new TableInfo()); [EOL] tableInfo.get().count = 10; [EOL] JacksonCore instance = new JacksonCore(tableInfo); [EOL] instance.mergeChild(childState); [EOL] assertEquals("Expected count should remain unchanged", 10, tableInfo.get().count); [EOL] }
public void testMergeChildWithChildCountGreaterThanCurrentCountAndNotExceedingLimits() { [EOL] TableInfo childState = new TableInfo(); [EOL] childState.count = 15; [EOL] childState.longestCollisionList = 5; [EOL] AtomicReference<TableInfo> tableInfo = new AtomicReference<>(new TableInfo()); [EOL] tableInfo.get().count = 10; [EOL] JacksonCore instance = new JacksonCore(tableInfo); [EOL] instance.mergeChild(childState); [EOL] assertEquals("Expected count should be updated to child's count", 15, tableInfo.get().count); [EOL] assertTrue("Expected longestCollisionList should be updated", tableInfo.get().longestCollisionList <= MAX_COLL_CHAIN_FOR_REUSE); [EOL] }
public void testMergeChildWithChildCountGreaterThanCurrentCountAndExceedingMaxEntriesForReuse() { [EOL] TableInfo childState = new TableInfo(); [EOL] childState.count = MAX_ENTRIES_FOR_REUSE + 1; [EOL] AtomicReference<TableInfo> tableInfo = new AtomicReference<>(new TableInfo()); [EOL] tableInfo.get().count = 10; [EOL] JacksonCore instance = new JacksonCore(tableInfo); [EOL] instance.mergeChild(childState); [EOL] assertEquals("Expected count should be reset to default", DEFAULT_TABLE_SIZE, tableInfo.get().count); [EOL] }
public void testMergeChildWithChildCountGreaterThanCurrentCountAndExceedingMaxCollChainForReuse() { [EOL] TableInfo childState = new TableInfo(); [EOL] childState.count = 15; [EOL] childState.longestCollisionList = MAX_COLL_CHAIN_FOR_REUSE + 1; [EOL] AtomicReference<TableInfo> tableInfo = new AtomicReference<>(new TableInfo()); [EOL] tableInfo.get().count = 10; [EOL] JacksonCore instance = new JacksonCore(tableInfo); [EOL] instance.mergeChild(childState); [EOL] assertEquals("Expected count should be reset to default", DEFAULT_TABLE_SIZE, tableInfo.get().count); [EOL] }
public void testFindNameWithNullName() { [EOL] _mainNames[ix] = null; // Set the name at index ix to null [EOL] Name result = findName(firstQuad); [EOL] assertNull(result); [EOL] } [EOL] public void testFindNameWithEqualName() { [EOL] Name testName = new Name(firstQuad); // Create a Name object with the same firstQuad [EOL] _mainNames[ix] = testName; // Set the name at index ix to testName [EOL] Name result = findName(firstQuad); [EOL] assertSame(testName, result); [EOL] } [EOL] public void testFindNameWithNonEqualName() { [EOL] Name testName = new Name(firstQuad); // Create a Name object with a different firstQuad [EOL] _mainNames[ix] = testName; // Set the name at index ix to testName [EOL] Name result = findName(differentFirstQuad); [EOL] assertNull(result); [EOL] } [EOL] public void testFindNameWithEmptyMainHash() { [EOL] _mainHash[ix] = 0; // Set the hash at index ix to 0 [EOL] Name result = findName(firstQuad); [EOL] assertNull(result); [EOL] } [EOL] public void testFindNameWithNonEmptyBucket() { [EOL] Bucket testBucket = new Bucket(); // Create a non-empty bucket [EOL] _collList[val - 1] = testBucket; // Set the bucket at index val-1 to testBucket [EOL] Name result = findName(firstQuad); [EOL] assertNotNull(result); [EOL] } [EOL] public void testFindNameWithEmptyBucket() { [EOL] _collList[val - 1] = null; // Set the bucket at index val-1 to null [EOL] Name result = findName(firstQuad); [EOL] assertNull(result); [EOL] }
public void testFindNameWithLessThanThreeQuads() { [EOL] int[] quads = {1}; [EOL] int qlen = 1; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithHashCollisionAndNameMatch() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithHashCollisionAndNoNameMatch() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithEmptyMainHashSlot() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithNonEmptyBucket() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithEmptyBucket() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testCalcHashWithPositiveQuads() { [EOL] int firstQuad = 123456; [EOL] int secondQuad = 654321; [EOL] int expectedHash = firstQuad; [EOL] expectedHash ^= (expectedHash >>> 15); [EOL] expectedHash += (secondQuad * MULT); [EOL] expectedHash ^= _hashSeed; [EOL] expectedHash += (expectedHash >>> 7); [EOL] int actualHash = calcHash(firstQuad, secondQuad); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testCalcHashWithNegativeQuads() { [EOL] int firstQuad = -123456; [EOL] int secondQuad = -654321; [EOL] int expectedHash = firstQuad; [EOL] expectedHash ^= (expectedHash >>> 15); [EOL] expectedHash += (secondQuad * MULT); [EOL] expectedHash ^= _hashSeed; [EOL] expectedHash += (expectedHash >>> 7); [EOL] int actualHash = calcHash(firstQuad, secondQuad); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testCalcHashWithZeroQuads() { [EOL] int firstQuad = 0; [EOL] int secondQuad = 0; [EOL] int expectedHash = firstQuad; [EOL] expectedHash ^= (expectedHash >>> 15); [EOL] expectedHash += (secondQuad * MULT); [EOL] expectedHash ^= _hashSeed; [EOL] expectedHash += (expectedHash >>> 7); [EOL] int actualHash = calcHash(firstQuad, secondQuad); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testCalcHashWithMaxIntQuads() { [EOL] int firstQuad = Integer.MAX_VALUE; [EOL] int secondQuad = Integer.MAX_VALUE; [EOL] int expectedHash = firstQuad; [EOL] expectedHash ^= (expectedHash >>> 15); [EOL] expectedHash += (secondQuad * MULT); [EOL] expectedHash ^= _hashSeed; [EOL] expectedHash += (expectedHash >>> 7); [EOL] int actualHash = calcHash(firstQuad, secondQuad); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testCalcHashWithMinIntQuads() { [EOL] int firstQuad = Integer.MIN_VALUE; [EOL] int secondQuad = Integer.MIN_VALUE; [EOL] int expectedHash = firstQuad; [EOL] expectedHash ^= (expectedHash >>> 15); [EOL] expectedHash += (secondQuad * MULT); [EOL] expectedHash ^= _hashSeed; [EOL] expectedHash += (expectedHash >>> 7); [EOL] int actualHash = calcHash(firstQuad, secondQuad); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
private void _addSymbol(int hash, Name symbol) { [EOL] if (_mainHashShared) { [EOL] unshareMain(); [EOL] } [EOL] if (_needRehash) { [EOL] rehash(); [EOL] } [EOL] ++_count; [EOL] int ix = (hash & _mainHashMask); [EOL] if (_mainNames[ix] == null) { [EOL] _mainHash[ix] = (hash << 8); [EOL] if (_mainNamesShared) { [EOL] unshareNames(); [EOL] } [EOL] _mainNames[ix] = symbol; [EOL] } else { [EOL] if (_collListShared) { [EOL] unshareCollision(); [EOL] } [EOL] ++_collCount; [EOL] int entryValue = _mainHash[ix]; [EOL] int bucket = entryValue & 0xFF; [EOL] if (bucket == 0) { [EOL] if (_collEnd <= LAST_VALID_BUCKET) { [EOL] bucket = _collEnd; [EOL] ++_collEnd; [EOL] if (bucket >= _collList.length) { [EOL] expandCollision(); [EOL] } [EOL] } else { [EOL] bucket = findBestBucket(); [EOL] } [EOL] _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1); [EOL] } else { [EOL] --bucket; [EOL] } [EOL] Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL] _collList[bucket] = newB; [EOL] _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL] if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL] reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL] } [EOL] } [EOL] { [EOL] int hashSize = _mainHash.length; [EOL] if (_count > (hashSize >> 1)) { [EOL] int hashQuarter = (hashSize >> 2); [EOL] if (_count > (hashSize - hashQuarter)) { [EOL] _needRehash = true; [EOL] } else if (_collCount >= hashQuarter) { [EOL] _needRehash = true; [EOL] } [EOL] } [EOL] } [EOL] }
public void testRehashWithSizeNotExceedingMax() { [EOL] int initialSize = (MAX_TABLE_SIZE / 2) - 1; [EOL] _mainHash = new int[initialSize]; [EOL] _mainNames = new Name[initialSize]; [EOL] _collList = new Bucket[initialSize]; [EOL] _collEnd = 0; [EOL] _count = 0; [EOL] for (int i = 0; i < initialSize; i++) { [EOL] _mainHash[i] = i; [EOL] _mainNames[i] = new Name(i, "Name" + i); [EOL] _count++; [EOL] } [EOL] rehash(); [EOL] assertEquals(_mainHash.length, initialSize * 2); [EOL] assertEquals(_mainNames.length, initialSize * 2); [EOL] for (int i = 0; i < initialSize; i++) { [EOL] assertEquals(_mainNames[i].hashCode(), _mainHash[i] >>> 8); [EOL] } [EOL] assertEquals(_longestCollisionList, 0); [EOL] }
public void testRehashWithSizeExceedingMax() { [EOL] int initialSize = (MAX_TABLE_SIZE / 2) + 1; [EOL] _mainHash = new int[initialSize]; [EOL] _mainNames = new Name[initialSize]; [EOL] _collList = new Bucket[initialSize]; [EOL] _collEnd = 0; [EOL] _count = 0; [EOL] for (int i = 0; i < initialSize; i++) { [EOL] _mainHash[i] = i; [EOL] _mainNames[i] = new Name(i, "Name" + i); [EOL] _count++; [EOL] } [EOL] rehash(); [EOL] assertTrue(_mainHash.length <= MAX_TABLE_SIZE); [EOL] assertTrue(_mainNames.length <= MAX_TABLE_SIZE); [EOL] assertEquals(_longestCollisionList, 0); [EOL] }
public void testRehashWithCollisions() { [EOL] int initialSize = 4; // Small size to force collisions [EOL] _mainHash = new int[initialSize]; [EOL] _mainNames = new Name[initialSize]; [EOL] _collList = new Bucket[initialSize]; [EOL] _collEnd = 0; [EOL] _count = 0; [EOL] for (int i = 0; i < initialSize; i++) { [EOL] Name name = new Name(i, "Name" + i); [EOL] _mainHash[i] = name.hashCode(); [EOL] _mainNames[i] = name; [EOL] _count++; [EOL] if (i % 2 == 0) { [EOL] Bucket bucket = new Bucket(name, null); [EOL] _collList[i] = bucket; [EOL] _collEnd++; [EOL] } [EOL] } [EOL] rehash(); [EOL] assertEquals(_mainHash.length, initialSize * 2); [EOL] assertEquals(_mainNames.length, initialSize * 2); [EOL] for (int i = 0; i < initialSize; i++) { [EOL] if (i % 2 == 0) { [EOL] assertNotNull(_collList[i]); [EOL] } else { [EOL] assertNull(_collList[i]); [EOL] } [EOL] } [EOL] assertTrue(_collCount > 0); [EOL] assertTrue(_longestCollisionList > 0); [EOL] }
public void testUnshareCollisionWithNullCollList() { [EOL] setCollListToNull(); [EOL] setCollListShared(true); [EOL] unshareCollision(); [EOL] assertNotNull("_collList should not be null after unshareCollision", _collList); [EOL] assertFalse("_collListShared should be false after unshareCollision", _collListShared); [EOL] }
public void testUnshareCollisionWithNonNullCollList() { [EOL] initializeCollList(); [EOL] setCollListShared(true); [EOL] int oldLength = _collList.length; [EOL] unshareCollision(); [EOL] assertEquals("Length of _collList should remain the same after unshareCollision", oldLength, _collList.length); [EOL] assertFalse("_collListShared should be false after unshareCollision", _collListShared); [EOL] }
public void testConstructNameWithOneQuad() { [EOL] int hash = 1; [EOL] String name = "test"; [EOL] int[] quads = {0}; [EOL] int qlen = 1; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name1); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] }
public void testConstructNameWithTwoQuads() { [EOL] int hash = 2; [EOL] String name = "test"; [EOL] int[] quads = {0, 1}; [EOL] int qlen = 2; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name2); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] assertEquals(quads[1], result.getQuad(1)); [EOL] }
public void testConstructNameWithThreeQuads() { [EOL] int hash = 3; [EOL] String name = "test"; [EOL] int[] quads = {0, 1, 2}; [EOL] int qlen = 3; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name3); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] assertEquals(quads[1], result.getQuad(1)); [EOL] assertEquals(quads[2], result.getQuad(2)); [EOL] }
public void testConstructNameWithMoreThanThreeQuads() { [EOL] int hash = 4; [EOL] String name = "test"; [EOL] int[] quads = {0, 1, 2, 3}; [EOL] int qlen = 4; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof NameN); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] for (int i = 0; i < qlen; i++) { [EOL] assertEquals(quads[i], result.getQuad(i)); [EOL] } [EOL] }
public void testBucketConstructorWithNullNext() { [EOL] Name testName = new Name("testName"); [EOL] Bucket bucket = new Bucket(testName, null); [EOL] assertEquals("Name should match", testName, bucket._name); [EOL] assertNull("Next should be null", bucket._next); [EOL] assertEquals("Length should be 1", 1, bucket._length); [EOL] }
public void testBucketConstructorWithNonNullNext() { [EOL] Name testName = new Name("testName"); [EOL] Name nextName = new Name("nextName"); [EOL] Bucket nextBucket = new Bucket(nextName, null); [EOL] Bucket bucket = new Bucket(testName, nextBucket); [EOL] assertEquals("Name should match", testName, bucket._name); [EOL] assertNotNull("Next should not be null", bucket._next); [EOL] assertEquals("Next name should match", nextName, bucket._next._name); [EOL] assertEquals("Length should be 2", 2, bucket._length); [EOL] }
public void testLength_PositiveScenario() { [EOL] JacksonCoreClass instance = new JacksonCoreClass(); [EOL] instance._length = 5; // Set _length to a positive value [EOL] int result = instance.length(); [EOL] assert result == 5; // Assert that the length method returns the correct value [EOL] }
public void testFindWithMatchingHashAndQuads() { [EOL] int hash = _name.hashCode(); [EOL] int firstQuad = // obtain firstQuad value that _name equals to [EOL] int secondQuad = // obtain secondQuad value that _name equals to [EOL] Name result = find(hash, firstQuad, secondQuad); [EOL] assertNotNull(result); [EOL] assertEquals(_name, result); [EOL] }
public void testFindWithNonMatchingHash() { [EOL] int hash = // generate a hash code different from _name.hashCode() [EOL] int firstQuad = // obtain firstQuad value [EOL] int secondQuad = // obtain secondQuad value [EOL] Name result = find(hash, firstQuad, secondQuad); [EOL] assertNull(result); [EOL] }
public void testFindInBucketWithMatchingHashAndQuads() { [EOL] int hash = // a hash code that matches a Name in a Bucket [EOL] int firstQuad = // obtain firstQuad value that matches a Name in a Bucket [EOL] int secondQuad = // obtain secondQuad value that matches a Name in a Bucket [EOL] Name result = find(hash, firstQuad, secondQuad); [EOL] assertNotNull(result); [EOL] }
public void testFindInBucketWithNonMatchingHashAndQuads() { [EOL] int hash = // a hash code that does not match any Name in Buckets [EOL] int firstQuad = // obtain firstQuad value [EOL] int secondQuad = // obtain secondQuad value [EOL] Name result = find(hash, firstQuad, secondQuad); [EOL] assertNull(result); [EOL] }
public void testFindWithMatchingHashCodeAndEquals() { [EOL] Name expectedName = new Name(hash, quads, qlen); // hash, quads, qlen are assumed to be predefined [EOL] Bucket bucket = new Bucket(expectedName, null); // Assuming Bucket has a constructor that takes Name and next Bucket [EOL] Name result = bucket.find(hash, quads, qlen); [EOL] assertNotNull(result); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindWithMatchingHashCodeButNotEquals() { [EOL] Name name = new Name(differentHash, quads, qlen); // differentHash is assumed to be predefined and different from hash [EOL] Bucket bucket = new Bucket(name, null); [EOL] Name result = bucket.find(hash, quads, qlen); [EOL] assertNull(result); [EOL] }
public void testFindInNextBucketWithMatchingHashCodeAndEquals() { [EOL] Name name = new Name(differentHash, quads, qlen); // differentHash is assumed to be predefined and different from hash [EOL] Name expectedName = new Name(hash, quads, qlen); [EOL] Bucket nextBucket = new Bucket(expectedName, null); [EOL] Bucket bucket = new Bucket(name, nextBucket); [EOL] Name result = bucket.find(hash, quads, qlen); [EOL] assertNotNull(result); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindInNextBucketWithNoMatch() { [EOL] Name name = new Name(differentHash, quads, qlen); [EOL] Name anotherName = new Name(anotherDifferentHash, quads, qlen); // anotherDifferentHash is assumed to be predefined and different from hash [EOL] Bucket nextBucket = new Bucket(anotherName, null); [EOL] Bucket bucket = new Bucket(name, nextBucket); [EOL] Name result = bucket.find(hash, quads, qlen); [EOL] assertNull(result); [EOL] }
public void testOutputIntNegativeMinValue() { [EOL] char[] buffer = new char[11]; [EOL] int offset = 0; [EOL] int result = outputInt(Integer.MIN_VALUE, buffer, offset); [EOL] assertEquals(11, result); [EOL] assertEquals("-2147483648", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntNegative() { [EOL] char[] buffer = new char[10]; [EOL] int offset = 0; [EOL] int result = outputInt(-123456, buffer, offset); [EOL] assertEquals(7, result); [EOL] assertEquals("-123456", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveLessThanTen() { [EOL] char[] buffer = new char[10]; [EOL] int offset = 0; [EOL] int result = outputInt(5, buffer, offset); [EOL] assertEquals(1, result); [EOL] assertEquals("5", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveLessThanThousand() { [EOL] char[] buffer = new char[10]; [EOL] int offset = 0; [EOL] int result = outputInt(123, buffer, offset); [EOL] assertEquals(3, result); [EOL] assertEquals("123", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveLessThanMillion() { [EOL] char[] buffer = new char[10]; [EOL] int offset = 0; [EOL] int result = outputInt(123456, buffer, offset); [EOL] assertEquals(6, result); [EOL] assertEquals("123456", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveWithBillions() { [EOL] char[] buffer = new char[15]; [EOL] int offset = 0; [EOL] int result = outputInt(2000000000, buffer, offset); [EOL] assertEquals(10, result); [EOL] assertEquals("2000000000", new String(buffer, 0, result)); [EOL] } [EOL] public void testOutputIntPositiveMaxInt() { [EOL] char[] buffer = new char[15]; [EOL] int offset = 0; [EOL] int result = outputInt(Integer.MAX_VALUE, buffer, offset); [EOL] assertEquals(10, result); [EOL] assertEquals("2147483647", new String(buffer, 0, result)); [EOL] }
public static int outputLong(long value, char[] buffer, int offset) { [EOL] if (value < 0L) { [EOL] if (value > MIN_INT_AS_LONG) { [EOL] return outputInt((int) value, buffer, offset); [EOL] } [EOL] if (value == Long.MIN_VALUE) { [EOL] int len = SMALLEST_LONG.length(); [EOL] SMALLEST_LONG.getChars(0, len, buffer, offset); [EOL] return (offset + len); [EOL] } [EOL] buffer[offset++] = '-'; [EOL] value = -value; [EOL] } else { [EOL] if (value <= MAX_INT_AS_LONG) { [EOL] return outputInt((int) value, buffer, offset); [EOL] } [EOL] } [EOL] int origOffset = offset; [EOL] offset += calcLongStrLength(value); [EOL] int ptr = offset; [EOL] while (value > MAX_INT_AS_LONG) { [EOL] ptr -= 3; [EOL] long newValue = value / THOUSAND_L; [EOL] int triplet = (int) (value - newValue * THOUSAND_L); [EOL] outputFullTriplet(triplet, buffer, ptr); [EOL] value = newValue; [EOL] } [EOL] int ivalue = (int) value; [EOL] while (ivalue >= 1000) { [EOL] ptr -= 3; [EOL] int newValue = ivalue / 1000; [EOL] int triplet = ivalue - (newValue * 1000); [EOL] outputFullTriplet(triplet, buffer, ptr); [EOL] ivalue = newValue; [EOL] } [EOL] outputLeadingTriplet(ivalue, buffer, origOffset); [EOL] return offset; [EOL] }
private static int calcLongStrLength(long posValue) { [EOL] int len = 10; [EOL] long comp = TEN_BILLION_L; [EOL] while (posValue >= comp) { [EOL] if (len == 19) { [EOL] break; [EOL] } [EOL] ++len; [EOL] comp = (comp << 3) + (comp << 1); [EOL] } [EOL] return len; [EOL] }
public void testName3_AllQuads() { [EOL] String name = "test"; [EOL] int hash = 123; [EOL] int q1 = 1; [EOL] int q2 = 2; [EOL] int q3 = 3; [EOL] Name3 name3 = new Name3(name, hash, q1, q2, q3); [EOL] assertEquals(name, name3.getName()); [EOL] assertEquals(hash, name3.hashCode()); [EOL] assertEquals(q1, name3.getQuad1()); [EOL] assertEquals(q2, name3.getQuad2()); [EOL] assertEquals(q3, name3.getQuad3()); [EOL] }
public void testEqualsWithThreeQuadsMatching() { [EOL] int[] quads = {mQuad1, mQuad2, mQuad3}; [EOL] int qlen = 3; [EOL] assertTrue(equals(quads, qlen)); [EOL] }
public void testEqualsWithThreeQuadsNotMatching() { [EOL] int[] quads = {mQuad1, mQuad2, 0}; [EOL] int qlen = 3; [EOL] assertFalse(equals(quads, qlen)); [EOL] }
public void testEqualsWithLengthNotThree() { [EOL] int[] quads = {mQuad1, mQuad2, mQuad3}; [EOL] int qlen = 2; [EOL] assertFalse(equals(quads, qlen)); [EOL] }
public void testParseBigDecimalValid() { [EOL] String validNumberStr = "123.456"; [EOL] BigDecimal result = JacksonCore.parseBigDecimal(validNumberStr); [EOL] assertEquals(new BigDecimal(validNumberStr), result); [EOL] }
public void testParseBigDecimalInvalid() { [EOL] String invalidNumberStr = "abc"; [EOL] try { [EOL] JacksonCore.parseBigDecimal(invalidNumberStr); [EOL] fail("NumberFormatException was expected"); [EOL] } catch (NumberFormatException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
private static NumberFormatException _badBigDecimal(String str) { [EOL] return new NumberFormatException("Value \"" + str + "\" can not be represented as BigDecimal"); [EOL] }
public void testLoadMoreWithNonNullInputStreamAndPositiveCount() throws IOException { [EOL] _currInputProcessed = 0; [EOL] _inputEnd = 10; [EOL] _currInputRowStart = 20; [EOL] _inputStream = Mockito.mock(InputStream.class); [EOL] _inputBuffer = new byte[100]; [EOL] Mockito.when(_inputStream.read(_inputBuffer, 0, _inputBuffer.length)).thenReturn(50); [EOL] boolean result = loadMore(); [EOL] assertEquals(10, _currInputProcessed); [EOL] assertEquals(10, _currInputRowStart); [EOL] assertEquals(0, _inputPtr); [EOL] assertEquals(50, _inputEnd); [EOL] assertTrue(result); [EOL] }
public void testLoadMoreWithNonNullInputStreamAndZeroCount() throws IOException { [EOL] _currInputProcessed = 0; [EOL] _inputEnd = 10; [EOL] _currInputRowStart = 20; [EOL] _inputStream = Mockito.mock(InputStream.class); [EOL] _inputBuffer = new byte[100]; [EOL] Mockito.when(_inputStream.read(_inputBuffer, 0, _inputBuffer.length)).thenReturn(0); [EOL] assertThrows(IOException.class, this::loadMore); [EOL] assertEquals(10, _currInputProcessed); [EOL] assertEquals(10, _currInputRowStart); [EOL] }
public void testLoadMoreWithNonNullInputStreamAndEndOfStream() throws IOException { [EOL] _currInputProcessed = 0; [EOL] _inputEnd = 10; [EOL] _currInputRowStart = 20; [EOL] _inputStream = Mockito.mock(InputStream.class); [EOL] _inputBuffer = new byte[100]; [EOL] Mockito.when(_inputStream.read(_inputBuffer, 0, _inputBuffer.length)).thenReturn(-1); [EOL] boolean result = loadMore(); [EOL] assertEquals(10, _currInputProcessed); [EOL] assertEquals(10, _currInputRowStart); [EOL] assertFalse(result); [EOL] }
public void testLoadMoreWithNullInputStream() throws IOException { [EOL] _currInputProcessed = 0; [EOL] _inputEnd = 10; [EOL] _currInputRowStart = 20; [EOL] _inputStream = null; [EOL] _inputBuffer = new byte[100]; [EOL] boolean result = loadMore(); [EOL] assertEquals(10, _currInputProcessed); [EOL] assertEquals(10, _currInputRowStart); [EOL] assertFalse(result); [EOL] }
public void testReadBinaryValueWithTokenIncompleteAndValueString() throws IOException { [EOL] JsonParser parser = createParserWithTokenIncompleteAndValueString(); [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL] int result = parser.readBinaryValue(b64variant, out); [EOL] assertEquals("The length of the result should match the expected value.", expectedLength, result); [EOL] assertArrayEquals("The output stream should contain the expected binary data.", expectedBinaryData, out.toByteArray()); [EOL] } [EOL] public void testReadBinaryValueWithoutTokenIncompleteAndValueString() throws IOException { [EOL] JsonParser parser = createParserWithoutTokenIncompleteAndValueString(); [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL] int result = parser.readBinaryValue(b64variant, out); [EOL] assertEquals("The length of the result should match the expected value.", expectedLength, result); [EOL] assertArrayEquals("The output stream should contain the expected binary data.", expectedBinaryData, out.toByteArray()); [EOL] }
public void testReadBinaryValueWithIOExceptionOnWrite() throws IOException { [EOL] JsonParser parser = createParserWithTokenIncompleteAndValueString(); [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] OutputStream out = createOutputStreamThatThrowsIOException(); [EOL] try { [EOL] parser.readBinaryValue(b64variant, out); [EOL] fail("IOException expected but not thrown."); [EOL] } catch (IOException e) { [EOL] } [EOL] }
protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL] int outputPtr = 0; [EOL] final int outputEnd = buffer.length - 3; [EOL] int outputCount = 0; [EOL] while (true) { [EOL] int ch; [EOL] do { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL] } while (ch <= INT_SPACE); [EOL] int bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (ch == INT_QUOTE) { [EOL] break; [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 0); [EOL] if (bits < 0) { [EOL] continue; [EOL] } [EOL] } [EOL] if (outputPtr > outputEnd) { [EOL] outputCount += outputPtr; [EOL] out.write(buffer, 0, outputPtr); [EOL] outputPtr = 0; [EOL] } [EOL] int decodedData = bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] bits = _decodeBase64Escape(b64variant, ch, 1); [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (ch == '"' && !b64variant.usesPadding()) { [EOL] decodedData >>= 4; [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] break; [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 2); [EOL] } [EOL] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (!b64variant.usesPaddingChar(ch)) { [EOL] throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL] } [EOL] decodedData >>= 4; [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] continue; [EOL] } [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (ch == '"' && !b64variant.usesPadding()) { [EOL] decodedData >>= 2; [EOL] buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] break; [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 3); [EOL] } [EOL] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL] decodedData >>= 2; [EOL] buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] continue; [EOL] } [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL] buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] } [EOL] _tokenIncomplete = false; [EOL] if (outputPtr > 0) { [EOL] outputCount += outputPtr; [EOL] out.write(buffer, 0, outputPtr); [EOL] } [EOL] return outputCount; [EOL] }
public void testNextTokenWithFieldName() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenWithIncompleteToken() throws IOException, JsonParseException { [EOL] _tokenIncomplete = true; [EOL] JsonToken result = nextToken(); [EOL] assertFalse(_tokenIncomplete); [EOL] }
public void testNextTokenAtEndOfInput() throws IOException, JsonParseException { [EOL] int i = -1; // simulate end of input [EOL] JsonToken result = nextToken(); [EOL] assertNull(result); [EOL] }
public void testNextTokenWithRBracket() throws IOException, JsonParseException { [EOL] int i = INT_RBRACKET; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_ARRAY, result); [EOL] }
public void testNextTokenWithRCurly() throws IOException, JsonParseException { [EOL] int i = INT_RCURLY; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, result); [EOL] }
public void testNextTokenExpectComma() throws IOException, JsonParseException { [EOL] int i = INT_COMMA; [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenNotInObject() throws IOException, JsonParseException { [EOL] int i = INT_COMMA; // or any other token that is not INT_COLON [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenWithColon() throws IOException, JsonParseException { [EOL] int i = INT_COLON; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithValueString() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_STRING, _nextToken); [EOL] }
public void testNextTokenWithStartArray() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.START_ARRAY, _nextToken); [EOL] }
public void testNextTokenWithStartObject() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.START_OBJECT, _nextToken); [EOL] }
public void testNextTokenWithTrue() throws IOException, JsonParseException { [EOL] int i = INT_t; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_TRUE, _nextToken); [EOL] }
public void testNextTokenWithFalse() throws IOException, JsonParseException { [EOL] int i = INT_f; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_FALSE, _nextToken); [EOL] }
public void testNextTokenWithNull() throws IOException, JsonParseException { [EOL] int i = INT_n; [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_NULL, _nextToken); [EOL] }
public void testNextTokenWithNumber() throws IOException, JsonParseException { [EOL] int i = INT_0; // or any other number token [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_UNKNOWN; // any value that would trigger the default case [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenNotInObjectWithQuote() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertTrue(_tokenIncomplete); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testNextTokenNotInObjectWithLBracket() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] }
public void testNextTokenNotInObjectWithLCurly() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testNextTokenNotInObjectWithRBracket() throws IOException, JsonParseException { [EOL] int i = INT_RBRACKET; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNextTokenNotInObjectWithRCurly() throws IOException, JsonParseException { [EOL] int i = INT_RCURLY; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNextTokenNotInObjectWithT() throws IOException, JsonParseException { [EOL] int i = INT_t; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_TRUE, result); [EOL] }
public void testNextTokenNotInObjectWithF() throws IOException, JsonParseException { [EOL] int i = INT_f; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_FALSE, result); [EOL] }
public void testNextTokenNotInObjectWithN() throws IOException, JsonParseException { [EOL] int i = INT_n; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_NULL, result); [EOL] }
public void testNextTokenNotInObjectWithMinus() throws IOException, JsonParseException { [EOL] int i = INT_MINUS; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(parseNumberText(i), result); [EOL] }
public void testNextTokenNotInObjectWithDigit() throws IOException, JsonParseException { [EOL] for (int i = INT_0; i <= INT_9; i++) { [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(parseNumberText(i), result); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_UNEXPECTED_VALUE; // Assuming INT_UNEXPECTED_VALUE is a constant for an unexpected value [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(_handleUnexpectedValue(i), result); [EOL] }
private void _isNextTokenNameYes() throws IOException, JsonParseException { [EOL] int i; [EOL] if (_inputPtr < (_inputEnd - 1) && _inputBuffer[_inputPtr] == INT_COLON) { [EOL] i = _inputBuffer[++_inputPtr]; [EOL] ++_inputPtr; [EOL] if (i == INT_QUOTE) { [EOL] _tokenIncomplete = true; [EOL] _nextToken = JsonToken.VALUE_STRING; [EOL] return; [EOL] } [EOL] if (i == INT_LCURLY) { [EOL] _nextToken = JsonToken.START_OBJECT; [EOL] return; [EOL] } [EOL] if (i == INT_LBRACKET) { [EOL] _nextToken = JsonToken.START_ARRAY; [EOL] return; [EOL] } [EOL] i &= 0xFF; [EOL] if (i <= INT_SPACE || i == INT_SLASH) { [EOL] --_inputPtr; [EOL] i = _skipWS(); [EOL] } [EOL] } else { [EOL] i = _skipColon(); [EOL] } [EOL] switch(i) { [EOL] case INT_QUOTE: [EOL] _tokenIncomplete = true; [EOL] _nextToken = JsonToken.VALUE_STRING; [EOL] return; [EOL] case INT_LBRACKET: [EOL] _nextToken = JsonToken.START_ARRAY; [EOL] return; [EOL] case INT_LCURLY: [EOL] _nextToken = JsonToken.START_OBJECT; [EOL] return; [EOL] case INT_RBRACKET: [EOL] case INT_RCURLY: [EOL] _reportUnexpectedChar(i, "expected a value"); [EOL] case INT_t: [EOL] _matchToken("true", 1); [EOL] _nextToken = JsonToken.VALUE_TRUE; [EOL] return; [EOL] case INT_f: [EOL] _matchToken("false", 1); [EOL] _nextToken = JsonToken.VALUE_FALSE; [EOL] return; [EOL] case INT_n: [EOL] _matchToken("null", 1); [EOL] _nextToken = JsonToken.VALUE_NULL; [EOL] return; [EOL] case INT_MINUS: [EOL] case INT_0: [EOL] case INT_1: [EOL] case INT_2: [EOL] case INT_3: [EOL] case INT_4: [EOL] case INT_5: [EOL] case INT_6: [EOL] case INT_7: [EOL] case INT_8: [EOL] case INT_9: [EOL] _nextToken = parseNumberText(i); [EOL] return; [EOL] } [EOL] _nextToken = _handleUnexpectedValue(i); [EOL] }
public void testParserNumber2EndOfInput() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testParserNumber2NonDigit() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] _inputBuffer[_inputPtr++] = (byte) 'x'; // Non-digit character [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testParserNumber2Dot() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] _inputBuffer[_inputPtr++] = (byte) '.'; // Decimal point [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParserNumber2ExponentE() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] _inputBuffer[_inputPtr++] = (byte) 'e'; // Lowercase exponent [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParserNumber2ExponentEUpper() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] _inputBuffer[_inputPtr++] = (byte) 'E'; // Uppercase exponent [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParserNumber2BufferOverflow() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[1]; // Small buffer to force overflow [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] _inputBuffer[_inputPtr++] = (byte) '1'; [EOL] _inputBuffer[_inputPtr++] = (byte) '2'; // Second digit to cause buffer overflow [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testParseFloatTextWithDotAndNoFraction() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = '.'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] try { [EOL] _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] fail("Should not pass: decimal point not followed by a digit"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testParseFloatTextWithDotAndFraction() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = '.'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new byte[] {'0', '1', '2', '3'}; [EOL] JsonToken result = _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] assertEquals("0.123", new String(outBuf, 0, 5)); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParseFloatTextWithExponent() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = 'e'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; [EOL] _inputBuffer = new byte[] {'1', '0', '0'}; [EOL] JsonToken result = _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] assertEquals("1e100", new String(outBuf, 0, 5)); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParseFloatTextWithExponentAndNoExponentDigits() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = 'e'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] try { [EOL] _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] fail("Should not pass: exponent indicator not followed by a digit"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testParseFloatTextWithExponentAndSign() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = 'e'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new byte[] {'+', '1', '0', '0'}; [EOL] JsonToken result = _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] assertEquals("1e+100", new String(outBuf, 0, 6)); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParseFloatTextWithExponentAndNegativeSign() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = 'e'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new byte[] {'-', '1', '0', '0'}; [EOL] JsonToken result = _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] assertEquals("1e-100", new String(outBuf, 0, 6)); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL] if (i != INT_QUOTE) { [EOL] return _handleUnusualFieldName(i); [EOL] } [EOL] if ((_inputPtr + 9) > _inputEnd) { [EOL] return slowParseFieldName(); [EOL] } [EOL] final byte[] input = _inputBuffer; [EOL] final int[] codes = sInputCodesLatin1; [EOL] int q = input[_inputPtr++] & 0xFF; [EOL] if (codes[q] == 0) { [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] _quad1 = q; [EOL] return parseMediumFieldName(i, codes); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 4); [EOL] } [EOL] return parseFieldName(q, i, 4); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 3); [EOL] } [EOL] return parseFieldName(q, i, 3); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 2); [EOL] } [EOL] return parseFieldName(q, i, 2); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 1); [EOL] } [EOL] return parseFieldName(q, i, 1); [EOL] } [EOL] if (q == INT_QUOTE) { [EOL] return BytesToNameCanonicalizer.getEmptyName(); [EOL] } [EOL] return parseFieldName(0, q, 0); [EOL] }
protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL] int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 1); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 1); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 2); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 2); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 3); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 3); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 4); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 4); [EOL] } [EOL] _quadBuffer[0] = _quad1; [EOL] _quadBuffer[1] = q2; [EOL] return parseLongFieldName(i); [EOL] }
protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL] final int[] codes = sInputCodesLatin1; [EOL] int qlen = 2; [EOL] while (true) { [EOL] if ((_inputEnd - _inputPtr) < 4) { [EOL] return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL] } [EOL] int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 1); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 2); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 3); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 4); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL] } [EOL] if (qlen >= _quadBuffer.length) { [EOL] _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL] } [EOL] _quadBuffer[qlen++] = q; [EOL] q = i; [EOL] } [EOL] }
public void testFindNameWhenNameExists() throws JsonParseException { [EOL] int q1 = SOME_VALID_QUAD_VALUE; [EOL] int lastQuadBytes = SOME_VALID_LAST_QUAD_BYTES; [EOL] Name expectedName = new Name("expectedName", q1, lastQuadBytes); [EOL] _symbols = mock(SymbolTable.class); [EOL] when(_symbols.findName(q1)).thenReturn(expectedName); [EOL] Name result = findName(q1, lastQuadBytes); [EOL] assertNotNull(result); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindNameWhenNameDoesNotExist() throws JsonParseException { [EOL] int q1 = SOME_VALID_QUAD_VALUE; [EOL] int lastQuadBytes = SOME_VALID_LAST_QUAD_BYTES; [EOL] _symbols = mock(SymbolTable.class); [EOL] when(_symbols.findName(q1)).thenReturn(null); [EOL] _quadBuffer = new int[1]; [EOL] Name result = findName(q1, lastQuadBytes); [EOL] assertNotNull(result); [EOL] assertEquals(new Name(null, q1, lastQuadBytes), result); [EOL] }
public void testFindNameWithExistingName() { [EOL] int[] quads = new int[] {1, 2, 3}; [EOL] int qlen = 3; [EOL] int lastQuad = 4; [EOL] int lastQuadBytes = 2; [EOL] Name expectedName = new Name("test", quads, qlen); [EOL] _symbols = mock(SymbolTable.class); [EOL] when(_symbols.findName(quads, qlen + 1)).thenReturn(expectedName); [EOL] Name result = findName(quads, qlen, lastQuad, lastQuadBytes); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindNameWithNewName() { [EOL] int[] quads = new int[] {1, 2, 3}; [EOL] int qlen = 3; [EOL] int lastQuad = 4; [EOL] int lastQuadBytes = 2; [EOL] Name expectedName = new Name("newName", new int[] {1, 2, 3, 4}, qlen + 1); [EOL] _symbols = mock(SymbolTable.class); [EOL] when(_symbols.findName(quads, qlen + 1)).thenReturn(null); [EOL] Name result = findName(quads, qlen, lastQuad, lastQuadBytes); [EOL] assertNotNull(result); [EOL] assertEquals(expectedName, addName(quads, qlen + 1, lastQuadBytes)); [EOL] }
public void testFindNameWithArrayExpansion() { [EOL] int[] quads = new int[] {1, 2}; [EOL] int qlen = 2; [EOL] int lastQuad = 3; [EOL] int lastQuadBytes = 2; [EOL] Name expectedName = new Name("expand", new int[] {1, 2, 3}, qlen + 1); [EOL] _symbols = mock(SymbolTable.class); [EOL] when(_symbols.findName(any(int[].class), eq(qlen + 1))).thenReturn(expectedName); [EOL] Name result = findName(quads, qlen, lastQuad, lastQuadBytes); [EOL] assertNotNull(result); [EOL] assertEquals(expectedName, result); [EOL] }
public void test_finishString2_withAsciiCharacters() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] _finishString2(outBuf, outPtr); [EOL] }
public void test_finishString2_withInputBufferEndReached() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] _finishString2(outBuf, outPtr); [EOL] }
public void test_finishString2_withOutputBufferFull() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[1]; // Small buffer to force buffer expansion [EOL] int outPtr = 0; [EOL] _finishString2(outBuf, outPtr); [EOL] }
public void test_finishString2_withNonAsciiCharacter() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] _finishString2(outBuf, outPtr); [EOL] }
public void test_finishString2_withEndQuote() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] _finishString2(outBuf, outPtr); [EOL] }
public void test_finishString2_withEscapeCharacter() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] _finishString2(outBuf, outPtr); [EOL] }
public void test_finishString2_withMultiByteCharacter() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] _finishString2(outBuf, outPtr); [EOL] }
public void test_finishString2_withInvalidCharacter() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] _finishString2(outBuf, outPtr); [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL] _tokenIncomplete = false; [EOL] final int[] codes = sInputCodesUtf8; [EOL] final byte[] inputBuffer = _inputBuffer; [EOL] main_loop: while (true) { [EOL] int c; [EOL] ascii_loop: while (true) { [EOL] int ptr = _inputPtr; [EOL] int max = _inputEnd; [EOL] if (ptr >= max) { [EOL] loadMoreGuaranteed(); [EOL] ptr = _inputPtr; [EOL] max = _inputEnd; [EOL] } [EOL] while (ptr < max) { [EOL] c = (int) inputBuffer[ptr++] & 0xFF; [EOL] if (codes[c] != 0) { [EOL] _inputPtr = ptr; [EOL] break ascii_loop; [EOL] } [EOL] } [EOL] _inputPtr = ptr; [EOL] } [EOL] if (c == INT_QUOTE) { [EOL] break main_loop; [EOL] } [EOL] switch(codes[c]) { [EOL] case 1: [EOL] _decodeEscaped(); [EOL] break; [EOL] case 2: [EOL] _skipUtf8_2(c); [EOL] break; [EOL] case 3: [EOL] _skipUtf8_3(c); [EOL] break; [EOL] case 4: [EOL] _skipUtf8_4(c); [EOL] break; [EOL] default: [EOL] if (c < INT_SPACE) { [EOL] _throwUnquotedSpace(c, "string value"); [EOL] } else { [EOL] _reportInvalidChar(c); [EOL] } [EOL] } [EOL] } [EOL] }
public void testHandleUnexpectedValueWithSingleQuote() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_SINGLE_QUOTES); [EOL] JsonToken result = parser._handleUnexpectedValue('\''); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testHandleUnexpectedValueWithN() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('N'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithNWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('N'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithI() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('I'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithIWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('I'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithPlusAtBufferEnd() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserAtBufferEnd(); [EOL] try { [EOL] parser._handleUnexpectedValue('+'); [EOL] fail("Expected JsonParseException for EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithPlusNotAtBufferEnd() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserNotAtBufferEnd(); [EOL] JsonToken result = parser._handleUnexpectedValue('+'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testHandleUnexpectedValueWithJavaIdentifierStart() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] try { [EOL] parser._handleUnexpectedValue('a'); [EOL] fail("Expected JsonParseException for invalid token"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithInvalidChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] try { [EOL] parser._handleUnexpectedValue('%'); [EOL] fail("Expected JsonParseException for unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'a'}; // 'a' is a non-space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWS(); [EOL] assertEquals('a', result); // Assert that the non-space character is returned [EOL] }
public void testSkipWSWithSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{' '}; // ' ' is a space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should throw an exception for unexpected end-of-input"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'/'}; // '/' to trigger _skipComment [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] }
public void testSkipWSWithNewLine() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'\n'}; // '\n' to trigger _skipLF [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] }
public void testSkipWSWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'\r'}; // '\r' to trigger _skipCR [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] }
public void testSkipWSWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{'\t'}; // '\t' is a tab character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWS(); [EOL] assertEquals('\t', result); // Assert that the tab character is returned [EOL] }
public void testSkipWSWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{(byte) 0xA0}; // Non-standard space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should throw an exception for invalid space character"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithEndOfInput() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[]{}; // Empty buffer to simulate end of input [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should throw an exception for unexpected end-of-input"); // Assert that an exception is thrown [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) 'a'; // 'a' is a non-space character [EOL] int result = _skipWSOrEnd(); [EOL] assertNotEquals(-1, result); // Assert that the result is not end of input [EOL] assertEquals('a', result); // Assert that the correct character is returned [EOL] }
public void testSkipWSOrEndWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '/'; // '/' is INT_SLASH [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) ' '; // ' ' is INT_SPACE [EOL] _inputPtr++; [EOL] _inputBuffer[_inputPtr] = (byte) 'a'; // 'a' is a non-space character [EOL] int result = _skipWSOrEnd(); [EOL] assertNotEquals(-1, result); // Assert that the result is not end of input [EOL] assertEquals('a', result); // Assert that the correct character is returned [EOL] }
public void testSkipWSOrEndWithNewLine() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\n'; // '\n' is INT_LF [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\r'; // '\r' is INT_CR [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\t'; // '\t' is INT_TAB [EOL] _inputPtr++; [EOL] _inputBuffer[_inputPtr] = (byte) 'a'; // 'a' is a non-space character [EOL] int result = _skipWSOrEnd(); [EOL] assertNotEquals(-1, result); // Assert that the result is not end of input [EOL] assertEquals('a', result); // Assert that the correct character is returned [EOL] }
public void testSkipWSOrEndAtEndOfInput() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assert that the result is end of input [EOL] }
public void testSkipWSOrEndWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) 0x01; // An invalid space character [EOL] try { [EOL] _skipWSOrEnd(); [EOL] fail("Expected JsonParseException for invalid space character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
private int _skipColon() throws IOException, JsonParseException { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] int i = _inputBuffer[_inputPtr++]; [EOL] if (i == INT_COLON) { [EOL] if (_inputPtr < _inputEnd) { [EOL] i = _inputBuffer[_inputPtr] & 0xFF; [EOL] if (i > INT_SPACE && i != INT_SLASH) { [EOL] ++_inputPtr; [EOL] return i; [EOL] } [EOL] } [EOL] } else { [EOL] i &= 0xFF; [EOL] space_loop: while (true) { [EOL] switch(i) { [EOL] case INT_SPACE: [EOL] case INT_TAB: [EOL] break; [EOL] case INT_CR: [EOL] _skipCR(); [EOL] break; [EOL] case INT_LF: [EOL] _skipLF(); [EOL] break; [EOL] case INT_SLASH: [EOL] _skipComment(); [EOL] break; [EOL] default: [EOL] if (i < INT_SPACE) { [EOL] _throwInvalidSpace(i); [EOL] } [EOL] break space_loop; [EOL] } [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] } [EOL] if (i != INT_COLON) { [EOL] _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL] } [EOL] } [EOL] while (_inputPtr < _inputEnd || loadMore()) { [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (i > INT_SPACE) { [EOL] if (i != INT_SLASH) { [EOL] return i; [EOL] } [EOL] _skipComment(); [EOL] } else if (i != INT_SPACE) { [EOL] if (i == INT_LF) { [EOL] _skipLF(); [EOL] } else if (i == INT_CR) { [EOL] _skipCR(); [EOL] } else if (i != INT_TAB) { [EOL] _throwInvalidSpace(i); [EOL] } [EOL] } [EOL] } [EOL] throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
public void testSkipCommentWithCommentsNotAllowed() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeature(ALLOW_COMMENTS, false); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for not allowed comments"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCommentAtEndOfFile() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("/"); [EOL] parser._inputPtr = parser._inputEnd; // Simulate end of file [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCommentWithCppStyle() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("//"); [EOL] parser._skipComment(); [EOL] assertEquals("Parser should have skipped C++ style comment", parser._inputPtr, 2); [EOL] }
public void testSkipCommentWithCStyle() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("/* comment */"); [EOL] parser._skipComment(); [EOL] assertTrue("Parser should have skipped C style comment", parser._inputPtr > 2); [EOL] }
public void testSkipCommentWithInvalidChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("/a"); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for invalid comment start"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCCommentWithAsteriskEnding() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', 'a', '*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("Input pointer should be at the end of the buffer", _inputEnd, _inputPtr); [EOL] }
public void testSkipCCommentWithNoEnding() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', 'a', '*', 'a'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] try { [EOL] _skipCComment(); [EOL] fail("Should throw JsonParseException for unclosed comment"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCCommentWithLineFeed() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', '\n'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("Input pointer should skip line feed", 3, _inputPtr); [EOL] }
public void testSkipCCommentWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', '\r'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("Input pointer should skip carriage return", 3, _inputPtr); [EOL] }
public void testSkipCCommentWithUtf8_2() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', (char) 0xC2, (char) 0xA2, '*'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("Input pointer should skip UTF-8 2-byte character", 5, _inputPtr); [EOL] }
public void testSkipCCommentWithUtf8_3() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', (char) 0xE2, (char) 0x82, (char) 0xAC, '*'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("Input pointer should skip UTF-8 3-byte character", 6, _inputPtr); [EOL] }
public void testSkipCCommentWithUtf8_4() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', (char) 0xF0, (char) 0x90, (char) 0x8D, (char) 0x88, '*'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("Input pointer should skip UTF-8 4-byte character", 7, _inputPtr); [EOL] }
public void testSkipCCommentWithInvalidChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', (char) 0xFF, '*'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] try { [EOL] _skipCComment(); [EOL] fail("Should throw JsonParseException for invalid character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipUtf8_2WithSufficientData() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new byte[] {(byte) 0x80, (byte) 0x81}; [EOL] _skipUtf8_2(0x80); [EOL] assertEquals("Pointer should have advanced by one", 1, _inputPtr); [EOL] }
public void testSkipUtf8_2AtEndOfBuffer() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] _skipUtf8_2(0x80); [EOL] assertTrue("loadMoreGuaranteed should have been called and _inputPtr should be less than _inputEnd", _inputPtr < _inputEnd); [EOL] }
public void testSkipUtf8_2WithInvalidData() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new byte[] {(byte) 0xFF, (byte) 0x81}; // 0xFF is not a valid continuation byte [EOL] try { [EOL] _skipUtf8_2(0x80); [EOL] fail("Should have thrown JsonParseException due to invalid data"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCRWithCRFollowedByLF() throws IOException { [EOL] JsonParser parser = createParserWithContent("\r\n"); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should be incremented twice", 2, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] } [EOL] public void testSkipCRWithLoneCR() throws IOException { [EOL] JsonParser parser = createParserWithContent("\r"); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should be incremented once", 1, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] } [EOL] public void testSkipCRWithNoCR() throws IOException { [EOL] JsonParser parser = createParserWithContent(""); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should not be incremented", 0, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] } [EOL] public void testSkipCRWithCRAtEndOfBuffer() throws IOException { [EOL] JsonParser parser = createParserWithContent("\r", true); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should be incremented once", 1, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] } [EOL] public void testSkipCRWithCRAndNoLFAtEndOfBuffer() throws IOException { [EOL] JsonParser parser = createParserWithContent("\r", false); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should not be incremented", 0, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] }

private void readObject(ObjectInputStream in) throws IOException { [EOL] _jdkSerializeValue = in.readUTF(); [EOL] }
public void testWriteObjectWithValidOutputStream() throws IOException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream out = new ObjectOutputStream(baos); [EOL] JsonString jsonString = new JsonString("testValue"); [EOL] jsonString.writeObject(out); [EOL] out.close(); [EOL] String result = baos.toString("UTF-8"); [EOL] assertTrue(result.contains("testValue")); [EOL] }
protected Object readResolve() { [EOL] return new SerializedString(_jdkSerializeValue); [EOL] }
public void testAllocBase64BufferWhenBufferIsNull() { [EOL] BufferRecycler bufferRecycler = new BufferRecycler(); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] jsonFactory._bufferRecycler = bufferRecycler; [EOL] jsonFactory._base64Buffer = null; // Assuming _base64Buffer is accessible, otherwise use reflection or appropriate setter [EOL] byte[] result = jsonFactory.allocBase64Buffer(); [EOL] assertNotNull(result); [EOL] assertEquals(bufferRecycler.byteBufferLength(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER), result.length); [EOL] }
public void testAllocBase64BufferWhenBufferIsNotNull() { [EOL] BufferRecycler bufferRecycler = new BufferRecycler(); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] jsonFactory._bufferRecycler = bufferRecycler; [EOL] byte[] preAllocatedBuffer = new byte[100]; [EOL] jsonFactory._base64Buffer = preAllocatedBuffer; // Assuming _base64Buffer is accessible, otherwise use reflection or appropriate setter [EOL] byte[] result = jsonFactory.allocBase64Buffer(); [EOL] assertNotNull(result); [EOL] assertNotSame(preAllocatedBuffer, result); [EOL] assertEquals(bufferRecycler.byteBufferLength(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER), result.length); [EOL] }
public void testReleaseBase64BufferWithNonNullBuffer() { [EOL] byte[] testBuffer = new byte[10]; [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(new ByteArrayOutputStream()); [EOL] ByteArrayBuilder builder = (ByteArrayBuilder) generator._getBufferRecycler().getByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER); [EOL] builder.resetAndStart(); [EOL] System.arraycopy(testBuffer, 0, builder.buffer(), 0, testBuffer.length); [EOL] builder.setCurrentSegmentLength(testBuffer.length); [EOL] generator.releaseBase64Buffer(testBuffer); [EOL] assertNull(generator._getBufferRecycler().getByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER)); [EOL] }
public void testReleaseBase64BufferWithNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(new ByteArrayOutputStream()); [EOL] generator.releaseBase64Buffer(null); [EOL] }
public void testReleaseConcatBufferWithNonNullBuffer() { [EOL] char[] testBuffer = new char[10]; [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] generator._concatCBuffer = testBuffer; [EOL] generator.releaseConcatBuffer(testBuffer); [EOL] assertNull(generator._concatCBuffer); [EOL] }
public void testReleaseConcatBufferWithNullBuffer() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] generator._concatCBuffer = new char[10]; [EOL] generator.releaseConcatBuffer(null); [EOL] assertNotNull(generator._concatCBuffer); [EOL] }
public void testName1WithValidParameters() { [EOL] String name = "testName"; [EOL] int hash = 123; [EOL] int quad = 456; [EOL] Name1 name1 = new Name1(name, hash, quad); [EOL] assertEquals(name, name1.getName()); [EOL] assertEquals(hash, name1.getHash()); [EOL] assertEquals(quad, name1.getQuad()); [EOL] }
public void testName1WithNullName() { [EOL] String name = null; [EOL] int hash = 123; [EOL] int quad = 456; [EOL] Name1 name1 = new Name1(name, hash, quad); [EOL] assertNull(name1.getName()); [EOL] assertEquals(hash, name1.getHash()); [EOL] assertEquals(quad, name1.getQuad()); [EOL] }
public void testEqualsWithEqualQuad() { [EOL] SimpleQuad simpleQuad = new SimpleQuad(1234); [EOL] assertTrue(simpleQuad.equals(1234)); [EOL] }
public void testEqualsWithUnequalQuad() { [EOL] SimpleQuad simpleQuad = new SimpleQuad(1234); [EOL] assertFalse(simpleQuad.equals(5678)); [EOL] }
public void testEqualsWithDifferentLengths() { [EOL] int[] quads1 = new int[] {1, 2, 3}; [EOL] int[] quads2 = new int[] {1, 2, 3, 4}; [EOL] YourClass instance = new YourClass(quads1, 3); [EOL] boolean result = instance.equals(quads2, 4); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithSameLengthsDifferentContent() { [EOL] int[] quads1 = new int[] {1, 2, 3}; [EOL] int[] quads2 = new int[] {1, 2, 4}; [EOL] YourClass instance = new YourClass(quads1, 3); [EOL] boolean result = instance.equals(quads2, 3); [EOL] assertFalse(result); [EOL] }
public void testEqualsWithSameLengthsAndContent() { [EOL] int[] quads1 = new int[] {1, 2, 3}; [EOL] int[] quads2 = new int[] {1, 2, 3}; [EOL] YourClass instance = new YourClass(quads1, 3); [EOL] boolean result = instance.equals(quads2, 3); [EOL] assertTrue(result); [EOL] }
public void testJsonTokenWithNull() { [EOL] JsonToken token = new JsonToken(null); [EOL] assertNull(token._serialized); [EOL] assertNull(token._serializedChars); [EOL] assertNull(token._serializedBytes); [EOL] }
public void testJsonTokenWithNonNull() { [EOL] String testString = "test"; [EOL] JsonToken token = new JsonToken(testString); [EOL] assertEquals(testString, token._serialized); [EOL] assertArrayEquals(testString.toCharArray(), token._serializedChars); [EOL] byte[] expectedBytes = new byte[testString.length()]; [EOL] for (int i = 0; i < testString.length(); ++i) { [EOL] expectedBytes[i] = (byte) testString.charAt(i); [EOL] } [EOL] assertArrayEquals(expectedBytes, token._serializedBytes); [EOL] }
public void testReadBinaryValueWithDefaultVariant() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithBinaryContent(); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] int result = parser.readBinaryValue(out); [EOL] assertTrue(result > 0); [EOL] }
public void testResetWithString_NullValue() { [EOL] TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL] tb.resetWithString(null); [EOL] assertNull(tb._inputBuffer); [EOL] assertEquals(-1, tb._inputStart); [EOL] assertEquals(0, tb._inputLen); [EOL] assertNull(tb._resultString); [EOL] assertNull(tb._resultArray); [EOL] assertFalse(tb._hasSegments); [EOL] assertEquals(0, tb._currentSize); [EOL] }
public void testResetWithString_EmptyString() { [EOL] TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL] tb.resetWithString(""); [EOL] assertNull(tb._inputBuffer); [EOL] assertEquals(-1, tb._inputStart); [EOL] assertEquals(0, tb._inputLen); [EOL] assertEquals("", tb._resultString); [EOL] assertNull(tb._resultArray); [EOL] assertFalse(tb._hasSegments); [EOL] assertEquals(0, tb._currentSize); [EOL] }
public void testResetWithString_NonEmptyString() { [EOL] TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL] tb.resetWithString("test"); [EOL] assertNull(tb._inputBuffer); [EOL] assertEquals(-1, tb._inputStart); [EOL] assertEquals(0, tb._inputLen); [EOL] assertEquals("test", tb._resultString); [EOL] assertNull(tb._resultArray); [EOL] assertFalse(tb._hasSegments); [EOL] assertEquals(0, tb._currentSize); [EOL] }
public void testResetWithString_WithSegments() { [EOL] TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL] tb._hasSegments = true; // Simulate the condition where segments exist [EOL] tb.resetWithString("segmented"); [EOL] assertNull(tb._inputBuffer); [EOL] assertEquals(-1, tb._inputStart); [EOL] assertEquals(0, tb._inputLen); [EOL] assertEquals("segmented", tb._resultString); [EOL] assertNull(tb._resultArray); [EOL] assertFalse(tb._hasSegments); // Ensure segments are cleared [EOL] assertEquals(0, tb._currentSize); [EOL] }
public void testEmptyAndGetCurrentSegment_WithoutSegments() { [EOL] YourClass instance = createInstance(); [EOL] char[] result = instance.emptyAndGetCurrentSegment(); [EOL] assertNotNull(result); [EOL] assertEquals(0, instance.getCurrentSize()); // Assuming a getter for _currentSize [EOL] assertNull(instance.getInputBuffer()); // Assuming a getter for _inputBuffer [EOL] assertNull(instance.getResultString()); // Assuming a getter for _resultString [EOL] assertNull(instance.getResultArray()); // Assuming a getter for _resultArray [EOL] assertEquals(-1, instance.getInputStart()); // Assuming a getter for _inputStart [EOL] assertEquals(0, instance.getInputLen()); // Assuming a getter for _inputLen [EOL] }
public void testEmptyAndGetCurrentSegment_WithSegments() { [EOL] YourClass instance = createInstance(); [EOL] instance.append('a'); // Assuming an append method to set _hasSegments to true [EOL] instance.append('b'); [EOL] char[] result = instance.emptyAndGetCurrentSegment(); [EOL] assertNotNull(result); [EOL] assertEquals(0, instance.getCurrentSize()); [EOL] assertNull(instance.getInputBuffer()); [EOL] assertNull(instance.getResultString()); [EOL] assertNull(instance.getResultArray()); [EOL] assertEquals(-1, instance.getInputStart()); [EOL] assertEquals(0, instance.getInputLen()); [EOL] assertEquals(0, instance.getSegmentSize()); // Assuming a getter for the size of segments [EOL] }
public void testWriteObjectWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonGenerator gen = createJsonGenerator(); // Implement this method to return a mock or a concrete JsonGenerator [EOL] gen.writeObject(null); [EOL] verify(gen).writeNull(); // Implement this method to verify that writeNull() was called [EOL] }
public void testWriteObjectWithNonNullValueUsingObjectCodec() throws IOException, JsonProcessingException { [EOL] JsonGenerator gen = createJsonGenerator(); // Implement this method to return a mock or a concrete JsonGenerator [EOL] ObjectCodec codec = mock(ObjectCodec.class); // Use a mocking framework like Mockito [EOL] gen.setObjectCodec(codec); // Implement this method to set the ObjectCodec [EOL] Object value = new Object(); [EOL] gen.writeObject(value); [EOL] verify(codec).writeValue(gen, value); // Implement this method to verify that writeValue() was called with the correct arguments [EOL] }
public void testWriteObjectWithNonNullValueWithoutObjectCodec() throws IOException, JsonProcessingException { [EOL] JsonGenerator gen = createJsonGenerator(); // Implement this method to return a mock or a concrete JsonGenerator [EOL] gen.setObjectCodec(null); // Implement this method to ensure no ObjectCodec is set [EOL] Object value = new Object(); [EOL] gen.writeObject(value); [EOL] verify(gen).writeSimpleObject(value); // Implement this method to verify that _writeSimpleObject() was called with the correct arguments [EOL] }
public void testCopyCurrentStructureWithFieldName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp).getCurrentName(); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(this).writeFieldName("fieldName"); [EOL] verify(this).writeStartArray(); [EOL] verify(this).writeEndArray(); [EOL] }
public void testCopyCurrentStructureWithStartArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(this).writeStartArray(); [EOL] verify(this).writeEndArray(); [EOL] }
public void testCopyCurrentStructureWithStartObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(this).writeStartObject(); [EOL] verify(this).writeEndObject(); [EOL] }
public void testCopyCurrentStructureWithOtherToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(this).copyCurrentEvent(jp); [EOL] }
public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) { [EOL] super(ctxt, features, codec); [EOL] _outputStream = out; [EOL] _bufferRecyclable = true; [EOL] _outputBuffer = ctxt.allocWriteEncodingBuffer(); [EOL] _outputEnd = _outputBuffer.length; [EOL] _outputMaxContiguous = _outputEnd >> 3; [EOL] _charBuffer = ctxt.allocConcatBuffer(); [EOL] _charBufferLength = _charBuffer.length; [EOL] if (isEnabled(Feature.ESCAPE_NON_ASCII)) { [EOL] setHighestNonEscapedChar(127); [EOL] } [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void testWriteFieldNameWithExpectedValueStatus() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithStatus(JsonWriteContext.STATUS_EXPECT_VALUE); [EOL] assertThrows(JsonGenerationException.class, () -> generator.writeFieldName("fieldName")); [EOL] }
public void testWriteFieldNameWithPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithPrettyPrinter(); [EOL] generator.writeFieldName("fieldName"); [EOL] }
public void testWriteFieldNameAfterComma() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithStatus(JsonWriteContext.STATUS_OK_AFTER_COMMA); [EOL] generator.writeFieldName("fieldName"); [EOL] }
public void testWriteFieldNameWithoutComma() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithStatus(JsonWriteContext.STATUS_OK_AFTER_COLON); [EOL] generator.writeFieldName("fieldName"); [EOL] }
public void testWriteStartArrayWithPrettyPrinter() throws IOException { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new OutputStream() { [EOL] @Override [EOL] public void write(int b) throws IOException { [EOL] } [EOL] }, false); [EOL] UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, 0, null, ctxt.getOutputStream(), new byte[200], 0, true); [EOL] gen._cfgPrettyPrinter = new MinimalPrettyPrinter(); [EOL] gen.writeStartArray(); [EOL] assertNotNull(gen._writeContext); [EOL] assertTrue(gen._writeContext.inArray()); [EOL] }
public void testWriteStartArrayWithoutPrettyPrinter() throws IOException { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new OutputStream() { [EOL] @Override [EOL] public void write(int b) throws IOException { [EOL] } [EOL] }, false); [EOL] UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, 0, null, ctxt.getOutputStream(), new byte[200], 0, true); [EOL] gen._cfgPrettyPrinter = null; [EOL] gen._outputTail = gen._outputEnd; // to trigger _flushBuffer [EOL] gen.writeStartArray(); [EOL] assertNotNull(gen._writeContext); [EOL] assertTrue(gen._writeContext.inArray()); [EOL] assertEquals(BYTE_LBRACKET, gen._outputBuffer[gen._outputTail - 1]); [EOL] }
@Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL] if (!_writeContext.inArray()) { [EOL] _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL] } [EOL] if (_cfgPrettyPrinter != null) { [EOL] _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL] } else { [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_RBRACKET; [EOL] } [EOL] _writeContext = _writeContext.getParent(); [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void testWriteStartObjectWithoutPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createUtf8JsonGeneratorWithNullPrettyPrinter(); [EOL] generator._outputTail = generator._outputEnd - 1; [EOL] generator.writeStartObject(); [EOL] assertEquals(generator._outputBuffer[generator._outputTail], generator.BYTE_LCURLY); [EOL] assertNotNull(generator._writeContext); [EOL] }
public void testWriteStartObjectWithPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createUtf8JsonGeneratorWithNonNullPrettyPrinter(); [EOL] generator.writeStartObject(); [EOL] assertTrue(generator._cfgPrettyPrinter.calledWriteStartObject); [EOL] }
public void testWriteStartObjectWithFlushBuffer() throws IOException { [EOL] UTF8JsonGenerator generator = createUtf8JsonGeneratorWithNullPrettyPrinter(); [EOL] generator._outputTail = generator._outputEnd; [EOL] generator.writeStartObject(); [EOL] assertEquals(generator._outputTail, 0); [EOL] assertEquals(generator._outputBuffer[0], generator.BYTE_LCURLY); [EOL] }
public void testWriteEndObjectNotInObjectContext() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithObjectContextNotInObject(); [EOL] try { [EOL] generator.writeEndObject(); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] } [EOL] public void testWriteEndObjectWithPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithPrettyPrinter(); [EOL] generator.writeStartObject(); [EOL] generator.writeEndObject(); [EOL] assertEquals("{}", generator.getOutputTarget().toString()); [EOL] } [EOL] public void testWriteEndObjectWithoutPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithoutPrettyPrinter(); [EOL] generator.writeStartObject(); [EOL] generator.writeEndObject(); [EOL] assertEquals("}", generator.getOutputTarget().toString()); [EOL] } [EOL] public void testWriteEndObjectWithBufferBoundary() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorAtBufferBoundary(); [EOL] generator.writeStartObject(); [EOL] generator.writeEndObject(); [EOL] assertEquals("}", generator.getOutputTarget().toString()); [EOL] }
private UTF8JsonGenerator createGeneratorWithObjectContextNotInObject() { [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithPrettyPrinter() { [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithoutPrettyPrinter() { [EOL] } [EOL] private UTF8JsonGenerator createGeneratorAtBufferBoundary() { [EOL] }
protected final void _writeFieldName(String name) throws IOException, JsonGenerationException { [EOL] if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL] _writeStringSegments(name); [EOL] return; [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] final int len = name.length(); [EOL] if (len <= _charBufferLength) { [EOL] name.getChars(0, len, _charBuffer, 0); [EOL] if (len <= _outputMaxContiguous) { [EOL] if ((_outputTail + len) > _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _writeStringSegment(_charBuffer, 0, len); [EOL] } else { [EOL] _writeStringSegments(_charBuffer, 0, len); [EOL] } [EOL] } else { [EOL] _writeStringSegments(name); [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL] if (commaBefore) { [EOL] _cfgPrettyPrinter.writeObjectEntrySeparator(this); [EOL] } else { [EOL] _cfgPrettyPrinter.beforeObjectEntries(this); [EOL] } [EOL] if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] final int len = name.length(); [EOL] if (len <= _charBufferLength) { [EOL] name.getChars(0, len, _charBuffer, 0); [EOL] if (len <= _outputMaxContiguous) { [EOL] if ((_outputTail + len) > _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _writeStringSegment(_charBuffer, 0, len); [EOL] } else { [EOL] _writeStringSegments(_charBuffer, 0, len); [EOL] } [EOL] } else { [EOL] _writeStringSegments(name); [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } else { [EOL] _writeStringSegments(name); [EOL] } [EOL] }
public void testWriteStringWithNullText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString(null); [EOL] }
public void testWriteStringWithEmptyText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString(""); [EOL] }
public void testWriteStringWithShortText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String shortText = "short"; [EOL] generator.writeString(shortText); [EOL] }
public void testWriteStringWithLongText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String longText = createLongString(); [EOL] generator.writeString(longText); [EOL] }
public void testWriteStringWithMaxLengthText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String maxLengthText = createMaxLengthString(); [EOL] generator.writeString(maxLengthText); [EOL] }
public void testWriteStringWithTextExceedingMaxContiguous() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String textExceedingMaxContiguous = createTextExceedingMaxContiguous(); [EOL] generator.writeString(textExceedingMaxContiguous); [EOL] }
public void testWriteStringWithOutputBufferAlmostFull() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithAlmostFullBuffer(); [EOL] generator.writeString("text"); [EOL] } [EOL] private UTF8JsonGenerator createGenerator() { [EOL] } [EOL] private String createLongString() { [EOL] } [EOL] private String createMaxLengthString() { [EOL] } [EOL] private String createTextExceedingMaxContiguous() { [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithAlmostFullBuffer() { [EOL] }
private void test_writeLongString_flushBufferBeforeAndAfter() throws IOException { [EOL] ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator gen = new UTF8JsonGenerator(null, 0, null, out, new byte[10], 0, true); [EOL] String longString = "longStringToFlushBuffer"; [EOL] gen._writeLongString(longString); [EOL] String result = out.toString("UTF-8"); [EOL] assertTrue(result.contains("\"" + longString + "\"")); [EOL] }
private void test_writeLongString_noFlushNeeded() throws IOException { [EOL] ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator gen = new UTF8JsonGenerator(null, 0, null, out, new byte[1024], 0, true); [EOL] String shortString = "short"; [EOL] gen._writeLongString(shortString); [EOL] String result = out.toString("UTF-8"); [EOL] assertTrue(result.contains("\"" + shortString + "\"")); [EOL] }
public void testWriteStringWithOffsetAndLengthWithinBuffer() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedMethods(); [EOL] char[] text = "testString".toCharArray(); [EOL] int offset = 2; [EOL] int len = 4; [EOL] generator.writeString(text, offset, len); [EOL] verify(generator, times(1))._writeStringSegment(text, offset, len); [EOL] verify(generator, times(2))._flushBuffer(); // once before and once after writing [EOL] verify(generator, times(2))._verifyValueWrite("write text value"); [EOL] }
public void testWriteStringWithOffsetAndLengthExceedingBuffer() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedMethods(); [EOL] char[] text = "testString".toCharArray(); [EOL] int offset = 0; [EOL] int len = text.length; [EOL] generator.writeString(text, offset, len); [EOL] verify(generator, times(1))._writeStringSegments(text, offset, len); [EOL] verify(generator, times(2))._flushBuffer(); // once before and once after writing [EOL] verify(generator, times(2))._verifyValueWrite("write text value"); [EOL] }
public void testWriteStringWithEmptyText() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedMethods(); [EOL] char[] text = new char[0]; [EOL] generator.writeString(text, 0, 0); [EOL] verify(generator, never())._writeStringSegment(any(char[].class), anyInt(), anyInt()); [EOL] verify(generator, never())._writeStringSegments(any(char[].class), anyInt(), anyInt()); [EOL] verify(generator, times(2))._flushBuffer(); // once before and once after writing [EOL] verify(generator, times(2))._verifyValueWrite("write text value"); [EOL] }
@Override [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL] _verifyValueWrite("write text value"); [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] if (len <= _outputMaxContiguous) { [EOL] _writeUTF8Segment(text, offset, len); [EOL] } else { [EOL] _writeUTF8Segments(text, offset, len); [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void testWriteRawWithEmptyString() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGenerator(); // Assuming createGenerator() is a method that creates an instance of UTF8JsonGenerator [EOL] generator.writeRaw(""); // Writing an empty string should not change the state of the generator [EOL] }
public void testWriteRawWithNonEmptyString() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGenerator(); // Assuming createGenerator() is a method that creates an instance of UTF8JsonGenerator [EOL] String text = "test"; [EOL] generator.writeRaw(text); // Writing a non-empty string should invoke writeRaw multiple times if the string is longer than the buffer [EOL] }
public void testWriteRawWithNullString() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGenerator(); // Assuming createGenerator() is a method that creates an instance of UTF8JsonGenerator [EOL] try { [EOL] generator.writeRaw(null); // Writing a null string should throw a NullPointerException [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testWriteRawWithBufferOverflow() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int offset = 0; [EOL] int len = 10; [EOL] UTF8JsonGenerator generator = createGeneratorWithSmallBuffer(); [EOL] generator.writeRaw(cbuf, offset, len); [EOL] } [EOL] public void testWriteRawWithoutBufferOverflow() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int offset = 0; [EOL] int len = 2; [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] generator.writeRaw(cbuf, offset, len); [EOL] } [EOL] public void testWriteRawWithNonAsciiChar() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', ''}; [EOL] int offset = 0; [EOL] int len = 11; [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] generator.writeRaw(cbuf, offset, len); [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithSmallBuffer() { [EOL] return null; [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithSufficientBuffer() { [EOL] return null; [EOL] }
public void testWriteRawCharWithinSingleByteRange() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedOutputStream(); [EOL] char ch = 'a'; // ASCII, single byte [EOL] generator.writeRaw(ch); [EOL] verifySingleByteWritten(generator, ch); [EOL] }
public void testWriteRawCharWithinDoubleByteRange() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedOutputStream(); [EOL] char ch = '\u00A2'; // 2-byte UTF-8 character [EOL] generator.writeRaw(ch); [EOL] verifyDoubleByteWritten(generator, ch); [EOL] }
public void testWriteRawCharAboveDoubleByteRange() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedOutputStream(); [EOL] char ch = '\u20AC'; // 3-byte UTF-8 character [EOL] generator.writeRaw(ch); [EOL] verifyOutputRawMultiByteCharCalled(generator, ch); [EOL] }
public void testWriteRawCharWithBufferFlush() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithAlmostFullBuffer(); [EOL] char ch = 'b'; // ASCII, single byte [EOL] generator.writeRaw(ch); [EOL] verifyFlushBufferCalled(generator); [EOL] verifySingleByteWritten(generator, ch); [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithMockedOutputStream() { [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithAlmostFullBuffer() { [EOL] } [EOL] private void verifySingleByteWritten(UTF8JsonGenerator generator, char ch) { [EOL] } [EOL] private void verifyDoubleByteWritten(UTF8JsonGenerator generator, char ch) { [EOL] } [EOL] private void verifyOutputRawMultiByteCharCalled(UTF8JsonGenerator generator, char ch) { [EOL] } [EOL] private void verifyFlushBufferCalled(UTF8JsonGenerator generator) { [EOL] }
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL] _verifyValueWrite("write binary value"); [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] _writeBinary(b64variant, data, offset, offset + len); [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void testWriteBinaryWithNegativeDataLength() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedConditions(); [EOL] InputStream data = new ByteArrayInputStream(new byte[0]); [EOL] int dataLength = -1; [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] int bytesWritten = generator.writeBinary(b64variant, data, dataLength); [EOL] assertEquals(0, bytesWritten); // Assuming _writeBinary returns 0 for empty streams [EOL] }
public void testWriteBinaryWithDataLength() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedConditions(); [EOL] byte[] inputData = {1, 2, 3, 4, 5}; [EOL] InputStream data = new ByteArrayInputStream(inputData); [EOL] int dataLength = inputData.length; [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] int bytesWritten = generator.writeBinary(b64variant, data, dataLength); [EOL] assertEquals(dataLength, bytesWritten); [EOL] }
public void testWriteBinaryWithInsufficientData() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedConditions(); [EOL] byte[] inputData = {1, 2, 3}; [EOL] InputStream data = new ByteArrayInputStream(inputData); [EOL] int dataLength = 5; // More than available in inputData [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] Exception exception = assertThrows(JsonGenerationException.class, () -> { [EOL] generator.writeBinary(b64variant, data, dataLength); [EOL] }); [EOL] String expectedMessage = "Too few bytes available: missing 2 bytes (out of 5)"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testWriteBinaryWithBufferFlush() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedConditions(); [EOL] byte[] inputData = new byte[1024]; // Large enough to trigger buffer flush [EOL] Arrays.fill(inputData, (byte) 1); [EOL] InputStream data = new ByteArrayInputStream(inputData); [EOL] int dataLength = -1; // Indicating unknown length [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] int bytesWritten = generator.writeBinary(b64variant, data, dataLength); [EOL] assertEquals(inputData.length, bytesWritten); [EOL] }
protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL] int status = _writeContext.writeValue(); [EOL] if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL] _reportError("Can not " + typeMsg + ", expecting field name"); [EOL] } [EOL] if (_cfgPrettyPrinter == null) { [EOL] byte b; [EOL] switch(status) { [EOL] case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL] b = BYTE_COMMA; [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL] b = BYTE_COLON; [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL] if (_rootValueSeparator != null) { [EOL] byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL] if (raw.length > 0) { [EOL] _writeBytes(raw); [EOL] } [EOL] } [EOL] return; [EOL] case JsonWriteContext.STATUS_OK_AS_IS: [EOL] default: [EOL] return; [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail] = b; [EOL] ++_outputTail; [EOL] return; [EOL] } [EOL] _verifyPrettyValueWrite(typeMsg, status); [EOL] }
protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL] switch(status) { [EOL] case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL] _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL] _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL] _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AS_IS: [EOL] if (_writeContext.inArray()) { [EOL] _cfgPrettyPrinter.beforeArrayValues(this); [EOL] } else if (_writeContext.inObject()) { [EOL] _cfgPrettyPrinter.beforeObjectEntries(this); [EOL] } [EOL] break; [EOL] default: [EOL] _throwInternal(); [EOL] break; [EOL] } [EOL] }
public void testCloseWithAutoCloseJsonContentAndInArray() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT.getMask(), null, out); [EOL] generator.writeStartArray(); // This will make the output context inArray() [EOL] generator.close(); [EOL] String output = out.toString(); [EOL] assertTrue(output.endsWith("]")); [EOL] }
public void testCloseWithAutoCloseJsonContentAndInObject() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT.getMask(), null, out); [EOL] generator.writeStartObject(); // This will make the output context inObject() [EOL] generator.close(); [EOL] String output = out.toString(); [EOL] assertTrue(output.endsWith("}")); [EOL] }
public void testCloseWithAutoCloseTargetEnabled() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), true); [EOL] OutputStream out = new MockOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, JsonGenerator.Feature.AUTO_CLOSE_TARGET.getMask(), null, out); [EOL] generator.close(); [EOL] assertTrue(((MockOutputStream) out).isClosed()); [EOL] }
public void testCloseWithFlushPassedToStreamEnabled() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new MockOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM.getMask(), null, out); [EOL] generator.close(); [EOL] assertTrue(((MockOutputStream) out).isFlushed()); [EOL] assertFalse(((MockOutputStream) out).isClosed()); [EOL] }
public void testCloseWithoutAutoCloseJsonContent() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, 0, null, out); [EOL] generator.writeStartArray(); [EOL] generator.close(); [EOL] String output = out.toString(); [EOL] assertFalse(output.endsWith("]")); [EOL] }
@Override [EOL] protected void _releaseBuffers() { [EOL] byte[] buf = _outputBuffer; [EOL] if (buf != null && _bufferRecyclable) { [EOL] _outputBuffer = null; [EOL] _ioContext.releaseWriteEncodingBuffer(buf); [EOL] } [EOL] char[] cbuf = _charBuffer; [EOL] if (cbuf != null) { [EOL] _charBuffer = null; [EOL] _ioContext.releaseConcatBuffer(cbuf); [EOL] } [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
private void testWriteStringSegmentsEmptyString() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedMethods(); [EOL] String text = ""; [EOL] generator._writeStringSegments(text); [EOL] verifyPrivate(generator, times(0)).invoke("_writeStringSegment", any(char[].class), anyInt(), anyInt()); [EOL] verifyPrivate(generator, times(0)).invoke("_flushBuffer"); [EOL] } [EOL] private void testWriteStringSegmentsShortString() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedMethods(); [EOL] String text = "short"; [EOL] generator._writeStringSegments(text); [EOL] verifyPrivate(generator).invoke("_writeStringSegment", any(char[].class), eq(0), eq(5)); [EOL] verifyPrivate(generator, times(0)).invoke("_flushBuffer"); [EOL] } [EOL] private void testWriteStringSegmentsLongString() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedMethods(); [EOL] String text = createLongString(); [EOL] generator._writeStringSegments(text); [EOL] verifyPrivate(generator, atLeastOnce()).invoke("_writeStringSegment", any(char[].class), anyInt(), anyInt()); [EOL] verifyPrivate(generator, atLeastOnce()).invoke("_flushBuffer"); [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithMockedMethods() { [EOL] return mock(UTF8JsonGenerator.class); [EOL] } [EOL] private String createLongString() { [EOL] return new String(new char[10000]); [EOL] }
private void testWriteStringSegmentsWithEmptyBuffer() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSmallBuffer(); [EOL] char[] cbuf = "testString".toCharArray(); [EOL] generator._writeStringSegments(cbuf, 0, cbuf.length); [EOL] } [EOL] private void testWriteStringSegmentsWithPartialBufferFlush() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSmallBuffer(); [EOL] char[] cbuf = "testStringLongEnoughToTriggerPartialFlush".toCharArray(); [EOL] generator._writeStringSegments(cbuf, 0, cbuf.length); [EOL] } [EOL] private void testWriteStringSegmentsWithExactBufferFill() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithExactBuffer(); [EOL] char[] cbuf = "testStringFitsBufferExactly".toCharArray(); [EOL] generator._writeStringSegments(cbuf, 0, cbuf.length); [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithSmallBuffer() { [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithExactBuffer() { [EOL] }
public void testWriteStringSegmentWithNoEscaping() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "normalString".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] } [EOL] public void testWriteStringSegmentWithEscaping() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "stringWithEscapingChar\u00A9".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] } [EOL] public void testWriteStringSegmentWithHighValueChar() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "stringWithHighValueChar\u20AC".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] }
public void testWriteStringSegmentWithCustomEscapes() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "customEscapeChar\u00A9".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _characterEscapes = new CustomCharacterEscapes(); // Assuming CustomCharacterEscapes is a valid implementation [EOL] _writeStringSegment(cbuf, offset, len); [EOL] }
public void testWriteStringSegmentWithMaximumNonEscapedChar() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "maxNonEscapedChar\u007F".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _maximumNonEscapedChar = 0x7F; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] }
private void test_writeStringSegment2_flushBufferNeeded() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] UTF8JsonGenerator generator = createGeneratorWithSmallBuffer(); [EOL] generator._writeStringSegment2(cbuf, offset, end); [EOL] }
private void test_writeStringSegment2_noEscapes() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] generator._writeStringSegment2(cbuf, offset, end); [EOL] }
private void test_writeStringSegment2_withEscapes() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', '\\', 'n', 'b', '\\', 't', 'c'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] generator._writeStringSegment2(cbuf, offset, end); [EOL] }
private void test_writeStringSegment2_withMultiByteChars() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'\u00A2', '\u00A3', '\u20AC'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] generator._writeStringSegment2(cbuf, offset, end); [EOL] }
public void testWriteUTF8SegmentsWithEmptyArray() throws IOException, JsonGenerationException { [EOL] byte[] utf8 = new byte[0]; [EOL] int offset = 0; [EOL] int totalLen = 0; [EOL] _writeUTF8Segments(utf8, offset, totalLen); [EOL] }
public void testWriteUTF8SegmentsWithNonEmptyArrayAndExactMaxContiguousLength() throws IOException, JsonGenerationException { [EOL] byte[] utf8 = new byte[_outputMaxContiguous]; [EOL] int offset = 0; [EOL] int totalLen = _outputMaxContiguous; [EOL] _writeUTF8Segments(utf8, offset, totalLen); [EOL] }
public void testWriteUTF8SegmentsWithNonEmptyArrayAndLengthGreaterThanMaxContiguous() throws IOException, JsonGenerationException { [EOL] byte[] utf8 = new byte[_outputMaxContiguous + 10]; [EOL] int offset = 0; [EOL] int totalLen = utf8.length; [EOL] _writeUTF8Segments(utf8, offset, totalLen); [EOL] }
public void testWriteUTF8SegmentsWithOffsetAndLength() throws IOException, JsonGenerationException { [EOL] byte[] utf8 = new byte[50]; [EOL] int offset = 10; [EOL] int totalLen = 30; [EOL] _writeUTF8Segments(utf8, offset, totalLen); [EOL] }
private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException { [EOL] final int[] escCodes = _outputEscapes; [EOL] for (int ptr = offset, end = offset + len; ptr < end; ) { [EOL] int ch = utf8[ptr++]; [EOL] if ((ch >= 0) && escCodes[ch] != 0) { [EOL] _writeUTF8Segment2(utf8, offset, len); [EOL] return; [EOL] } [EOL] } [EOL] if ((_outputTail + len) > _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); [EOL] _outputTail += len; [EOL] }
private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException { [EOL] int outputPtr = _outputTail; [EOL] if ((outputPtr + (len * 6)) > _outputEnd) { [EOL] _flushBuffer(); [EOL] outputPtr = _outputTail; [EOL] } [EOL] final byte[] outputBuffer = _outputBuffer; [EOL] final int[] escCodes = _outputEscapes; [EOL] len += offset; [EOL] while (offset < len) { [EOL] byte b = utf8[offset++]; [EOL] int ch = b; [EOL] if (ch < 0 || escCodes[ch] == 0) { [EOL] outputBuffer[outputPtr++] = b; [EOL] continue; [EOL] } [EOL] int escape = escCodes[ch]; [EOL] if (escape > 0) { [EOL] outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL] outputBuffer[outputPtr++] = (byte) escape; [EOL] } else { [EOL] outputPtr = _writeGenericEscape(ch, outputPtr); [EOL] } [EOL] } [EOL] _outputTail = outputPtr; [EOL] }
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL] int safeInputEnd = inputEnd - 3; [EOL] int safeOutputEnd = _outputEnd - 6; [EOL] int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL] while (inputPtr <= safeInputEnd) { [EOL] if (_outputTail > safeOutputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] int b24 = ((int) input[inputPtr++]) << 8; [EOL] b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL] b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL] _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL] if (--chunksBeforeLF <= 0) { [EOL] _outputBuffer[_outputTail++] = '\\'; [EOL] _outputBuffer[_outputTail++] = 'n'; [EOL] chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL] } [EOL] } [EOL] int inputLeft = inputEnd - inputPtr; [EOL] if (inputLeft > 0) { [EOL] if (_outputTail > safeOutputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] int b24 = ((int) input[inputPtr++]) << 16; [EOL] if (inputLeft == 2) { [EOL] b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL] } [EOL] _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL] } [EOL] }
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { [EOL] int inputPtr = 0; [EOL] int inputEnd = 0; [EOL] int lastFullOffset = -3; [EOL] int safeOutputEnd = _outputEnd - 6; [EOL] int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL] while (bytesLeft > 2) { [EOL] if (inputPtr > lastFullOffset) { [EOL] inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL] inputPtr = 0; [EOL] if (inputEnd < 3) { [EOL] break; [EOL] } [EOL] lastFullOffset = inputEnd - 3; [EOL] } [EOL] if (_outputTail > safeOutputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL] b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL] b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL] bytesLeft -= 3; [EOL] _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL] if (--chunksBeforeLF <= 0) { [EOL] _outputBuffer[_outputTail++] = '\\'; [EOL] _outputBuffer[_outputTail++] = 'n'; [EOL] chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL] } [EOL] } [EOL] if (bytesLeft > 0) { [EOL] inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL] inputPtr = 0; [EOL] if (inputEnd > 0) { [EOL] if (_outputTail > safeOutputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL] int amount; [EOL] if (inputPtr < inputEnd) { [EOL] b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL] amount = 2; [EOL] } else { [EOL] amount = 1; [EOL] } [EOL] _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL] bytesLeft -= amount; [EOL] } [EOL] } [EOL] return bytesLeft; [EOL] }
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { [EOL] int inputPtr = 0; [EOL] int inputEnd = 0; [EOL] int lastFullOffset = -3; [EOL] int bytesDone = 0; [EOL] int safeOutputEnd = _outputEnd - 6; [EOL] int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL] while (true) { [EOL] if (inputPtr > lastFullOffset) { [EOL] inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); [EOL] inputPtr = 0; [EOL] if (inputEnd < 3) { [EOL] break; [EOL] } [EOL] lastFullOffset = inputEnd - 3; [EOL] } [EOL] if (_outputTail > safeOutputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL] b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL] b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL] bytesDone += 3; [EOL] _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL] if (--chunksBeforeLF <= 0) { [EOL] _outputBuffer[_outputTail++] = '\\'; [EOL] _outputBuffer[_outputTail++] = 'n'; [EOL] chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL] } [EOL] } [EOL] if (inputPtr < inputEnd) { [EOL] if (_outputTail > safeOutputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL] int amount = 1; [EOL] if (inputPtr < inputEnd) { [EOL] b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL] amount = 2; [EOL] } [EOL] bytesDone += amount; [EOL] _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL] } [EOL] return bytesDone; [EOL] }
private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { [EOL] int i = 0; [EOL] while (inputPtr < inputEnd) { [EOL] readBuffer[i++] = readBuffer[inputPtr++]; [EOL] } [EOL] inputPtr = 0; [EOL] inputEnd = i; [EOL] maxRead = Math.min(maxRead, readBuffer.length); [EOL] do { [EOL] int length = maxRead - inputEnd; [EOL] if (length == 0) { [EOL] break; [EOL] } [EOL] int count = in.read(readBuffer, inputEnd, length); [EOL] if (count < 0) { [EOL] return inputEnd; [EOL] } [EOL] inputEnd += count; [EOL] } while (inputEnd < 3); [EOL] return inputEnd; [EOL] }
public void testOutputMultiByteCharWithSurrogate() throws IOException { [EOL] UTF8JsonGenerator gen = createGenerator(); // Assuming createGenerator() properly initializes UTF8JsonGenerator [EOL] int outputPtr = 0; [EOL] int ch = 0xD800; // SURR1_FIRST [EOL] outputPtr = gen._outputMultiByteChar(ch, outputPtr); [EOL] assertEquals(6, outputPtr); // 6 bytes for surrogate pair encoding [EOL] ch = 0xDFFF; // SURR2_LAST [EOL] outputPtr = gen._outputMultiByteChar(ch, outputPtr); [EOL] assertEquals(12, outputPtr); // 6 more bytes for the second surrogate pair encoding [EOL] }
public void testOutputMultiByteCharWithoutSurrogate() throws IOException { [EOL] UTF8JsonGenerator gen = createGenerator(); // Assuming createGenerator() properly initializes UTF8JsonGenerator [EOL] int outputPtr = 0; [EOL] int ch = 0x007F; // A char that is not a surrogate [EOL] outputPtr = gen._outputMultiByteChar(ch, outputPtr); [EOL] assertEquals(3, outputPtr); // 3 bytes for non-surrogate multi-byte encoding [EOL] }
protected final void _flushBuffer() throws IOException { [EOL] int len = _outputTail; [EOL] if (len > 0) { [EOL] _outputTail = 0; [EOL] _outputStream.write(_outputBuffer, 0, len); [EOL] } [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void testGetEntryCount_WhenIndexIsZero() { [EOL] JsonPointer pointer = new JsonPointer(""); // Assuming JsonPointer is the class containing getEntryCount [EOL] int count = pointer.getEntryCount(); [EOL] assertEquals(1, count); [EOL] }
public void testGetEntryCount_WhenIndexIsPositive() { [EOL] JsonPointer pointer = new JsonPointer("/0"); // Assuming JsonPointer uses "/0" to set _index to 1 [EOL] int count = pointer.getEntryCount(); [EOL] assertEquals(2, count); [EOL] }
public void testHasJSONFormatWithNoMoreBytesInitially() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(false); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithUTF8BOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB).thenReturn((byte) 0xBF); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithInvalidUTF8BOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithEmptyJsonObject() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn((byte) '{').thenReturn((byte) '}'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonEmptyJsonObject() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '{').thenReturn((byte) '"'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithEmptyJsonArray() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn((byte) '[').thenReturn((byte) ']'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithJsonArrayStart() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '[').thenReturn((byte) '['); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNumber() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '1'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNegativeNumber() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '-').thenReturn((byte) '1'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithInvalidNegativeNumber() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '-').thenReturn((byte) 'a'); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithLiteralNull() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn((byte) 'n').thenReturn((byte) 'u').thenReturn((byte) 'l').thenReturn((byte) 'l'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithLiteralTrue() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn((byte) 't').thenReturn((byte) 'r').thenReturn((byte) 'u').thenReturn((byte) 'e'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithLiteralFalse() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn((byte) 'f').thenReturn((byte) 'a').thenReturn((byte) 'l').thenReturn((byte) 's').thenReturn((byte) 'e'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testJsonLocationWithPositiveTotalChars() { [EOL] Object srcRef = new Object(); [EOL] long totalChars = 100L; [EOL] int lineNr = 1; [EOL] int colNr = 20; [EOL] JsonLocation location = new JsonLocation(srcRef, totalChars, lineNr, colNr); [EOL] assertEquals(srcRef, location.getSourceRef()); [EOL] assertEquals(totalChars, location.getCharOffset()); [EOL] assertEquals(lineNr, location.getLineNr()); [EOL] assertEquals(colNr, location.getColumnNr()); [EOL] }
public void testJsonLocationWithNegativeTotalChars() { [EOL] Object srcRef = new Object(); [EOL] long totalChars = -100L; [EOL] int lineNr = 1; [EOL] int colNr = 20; [EOL] JsonLocation location = new JsonLocation(srcRef, totalChars, lineNr, colNr); [EOL] assertEquals(srcRef, location.getSourceRef()); [EOL] assertEquals(-1L, location.getByteOffset()); [EOL] assertEquals(totalChars, location.getCharOffset()); [EOL] assertEquals(lineNr, location.getLineNr()); [EOL] assertEquals(colNr, location.getColumnNr()); [EOL] }
public void testJsonLocationWithNonNullSourceRef() { [EOL] Object sourceRef = new Object(); [EOL] long totalBytes = 100L; [EOL] long totalChars = 200L; [EOL] int lineNr = 10; [EOL] int columnNr = 20; [EOL] JsonLocation location = new JsonLocation(sourceRef, totalBytes, totalChars, lineNr, columnNr); [EOL] assertNotNull(location.getSourceRef()); [EOL] assertEquals(totalBytes, location.getTotalBytes()); [EOL] assertEquals(totalChars, location.getTotalChars()); [EOL] assertEquals(lineNr, location.getLineNr()); [EOL] assertEquals(columnNr, location.getColumnNr()); [EOL] }
public void testJsonLocationWithNullSourceRef() { [EOL] long totalBytes = 100L; [EOL] long totalChars = 200L; [EOL] int lineNr = 10; [EOL] int columnNr = 20; [EOL] JsonLocation location = new JsonLocation(null, totalBytes, totalChars, lineNr, columnNr); [EOL] assertNull(location.getSourceRef()); [EOL] assertEquals(totalBytes, location.getTotalBytes()); [EOL] assertEquals(totalChars, location.getTotalChars()); [EOL] assertEquals(lineNr, location.getLineNr()); [EOL] assertEquals(columnNr, location.getColumnNr()); [EOL] }
public void testGetLineNr() { [EOL] JsonLocation location = new JsonLocation(null, -1, 1, 2); [EOL] int lineNr = location.getLineNr(); [EOL] assertEquals(1, lineNr); [EOL] }
public void testToStringWithNullSourceRef() { [EOL] SourceInfo sourceInfo = new SourceInfo(null, 1, 1); [EOL] String result = sourceInfo.toString(); [EOL] assertTrue(result.contains("UNKNOWN")); [EOL] assertTrue(result.contains("line: 1")); [EOL] assertTrue(result.contains("column: 1")); [EOL] } [EOL] public void testToStringWithNonNullSourceRef() { [EOL] Object sourceRef = "SourceRef"; [EOL] SourceInfo sourceInfo = new SourceInfo(sourceRef, 2, 3); [EOL] String result = sourceInfo.toString(); [EOL] assertTrue(result.contains(sourceRef.toString())); [EOL] assertTrue(result.contains("line: 2")); [EOL] assertTrue(result.contains("column: 3")); [EOL] }
public void testJsonEncodingWithBigEndianTrue() { [EOL] JsonEncoding encoding = new JsonEncoding("UTF-8", true); [EOL] assertEquals("UTF-8", encoding.getJavaName()); [EOL] assertTrue(encoding.isBigEndian()); [EOL] }
public void testJsonEncodingWithBigEndianFalse() { [EOL] JsonEncoding encoding = new JsonEncoding("UTF-16", false); [EOL] assertEquals("UTF-16", encoding.getJavaName()); [EOL] assertFalse(encoding.isBigEndian()); [EOL] }
public void testCollectDefaults_AllFeaturesEnabled() { [EOL] Feature[] allFeaturesEnabled = new Feature[] { /* populate with all features enabled */ }; [EOL] int expectedFlags = 0; [EOL] for (Feature f : allFeaturesEnabled) { [EOL] expectedFlags |= f.getMask(); [EOL] } [EOL] int actualFlags = YourClass.collectDefaults(); // YourClass should be replaced with the actual class name [EOL] assertEquals(expectedFlags, actualFlags); [EOL] }
public void testCollectDefaults_NoFeaturesEnabled() { [EOL] Feature[] noFeaturesEnabled = new Feature[] { /* populate with all features disabled */ }; [EOL] int expectedFlags = 0; // Since no features are enabled, expected flags should be 0 [EOL] int actualFlags = YourClass.collectDefaults(); // YourClass should be replaced with the actual class name [EOL] assertEquals(expectedFlags, actualFlags); [EOL] }
public void testCollectDefaults_SomeFeaturesEnabled() { [EOL] Feature[] someFeaturesEnabled = new Feature[] { /* populate with some features enabled and some disabled */ }; [EOL] int expectedFlags = 0; [EOL] for (Feature f : someFeaturesEnabled) { [EOL] if (f.enabledByDefault()) { [EOL] expectedFlags |= f.getMask(); [EOL] } [EOL] } [EOL] int actualFlags = YourClass.collectDefaults(); // YourClass should be replaced with the actual class name [EOL] assertEquals(expectedFlags, actualFlags); [EOL] }
private Feature(boolean defaultState) { [EOL] _mask = (1 << ordinal()); [EOL] _defaultState = defaultState; [EOL] }
public void testEnabledByDefaultTrue() { [EOL] Feature feature = new Feature() { [EOL] public boolean enabledByDefault() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(feature.enabledByDefault()); [EOL] }
public void testEnabledByDefaultFalse() { [EOL] Feature feature = new Feature() { [EOL] public boolean enabledByDefault() { [EOL] return false; [EOL] } [EOL] }; [EOL] assertFalse(feature.enabledByDefault()); [EOL] }
public void testSetPrettyPrinterWithNull() { [EOL] JsonGenerator generator = createJsonGenerator(); // You need to implement this method to create an instance of JsonGenerator [EOL] JsonGenerator result = generator.setPrettyPrinter(null); [EOL] assertNull(generator.getPrettyPrinter()); // Assuming there's a method to get the current PrettyPrinter [EOL] assertSame(result, generator); [EOL] }
public void testSetPrettyPrinterWithNonNull() { [EOL] JsonGenerator generator = createJsonGenerator(); // You need to implement this method to create an instance of JsonGenerator [EOL] PrettyPrinter pp = new DefaultPrettyPrinter(); // Or any other implementation of PrettyPrinter [EOL] JsonGenerator result = generator.setPrettyPrinter(pp); [EOL] assertSame(pp, generator.getPrettyPrinter()); // Assuming there's a method to get the current PrettyPrinter [EOL] assertSame(result, generator); [EOL] }
public void testWriteBinaryWithValidData() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); // Assume this method properly creates a JsonGenerator instance [EOL] InputStream data = new ByteArrayInputStream(new byte[]{0, 1, 2, 3, 4}); // Sample binary data [EOL] int dataLength = 5; // Length of the data to write [EOL] int result = generator.writeBinary(data, dataLength); [EOL] assertEquals(dataLength, result); // Assert that the returned length is equal to the data length [EOL] }
public void testWriteBinaryWithNegativeDataLength() { [EOL] JsonGenerator generator = createJsonGenerator(); // Assume this method properly creates a JsonGenerator instance [EOL] InputStream data = new ByteArrayInputStream(new byte[]{0, 1, 2, 3, 4}); // Sample binary data [EOL] int dataLength = -1; // Invalid data length [EOL] try { [EOL] generator.writeBinary(data, dataLength); [EOL] fail("Should have thrown JsonGenerationException due to negative data length"); [EOL] } catch (JsonGenerationException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonGenerationException, not IOException"); [EOL] } [EOL] }
public void testWriteBinaryWithNullData() { [EOL] JsonGenerator generator = createJsonGenerator(); // Assume this method properly creates a JsonGenerator instance [EOL] InputStream data = null; // Null data [EOL] int dataLength = 5; // Length of the data to write [EOL] try { [EOL] generator.writeBinary(data, dataLength); [EOL] fail("Should have thrown NullPointerException due to null data"); [EOL] } catch (NullPointerException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected NullPointerException, not IOException"); [EOL] } [EOL] }
public void testWriteObjectFieldWithValidFieldNameAndPojo() throws IOException, JsonProcessingException { [EOL] String fieldName = "testField"; [EOL] Object pojo = new Object(); [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] doNothing().when(mockGenerator).writeFieldName(anyString()); [EOL] doNothing().when(mockGenerator).writeObject(any()); [EOL] mockGenerator.writeObjectField(fieldName, pojo); [EOL] verify(mockGenerator).writeFieldName(fieldName); [EOL] verify(mockGenerator).writeObject(pojo); [EOL] }
public void testWriteObjectFieldWithNullFieldName() throws IOException, JsonProcessingException { [EOL] String fieldName = null; [EOL] Object pojo = new Object(); [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] doNothing().when(mockGenerator).writeFieldName(anyString()); [EOL] doNothing().when(mockGenerator).writeObject(any()); [EOL] mockGenerator.writeObjectField(fieldName, pojo); [EOL] verify(mockGenerator).writeFieldName(fieldName); [EOL] verify(mockGenerator).writeObject(pojo); [EOL] }
public void testWriteObjectFieldWithNullPojo() throws IOException, JsonProcessingException { [EOL] String fieldName = "testField"; [EOL] Object pojo = null; [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] doNothing().when(mockGenerator).writeFieldName(anyString()); [EOL] doNothing().when(mockGenerator).writeObject(any()); [EOL] mockGenerator.writeObjectField(fieldName, pojo); [EOL] verify(mockGenerator).writeFieldName(fieldName); [EOL] verify(mockGenerator).writeObject(pojo); [EOL] }
public void testUsesPaddingCharWithPaddingChar() { [EOL] Base64Variant base64Variant = new Base64Variant("TEST", "ABC=", true); [EOL] assertTrue(base64Variant.usesPaddingChar((int) '=')); [EOL] }
public void testUsesPaddingCharWithNonPaddingChar() { [EOL] Base64Variant base64Variant = new Base64Variant("TEST", "ABC=", true); [EOL] assertFalse(base64Variant.usesPaddingChar((int) 'A')); [EOL] }
public void testEncodeBase64Chunk() { [EOL] Base64Variant base64 = Base64Variants.getDefaultVariant(); [EOL] char[] buffer = new char[4]; [EOL] int ptr = 0; [EOL] int b24 = 0x00FC0000; // Arbitrary 24-bit value to cover all shifts [EOL] ptr = encodeBase64Chunk(b24, buffer, ptr); [EOL] assertEquals(base64.encodeBase64Chunk(b24, buffer, 0), 4); [EOL] assertEquals(buffer[0], base64.encodeToChar((b24 >> 18) & 0x3F)); [EOL] assertEquals(buffer[1], base64.encodeToChar((b24 >> 12) & 0x3F)); [EOL] assertEquals(buffer[2], base64.encodeToChar((b24 >> 6) & 0x3F)); [EOL] assertEquals(buffer[3], base64.encodeToChar(b24 & 0x3F)); [EOL] }
public void testEncodeBase64PartialWithPaddingTwoBytes() { [EOL] int bits = 0x00FC0000; // Arbitrary bits with significant data in the first two bytes [EOL] int outputBytes = 2; [EOL] char[] buffer = new char[4]; [EOL] int outPtr = 0; [EOL] boolean _usesPadding = true; [EOL] char _paddingChar = '='; [EOL] char[] _base64ToAsciiC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray(); [EOL] int result = encodeBase64Partial(bits, outputBytes, buffer, outPtr, _usesPadding, _paddingChar, _base64ToAsciiC); [EOL] assert buffer[0] == _base64ToAsciiC[63]; [EOL] assert buffer[1] == _base64ToAsciiC[48]; [EOL] assert buffer[2] == _base64ToAsciiC[60]; [EOL] assert buffer[3] == _paddingChar; [EOL] assert result == 4; [EOL] }
public void testEncodeBase64PartialWithoutPaddingTwoBytes() { [EOL] int bits = 0x00FC0000; // Arbitrary bits with significant data in the first two bytes [EOL] int outputBytes = 2; [EOL] char[] buffer = new char[3]; [EOL] int outPtr = 0; [EOL] boolean _usesPadding = false; [EOL] char _paddingChar = '='; [EOL] char[] _base64ToAsciiC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray(); [EOL] int result = encodeBase64Partial(bits, outputBytes, buffer, outPtr, _usesPadding, _paddingChar, _base64ToAsciiC); [EOL] assert buffer[0] == _base64ToAsciiC[63]; [EOL] assert buffer[1] == _base64ToAsciiC[48]; [EOL] assert buffer[2] == _base64ToAsciiC[60]; [EOL] assert result == 3; [EOL] }
public void testEncodeBase64PartialWithPaddingOneByte() { [EOL] int bits = 0x00FC0000; // Arbitrary bits with significant data in the first byte only [EOL] int outputBytes = 1; [EOL] char[] buffer = new char[4]; [EOL] int outPtr = 0; [EOL] boolean _usesPadding = true; [EOL] char _paddingChar = '='; [EOL] char[] _base64ToAsciiC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray(); [EOL] int result = encodeBase64Partial(bits, outputBytes, buffer, outPtr, _usesPadding, _paddingChar, _base64ToAsciiC); [EOL] assert buffer[0] == _base64ToAsciiC[63]; [EOL] assert buffer[1] == _base64ToAsciiC[48]; [EOL] assert buffer[2] == _paddingChar; [EOL] assert buffer[3] == _paddingChar; [EOL] assert result == 4; [EOL] }
public void testEncodeBase64PartialWithoutPaddingOneByte() { [EOL] int bits = 0x00FC0000; // Arbitrary bits with significant data in the first byte only [EOL] int outputBytes = 1; [EOL] char[] buffer = new char[2]; [EOL] int outPtr = 0; [EOL] boolean _usesPadding = false; [EOL] char _paddingChar = '='; [EOL] char[] _base64ToAsciiC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray(); [EOL] int result = encodeBase64Partial(bits, outputBytes, buffer, outPtr, _usesPadding, _paddingChar, _base64ToAsciiC); [EOL] assert buffer[0] == _base64ToAsciiC[63]; [EOL] assert buffer[1] == _base64ToAsciiC[48]; [EOL] assert result == 2; [EOL] }
public void testEncodeBase64PartialWithPaddingTwoBytes() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] Base64Variant base64Variant = new Base64Variant("MODIFIED-FOR-URL", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", true, '=', Integer.MAX_VALUE); [EOL] int bits = 0x00FC0000; // Arbitrary bits that will result in two characters plus padding [EOL] int outputBytes = 2; [EOL] base64Variant.encodeBase64Partial(sb, bits, outputBytes); [EOL] assertEquals("8A==", sb.toString()); [EOL] }
public void testEncodeBase64PartialWithPaddingOneByte() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] Base64Variant base64Variant = new Base64Variant("MODIFIED-FOR-URL", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", true, '=', Integer.MAX_VALUE); [EOL] int bits = 0x00FC0000; // Arbitrary bits that will result in one character plus padding [EOL] int outputBytes = 1; [EOL] base64Variant.encodeBase64Partial(sb, bits, outputBytes); [EOL] assertEquals("8A==", sb.toString()); [EOL] }
public void testEncodeBase64PartialWithoutPaddingTwoBytes() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] Base64Variant base64Variant = new Base64Variant("MODIFIED-FOR-URL", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", false, '=', Integer.MAX_VALUE); [EOL] int bits = 0x00FC0000; // Arbitrary bits that will result in two characters without padding [EOL] int outputBytes = 2; [EOL] base64Variant.encodeBase64Partial(sb, bits, outputBytes); [EOL] assertEquals("8A", sb.toString()); [EOL] }
public void testEncodeBase64PartialWithoutPaddingOneByte() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] Base64Variant base64Variant = new Base64Variant("MODIFIED-FOR-URL", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", false, '=', Integer.MAX_VALUE); [EOL] int bits = 0x00FC0000; // Arbitrary bits that will result in one character without padding [EOL] int outputBytes = 1; [EOL] base64Variant.encodeBase64Partial(sb, bits, outputBytes); [EOL] assertEquals("8", sb.toString()); [EOL] }
public void testEncodeBase64Chunk() { [EOL] JacksonCore target = new JacksonCore(); // Assuming JacksonCore is the class where the method is defined [EOL] byte[] buffer = new byte[4]; [EOL] int b24 = 0x00FC0000; // Any arbitrary 24-bit number [EOL] int ptr = 0; [EOL] int newPtr = target.encodeBase64Chunk(b24, buffer, ptr); [EOL] assertEquals('w', buffer[0]); // Assuming _base64ToAsciiB[0] == 'w' [EOL] assertEquals('A', buffer[1]); // Assuming _base64ToAsciiB[16] == 'A' [EOL] assertEquals('A', buffer[2]); // Assuming _base64ToAsciiB[4] == 'A' [EOL] assertEquals('A', buffer[3]); // Assuming _base64ToAsciiB[0] == 'A' [EOL] assertEquals(4, newPtr); // Check if the pointer is incremented correctly [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr) { [EOL] buffer[outPtr++] = _base64ToAsciiB[(bits >> 18) & 0x3F]; [EOL] buffer[outPtr++] = _base64ToAsciiB[(bits >> 12) & 0x3F]; [EOL] if (_usesPadding) { [EOL] byte pb = (byte) _paddingChar; [EOL] buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiB[(bits >> 6) & 0x3F] : pb; [EOL] buffer[outPtr++] = pb; [EOL] } else { [EOL] if (outputBytes == 2) { [EOL] buffer[outPtr++] = _base64ToAsciiB[(bits >> 6) & 0x3F]; [EOL] } [EOL] } [EOL] return outPtr; [EOL] }
public String encode(byte[] input) { [EOL] return encode(input, false); [EOL] }
public void testEncodeEmptyInputWithoutQuotes() { [EOL] String result = encode(new byte[0], false); [EOL] assertEquals("", result); [EOL] } [EOL] public void testEncodeEmptyInputWithQuotes() { [EOL] String result = encode(new byte[0], true); [EOL] assertEquals("\"\"", result); [EOL] }
public void testEncodeNonEmptyInputWithoutQuotes() { [EOL] byte[] input = new byte[] { 'a', 'b', 'c' }; [EOL] String result = encode(input, false); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertFalse(result.startsWith("\"")); [EOL] assertFalse(result.endsWith("\"")); [EOL] }
public void testEncodeNonEmptyInputWithQuotes() { [EOL] byte[] input = new byte[] { 'a', 'b', 'c' }; [EOL] String result = encode(input, true); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith("\"")); [EOL] assertTrue(result.endsWith("\"")); [EOL] }
public void testEncodeInputWithLineBreaks() { [EOL] byte[] input = new byte[16]; // length that requires line breaks [EOL] String result = encode(input, false); [EOL] assertNotNull(result); [EOL] int expectedLineBreaks = input.length / (getMaxLineLength() >> 2); [EOL] int actualLineBreaks = result.length() - result.replace("\\n", "").length(); [EOL] assertEquals(expectedLineBreaks, actualLineBreaks); [EOL] }
public void testEncodeInputWithOneByteLeft() { [EOL] byte[] input = new byte[] { 'a', 'b', 'c', 'd', 'e' }; // 5 bytes, 1 byte left after full chunks [EOL] String result = encode(input, false); [EOL] assertNotNull(result); [EOL] String expectedEnding = encodeBase64Partial(new StringBuilder(), 'e' << 16, 1).toString(); [EOL] assertTrue(result.endsWith(expectedEnding)); [EOL] }
public void testEncodeInputWithTwoBytesLeft() { [EOL] byte[] input = new byte[] { 'a', 'b', 'c', 'd', 'e', 'f' }; // 6 bytes, 2 bytes left after full chunks [EOL] String result = encode(input, false); [EOL] assertNotNull(result); [EOL] String expectedEnding = encodeBase64Partial(new StringBuilder(), ('e' << 16) | ('f' << 8), 2).toString(); [EOL] assertTrue(result.endsWith(expectedEnding)); [EOL] }
public void testJsonParseExceptionWithMessageAndLocation() { [EOL] String message = "Test message"; [EOL] JsonLocation location = new JsonLocation(null, -1, -1, -1, -1); [EOL] JsonParseException exception = new JsonParseException(message, location); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertEquals(location, exception.getLocation()); [EOL] }
public void testGetNextCharWithEofMessageAndLoadMore() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("abc"); [EOL] assertEquals('a', parser.getNextChar("EOF")); [EOL] assertEquals('b', parser.getNextChar("EOF")); [EOL] parser.loadMore(); // Assuming this method sets _inputPtr to _inputEnd [EOL] try { [EOL] parser.getNextChar("EOF"); [EOL] fail("Should have thrown JsonParseException due to EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testGetNextCharWithoutEofMessageAndLoadMore() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("abc"); [EOL] assertEquals('a', parser.getNextChar(null)); [EOL] assertEquals('b', parser.getNextChar(null)); [EOL] parser.loadMore(); // Assuming this method sets _inputPtr to _inputEnd [EOL] try { [EOL] parser.getNextChar(null); [EOL] fail("Should have thrown JsonParseException due to EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testGetNextCharWithEofMessageWithoutLoadMore() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("a"); [EOL] assertEquals('a', parser.getNextChar("EOF")); [EOL] try { [EOL] parser.getNextChar("EOF"); [EOL] fail("Should have thrown JsonParseException due to EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testGetNextCharWithoutEofMessageWithoutLoadMore() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("a"); [EOL] assertEquals('a', parser.getNextChar(null)); [EOL] try { [EOL] parser.getNextChar(null); [EOL] fail("Should have thrown JsonParseException due to EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testGetText2WithNullToken() { [EOL] String result = _getText2(null); [EOL] assertNull(result); [EOL] }
public void testGetText2WithFieldNameToken() { [EOL] JsonToken token = JsonToken.FIELD_NAME; [EOL] when(_parsingContext.getCurrentName()).thenReturn("fieldName"); [EOL] String result = _getText2(token); [EOL] assertEquals("fieldName", result); [EOL] }
public void testGetText2WithValueStringToken() { [EOL] JsonToken token = JsonToken.VALUE_STRING; [EOL] when(_textBuffer.contentsAsString()).thenReturn("stringValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("stringValue", result); [EOL] }
public void testGetText2WithValueNumberIntToken() { [EOL] JsonToken token = JsonToken.VALUE_NUMBER_INT; [EOL] when(_textBuffer.contentsAsString()).thenReturn("intValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("intValue", result); [EOL] }
public void testGetText2WithValueNumberFloatToken() { [EOL] JsonToken token = JsonToken.VALUE_NUMBER_FLOAT; [EOL] when(_textBuffer.contentsAsString()).thenReturn("floatValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("floatValue", result); [EOL] }
public void testGetText2WithDefaultToken() { [EOL] for (JsonToken token : JsonToken.values()) { [EOL] if (!EnumSet.of(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_FLOAT).contains(token)) { [EOL] String result = _getText2(token); [EOL] assertEquals(token.asString(), result); [EOL] } [EOL] } [EOL] }
protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL] int outputPtr = 0; [EOL] final int outputEnd = buffer.length - 3; [EOL] int outputCount = 0; [EOL] while (true) { [EOL] char ch; [EOL] do { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++]; [EOL] } while (ch <= INT_SPACE); [EOL] int bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (ch == '"') { [EOL] break; [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 0); [EOL] if (bits < 0) { [EOL] continue; [EOL] } [EOL] } [EOL] if (outputPtr > outputEnd) { [EOL] outputCount += outputPtr; [EOL] out.write(buffer, 0, outputPtr); [EOL] outputPtr = 0; [EOL] } [EOL] int decodedData = bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++]; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] bits = _decodeBase64Escape(b64variant, ch, 1); [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++]; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (ch == '"' && !b64variant.usesPadding()) { [EOL] decodedData >>= 4; [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] break; [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 2); [EOL] } [EOL] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++]; [EOL] if (!b64variant.usesPaddingChar(ch)) { [EOL] throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL] } [EOL] decodedData >>= 4; [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] continue; [EOL] } [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++]; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (ch == '"' && !b64variant.usesPadding()) { [EOL] decodedData >>= 2; [EOL] buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] break; [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 3); [EOL] } [EOL] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL] decodedData >>= 2; [EOL] buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] continue; [EOL] } [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL] buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL] buffer[outputPtr++] = (byte) decodedData; [EOL] } [EOL] _tokenIncomplete = false; [EOL] if (outputPtr > 0) { [EOL] outputCount += outputPtr; [EOL] out.write(buffer, 0, outputPtr); [EOL] } [EOL] return outputCount; [EOL] }
public void testNextTokenWithFieldName() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] JsonToken result = nextToken(); [EOL] }
public void testNextTokenWithIncompleteToken() throws IOException, JsonParseException { [EOL] _tokenIncomplete = true; [EOL] JsonToken result = nextToken(); [EOL] }
public void testNextTokenAtEndOfInput() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(-1); [EOL] JsonToken result = nextToken(); [EOL] assertNull(result); [EOL] }
public void testNextTokenWithRightBracket() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_RBRACKET); [EOL] when(_parsingContext.inArray()).thenReturn(true); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_ARRAY, result); [EOL] }
public void testNextTokenWithRightCurly() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_RCURLY); [EOL] when(_parsingContext.inObject()).thenReturn(true); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, result); [EOL] }
public void testNextTokenExpectComma() throws IOException, JsonParseException { [EOL] when(_parsingContext.expectComma()).thenReturn(true); [EOL] when(_skipWS()).thenReturn(INT_COMMA); [EOL] JsonToken result = nextToken(); [EOL] }
public void testNextTokenInObject() throws IOException, JsonParseException { [EOL] when(_parsingContext.inObject()).thenReturn(true); [EOL] when(_skipWS()).thenReturn(INT_COLON); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithValueString() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_QUOTE); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] assertTrue(_tokenIncomplete); [EOL] }
public void testNextTokenWithStartArray() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_LBRACKET); [EOL] when(_parsingContext.inObject()).thenReturn(false); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] }
public void testNextTokenWithStartObject() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_LCURLY); [EOL] when(_parsingContext.inObject()).thenReturn(false); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testNextTokenWithUnexpectedChar() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_RBRACKET); [EOL] when(_parsingContext.inObject()).thenReturn(false); [EOL] assertThrows(JsonParseException.class, () -> nextToken()); [EOL] }
public void testNextTokenWithTrueValue() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_t); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_TRUE, result); [EOL] }
public void testNextTokenWithFalseValue() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_f); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_FALSE, result); [EOL] }
public void testNextTokenWithNullValue() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_n); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_NULL, result); [EOL] }
public void testNextTokenWithNumber() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_0); [EOL] JsonToken result = nextToken(); [EOL] }
public void testNextTokenWithUnexpectedValue() throws IOException, JsonParseException { [EOL] when(_skipWSOrEnd()).thenReturn(INT_ASTERISK); // Assuming INT_ASTERISK is an unexpected character [EOL] JsonToken result = nextToken(); [EOL] }
public void testNextAfterNameWithStartArray() { [EOL] _nextToken = JsonToken.START_ARRAY; [EOL] _tokenInputRow = 1; // example row [EOL] _tokenInputCol = 1; // example column [EOL] JsonToken result = _nextAfterName(); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] assertFalse(_nameCopied); [EOL] assertNull(_nextToken); [EOL] }
public void testNextAfterNameWithStartObject() { [EOL] _nextToken = JsonToken.START_OBJECT; [EOL] _tokenInputRow = 1; // example row [EOL] _tokenInputCol = 1; // example column [EOL] JsonToken result = _nextAfterName(); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] assertFalse(_nameCopied); [EOL] assertNull(_nextToken); [EOL] }
public void testNextAfterNameWithOtherToken() { [EOL] _nextToken = JsonToken.VALUE_STRING; // example token that is neither START_ARRAY nor START_OBJECT [EOL] _tokenInputRow = 1; // example row [EOL] _tokenInputCol = 1; // example column [EOL] JsonToken result = _nextAfterName(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] assertFalse(_nameCopied); [EOL] assertNull(_nextToken); [EOL] }
protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException { [EOL] boolean negative = (ch == INT_MINUS); [EOL] int ptr = _inputPtr; [EOL] int startPtr = ptr - 1; [EOL] final int inputLen = _inputEnd; [EOL] dummy_loop: do { [EOL] if (negative) { [EOL] if (ptr >= _inputEnd) { [EOL] break dummy_loop; [EOL] } [EOL] ch = _inputBuffer[ptr++]; [EOL] if (ch > INT_9 || ch < INT_0) { [EOL] _inputPtr = ptr; [EOL] return _handleInvalidNumberStart(ch, true); [EOL] } [EOL] } [EOL] if (ch == INT_0) { [EOL] break dummy_loop; [EOL] } [EOL] int intLen = 1; [EOL] int_loop: while (true) { [EOL] if (ptr >= _inputEnd) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch < INT_0 || ch > INT_9) { [EOL] break int_loop; [EOL] } [EOL] ++intLen; [EOL] } [EOL] int fractLen = 0; [EOL] if (ch == INT_DECIMAL_POINT) { [EOL] fract_loop: while (true) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch < INT_0 || ch > INT_9) { [EOL] break fract_loop; [EOL] } [EOL] ++fractLen; [EOL] } [EOL] if (fractLen == 0) { [EOL] reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); [EOL] } [EOL] } [EOL] int expLen = 0; [EOL] if (ch == INT_e || ch == INT_E) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch == INT_MINUS || ch == INT_PLUS) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] } [EOL] while (ch <= INT_9 && ch >= INT_0) { [EOL] ++expLen; [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] } [EOL] if (expLen == 0) { [EOL] reportUnexpectedNumberChar(ch, "Exponent indicator not followed by a digit"); [EOL] } [EOL] } [EOL] --ptr; [EOL] _inputPtr = ptr; [EOL] int len = ptr - startPtr; [EOL] _textBuffer.resetWithShared(_inputBuffer, startPtr, len); [EOL] return reset(negative, intLen, fractLen, expLen); [EOL] } while (false); [EOL] _inputPtr = negative ? (startPtr + 1) : startPtr; [EOL] return parseNumberText2(negative); [EOL] }
public void testParseNumberText2Negative() throws IOException, JsonParseException { [EOL] boolean negative = true; [EOL] JsonToken result = parseNumberText2(negative); [EOL] } [EOL] public void testParseNumberText2NonNegative() throws IOException, JsonParseException { [EOL] boolean negative = false; [EOL] JsonToken result = parseNumberText2(negative); [EOL] } [EOL] public void testParseNumberText2LeadingZero() throws IOException, JsonParseException { [EOL] boolean negative = false; [EOL] JsonToken result = parseNumberText2(negative); [EOL] } [EOL] public void testParseNumberText2NoIntegerPart() throws IOException, JsonParseException { [EOL] boolean negative = false; [EOL] try { [EOL] JsonToken result = parseNumberText2(negative); [EOL] fail("Should have thrown JsonParseException due to missing integer part"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testParseNumberText2WithFraction() throws IOException, JsonParseException { [EOL] boolean negative = false; [EOL] JsonToken result = parseNumberText2(negative); [EOL] } [EOL] public void testParseNumberText2WithExponent() throws IOException, JsonParseException { [EOL] boolean negative = false; [EOL] JsonToken result = parseNumberText2(negative); [EOL] } [EOL] public void testParseNumberText2WithInvalidExponent() throws IOException, JsonParseException { [EOL] boolean negative = false; [EOL] try { [EOL] JsonToken result = parseNumberText2(negative); [EOL] fail("Should have thrown JsonParseException due to invalid exponent"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testParseNumberText2EndOfFile() throws IOException, JsonParseException { [EOL] boolean negative = false; [EOL] JsonToken result = parseNumberText2(negative); [EOL] }
public void testVerifyNoLeadingZeroesInputPtrAtEndNoLoadMore() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; // Assuming _inputPtr and _inputEnd are class members [EOL] when(loadMore()).thenReturn(false); // Assuming loadMore() can be mocked [EOL] char result = _verifyNoLeadingZeroes(); [EOL] assertEquals('0', result); [EOL] }
public void testVerifyNoLeadingZeroesNonDigitChar() throws IOException, JsonParseException { [EOL] _inputPtr = 0; // Assuming _inputPtr is a class member [EOL] _inputBuffer = new char[]{'a'}; // Assuming _inputBuffer is a class member [EOL] _inputEnd = 1; // Assuming _inputEnd is a class member [EOL] char result = _verifyNoLeadingZeroes(); [EOL] assertEquals('0', result); [EOL] }
public void testVerifyNoLeadingZeroesLeadingZeroesNotAllowed() throws IOException, JsonParseException { [EOL] _inputPtr = 0; // Assuming _inputPtr is a class member [EOL] _inputBuffer = new char[]{'0'}; // Assuming _inputBuffer is a class member [EOL] _inputEnd = 1; // Assuming _inputEnd is a class member [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(false); // Assuming isEnabled can be mocked [EOL] assertThrows(JsonParseException.class, () -> _verifyNoLeadingZeroes()); [EOL] }
public void testVerifyNoLeadingZeroesLeadingZeroesAllowed() throws IOException, JsonParseException { [EOL] _inputPtr = 0; // Assuming _inputPtr is a class member [EOL] _inputBuffer = new char[]{'0', '1'}; // Assuming _inputBuffer is a class member [EOL] _inputEnd = 2; // Assuming _inputEnd is a class member [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(true); // Assuming isEnabled can be mocked [EOL] char result = _verifyNoLeadingZeroes(); [EOL] assertEquals('1', result); [EOL] }
public void testVerifyNoLeadingZeroesLeadingZeroesAllowedWithLoadMore() throws IOException, JsonParseException { [EOL] _inputPtr = 0; // Assuming _inputPtr is a class member [EOL] _inputBuffer = new char[]{'0'}; // Assuming _inputBuffer is a class member [EOL] _inputEnd = 1; // Assuming _inputEnd is a class member [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(true); // Assuming isEnabled can be mocked [EOL] when(loadMore()).thenReturn(true).thenReturn(false); // Assuming loadMore() can be mocked [EOL] when(_inputBuffer).thenReturn(new char[]{'0', '2'}); // Assuming _inputBuffer can be mocked [EOL] char result = _verifyNoLeadingZeroes(); [EOL] assertEquals('2', result); [EOL] }
public void testHandleUnexpectedValueWithApostrophe() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithFeatureEnabled(Feature.ALLOW_SINGLE_QUOTES); [EOL] assertEquals(JsonToken.VALUE_STRING, jp._handleUnexpectedValue('\'')); [EOL] }
public void testHandleUnexpectedValueWithN() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp._handleUnexpectedValue('N')); [EOL] }
public void testHandleUnexpectedValueWithNWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] jp._handleUnexpectedValue('N'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithI() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp._handleUnexpectedValue('I')); [EOL] }
public void testHandleUnexpectedValueWithIWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] jp._handleUnexpectedValue('I'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithPlus() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithInput("+"); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, jp._handleUnexpectedValue('+')); [EOL] }
public void testHandleUnexpectedValueWithJavaIdentifierStart() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithInput("a"); [EOL] try { [EOL] jp._handleUnexpectedValue('a'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithInvalidChar() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithInput("@"); [EOL] try { [EOL] jp._handleUnexpectedValue('@'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipStringWithClosingQuote() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 5; [EOL] _inputBuffer = new char[]{'"', 't', 'e', 's', 't', '"'}; [EOL] _skipString(); [EOL] assertEquals(6, _inputPtr); [EOL] }
public void testSkipStringWithoutClosingQuote() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new char[]{'"', 't', 'e', 's', 't'}; [EOL] try { [EOL] _skipString(); [EOL] fail("Should throw JsonParseException due to missing closing quote"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipStringWithBackslash() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 7; [EOL] _inputBuffer = new char[]{'"', 't', '\\', 'n', 'e', 's', 't', '"'}; [EOL] _skipString(); [EOL] assertEquals(8, _inputPtr); [EOL] }
public void testSkipStringWithUnquotedSpace() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 6; [EOL] _inputBuffer = new char[]{'"', 't', 'e', 's', 't', '\n'}; [EOL] try { [EOL] _skipString(); [EOL] fail("Should throw JsonParseException due to unquoted space"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCRWithCRFollowedByLF() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new char[] {'\r', '\n'}; [EOL] _currInputRow = 1; [EOL] _currInputRowStart = 0; [EOL] _skipCR(); [EOL] assertEquals("Pointer should move past CR and LF", 2, _inputPtr); [EOL] assertEquals("Row should increment", 2, _currInputRow); [EOL] assertEquals("Row start should be updated to pointer position", 2, _currInputRowStart); [EOL] }
public void testSkipCRWithCRNotFollowedByLF() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[] {'\r'}; [EOL] _currInputRow = 1; [EOL] _currInputRowStart = 0; [EOL] _skipCR(); [EOL] assertEquals("Pointer should move past CR", 1, _inputPtr); [EOL] assertEquals("Row should increment", 2, _currInputRow); [EOL] assertEquals("Row start should be updated to pointer position", 1, _currInputRowStart); [EOL] }
public void testSkipCRWithoutCR() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[] {'\n'}; [EOL] _currInputRow = 1; [EOL] _currInputRowStart = 0; [EOL] _skipCR(); [EOL] assertEquals("Pointer should not move", 0, _inputPtr); [EOL] assertEquals("Row should increment", 2, _currInputRow); [EOL] assertEquals("Row start should be updated to pointer position", 0, _currInputRowStart); [EOL] }
public void testSkipCRWithLoadMore() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // simulate buffer end [EOL] _inputBuffer = new char[] {'\r', '\n'}; [EOL] _currInputRow = 1; [EOL] _currInputRowStart = 0; [EOL] when(loadMore()).thenReturn(true); [EOL] _inputEnd = 2; // pretend more data was loaded [EOL] _skipCR(); [EOL] assertEquals("Pointer should move past CR and LF after loading more", 2, _inputPtr); [EOL] assertEquals("Row should increment after loading more", 2, _currInputRow); [EOL] assertEquals("Row start should be updated to pointer position after loading more", 2, _currInputRowStart); [EOL] }
public void testSkipWSWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = 'a'; // 'a' is greater than INT_SPACE [EOL] int result = _skipWS(); [EOL] assertEquals('a', result); [EOL] }
public void testSkipWSWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '/'; // INT_SLASH [EOL] _skipWS(); [EOL] }
public void testSkipWSWithSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = ' '; // INT_SPACE [EOL] int result = _skipWS(); [EOL] assertEquals(_inputBuffer[_inputPtr], result); [EOL] }
public void testSkipWSWithLF() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\n'; // INT_LF [EOL] _skipWS(); [EOL] }
public void testSkipWSWithCR() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\r'; // INT_CR [EOL] _skipWS(); [EOL] }
public void testSkipWSWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\t'; // INT_TAB [EOL] int result = _skipWS(); [EOL] assertEquals(_inputBuffer[_inputPtr], result); [EOL] }
public void testSkipWSWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\b'; // Some invalid space character [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to invalid space character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithEndOfInput() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; [EOL] try { [EOL] _skipWS(); [EOL] fail("Should have thrown JsonParseException due to unexpected end-of-input"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = 'a'; // 'a' is greater than INT_SPACE [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals('a', result); [EOL] } [EOL] public void testSkipWSOrEndWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '/'; // INT_SLASH [EOL] _skipComment(); [EOL] int result = _skipWSOrEnd(); [EOL] assertTrue(result > INT_SPACE); [EOL] } [EOL] public void testSkipWSOrEndWithSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = ' '; // INT_SPACE [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming loadMore() returns false and _handleEOF() does not throw [EOL] } [EOL] public void testSkipWSOrEndWithNewLine() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\n'; // INT_LF [EOL] _skipLF(); [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming loadMore() returns false and _handleEOF() does not throw [EOL] } [EOL] public void testSkipWSOrEndWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\r'; // INT_CR [EOL] _skipCR(); [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming loadMore() returns false and _handleEOF() does not throw [EOL] } [EOL] public void testSkipWSOrEndWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\t'; // INT_TAB [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming loadMore() returns false and _handleEOF() does not throw [EOL] } [EOL] public void testSkipWSOrEndWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\u0000'; // An invalid space character [EOL] try { [EOL] _skipWSOrEnd(); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testSkipWSOrEndAtEndOfBuffer() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // _handleEOF() should be called and return -1 [EOL] }

public void testSkipCommentWithCommentsDisabled() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCommentAtEndOfFile() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserAtEndOfFile(); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for end of file"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCommentWithCppStyle() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithCppStyleComment(); [EOL] parser._skipComment(); [EOL] }
public void testSkipCommentWithCStyle() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithCStyleComment(); [EOL] parser._skipComment(); [EOL] }
public void testSkipCommentWithInvalidChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInvalidChar(); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for invalid character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeEscapedInputPtrAtOrBeyondInputEndAndLoadMoreFails() throws IOException { [EOL] try { [EOL] _decodeEscaped(); [EOL] fail("Expected an IOException due to end of input"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDecodeEscapedWithValidEscapeCharacters() throws IOException { [EOL] _inputBuffer = new char[] {'b', 't', 'n', 'f', 'r', '"', '/', '\\'}; [EOL] _inputEnd = _inputBuffer.length; [EOL] _inputPtr = 0; [EOL] assertEquals('\b', _decodeEscaped()); [EOL] assertEquals('\t', _decodeEscaped()); [EOL] assertEquals('\n', _decodeEscaped()); [EOL] assertEquals('\f', _decodeEscaped()); [EOL] assertEquals('\r', _decodeEscaped()); [EOL] assertEquals('"', _decodeEscaped()); [EOL] assertEquals('/', _decodeEscaped()); [EOL] assertEquals('\\', _decodeEscaped()); [EOL] }
public void testDecodeEscapedWithUnrecognizedCharacter() throws IOException { [EOL] _inputBuffer = new char[] {'x'}; [EOL] _inputEnd = _inputBuffer.length; [EOL] _inputPtr = 0; [EOL] char result = _decodeEscaped(); [EOL] }
public void testDecodeEscapedWithUnicodeSequence() throws IOException { [EOL] _inputBuffer = new char[] {'u', '0', '0', '2', '0'}; [EOL] _inputEnd = _inputBuffer.length; [EOL] _inputPtr = 0; [EOL] assertEquals(' ', _decodeEscaped()); [EOL] }
public void testDecodeEscapedWithInvalidHexDigitInUnicodeSequence() throws IOException { [EOL] _inputBuffer = new char[] {'u', '0', '0', 'G', '0'}; [EOL] _inputEnd = _inputBuffer.length; [EOL] _inputPtr = 0; [EOL] try { [EOL] _decodeEscaped(); [EOL] fail("Expected an IOException due to invalid hex digit in unicode escape sequence"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL] final int len = matchStr.length(); [EOL] do { [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidToken(matchStr.substring(0, i)); [EOL] } [EOL] } [EOL] if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { [EOL] _reportInvalidToken(matchStr.substring(0, i)); [EOL] } [EOL] ++_inputPtr; [EOL] } while (++i < len); [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] return; [EOL] } [EOL] } [EOL] char c = _inputBuffer[_inputPtr]; [EOL] if (c < '0' || c == ']' || c == '}') { [EOL] return; [EOL] } [EOL] if (Character.isJavaIdentifierPart(c)) { [EOL] _reportInvalidToken(matchStr.substring(0, i)); [EOL] } [EOL] return; [EOL] }
protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException { [EOL] _reportInvalidToken(matchedPart, "'null', 'true', 'false' or NaN"); [EOL] }
public void testReportInvalidTokenWithEmptyMatchedPartAndNoMoreInput() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithEmptyBuffer(); [EOL] try { [EOL] parser._reportInvalidToken("", "expected error message"); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertTrue(e.getMessage().contains("Unrecognized token '': was expecting ")); [EOL] } [EOL] }
public void testReportInvalidTokenWithPartialMatchedPartAndNoMoreInput() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithPartialBuffer("partial"); [EOL] try { [EOL] parser._reportInvalidToken("partial", "expected error message"); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertTrue(e.getMessage().contains("Unrecognized token 'partial': was expecting ")); [EOL] } [EOL] }
public void testReportInvalidTokenWithMatchedPartAndAdditionalInput() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithBuffer("matchedPart123"); [EOL] parser._inputPtr = 11; // Set pointer to simulate partially read input [EOL] try { [EOL] parser._reportInvalidToken("matchedPart", "expected error message"); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertTrue(e.getMessage().contains("Unrecognized token 'matchedPart1': was expecting ")); [EOL] } [EOL] }
public void testInternCacheInstantiation() { [EOL] Constructor<InternCache> constructor = InternCache.class.getDeclaredConstructor(); [EOL] constructor.setAccessible(true); [EOL] InternCache cache = constructor.newInstance(); [EOL] }
public void testRemoveEldestEntry_ShouldReturnFalse_WhenSizeNotExceedingMaxEntries() { [EOL] LruCache cache = new LruCache(MAX_ENTRIES); [EOL] for (int i = 0; i < MAX_ENTRIES; i++) { [EOL] cache.put("key" + i, "value" + i); [EOL] } [EOL] Map.Entry<String, String> eldest = cache.entrySet().iterator().next(); [EOL] boolean result = cache.removeEldestEntry(eldest); [EOL] assertFalse(result); [EOL] }
public void testRemoveEldestEntry_ShouldReturnTrue_WhenSizeExceedingMaxEntries() { [EOL] LruCache cache = new LruCache(MAX_ENTRIES); [EOL] for (int i = 0; i <= MAX_ENTRIES; i++) { [EOL] cache.put("key" + i, "value" + i); [EOL] } [EOL] Map.Entry<String, String> eldest = cache.entrySet().iterator().next(); [EOL] boolean result = cache.removeEldestEntry(eldest); [EOL] assertTrue(result); [EOL] }
public void testInternWithNewString() { [EOL] String input = new String("test"); [EOL] String result = intern(input); [EOL] assertSame("Expected the same reference for interned string", result, input); [EOL] }
public void testInternWithExistingString() { [EOL] String input = new String("test"); [EOL] intern(input); // Intern the string first time [EOL] String secondInput = new String("test"); [EOL] String result = intern(secondInput); [EOL] assertSame("Expected the same reference for already interned string", result, input); [EOL] }
public void testWriteStartArrayWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithPrettyPrinter(); [EOL] generator.writeStartArray(); [EOL] } [EOL] public void testWriteStartArrayWithoutPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithoutPrettyPrinter(); [EOL] generator.writeStartArray(); [EOL] } [EOL] public void testWriteStartArrayWithOutputTailAtEnd() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithOutputTailAtEnd(); [EOL] generator.writeStartArray(); [EOL] }
public void testWriteEndArrayNotInArrayContext() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] setWriteContextNotInArray(generator); [EOL] try { [EOL] generator.writeEndArray(); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testWriteEndArrayWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] setPrettyPrinter(generator); [EOL] enterArrayContext(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue(prettyPrinterWriteEndArrayCalled(generator)); [EOL] }
public void testWriteEndArrayWithoutPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] assertNull(generator.getPrettyPrinter()); [EOL] enterArrayContext(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue(outputBufferEndsWithBracket(generator)); [EOL] }
public void testWriteEndArrayFlushBuffer() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] assertNull(generator.getPrettyPrinter()); [EOL] enterArrayContext(generator); [EOL] fillOutputBuffer(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue(outputBufferFlushedAndEndsWithBracket(generator)); [EOL] }
public void testWriteStringWithNullText() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator.writeString(null); [EOL] } [EOL] public void testWriteStringWithEmptyText() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator.writeString(""); [EOL] } [EOL] public void testWriteStringWithNonEmptyText() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator.writeString("text"); [EOL] } [EOL] public void testWriteStringRequiresFlush() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator._outputTail = generator._outputEnd; [EOL] generator.writeString("text"); [EOL] }
public void testWriteRawWithEnoughRoom() throws IOException { [EOL] String text = "text"; [EOL] _outputEnd = 10; [EOL] _outputTail = 0; [EOL] _outputBuffer = new char[_outputEnd]; [EOL] writeRaw(text); [EOL] assertEquals(4, _outputTail); // Check if _outputTail is incremented by text length [EOL] assertEquals('t', _outputBuffer[0]); // Check the first character [EOL] assertEquals('e', _outputBuffer[1]); // Check the second character [EOL] assertEquals('x', _outputBuffer[2]); // Check the third character [EOL] assertEquals('t', _outputBuffer[3]); // Check the fourth character [EOL] }
public void testWriteRawWithExactRoom() throws IOException { [EOL] String text = "text"; [EOL] _outputEnd = 4; [EOL] _outputTail = 0; [EOL] _outputBuffer = new char[_outputEnd]; [EOL] writeRaw(text); [EOL] assertEquals(4, _outputTail); // Check if _outputTail is incremented by text length [EOL] assertEquals('t', _outputBuffer[0]); // Check the first character [EOL] assertEquals('e', _outputBuffer[1]); // Check the second character [EOL] assertEquals('x', _outputBuffer[2]); // Check the third character [EOL] assertEquals('t', _outputBuffer[3]); // Check the fourth character [EOL] }
public void testWriteRawWithInsufficientRoomBeforeFlush() throws IOException { [EOL] String text = "text"; [EOL] _outputEnd = 10; [EOL] _outputTail = 10; // No room [EOL] _outputBuffer = new char[_outputEnd]; [EOL] writeRaw(text); [EOL] }
public void testWriteRawWithInsufficientRoomAfterFlush() throws IOException { [EOL] String text = "text"; [EOL] _outputEnd = 3; [EOL] _outputTail = 3; // No room, will require flush [EOL] _outputBuffer = new char[_outputEnd]; [EOL] writeRaw(text); [EOL] }
public void testWriteRawWithBufferSpace() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedBuffer(); [EOL] char testChar = 'a'; [EOL] generator._outputTail = 0; [EOL] generator._outputEnd = 10; [EOL] generator.writeRaw(testChar); [EOL] assertEquals(testChar, generator._outputBuffer[generator._outputTail - 1]); [EOL] } [EOL] public void testWriteRawWithBufferFlush() throws IOException, JsonGenerationException { [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedBuffer(); [EOL] char testChar = 'b'; [EOL] generator._outputTail = 10; [EOL] generator._outputEnd = 10; [EOL] generator.writeRaw(testChar); [EOL] assertEquals(testChar, generator._outputBuffer[generator._outputTail - 1]); [EOL] }
public void testWriteBinaryWithNegativeDataLength() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] InputStream data = new ByteArrayInputStream(new byte[0]); [EOL] int dataLength = -1; [EOL] int bytes = writeBinary(b64variant, data, dataLength); [EOL] assertEquals("The number of bytes written should be correct", expectedBytes, bytes); [EOL] }
public void testWriteBinaryWithExactDataLength() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] InputStream data = new ByteArrayInputStream(new byte[10]); [EOL] int dataLength = 10; [EOL] int bytes = writeBinary(b64variant, data, dataLength); [EOL] assertEquals("The number of bytes written should be equal to dataLength", dataLength, bytes); [EOL] }
public void testWriteBinaryWithInsufficientData() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] InputStream data = new ByteArrayInputStream(new byte[5]); [EOL] int dataLength = 10; [EOL] try { [EOL] writeBinary(b64variant, data, dataLength); [EOL] fail("Should have thrown JsonGenerationException due to insufficient data"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testWriteBinaryWithBufferFlush() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] InputStream data = new ByteArrayInputStream(new byte[10]); [EOL] int dataLength = 10; [EOL] _outputTail = _outputEnd; [EOL] int bytes = writeBinary(b64variant, data, dataLength); [EOL] assertTrue("Buffer should have been flushed", conditionToCheckBufferFlushed); [EOL] }
public void testWriteNumberWithNullValue() throws IOException { [EOL] JsonGenerator gen = createGenerator(); // Assuming createGenerator() is a method that creates a JsonGenerator instance [EOL] gen.writeNumber((BigDecimal) null); [EOL] } [EOL] public void testWriteNumberWithNumbersAsStringsEnabled() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] enableNumbersAsStrings(gen); // Assuming enableNumbersAsStrings() is a method that sets _cfgNumbersAsStrings to true [EOL] gen.writeNumber(new BigDecimal("123.456")); [EOL] } [EOL] public void testWriteNumberWithBigDecimalAsPlain() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] enableFeature(gen, Feature.WRITE_BIGDECIMAL_AS_PLAIN); // Assuming enableFeature() is a method that enables a specific feature [EOL] gen.writeNumber(new BigDecimal("123.456")); [EOL] } [EOL] public void testWriteNumberWithDefaultBehavior() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] disableFeature(gen, Feature.WRITE_BIGDECIMAL_AS_PLAIN); // Assuming disableFeature() is a method that disables a specific feature [EOL] gen.writeNumber(new BigDecimal("123.456")); [EOL] }
public void testVerifyValueWriteExpectingFieldName() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assume this method properly creates a JsonGeneratorImpl instance [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up context to expect a name [EOL] try { [EOL] generator._verifyValueWrite("start an array"); [EOL] fail("Should throw JsonGenerationException due to expecting a field name"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testVerifyValueWriteAfterComma() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assume this method properly creates a JsonGeneratorImpl instance [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up context [EOL] generator._writeContext.writeValue(); // Change context state to STATUS_OK_AFTER_COMMA [EOL] generator._verifyValueWrite("start an object"); [EOL] assertEquals(',', generator._outputBuffer[generator._outputTail - 1]); [EOL] }
public void testVerifyValueWriteAfterColon() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assume this method properly creates a JsonGeneratorImpl instance [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up context [EOL] generator._writeContext.writeValue(); // Change context state to STATUS_OK_AFTER_COLON [EOL] generator._verifyValueWrite("write a value"); [EOL] assertEquals(':', generator._outputBuffer[generator._outputTail - 1]); [EOL] }
public void testVerifyValueWriteAfterSpaceWithRootValueSeparator() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assume this method properly creates a JsonGeneratorImpl instance [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up context [EOL] generator._writeContext.writeValue(); // Change context state to STATUS_OK_AFTER_SPACE [EOL] generator._rootValueSeparator = new SerializedString(" "); // Set a root value separator [EOL] generator._verifyValueWrite("write a value"); [EOL] assertTrue(new String(generator._outputBuffer, generator._outputTail - 1, 1).contains(" ")); [EOL] }
public void testVerifyValueWriteAfterSpaceWithoutRootValueSeparator() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assume this method properly creates a JsonGeneratorImpl instance [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up context [EOL] generator._writeContext.writeValue(); // Change context state to STATUS_OK_AFTER_SPACE [EOL] generator._rootValueSeparator = null; // No root value separator [EOL] generator._verifyValueWrite("write a value"); [EOL] }
public void testVerifyValueWriteAsIs() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assume this method properly creates a JsonGeneratorImpl instance [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up context [EOL] generator._writeContext.writeValue(); // Change context state to STATUS_OK_AS_IS [EOL] generator._verifyValueWrite("write a value"); [EOL] }
public void testVerifyValueWriteWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assume this method properly creates a JsonGeneratorImpl instance [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up context [EOL] generator._cfgPrettyPrinter = mock(PrettyPrinter.class); // Assume mock creates a mock PrettyPrinter instance [EOL] generator._verifyValueWrite("write a value"); [EOL] verify(generator._cfgPrettyPrinter).writeValueSeparator(generator); [EOL] }
public void testVerifyPrettyValueWriteAfterComma() throws IOException, JsonGenerationException { [EOL] _verifyPrettyValueWrite("after comma", JsonWriteContext.STATUS_OK_AFTER_COMMA); [EOL] }
public void testVerifyPrettyValueWriteAfterColon() throws IOException, JsonGenerationException { [EOL] _verifyPrettyValueWrite("after colon", JsonWriteContext.STATUS_OK_AFTER_COLON); [EOL] }
public void testVerifyPrettyValueWriteAfterSpace() throws IOException, JsonGenerationException { [EOL] _verifyPrettyValueWrite("after space", JsonWriteContext.STATUS_OK_AFTER_SPACE); [EOL] }
public void testVerifyPrettyValueWriteAsIsInArray() throws IOException, JsonGenerationException { [EOL] _verifyPrettyValueWrite("as is in array", JsonWriteContext.STATUS_OK_AS_IS); [EOL] }
public void testVerifyPrettyValueWriteAsIsInObject() throws IOException, JsonGenerationException { [EOL] _verifyPrettyValueWrite("as is in object", JsonWriteContext.STATUS_OK_AS_IS); [EOL] }
public void testVerifyPrettyValueWriteDefault() throws IOException, JsonGenerationException { [EOL] _verifyPrettyValueWrite("default", -1); [EOL] }
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { [EOL] int inputPtr = 0; [EOL] int inputEnd = 0; [EOL] int lastFullOffset = -3; [EOL] int safeOutputEnd = _outputEnd - 6; [EOL] int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL] while (bytesLeft > 2) { [EOL] if (inputPtr > lastFullOffset) { [EOL] inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL] inputPtr = 0; [EOL] if (inputEnd < 3) { [EOL] break; [EOL] } [EOL] lastFullOffset = inputEnd - 3; [EOL] } [EOL] if (_outputTail > safeOutputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL] b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL] b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL] bytesLeft -= 3; [EOL] _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL] if (--chunksBeforeLF <= 0) { [EOL] _outputBuffer[_outputTail++] = '\\'; [EOL] _outputBuffer[_outputTail++] = 'n'; [EOL] chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL] } [EOL] } [EOL] if (bytesLeft > 0) { [EOL] inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL] inputPtr = 0; [EOL] if (inputEnd > 0) { [EOL] if (_outputTail > safeOutputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL] int amount; [EOL] if (inputPtr < inputEnd) { [EOL] b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL] amount = 2; [EOL] } else { [EOL] amount = 1; [EOL] } [EOL] _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL] bytesLeft -= amount; [EOL] } [EOL] } [EOL] return bytesLeft; [EOL] }
public void testWriteBinaryWithEmptyInputStream() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] InputStream data = new ByteArrayInputStream(new byte[0]); [EOL] byte[] readBuffer = new byte[1024]; [EOL] int bytesWritten = _writeBinary(b64variant, data, readBuffer); [EOL] assertEquals(0, bytesWritten); [EOL] } [EOL] public void testWriteBinaryWithNonEmptyInputStreamAndNoFlush() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] inputData = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; [EOL] InputStream data = new ByteArrayInputStream(inputData); [EOL] byte[] readBuffer = new byte[1024]; [EOL] int bytesWritten = _writeBinary(b64variant, data, readBuffer); [EOL] assertEquals(inputData.length, bytesWritten); [EOL] } [EOL] public void testWriteBinaryWithNonEmptyInputStreamAndFlush() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] inputData = new byte[2048]; [EOL] new Random().nextBytes(inputData); [EOL] InputStream data = new ByteArrayInputStream(inputData); [EOL] byte[] readBuffer = new byte[1024]; [EOL] int bytesWritten = _writeBinary(b64variant, data, readBuffer); [EOL] assertEquals(inputData.length, bytesWritten); [EOL] } [EOL] public void testWriteBinaryWithInputStreamRequiringMultipleReads() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] inputData = new byte[5000]; [EOL] new Random().nextBytes(inputData); [EOL] InputStream data = new ByteArrayInputStream(inputData); [EOL] byte[] readBuffer = new byte[1024]; [EOL] int bytesWritten = _writeBinary(b64variant, data, readBuffer); [EOL] assertEquals(inputData.length, bytesWritten); [EOL] } [EOL] public void testWriteBinaryWithInputStreamRequiringPartialEncoding() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] inputData = {1, 2}; // Only 2 bytes, should trigger partial encoding [EOL] InputStream data = new ByteArrayInputStream(inputData); [EOL] byte[] readBuffer = new byte[1024]; [EOL] int bytesWritten = _writeBinary(b64variant, data, readBuffer); [EOL] assertEquals(inputData.length, bytesWritten); [EOL] }
public void testReadMoreWithEmptyBuffer() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] byte[] readBuffer = new byte[10]; [EOL] int inputPtr = 0; [EOL] int inputEnd = 0; [EOL] int maxRead = 10; [EOL] int result = _readMore(in, readBuffer, inputPtr, inputEnd, maxRead); [EOL] assertEquals(0, result); [EOL] }
public void testReadMoreWithPartialBuffer() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5}); [EOL] byte[] readBuffer = new byte[10]; [EOL] int inputPtr = 0; [EOL] int inputEnd = 2; [EOL] int maxRead = 10; [EOL] readBuffer[0] = 9; [EOL] readBuffer[1] = 8; [EOL] int result = _readMore(in, readBuffer, inputPtr, inputEnd, maxRead); [EOL] assertEquals(5, result); [EOL] assertArrayEquals(new byte[]{9, 8, 1, 2, 3, 0, 0, 0, 0, 0}, readBuffer); [EOL] }
public void testReadMoreWithFullBuffer() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5}); [EOL] byte[] readBuffer = new byte[5]; [EOL] int inputPtr = 0; [EOL] int inputEnd = 5; [EOL] int maxRead = 5; [EOL] for (int i = 0; i < inputEnd; i++) { [EOL] readBuffer[i] = (byte) (i + 1); [EOL] } [EOL] int result = _readMore(in, readBuffer, inputPtr, inputEnd, maxRead); [EOL] assertEquals(5, result); [EOL] assertArrayEquals(new byte[]{1, 2, 3, 4, 5}, readBuffer); [EOL] }
public void testReadMoreWithInputStreamEnd() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[]{1, 2}); [EOL] byte[] readBuffer = new byte[10]; [EOL] int inputPtr = 0; [EOL] int inputEnd = 0; [EOL] int maxRead = 10; [EOL] int result = _readMore(in, readBuffer, inputPtr, inputEnd, maxRead); [EOL] assertEquals(2, result); [EOL] assertArrayEquals(new byte[]{1, 2, 0, 0, 0, 0, 0, 0, 0, 0}, readBuffer); [EOL] }
public void testReadMoreWithMaxReadLessThanBufferLength() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}); [EOL] byte[] readBuffer = new byte[10]; [EOL] int inputPtr = 0; [EOL] int inputEnd = 0; [EOL] int maxRead = 5; [EOL] int result = _readMore(in, readBuffer, inputPtr, inputEnd, maxRead); [EOL] assertEquals(5, result); [EOL] assertArrayEquals(new byte[]{1, 2, 3, 4, 5, 0, 0, 0, 0, 0}, readBuffer); [EOL] }
public void testFlushBufferWithNonEmptyBuffer() throws IOException { [EOL] _outputTail = 10; [EOL] _outputHead = 5; [EOL] _outputBuffer = new char[10]; [EOL] _writer = new StringWriter(); [EOL] _flushBuffer(); [EOL] assertEquals("Buffer should be flushed", "", _writer.toString()); [EOL] }
public void testFlushBufferWithEmptyBuffer() throws IOException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[10]; [EOL] _writer = new StringWriter(); [EOL] _flushBuffer(); [EOL] assertEquals("Buffer should be empty", "", _writer.toString()); [EOL] }
public void testEncodeAsUTF8WithEmptyString() { [EOL] String text = ""; [EOL] byte[] result = encodeAsUTF8(text); [EOL] assertEquals(0, result.length); [EOL] }
public void testEncodeAsUTF8WithAscii() { [EOL] String text = "hello"; [EOL] byte[] result = encodeAsUTF8(text); [EOL] assertEquals(5, result.length); [EOL] assertArrayEquals(new byte[]{104, 101, 108, 108, 111}, result); [EOL] }
public void testEncodeAsUTF8WithExtendedAscii() { [EOL] String text = "h\u00e9llo"; [EOL] byte[] result = encodeAsUTF8(text); [EOL] assertEquals(6, result.length); [EOL] assertArrayEquals(new byte[]{104, (byte) 0xc3, (byte) 0xa9, 108, 108, 111}, result); [EOL] }
public void testEncodeAsUTF8WithSurrogatePairs() { [EOL] String text = ""; [EOL] byte[] result = encodeAsUTF8(text); [EOL] assertEquals(4, result.length); [EOL] assertArrayEquals(new byte[]{(byte) 0xF0, (byte) 0x90, (byte) 0x90, (byte) 0xB7}, result); [EOL] }
public void testEncodeAsUTF8WithIllegalSurrogate() { [EOL] String text = "\uDC00"; // This is a low surrogate without its preceding high surrogate. [EOL] try { [EOL] encodeAsUTF8(text); [EOL] fail("Should have thrown an exception due to illegal surrogate"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriteValueWithObjectExpectingName() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(); [EOL] gen._type = JsonGeneratorImpl.TYPE_OBJECT; [EOL] gen._currentName = null; [EOL] int status = gen.writeValue(); [EOL] assertEquals(JsonGeneratorImpl.STATUS_EXPECT_NAME, status); [EOL] }
public void testWriteValueWithObjectAfterSettingName() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(); [EOL] gen._type = JsonGeneratorImpl.TYPE_OBJECT; [EOL] gen._currentName = "name"; [EOL] int status = gen.writeValue(); [EOL] assertNull(gen._currentName); [EOL] assertEquals(1, gen._index); [EOL] assertEquals(JsonGeneratorImpl.STATUS_OK_AFTER_COLON, status); [EOL] }
public void testWriteValueWithArrayBeforeFirstElement() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(); [EOL] gen._type = JsonGeneratorImpl.TYPE_ARRAY; [EOL] gen._index = -1; [EOL] int status = gen.writeValue(); [EOL] assertEquals(0, gen._index); [EOL] assertEquals(JsonGeneratorImpl.STATUS_OK_AS_IS, status); [EOL] }
public void testWriteValueWithArrayAfterFirstElement() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(); [EOL] gen._type = JsonGeneratorImpl.TYPE_ARRAY; [EOL] gen._index = 0; [EOL] int status = gen.writeValue(); [EOL] assertEquals(1, gen._index); [EOL] assertEquals(JsonGeneratorImpl.STATUS_OK_AFTER_COMMA, status); [EOL] }
public void testWriteValueWithScalarAtStart() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(); [EOL] gen._type = JsonGeneratorImpl.TYPE_SCALAR; [EOL] gen._index = -1; [EOL] int status = gen.writeValue(); [EOL] assertEquals(0, gen._index); [EOL] assertEquals(JsonGeneratorImpl.STATUS_OK_AS_IS, status); [EOL] }
public void testWriteValueWithScalarAfterFirstElement() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(); [EOL] gen._type = JsonGeneratorImpl.TYPE_SCALAR; [EOL] gen._index = 0; [EOL] int status = gen.writeValue(); [EOL] assertEquals(1, gen._index); [EOL] assertEquals(JsonGeneratorImpl.STATUS_OK_AFTER_SPACE, status); [EOL] }
public void testDisableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int initialFeatures = factory._parserFeatures; [EOL] JsonParser.Feature featureToDisable = JsonParser.Feature.AUTO_CLOSE_SOURCE; [EOL] factory.disable(featureToDisable); [EOL] int featuresAfterDisable = factory._parserFeatures; [EOL] int featureMask = featureToDisable.getMask(); [EOL] assertTrue((initialFeatures & featureMask) != 0); [EOL] assertTrue((featuresAfterDisable & featureMask) == 0); [EOL] }
public void testDisableFeatureNoOp() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int initialFeatures = factory._parserFeatures; [EOL] JsonParser.Feature featureAlreadyDisabled = JsonParser.Feature.STRICT_DUPLICATE_DETECTION; [EOL] factory.disable(featureAlreadyDisabled); [EOL] int featuresAfterDisable = factory._parserFeatures; [EOL] assertEquals(initialFeatures, featuresAfterDisable); [EOL] }
public void testSetInputDecoratorWithNonNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] InputDecorator decorator = new InputDecorator() {}; [EOL] JsonFactory result = factory.setInputDecorator(decorator); [EOL] assertNotNull(result); [EOL] assertSame(factory, result); [EOL] assertSame(decorator, result.getInputDecorator()); [EOL] }
public void testSetInputDecoratorWithNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonFactory result = factory.setInputDecorator(null); [EOL] assertNotNull(result); [EOL] assertSame(factory, result); [EOL] assertNull(result.getInputDecorator()); [EOL] }
public void testSetRootValueSeparatorWithNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setRootValueSeparator(null); [EOL] assertNull(factory._rootValueSeparator); [EOL] }
public void testSetRootValueSeparatorWithNonNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setRootValueSeparator(","); [EOL] assertNotNull(factory._rootValueSeparator); [EOL] assertEquals(",", factory._rootValueSeparator.getValue()); [EOL] }
public void testCreateParserWithNullInput() throws IOException, JsonParseException { [EOL] try { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.createParser((InputStream) null); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Input stream can not be null", e.getMessage()); [EOL] } [EOL] }
public void testCreateParserWithNonNullInputAndNoDecorator() throws IOException, JsonParseException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] InputStream mockInputStream = new ByteArrayInputStream("{}".getBytes()); [EOL] JsonParser parser = factory.createParser(mockInputStream); [EOL] assertNotNull(parser); [EOL] assertTrue(parser instanceof JsonParser); [EOL] }
public void testCreateParserWithNonNullInputAndDecorator() throws IOException, JsonParseException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected InputStreamDecorator _inputDecorator() { [EOL] return new InputStreamDecorator() { [EOL] @Override [EOL] public InputStream decorate(IOContext ctxt, InputStream in) throws IOException { [EOL] return new ByteArrayInputStream("{}".getBytes()); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] InputStream mockInputStream = new ByteArrayInputStream("{}".getBytes()); [EOL] JsonParser parser = factory.createParser(mockInputStream); [EOL] assertNotNull(parser); [EOL] assertTrue(parser instanceof JsonParser); [EOL] }
public void testCreateParserWithNullReader() throws IOException { [EOL] try { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.createParser((Reader) null); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCreateParserWithNonNullReaderAndNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] Reader reader = new StringReader("{}"); [EOL] JsonParser parser = factory.createParser(reader); [EOL] assertNotNull(parser); [EOL] assertTrue(parser instanceof ReaderBasedJsonParser); [EOL] }
public void testCreateParserWithNonNullReaderAndDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] Reader reader = new StringReader("{}"); [EOL] InputDecorator decorator = new InputDecorator() { [EOL] @Override [EOL] public Reader decorate(IOContext ctxt, Reader r) { [EOL] return new StringReader("decorated"); [EOL] } [EOL] }; [EOL] factory.setInputDecorator(decorator); [EOL] JsonParser parser = factory.createParser(reader); [EOL] assertNotNull(parser); [EOL] assertTrue(parser instanceof ReaderBasedJsonParser); [EOL] assertEquals("decorated", ((ReaderBasedJsonParser) parser).getText()); [EOL] }
public void testCreateParserWithNullData() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] data = null; [EOL] try { [EOL] factory.createParser(data); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCreateParserWithEmptyData() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] data = new byte[0]; [EOL] JsonParser parser = factory.createParser(data); [EOL] assertNotNull(parser); [EOL] assertEquals(JsonToken.NOT_AVAILABLE, parser.nextToken()); [EOL] }
public void testCreateParserWithNonNullDataNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] data = "test".getBytes(); [EOL] JsonParser parser = factory.createParser(data); [EOL] assertNotNull(parser); [EOL] assertNotEquals(JsonToken.NOT_AVAILABLE, parser.nextToken()); [EOL] }
public void testCreateParserWithNonNullDataWithDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected InputStreamDecorator _inputDecorator() { [EOL] return new InputStreamDecorator() { [EOL] @Override [EOL] public InputStream decorate(IOContext ctxt, byte[] src, int offset, int length) { [EOL] return new ByteArrayInputStream(src, offset, length); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] byte[] data = "test".getBytes(); [EOL] JsonParser parser = factory.createParser(data); [EOL] assertNotNull(parser); [EOL] assertNotEquals(JsonToken.NOT_AVAILABLE, parser.nextToken()); [EOL] }
