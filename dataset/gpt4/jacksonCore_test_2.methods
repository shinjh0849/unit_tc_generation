protected JsonProcessingException(String msg, JsonLocation loc, Throwable rootCause) { [EOL]     super(msg); [EOL]     if (rootCause != null) { [EOL]         initCause(rootCause); [EOL]     } [EOL]     _location = loc; [EOL] }
protected JsonProcessingException(String msg, JsonLocation loc, Throwable rootCause) { [EOL]     super(msg); [EOL]     if (rootCause != null) { [EOL]         initCause(rootCause); [EOL]     } [EOL]     _location = loc; [EOL] }
protected JsonProcessingException(String msg, JsonLocation loc) { [EOL]     this(msg, loc, null); [EOL] }
protected JsonProcessingException(String msg, JsonLocation loc) { [EOL]     this(msg, loc, null); [EOL] }
public JsonLocation getLocation() { [EOL]     return _location; [EOL] }
protected String getMessageSuffix() { [EOL]     return null; [EOL] }
@Override [EOL] public String getMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (msg == null) { [EOL]         msg = "N/A"; [EOL]     } [EOL]     JsonLocation loc = getLocation(); [EOL]     String suffix = getMessageSuffix(); [EOL]     if (loc != null || suffix != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         sb.append(msg); [EOL]         if (suffix != null) { [EOL]             sb.append(suffix); [EOL]         } [EOL]         if (loc != null) { [EOL]             sb.append('\n'); [EOL]             sb.append(" at "); [EOL]             sb.append(loc.toString()); [EOL]         } [EOL]         msg = sb.toString(); [EOL]     } [EOL]     return msg; [EOL] }
@Override [EOL] public String getMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (msg == null) { [EOL]         msg = "N/A"; [EOL]     } [EOL]     JsonLocation loc = getLocation(); [EOL]     String suffix = getMessageSuffix(); [EOL]     if (loc != null || suffix != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         sb.append(msg); [EOL]         if (suffix != null) { [EOL]             sb.append(suffix); [EOL]         } [EOL]         if (loc != null) { [EOL]             sb.append('\n'); [EOL]             sb.append(" at "); [EOL]             sb.append(loc.toString()); [EOL]         } [EOL]         msg = sb.toString(); [EOL]     } [EOL]     return msg; [EOL] }
@Override [EOL] public String getMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (msg == null) { [EOL]         msg = "N/A"; [EOL]     } [EOL]     JsonLocation loc = getLocation(); [EOL]     String suffix = getMessageSuffix(); [EOL]     if (loc != null || suffix != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         sb.append(msg); [EOL]         if (suffix != null) { [EOL]             sb.append(suffix); [EOL]         } [EOL]         if (loc != null) { [EOL]             sb.append('\n'); [EOL]             sb.append(" at "); [EOL]             sb.append(loc.toString()); [EOL]         } [EOL]         msg = sb.toString(); [EOL]     } [EOL]     return msg; [EOL] }
@Override [EOL] public String getMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (msg == null) { [EOL]         msg = "N/A"; [EOL]     } [EOL]     JsonLocation loc = getLocation(); [EOL]     String suffix = getMessageSuffix(); [EOL]     if (loc != null || suffix != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         sb.append(msg); [EOL]         if (suffix != null) { [EOL]             sb.append(suffix); [EOL]         } [EOL]         if (loc != null) { [EOL]             sb.append('\n'); [EOL]             sb.append(" at "); [EOL]             sb.append(loc.toString()); [EOL]         } [EOL]         msg = sb.toString(); [EOL]     } [EOL]     return msg; [EOL] }
@Override [EOL] public String getMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (msg == null) { [EOL]         msg = "N/A"; [EOL]     } [EOL]     JsonLocation loc = getLocation(); [EOL]     String suffix = getMessageSuffix(); [EOL]     if (loc != null || suffix != null) { [EOL]         StringBuilder sb = new StringBuilder(100); [EOL]         sb.append(msg); [EOL]         if (suffix != null) { [EOL]             sb.append(suffix); [EOL]         } [EOL]         if (loc != null) { [EOL]             sb.append('\n'); [EOL]             sb.append(" at "); [EOL]             sb.append(loc.toString()); [EOL]         } [EOL]         msg = sb.toString(); [EOL]     } [EOL]     return msg; [EOL] }
@Override [EOL] public String getCurrentName() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         JsonReadContext parent = _parsingContext.getParent(); [EOL]         return parent.getCurrentName(); [EOL]     } [EOL]     return _parsingContext.getCurrentName(); [EOL] }
@Override [EOL] public String getCurrentName() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         JsonReadContext parent = _parsingContext.getParent(); [EOL]         return parent.getCurrentName(); [EOL]     } [EOL]     return _parsingContext.getCurrentName(); [EOL] }
@Override [EOL] public void overrideCurrentName(String name) { [EOL]     JsonReadContext ctxt = _parsingContext; [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         ctxt = ctxt.getParent(); [EOL]     } [EOL]     ctxt.setCurrentName(name); [EOL] }
@Override [EOL] public void overrideCurrentName(String name) { [EOL]     JsonReadContext ctxt = _parsingContext; [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         ctxt = ctxt.getParent(); [EOL]     } [EOL]     ctxt.setCurrentName(name); [EOL] }
@Override [EOL] public void overrideCurrentName(String name) { [EOL]     JsonReadContext ctxt = _parsingContext; [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         ctxt = ctxt.getParent(); [EOL]     } [EOL]     ctxt.setCurrentName(name); [EOL] }
protected final JsonToken resetAsNaN(String valueStr, double value) { [EOL]     _textBuffer.resetWithString(valueStr); [EOL]     _numberDouble = value; [EOL]     _numTypesValid = NR_DOUBLE; [EOL]     return JsonToken.VALUE_NUMBER_FLOAT; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_DOUBLE); [EOL]         } [EOL]         if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]             convertNumberToDouble(); [EOL]         } [EOL]     } [EOL]     return _numberDouble; [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_DOUBLE); [EOL]         } [EOL]         if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]             convertNumberToDouble(); [EOL]         } [EOL]     } [EOL]     return _numberDouble; [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_DOUBLE); [EOL]         } [EOL]         if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]             convertNumberToDouble(); [EOL]         } [EOL]     } [EOL]     return _numberDouble; [EOL] }
@Override [EOL] public BigDecimal getDecimalValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGDECIMAL); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]             convertNumberToBigDecimal(); [EOL]         } [EOL]     } [EOL]     return _numberBigDecimal; [EOL] }
@Override [EOL] public BigDecimal getDecimalValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGDECIMAL); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]             convertNumberToBigDecimal(); [EOL]         } [EOL]     } [EOL]     return _numberBigDecimal; [EOL] }
@Override [EOL] public BigDecimal getDecimalValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGDECIMAL); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]             convertNumberToBigDecimal(); [EOL]         } [EOL]     } [EOL]     return _numberBigDecimal; [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + numStr + "'", nex); [EOL]     } [EOL] }
private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + numStr + "'", nex); [EOL]     } [EOL] }
private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + numStr + "'", nex); [EOL]     } [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] }
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] }
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] }
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public int calcHash(int firstQuad, int secondQuad) { [EOL]     int hash = firstQuad; [EOL]     hash ^= (hash >>> 15); [EOL]     hash += (secondQuad * MULT); [EOL]     hash ^= _hashSeed; [EOL]     hash += (hash >>> 7); [EOL]     return hash; [EOL] }
public int calcHash(int firstQuad, int secondQuad) { [EOL]     int hash = firstQuad; [EOL]     hash ^= (hash >>> 15); [EOL]     hash += (secondQuad * MULT); [EOL]     hash ^= _hashSeed; [EOL]     hash += (hash >>> 7); [EOL]     return hash; [EOL] }
public int calcHash(int firstQuad, int secondQuad) { [EOL]     int hash = firstQuad; [EOL]     hash ^= (hash >>> 15); [EOL]     hash += (secondQuad * MULT); [EOL]     hash ^= _hashSeed; [EOL]     hash += (hash >>> 7); [EOL]     return hash; [EOL] }
public int calcHash(int firstQuad, int secondQuad) { [EOL]     int hash = firstQuad; [EOL]     hash ^= (hash >>> 15); [EOL]     hash += (secondQuad * MULT); [EOL]     hash ^= _hashSeed; [EOL]     hash += (hash >>> 7); [EOL]     return hash; [EOL] }
public int calcHash(int firstQuad, int secondQuad) { [EOL]     int hash = firstQuad; [EOL]     hash ^= (hash >>> 15); [EOL]     hash += (secondQuad * MULT); [EOL]     hash ^= _hashSeed; [EOL]     hash += (hash >>> 7); [EOL]     return hash; [EOL] }
private void _addSymbol(int hash, Name symbol) { [EOL]     if (_mainHashShared) { [EOL]         unshareMain(); [EOL]     } [EOL]     if (_needRehash) { [EOL]         rehash(); [EOL]     } [EOL]     ++_count; [EOL]     int ix = (hash & _mainHashMask); [EOL]     if (_mainNames[ix] == null) { [EOL]         _mainHash[ix] = (hash << 8); [EOL]         if (_mainNamesShared) { [EOL]             unshareNames(); [EOL]         } [EOL]         _mainNames[ix] = symbol; [EOL]     } else { [EOL]         if (_collListShared) { [EOL]             unshareCollision(); [EOL]         } [EOL]         ++_collCount; [EOL]         int entryValue = _mainHash[ix]; [EOL]         int bucket = entryValue & 0xFF; [EOL]         if (bucket == 0) { [EOL]             if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                 bucket = _collEnd; [EOL]                 ++_collEnd; [EOL]                 if (bucket >= _collList.length) { [EOL]                     expandCollision(); [EOL]                 } [EOL]             } else { [EOL]                 bucket = findBestBucket(); [EOL]             } [EOL]             _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1); [EOL]         } else { [EOL]             --bucket; [EOL]         } [EOL]         Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]         _collList[bucket] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     { [EOL]         int hashSize = _mainHash.length; [EOL]         if (_count > (hashSize >> 1)) { [EOL]             int hashQuarter = (hashSize >> 2); [EOL]             if (_count > (hashSize - hashQuarter)) { [EOL]                 _needRehash = true; [EOL]             } else if (_collCount >= hashQuarter) { [EOL]                 _needRehash = true; [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void rehash() { [EOL]     _needRehash = false; [EOL]     _mainNamesShared = false; [EOL]     int[] oldMainHash = _mainHash; [EOL]     int len = oldMainHash.length; [EOL]     int newLen = len + len; [EOL]     if (newLen > MAX_TABLE_SIZE) { [EOL]         nukeSymbols(); [EOL]         return; [EOL]     } [EOL]     _mainHash = new int[newLen]; [EOL]     _mainHashMask = (newLen - 1); [EOL]     Name[] oldNames = _mainNames; [EOL]     _mainNames = new Name[newLen]; [EOL]     int symbolsSeen = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Name symbol = oldNames[i]; [EOL]         if (symbol != null) { [EOL]             ++symbolsSeen; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             _mainNames[ix] = symbol; [EOL]             _mainHash[ix] = hash << 8; [EOL]         } [EOL]     } [EOL]     int oldEnd = _collEnd; [EOL]     if (oldEnd == 0) { [EOL]         _longestCollisionList = 0; [EOL]         return; [EOL]     } [EOL]     _collCount = 0; [EOL]     _collEnd = 0; [EOL]     _collListShared = false; [EOL]     int maxColl = 0; [EOL]     Bucket[] oldBuckets = _collList; [EOL]     _collList = new Bucket[oldBuckets.length]; [EOL]     for (int i = 0; i < oldEnd; ++i) { [EOL]         for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL]             ++symbolsSeen; [EOL]             Name symbol = curr._name; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             int val = _mainHash[ix]; [EOL]             if (_mainNames[ix] == null) { [EOL]                 _mainHash[ix] = (hash << 8); [EOL]                 _mainNames[ix] = symbol; [EOL]             } else { [EOL]                 ++_collCount; [EOL]                 int bucket = val & 0xFF; [EOL]                 if (bucket == 0) { [EOL]                     if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                         bucket = _collEnd; [EOL]                         ++_collEnd; [EOL]                         if (bucket >= _collList.length) { [EOL]                             expandCollision(); [EOL]                         } [EOL]                     } else { [EOL]                         bucket = findBestBucket(); [EOL]                     } [EOL]                     _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL]                 } else { [EOL]                     --bucket; [EOL]                 } [EOL]                 Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]                 _collList[bucket] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (symbolsSeen != _count) { [EOL]         throw new RuntimeException("Internal error: count after rehash " + symbolsSeen + "; should be " + _count); [EOL]     } [EOL] }
private void rehash() { [EOL]     _needRehash = false; [EOL]     _mainNamesShared = false; [EOL]     int[] oldMainHash = _mainHash; [EOL]     int len = oldMainHash.length; [EOL]     int newLen = len + len; [EOL]     if (newLen > MAX_TABLE_SIZE) { [EOL]         nukeSymbols(); [EOL]         return; [EOL]     } [EOL]     _mainHash = new int[newLen]; [EOL]     _mainHashMask = (newLen - 1); [EOL]     Name[] oldNames = _mainNames; [EOL]     _mainNames = new Name[newLen]; [EOL]     int symbolsSeen = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Name symbol = oldNames[i]; [EOL]         if (symbol != null) { [EOL]             ++symbolsSeen; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             _mainNames[ix] = symbol; [EOL]             _mainHash[ix] = hash << 8; [EOL]         } [EOL]     } [EOL]     int oldEnd = _collEnd; [EOL]     if (oldEnd == 0) { [EOL]         _longestCollisionList = 0; [EOL]         return; [EOL]     } [EOL]     _collCount = 0; [EOL]     _collEnd = 0; [EOL]     _collListShared = false; [EOL]     int maxColl = 0; [EOL]     Bucket[] oldBuckets = _collList; [EOL]     _collList = new Bucket[oldBuckets.length]; [EOL]     for (int i = 0; i < oldEnd; ++i) { [EOL]         for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL]             ++symbolsSeen; [EOL]             Name symbol = curr._name; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             int val = _mainHash[ix]; [EOL]             if (_mainNames[ix] == null) { [EOL]                 _mainHash[ix] = (hash << 8); [EOL]                 _mainNames[ix] = symbol; [EOL]             } else { [EOL]                 ++_collCount; [EOL]                 int bucket = val & 0xFF; [EOL]                 if (bucket == 0) { [EOL]                     if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                         bucket = _collEnd; [EOL]                         ++_collEnd; [EOL]                         if (bucket >= _collList.length) { [EOL]                             expandCollision(); [EOL]                         } [EOL]                     } else { [EOL]                         bucket = findBestBucket(); [EOL]                     } [EOL]                     _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL]                 } else { [EOL]                     --bucket; [EOL]                 } [EOL]                 Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]                 _collList[bucket] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (symbolsSeen != _count) { [EOL]         throw new RuntimeException("Internal error: count after rehash " + symbolsSeen + "; should be " + _count); [EOL]     } [EOL] }
private void rehash() { [EOL]     _needRehash = false; [EOL]     _mainNamesShared = false; [EOL]     int[] oldMainHash = _mainHash; [EOL]     int len = oldMainHash.length; [EOL]     int newLen = len + len; [EOL]     if (newLen > MAX_TABLE_SIZE) { [EOL]         nukeSymbols(); [EOL]         return; [EOL]     } [EOL]     _mainHash = new int[newLen]; [EOL]     _mainHashMask = (newLen - 1); [EOL]     Name[] oldNames = _mainNames; [EOL]     _mainNames = new Name[newLen]; [EOL]     int symbolsSeen = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Name symbol = oldNames[i]; [EOL]         if (symbol != null) { [EOL]             ++symbolsSeen; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             _mainNames[ix] = symbol; [EOL]             _mainHash[ix] = hash << 8; [EOL]         } [EOL]     } [EOL]     int oldEnd = _collEnd; [EOL]     if (oldEnd == 0) { [EOL]         _longestCollisionList = 0; [EOL]         return; [EOL]     } [EOL]     _collCount = 0; [EOL]     _collEnd = 0; [EOL]     _collListShared = false; [EOL]     int maxColl = 0; [EOL]     Bucket[] oldBuckets = _collList; [EOL]     _collList = new Bucket[oldBuckets.length]; [EOL]     for (int i = 0; i < oldEnd; ++i) { [EOL]         for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL]             ++symbolsSeen; [EOL]             Name symbol = curr._name; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             int val = _mainHash[ix]; [EOL]             if (_mainNames[ix] == null) { [EOL]                 _mainHash[ix] = (hash << 8); [EOL]                 _mainNames[ix] = symbol; [EOL]             } else { [EOL]                 ++_collCount; [EOL]                 int bucket = val & 0xFF; [EOL]                 if (bucket == 0) { [EOL]                     if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                         bucket = _collEnd; [EOL]                         ++_collEnd; [EOL]                         if (bucket >= _collList.length) { [EOL]                             expandCollision(); [EOL]                         } [EOL]                     } else { [EOL]                         bucket = findBestBucket(); [EOL]                     } [EOL]                     _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL]                 } else { [EOL]                     --bucket; [EOL]                 } [EOL]                 Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]                 _collList[bucket] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (symbolsSeen != _count) { [EOL]         throw new RuntimeException("Internal error: count after rehash " + symbolsSeen + "; should be " + _count); [EOL]     } [EOL] }
private void unshareCollision() { [EOL]     Bucket[] old = _collList; [EOL]     if (old == null) { [EOL]         _collList = new Bucket[INITIAL_COLLISION_LEN]; [EOL]     } else { [EOL]         _collList = Arrays.copyOf(old, old.length); [EOL]     } [EOL]     _collListShared = false; [EOL] }
private void unshareCollision() { [EOL]     Bucket[] old = _collList; [EOL]     if (old == null) { [EOL]         _collList = new Bucket[INITIAL_COLLISION_LEN]; [EOL]     } else { [EOL]         _collList = Arrays.copyOf(old, old.length); [EOL]     } [EOL]     _collListShared = false; [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
Bucket(Name name, Bucket next) { [EOL]     _name = name; [EOL]     _next = next; [EOL]     _length = (next == null) ? 1 : next._length + 1; [EOL] }
Bucket(Name name, Bucket next) { [EOL]     _name = name; [EOL]     _next = next; [EOL]     _length = (next == null) ? 1 : next._length + 1; [EOL] }
public int length() { [EOL]     return _length; [EOL] }
public Name find(int hash, int firstQuad, int secondQuad) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(firstQuad, secondQuad)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(firstQuad, secondQuad)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name find(int hash, int firstQuad, int secondQuad) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(firstQuad, secondQuad)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(firstQuad, secondQuad)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name find(int hash, int firstQuad, int secondQuad) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(firstQuad, secondQuad)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(firstQuad, secondQuad)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name find(int hash, int firstQuad, int secondQuad) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(firstQuad, secondQuad)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(firstQuad, secondQuad)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name find(int hash, int[] quads, int qlen) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(quads, qlen)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(quads, qlen)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name find(int hash, int[] quads, int qlen) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(quads, qlen)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(quads, qlen)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name find(int hash, int[] quads, int qlen) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(quads, qlen)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(quads, qlen)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name find(int hash, int[] quads, int qlen) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(quads, qlen)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(quads, qlen)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static int outputInt(int value, char[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (char) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
public static int outputLong(long value, char[] buffer, int offset) { [EOL]     if (value < 0L) { [EOL]         if (value > MIN_INT_AS_LONG) { [EOL]             return outputInt((int) value, buffer, offset); [EOL]         } [EOL]         if (value == Long.MIN_VALUE) { [EOL]             int len = SMALLEST_LONG.length(); [EOL]             SMALLEST_LONG.getChars(0, len, buffer, offset); [EOL]             return (offset + len); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } else { [EOL]         if (value <= MAX_INT_AS_LONG) { [EOL]             return outputInt((int) value, buffer, offset); [EOL]         } [EOL]     } [EOL]     int origOffset = offset; [EOL]     offset += calcLongStrLength(value); [EOL]     int ptr = offset; [EOL]     while (value > MAX_INT_AS_LONG) { [EOL]         ptr -= 3; [EOL]         long newValue = value / THOUSAND_L; [EOL]         int triplet = (int) (value - newValue * THOUSAND_L); [EOL]         outputFullTriplet(triplet, buffer, ptr); [EOL]         value = newValue; [EOL]     } [EOL]     int ivalue = (int) value; [EOL]     while (ivalue >= 1000) { [EOL]         ptr -= 3; [EOL]         int newValue = ivalue / 1000; [EOL]         int triplet = ivalue - (newValue * 1000); [EOL]         outputFullTriplet(triplet, buffer, ptr); [EOL]         ivalue = newValue; [EOL]     } [EOL]     outputLeadingTriplet(ivalue, buffer, origOffset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
private static int calcLongStrLength(long posValue) { [EOL]     int len = 10; [EOL]     long comp = TEN_BILLION_L; [EOL]     while (posValue >= comp) { [EOL]         if (len == 19) { [EOL]             break; [EOL]         } [EOL]         ++len; [EOL]         comp = (comp << 3) + (comp << 1); [EOL]     } [EOL]     return len; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }
Name3(String name, int hash, int q1, int q2, int q3) { [EOL]     super(name, hash); [EOL]     mQuad1 = q1; [EOL]     mQuad2 = q2; [EOL]     mQuad3 = q3; [EOL] }
@Override [EOL] public boolean equals(int[] quads, int qlen) { [EOL]     return (qlen == 3) && (quads[0] == mQuad1) && (quads[1] == mQuad2) && (quads[2] == mQuad3); [EOL] }
@Override [EOL] public boolean equals(int[] quads, int qlen) { [EOL]     return (qlen == 3) && (quads[0] == mQuad1) && (quads[1] == mQuad2) && (quads[2] == mQuad3); [EOL] }
@Override [EOL] public boolean equals(int[] quads, int qlen) { [EOL]     return (qlen == 3) && (quads[0] == mQuad1) && (quads[1] == mQuad2) && (quads[2] == mQuad3); [EOL] }
public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException { [EOL]     try { [EOL]         return new BigDecimal(numStr); [EOL]     } catch (NumberFormatException e) { [EOL]         throw _badBigDecimal(numStr); [EOL]     } [EOL] }
public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException { [EOL]     try { [EOL]         return new BigDecimal(numStr); [EOL]     } catch (NumberFormatException e) { [EOL]         throw _badBigDecimal(numStr); [EOL]     } [EOL] }
private static NumberFormatException _badBigDecimal(String str) { [EOL]     return new NumberFormatException("Value \"" + str + "\" can not be represented as BigDecimal"); [EOL] }
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_inputStream != null) { [EOL]         int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("InputStream.read() returned 0 characters when trying to read " + _inputBuffer.length + " bytes"); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_inputStream != null) { [EOL]         int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("InputStream.read() returned 0 characters when trying to read " + _inputBuffer.length + " bytes"); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_inputStream != null) { [EOL]         int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("InputStream.read() returned 0 characters when trying to read " + _inputBuffer.length + " bytes"); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_inputStream != null) { [EOL]         int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("InputStream.read() returned 0 characters when trying to read " + _inputBuffer.length + " bytes"); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { [EOL]     if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { [EOL]         byte[] b = getBinaryValue(b64variant); [EOL]         out.write(b); [EOL]         return b.length; [EOL]     } [EOL]     byte[] buf = _ioContext.allocBase64Buffer(); [EOL]     try { [EOL]         return _readBinary(b64variant, out, buf); [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(buf); [EOL]     } [EOL] }
@Override [EOL] public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { [EOL]     if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { [EOL]         byte[] b = getBinaryValue(b64variant); [EOL]         out.write(b); [EOL]         return b.length; [EOL]     } [EOL]     byte[] buf = _ioContext.allocBase64Buffer(); [EOL]     try { [EOL]         return _readBinary(b64variant, out, buf); [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(buf); [EOL]     } [EOL] }
protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL]     int outputPtr = 0; [EOL]     final int outputEnd = buffer.length - 3; [EOL]     int outputCount = 0; [EOL]     while (true) { [EOL]         int ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 break; [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (outputPtr > outputEnd) { [EOL]             outputCount += outputPtr; [EOL]             out.write(buffer, 0, outputPtr); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]         buffer[outputPtr++] = (byte) decodedData; [EOL]     } [EOL]     _tokenIncomplete = false; [EOL]     if (outputPtr > 0) { [EOL]         outputCount += outputPtr; [EOL]         out.write(buffer, 0, outputPtr); [EOL]     } [EOL]     return outputCount; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private void _isNextTokenNameYes() throws IOException, JsonParseException { [EOL]     int i; [EOL]     if (_inputPtr < (_inputEnd - 1) && _inputBuffer[_inputPtr] == INT_COLON) { [EOL]         i = _inputBuffer[++_inputPtr]; [EOL]         ++_inputPtr; [EOL]         if (i == INT_QUOTE) { [EOL]             _tokenIncomplete = true; [EOL]             _nextToken = JsonToken.VALUE_STRING; [EOL]             return; [EOL]         } [EOL]         if (i == INT_LCURLY) { [EOL]             _nextToken = JsonToken.START_OBJECT; [EOL]             return; [EOL]         } [EOL]         if (i == INT_LBRACKET) { [EOL]             _nextToken = JsonToken.START_ARRAY; [EOL]             return; [EOL]         } [EOL]         i &= 0xFF; [EOL]         if (i <= INT_SPACE || i == INT_SLASH) { [EOL]             --_inputPtr; [EOL]             i = _skipWS(); [EOL]         } [EOL]     } else { [EOL]         i = _skipColon(); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             _nextToken = JsonToken.VALUE_STRING; [EOL]             return; [EOL]         case INT_LBRACKET: [EOL]             _nextToken = JsonToken.START_ARRAY; [EOL]             return; [EOL]         case INT_LCURLY: [EOL]             _nextToken = JsonToken.START_OBJECT; [EOL]             return; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             _nextToken = JsonToken.VALUE_TRUE; [EOL]             return; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             _nextToken = JsonToken.VALUE_FALSE; [EOL]             return; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             _nextToken = JsonToken.VALUE_NULL; [EOL]             return; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             _nextToken = parseNumberText(i); [EOL]             return; [EOL]     } [EOL]     _nextToken = _handleUnexpectedValue(i); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] }
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     if ((_inputPtr + 9) > _inputEnd) { [EOL]         return slowParseFieldName(); [EOL]     } [EOL]     final byte[] input = _inputBuffer; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int q = input[_inputPtr++] & 0xFF; [EOL]     if (codes[q] == 0) { [EOL]         i = input[_inputPtr++] & 0xFF; [EOL]         if (codes[i] == 0) { [EOL]             q = (q << 8) | i; [EOL]             i = input[_inputPtr++] & 0xFF; [EOL]             if (codes[i] == 0) { [EOL]                 q = (q << 8) | i; [EOL]                 i = input[_inputPtr++] & 0xFF; [EOL]                 if (codes[i] == 0) { [EOL]                     q = (q << 8) | i; [EOL]                     i = input[_inputPtr++] & 0xFF; [EOL]                     if (codes[i] == 0) { [EOL]                         _quad1 = q; [EOL]                         return parseMediumFieldName(i, codes); [EOL]                     } [EOL]                     if (i == INT_QUOTE) { [EOL]                         return findName(q, 4); [EOL]                     } [EOL]                     return parseFieldName(q, i, 4); [EOL]                 } [EOL]                 if (i == INT_QUOTE) { [EOL]                     return findName(q, 3); [EOL]                 } [EOL]                 return parseFieldName(q, i, 3); [EOL]             } [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(q, 2); [EOL]             } [EOL]             return parseFieldName(q, i, 2); [EOL]         } [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(q, 1); [EOL]         } [EOL]         return parseFieldName(q, i, 1); [EOL]     } [EOL]     if (q == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseFieldName(0, q, 0); [EOL] }
protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 1); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 1); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 2); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 2); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 3); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 3); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 4); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 4); [EOL]     } [EOL]     _quadBuffer[0] = _quad1; [EOL]     _quadBuffer[1] = q2; [EOL]     return parseLongFieldName(i); [EOL] }
protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] }
private Name findName(int q1, int lastQuadBytes) throws JsonParseException { [EOL]     Name name = _symbols.findName(q1); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     _quadBuffer[0] = q1; [EOL]     return addName(_quadBuffer, 1, lastQuadBytes); [EOL] }
private Name findName(int q1, int lastQuadBytes) throws JsonParseException { [EOL]     Name name = _symbols.findName(q1); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     _quadBuffer[0] = q1; [EOL]     return addName(_quadBuffer, 1, lastQuadBytes); [EOL] }
private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { [EOL]     if (qlen >= quads.length) { [EOL]         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]     } [EOL]     quads[qlen++] = lastQuad; [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         return addName(quads, qlen, lastQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { [EOL]     if (qlen >= quads.length) { [EOL]         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]     } [EOL]     quads[qlen++] = lastQuad; [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         return addName(quads, qlen, lastQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { [EOL]     if (qlen >= quads.length) { [EOL]         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]     } [EOL]     quads[qlen++] = lastQuad; [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         return addName(quads, qlen, lastQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         int c; [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             int max = _inputEnd; [EOL]             if (ptr >= max) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]                 max = _inputEnd; [EOL]             } [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 _skipUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 _skipUtf8_3(c); [EOL]                 break; [EOL]             case 4: [EOL]                 _skipUtf8_4(c); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]     } [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipColon() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++]; [EOL]     if (i == INT_COLON) { [EOL]         if (_inputPtr < _inputEnd) { [EOL]             i = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (i > INT_SPACE && i != INT_SLASH) { [EOL]                 ++_inputPtr; [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         i &= 0xFF; [EOL]         space_loop: while (true) { [EOL]             switch(i) { [EOL]                 case INT_SPACE: [EOL]                 case INT_TAB: [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_SLASH: [EOL]                     _skipComment(); [EOL]                     break; [EOL]                 default: [EOL]                     if (i < INT_SPACE) { [EOL]                         _throwInvalidSpace(i); [EOL]                     } [EOL]                     break space_loop; [EOL]             } [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]     } [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] }
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] }
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] }
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] }
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] }
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] }
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] }
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] }
private void _skipUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((c & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(c & 0xFF, _inputPtr); [EOL]     } [EOL] }
private void _skipUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((c & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(c & 0xFF, _inputPtr); [EOL]     } [EOL] }
private void _skipUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((c & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(c & 0xFF, _inputPtr); [EOL]     } [EOL] }
protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == BYTE_LF) { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] }
protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == BYTE_LF) { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] }
private void readObject(ObjectInputStream in) throws IOException { [EOL]     _jdkSerializeValue = in.readUTF(); [EOL] }
private void writeObject(ObjectOutputStream out) throws IOException { [EOL]     out.writeUTF(_value); [EOL] }
protected Object readResolve() { [EOL]     return new SerializedString(_jdkSerializeValue); [EOL] }
public byte[] allocBase64Buffer() { [EOL]     _verifyAlloc(_base64Buffer); [EOL]     return (_base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER)); [EOL] }
public byte[] allocBase64Buffer() { [EOL]     _verifyAlloc(_base64Buffer); [EOL]     return (_base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER)); [EOL] }
public void releaseBase64Buffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _base64Buffer); [EOL]         _base64Buffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER, buf); [EOL]     } [EOL] }
public void releaseBase64Buffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _base64Buffer); [EOL]         _base64Buffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER, buf); [EOL]     } [EOL] }
public void releaseConcatBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _concatCBuffer); [EOL]         _concatCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER, buf); [EOL]     } [EOL] }
public void releaseConcatBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _concatCBuffer); [EOL]         _concatCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER, buf); [EOL]     } [EOL] }
Name1(String name, int hash, int quad) { [EOL]     super(name, hash); [EOL]     mQuad = quad; [EOL] }
Name1(String name, int hash, int quad) { [EOL]     super(name, hash); [EOL]     mQuad = quad; [EOL] }
@Override [EOL] public boolean equals(int quad) { [EOL]     return (quad == mQuad); [EOL] }
@Override [EOL] public boolean equals(int quad) { [EOL]     return (quad == mQuad); [EOL] }
@Override [EOL] public boolean equals(int[] quads, int qlen) { [EOL]     if (qlen != mQuadLen) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         if (quads[i] != mQuads[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(int[] quads, int qlen) { [EOL]     if (qlen != mQuadLen) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         if (quads[i] != mQuads[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(int[] quads, int qlen) { [EOL]     if (qlen != mQuadLen) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         if (quads[i] != mQuads[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
JsonToken(String token) { [EOL]     if (token == null) { [EOL]         _serialized = null; [EOL]         _serializedChars = null; [EOL]         _serializedBytes = null; [EOL]     } else { [EOL]         _serialized = token; [EOL]         _serializedChars = token.toCharArray(); [EOL]         int len = _serializedChars.length; [EOL]         _serializedBytes = new byte[len]; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             _serializedBytes[i] = (byte) _serializedChars[i]; [EOL]         } [EOL]     } [EOL] }
JsonToken(String token) { [EOL]     if (token == null) { [EOL]         _serialized = null; [EOL]         _serializedChars = null; [EOL]         _serializedBytes = null; [EOL]     } else { [EOL]         _serialized = token; [EOL]         _serializedChars = token.toCharArray(); [EOL]         int len = _serializedChars.length; [EOL]         _serializedBytes = new byte[len]; [EOL]         for (int i = 0; i < len; ++i) { [EOL]             _serializedBytes[i] = (byte) _serializedChars[i]; [EOL]         } [EOL]     } [EOL] }
public int readBinaryValue(OutputStream out) throws IOException, JsonParseException { [EOL]     return readBinaryValue(Base64Variants.getDefaultVariant(), out); [EOL] }
public void resetWithString(String value) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = value; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     _currentSize = 0; [EOL] }
public void resetWithString(String value) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = value; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     _currentSize = 0; [EOL] }
public void resetWithString(String value) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = value; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     _currentSize = 0; [EOL] }
public void resetWithString(String value) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = value; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     _currentSize = 0; [EOL] }
public char[] emptyAndGetCurrentSegment() { [EOL]     _inputStart = -1; [EOL]     _currentSize = 0; [EOL]     _inputLen = 0; [EOL]     _inputBuffer = null; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     if (curr == null) { [EOL]         _currentSegment = curr = findBuffer(0); [EOL]     } [EOL]     return curr; [EOL] }
public char[] emptyAndGetCurrentSegment() { [EOL]     _inputStart = -1; [EOL]     _currentSize = 0; [EOL]     _inputLen = 0; [EOL]     _inputBuffer = null; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     if (curr == null) { [EOL]         _currentSegment = curr = findBuffer(0); [EOL]     } [EOL]     return curr; [EOL] }
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         if (_objectCodec != null) { [EOL]             _objectCodec.writeValue(this, value); [EOL]             return; [EOL]         } [EOL]         _writeSimpleObject(value); [EOL]     } [EOL] }
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         if (_objectCodec != null) { [EOL]             _objectCodec.writeValue(this, value); [EOL]             return; [EOL]         } [EOL]         _writeSimpleObject(value); [EOL]     } [EOL] }
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         if (_objectCodec != null) { [EOL]             _objectCodec.writeValue(this, value); [EOL]             return; [EOL]         } [EOL]         _writeSimpleObject(value); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] }
public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out) { [EOL]     super(ctxt, features, codec); [EOL]     _outputStream = out; [EOL]     _bufferRecyclable = true; [EOL]     _outputBuffer = ctxt.allocWriteEncodingBuffer(); [EOL]     _outputEnd = _outputBuffer.length; [EOL]     _outputMaxContiguous = _outputEnd >> 3; [EOL]     _charBuffer = ctxt.allocConcatBuffer(); [EOL]     _charBufferLength = _charBuffer.length; [EOL]     if (isEnabled(Feature.ESCAPE_NON_ASCII)) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LBRACKET; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LBRACKET; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RBRACKET; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an object"); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartObject(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LCURLY; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an object"); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartObject(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LCURLY; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an object"); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartObject(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LCURLY; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeEndObject() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inObject()) { [EOL]         _reportError("Current context not an object but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RCURLY; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeEndObject() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inObject()) { [EOL]         _reportError("Current context not an object but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RCURLY; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected final void _writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeStringSegments(name); [EOL]         return; [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     final int len = name.length(); [EOL]     if (len <= _charBufferLength) { [EOL]         name.getChars(0, len, _charBuffer, 0); [EOL]         if (len <= _outputMaxContiguous) { [EOL]             if ((_outputTail + len) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             _writeStringSegment(_charBuffer, 0, len); [EOL]         } else { [EOL]             _writeStringSegments(_charBuffer, 0, len); [EOL]         } [EOL]     } else { [EOL]         _writeStringSegments(name); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (commaBefore) { [EOL]         _cfgPrettyPrinter.writeObjectEntrySeparator(this); [EOL]     } else { [EOL]         _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]     } [EOL]     if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]         final int len = name.length(); [EOL]         if (len <= _charBufferLength) { [EOL]             name.getChars(0, len, _charBuffer, 0); [EOL]             if (len <= _outputMaxContiguous) { [EOL]                 if ((_outputTail + len) > _outputEnd) { [EOL]                     _flushBuffer(); [EOL]                 } [EOL]                 _writeStringSegment(_charBuffer, 0, len); [EOL]             } else { [EOL]                 _writeStringSegments(_charBuffer, 0, len); [EOL]             } [EOL]         } else { [EOL]             _writeStringSegments(name); [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     } else { [EOL]         _writeStringSegments(name); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeLongString(String text) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegments(text); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeLongString(String text) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegments(text); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     if (len <= _outputMaxContiguous) { [EOL]         if ((_outputTail + len) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _writeStringSegment(text, offset, len); [EOL]     } else { [EOL]         _writeStringSegments(text, offset, len); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     if (len <= _outputMaxContiguous) { [EOL]         if ((_outputTail + len) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _writeStringSegment(text, offset, len); [EOL]     } else { [EOL]         _writeStringSegments(text, offset, len); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     if (len <= _outputMaxContiguous) { [EOL]         if ((_outputTail + len) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _writeStringSegment(text, offset, len); [EOL]     } else { [EOL]         _writeStringSegments(text, offset, len); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     if (len <= _outputMaxContiguous) { [EOL]         _writeUTF8Segment(text, offset, len); [EOL]     } else { [EOL]         _writeUTF8Segments(text, offset, len); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int start = 0; [EOL]     int len = text.length(); [EOL]     while (len > 0) { [EOL]         char[] buf = _charBuffer; [EOL]         final int blen = buf.length; [EOL]         final int len2 = (len < blen) ? len : blen; [EOL]         text.getChars(start, start + len2, buf, 0); [EOL]         writeRaw(buf, 0, len2); [EOL]         start += len2; [EOL]         len -= len2; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int start = 0; [EOL]     int len = text.length(); [EOL]     while (len > 0) { [EOL]         char[] buf = _charBuffer; [EOL]         final int blen = buf.length; [EOL]         final int len2 = (len < blen) ? len : blen; [EOL]         text.getChars(start, start + len2, buf, 0); [EOL]         writeRaw(buf, 0, len2); [EOL]         start += len2; [EOL]         len -= len2; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int start = 0; [EOL]     int len = text.length(); [EOL]     while (len > 0) { [EOL]         char[] buf = _charBuffer; [EOL]         final int blen = buf.length; [EOL]         final int len2 = (len < blen) ? len : blen; [EOL]         text.getChars(start, start + len2, buf, 0); [EOL]         writeRaw(buf, 0, len2); [EOL]         start += len2; [EOL]         len -= len2; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     { [EOL]         int len3 = len + len + len; [EOL]         if ((_outputTail + len3) > _outputEnd) { [EOL]             if (_outputEnd < len3) { [EOL]                 _writeSegmentedRaw(cbuf, offset, len); [EOL]                 return; [EOL]             } [EOL]             _flushBuffer(); [EOL]         } [EOL]     } [EOL]     len += offset; [EOL]     main_loop: while (offset < len) { [EOL]         inner_loop: while (true) { [EOL]             int ch = (int) cbuf[offset]; [EOL]             if (ch > 0x7F) { [EOL]                 break inner_loop; [EOL]             } [EOL]             _outputBuffer[_outputTail++] = (byte) ch; [EOL]             if (++offset >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         char ch = cbuf[offset++]; [EOL]         if (ch < 0x800) { [EOL]             _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6)); [EOL]             _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             _outputRawMultiByteChar(ch, cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 3) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     final byte[] bbuf = _outputBuffer; [EOL]     if (ch <= 0x7F) { [EOL]         bbuf[_outputTail++] = (byte) ch; [EOL]     } else if (ch < 0x800) { [EOL]         bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); [EOL]         bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } else { [EOL]         _outputRawMultiByteChar(ch, null, 0, 0); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 3) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     final byte[] bbuf = _outputBuffer; [EOL]     if (ch <= 0x7F) { [EOL]         bbuf[_outputTail++] = (byte) ch; [EOL]     } else if (ch < 0x800) { [EOL]         bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); [EOL]         bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } else { [EOL]         _outputRawMultiByteChar(ch, null, 0, 0); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 3) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     final byte[] bbuf = _outputBuffer; [EOL]     if (ch <= 0x7F) { [EOL]         bbuf[_outputTail++] = (byte) ch; [EOL]     } else if (ch < 0x800) { [EOL]         bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); [EOL]         bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } else { [EOL]         _outputRawMultiByteChar(ch, null, 0, 0); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 3) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     final byte[] bbuf = _outputBuffer; [EOL]     if (ch <= 0x7F) { [EOL]         bbuf[_outputTail++] = (byte) ch; [EOL]     } else if (ch < 0x800) { [EOL]         bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6)); [EOL]         bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } else { [EOL]         _outputRawMultiByteChar(ch, null, 0, 0); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeBinary(b64variant, data, offset, offset + len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     return bytes; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     return bytes; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     return bytes; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     return bytes; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         byte b; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 b = BYTE_COMMA; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 b = BYTE_COLON; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL]                     if (raw.length > 0) { [EOL]                         _writeBytes(raw); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = b; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_outputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _outputStream.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _outputStream.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_outputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _outputStream.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _outputStream.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_outputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _outputStream.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _outputStream.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_outputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _outputStream.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _outputStream.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_outputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _outputStream.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _outputStream.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] protected void _releaseBuffers() { [EOL]     byte[] buf = _outputBuffer; [EOL]     if (buf != null && _bufferRecyclable) { [EOL]         _outputBuffer = null; [EOL]         _ioContext.releaseWriteEncodingBuffer(buf); [EOL]     } [EOL]     char[] cbuf = _charBuffer; [EOL]     if (cbuf != null) { [EOL]         _charBuffer = null; [EOL]         _ioContext.releaseConcatBuffer(cbuf); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegments(String text) throws IOException, JsonGenerationException { [EOL]     int left = text.length(); [EOL]     int offset = 0; [EOL]     final char[] cbuf = _charBuffer; [EOL]     while (left > 0) { [EOL]         int len = Math.min(_outputMaxContiguous, left); [EOL]         text.getChars(offset, offset + len, cbuf, 0); [EOL]         if ((_outputTail + len) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _writeStringSegment(cbuf, 0, len); [EOL]         offset += len; [EOL]         left -= len; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException { [EOL]     do { [EOL]         int len = Math.min(_outputMaxContiguous, totalLen); [EOL]         if ((_outputTail + len) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _writeStringSegment(cbuf, offset, len); [EOL]         offset += len; [EOL]         totalLen -= len; [EOL]     } while (totalLen > 0); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < len) { [EOL]         int ch = cbuf[offset]; [EOL]         if (ch > 0x7F || escCodes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]         ++offset; [EOL]     } [EOL]     _outputTail = outputPtr; [EOL]     if (offset < len) { [EOL]         if (_characterEscapes != null) { [EOL]             _writeCustomStringSegment2(cbuf, offset, len); [EOL]         } else if (_maximumNonEscapedChar == 0) { [EOL]             _writeStringSegment2(cbuf, offset, len); [EOL]         } else { [EOL]             _writeStringSegmentASCII2(cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < len) { [EOL]         int ch = cbuf[offset]; [EOL]         if (ch > 0x7F || escCodes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]         ++offset; [EOL]     } [EOL]     _outputTail = outputPtr; [EOL]     if (offset < len) { [EOL]         if (_characterEscapes != null) { [EOL]             _writeCustomStringSegment2(cbuf, offset, len); [EOL]         } else if (_maximumNonEscapedChar == 0) { [EOL]             _writeStringSegment2(cbuf, offset, len); [EOL]         } else { [EOL]             _writeStringSegmentASCII2(cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < len) { [EOL]         int ch = cbuf[offset]; [EOL]         if (ch > 0x7F || escCodes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]         ++offset; [EOL]     } [EOL]     _outputTail = outputPtr; [EOL]     if (offset < len) { [EOL]         if (_characterEscapes != null) { [EOL]             _writeCustomStringSegment2(cbuf, offset, len); [EOL]         } else if (_maximumNonEscapedChar == 0) { [EOL]             _writeStringSegment2(cbuf, offset, len); [EOL]         } else { [EOL]             _writeStringSegmentASCII2(cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { [EOL]     do { [EOL]         int len = Math.min(_outputMaxContiguous, totalLen); [EOL]         _writeUTF8Segment(utf8, offset, len); [EOL]         offset += len; [EOL]         totalLen -= len; [EOL]     } while (totalLen > 0); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { [EOL]     do { [EOL]         int len = Math.min(_outputMaxContiguous, totalLen); [EOL]         _writeUTF8Segment(utf8, offset, len); [EOL]         offset += len; [EOL]         totalLen -= len; [EOL]     } while (totalLen > 0); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { [EOL]     do { [EOL]         int len = Math.min(_outputMaxContiguous, totalLen); [EOL]         _writeUTF8Segment(utf8, offset, len); [EOL]         offset += len; [EOL]         totalLen -= len; [EOL]     } while (totalLen > 0); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException { [EOL]     do { [EOL]         int len = Math.min(_outputMaxContiguous, totalLen); [EOL]         _writeUTF8Segment(utf8, offset, len); [EOL]         offset += len; [EOL]         totalLen -= len; [EOL]     } while (totalLen > 0); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     for (int ptr = offset, end = offset + len; ptr < end; ) { [EOL]         int ch = utf8[ptr++]; [EOL]         if ((ch >= 0) && escCodes[ch] != 0) { [EOL]             _writeUTF8Segment2(utf8, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException { [EOL]     int outputPtr = _outputTail; [EOL]     if ((outputPtr + (len * 6)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         outputPtr = _outputTail; [EOL]     } [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     len += offset; [EOL]     while (offset < len) { [EOL]         byte b = utf8[offset++]; [EOL]         int ch = b; [EOL]         if (ch < 0 || escCodes[ch] == 0) { [EOL]             outputBuffer[outputPtr++] = b; [EOL]             continue; [EOL]         } [EOL]         int escape = escCodes[ch]; [EOL]         if (escape > 0) { [EOL]             outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]             outputBuffer[outputPtr++] = (byte) escape; [EOL]         } else { [EOL]             outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { [EOL]     int inputPtr = 0; [EOL]     int inputEnd = 0; [EOL]     int lastFullOffset = -3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (bytesLeft > 2) { [EOL]         if (inputPtr > lastFullOffset) { [EOL]             inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL]             inputPtr = 0; [EOL]             if (inputEnd < 3) { [EOL]                 break; [EOL]             } [EOL]             lastFullOffset = inputEnd - 3; [EOL]         } [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL]         b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL]         bytesLeft -= 3; [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     if (bytesLeft > 0) { [EOL]         inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL]         inputPtr = 0; [EOL]         if (inputEnd > 0) { [EOL]             if (_outputTail > safeOutputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL]             int amount; [EOL]             if (inputPtr < inputEnd) { [EOL]                 b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL]                 amount = 2; [EOL]             } else { [EOL]                 amount = 1; [EOL]             } [EOL]             _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL]             bytesLeft -= amount; [EOL]         } [EOL]     } [EOL]     return bytesLeft; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { [EOL]     int inputPtr = 0; [EOL]     int inputEnd = 0; [EOL]     int lastFullOffset = -3; [EOL]     int bytesDone = 0; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (true) { [EOL]         if (inputPtr > lastFullOffset) { [EOL]             inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); [EOL]             inputPtr = 0; [EOL]             if (inputEnd < 3) { [EOL]                 break; [EOL]             } [EOL]             lastFullOffset = inputEnd - 3; [EOL]         } [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL]         b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL]         bytesDone += 3; [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     if (inputPtr < inputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL]         int amount = 1; [EOL]         if (inputPtr < inputEnd) { [EOL]             b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL]             amount = 2; [EOL]         } [EOL]         bytesDone += amount; [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL]     } [EOL]     return bytesDone; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { [EOL]     int i = 0; [EOL]     while (inputPtr < inputEnd) { [EOL]         readBuffer[i++] = readBuffer[inputPtr++]; [EOL]     } [EOL]     inputPtr = 0; [EOL]     inputEnd = i; [EOL]     maxRead = Math.min(maxRead, readBuffer.length); [EOL]     do { [EOL]         int length = maxRead - inputEnd; [EOL]         if (length == 0) { [EOL]             break; [EOL]         } [EOL]         int count = in.read(readBuffer, inputEnd, length); [EOL]         if (count < 0) { [EOL]             return inputEnd; [EOL]         } [EOL]         inputEnd += count; [EOL]     } while (inputEnd < 3); [EOL]     return inputEnd; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _outputMultiByteChar(int ch, int outputPtr) throws IOException { [EOL]     byte[] bbuf = _outputBuffer; [EOL]     if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { [EOL]         bbuf[outputPtr++] = BYTE_BACKSLASH; [EOL]         bbuf[outputPtr++] = BYTE_u; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; [EOL]     } else { [EOL]         bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]         bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]         bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } [EOL]     return outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _outputMultiByteChar(int ch, int outputPtr) throws IOException { [EOL]     byte[] bbuf = _outputBuffer; [EOL]     if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { [EOL]         bbuf[outputPtr++] = BYTE_BACKSLASH; [EOL]         bbuf[outputPtr++] = BYTE_u; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[ch & 0xF]; [EOL]     } else { [EOL]         bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]         bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]         bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]     } [EOL]     return outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected final void _flushBuffer() throws IOException { [EOL]     int len = _outputTail; [EOL]     if (len > 0) { [EOL]         _outputTail = 0; [EOL]         _outputStream.write(_outputBuffer, 0, len); [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
public final int getEntryCount() { [EOL]     return _index + 1; [EOL] }
public final int getEntryCount() { [EOL]     return _index + 1; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public JsonLocation(Object srcRef, long totalChars, int lineNr, int colNr) { [EOL]     this(srcRef, -1L, totalChars, lineNr, colNr); [EOL] }
public JsonLocation(Object srcRef, long totalChars, int lineNr, int colNr) { [EOL]     this(srcRef, -1L, totalChars, lineNr, colNr); [EOL] }
public JsonLocation(Object sourceRef, long totalBytes, long totalChars, int lineNr, int columnNr) { [EOL]     _sourceRef = sourceRef; [EOL]     _totalBytes = totalBytes; [EOL]     _totalChars = totalChars; [EOL]     _lineNr = lineNr; [EOL]     _columnNr = columnNr; [EOL] }
public JsonLocation(Object sourceRef, long totalBytes, long totalChars, int lineNr, int columnNr) { [EOL]     _sourceRef = sourceRef; [EOL]     _totalBytes = totalBytes; [EOL]     _totalChars = totalChars; [EOL]     _lineNr = lineNr; [EOL]     _columnNr = columnNr; [EOL] }
public int getLineNr() { [EOL]     return _lineNr; [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(80); [EOL]     sb.append("[Source: "); [EOL]     if (_sourceRef == null) { [EOL]         sb.append("UNKNOWN"); [EOL]     } else { [EOL]         sb.append(_sourceRef.toString()); [EOL]     } [EOL]     sb.append("; line: "); [EOL]     sb.append(_lineNr); [EOL]     sb.append(", column: "); [EOL]     sb.append(_columnNr); [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
JsonEncoding(String javaName, boolean bigEndian) { [EOL]     _javaName = javaName; [EOL]     _bigEndian = bigEndian; [EOL] }
JsonEncoding(String javaName, boolean bigEndian) { [EOL]     _javaName = javaName; [EOL]     _bigEndian = bigEndian; [EOL] }
public static int collectDefaults() { [EOL]     int flags = 0; [EOL]     for (Feature f : values()) { [EOL]         if (f.enabledByDefault()) { [EOL]             flags |= f.getMask(); [EOL]         } [EOL]     } [EOL]     return flags; [EOL] }
public static int collectDefaults() { [EOL]     int flags = 0; [EOL]     for (Feature f : values()) { [EOL]         if (f.enabledByDefault()) { [EOL]             flags |= f.getMask(); [EOL]         } [EOL]     } [EOL]     return flags; [EOL] }
public static int collectDefaults() { [EOL]     int flags = 0; [EOL]     for (Feature f : values()) { [EOL]         if (f.enabledByDefault()) { [EOL]             flags |= f.getMask(); [EOL]         } [EOL]     } [EOL]     return flags; [EOL] }
private Feature(boolean defaultState) { [EOL]     _mask = (1 << ordinal()); [EOL]     _defaultState = defaultState; [EOL] }
public boolean enabledByDefault() { [EOL]     return _defaultState; [EOL] }
public boolean enabledByDefault() { [EOL]     return _defaultState; [EOL] }
public JsonGenerator setPrettyPrinter(PrettyPrinter pp) { [EOL]     _cfgPrettyPrinter = pp; [EOL]     return this; [EOL] }
public JsonGenerator setPrettyPrinter(PrettyPrinter pp) { [EOL]     _cfgPrettyPrinter = pp; [EOL]     return this; [EOL] }
public int writeBinary(InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength); [EOL] }
public int writeBinary(InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength); [EOL] }
public int writeBinary(InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength); [EOL] }
public final void writeObjectField(String fieldName, Object pojo) throws IOException, JsonProcessingException { [EOL]     writeFieldName(fieldName); [EOL]     writeObject(pojo); [EOL] }
public final void writeObjectField(String fieldName, Object pojo) throws IOException, JsonProcessingException { [EOL]     writeFieldName(fieldName); [EOL]     writeObject(pojo); [EOL] }
public final void writeObjectField(String fieldName, Object pojo) throws IOException, JsonProcessingException { [EOL]     writeFieldName(fieldName); [EOL]     writeObject(pojo); [EOL] }
public boolean usesPaddingChar(int ch) { [EOL]     return ch == (int) _paddingChar; [EOL] }
public boolean usesPaddingChar(int ch) { [EOL]     return ch == (int) _paddingChar; [EOL] }
public int encodeBase64Chunk(int b24, char[] buffer, int ptr) { [EOL]     buffer[ptr++] = _base64ToAsciiC[(b24 >> 18) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiC[(b24 >> 12) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiC[(b24 >> 6) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiC[b24 & 0x3F]; [EOL]     return ptr; [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes) { [EOL]     sb.append(_base64ToAsciiC[(bits >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(bits >> 12) & 0x3F]); [EOL]     if (_usesPadding) { [EOL]         sb.append((outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar); [EOL]         sb.append(_paddingChar); [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             sb.append(_base64ToAsciiC[(bits >> 6) & 0x3F]); [EOL]         } [EOL]     } [EOL] }
public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes) { [EOL]     sb.append(_base64ToAsciiC[(bits >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(bits >> 12) & 0x3F]); [EOL]     if (_usesPadding) { [EOL]         sb.append((outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar); [EOL]         sb.append(_paddingChar); [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             sb.append(_base64ToAsciiC[(bits >> 6) & 0x3F]); [EOL]         } [EOL]     } [EOL] }
public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes) { [EOL]     sb.append(_base64ToAsciiC[(bits >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(bits >> 12) & 0x3F]); [EOL]     if (_usesPadding) { [EOL]         sb.append((outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar); [EOL]         sb.append(_paddingChar); [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             sb.append(_base64ToAsciiC[(bits >> 6) & 0x3F]); [EOL]         } [EOL]     } [EOL] }
public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes) { [EOL]     sb.append(_base64ToAsciiC[(bits >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(bits >> 12) & 0x3F]); [EOL]     if (_usesPadding) { [EOL]         sb.append((outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar); [EOL]         sb.append(_paddingChar); [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             sb.append(_base64ToAsciiC[(bits >> 6) & 0x3F]); [EOL]         } [EOL]     } [EOL] }
public int encodeBase64Chunk(int b24, byte[] buffer, int ptr) { [EOL]     buffer[ptr++] = _base64ToAsciiB[(b24 >> 18) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiB[(b24 >> 12) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiB[(b24 >> 6) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiB[b24 & 0x3F]; [EOL]     return ptr; [EOL] }
public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiB[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiB[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         byte pb = (byte) _paddingChar; [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiB[(bits >> 6) & 0x3F] : pb; [EOL]         buffer[outPtr++] = pb; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiB[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] }
public String encode(byte[] input) { [EOL]     return encode(input, false); [EOL] }
public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public JsonParseException(String msg, JsonLocation loc) { [EOL]     super(msg, loc); [EOL] }
protected char getNextChar(String eofMsg) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(eofMsg); [EOL]         } [EOL]     } [EOL]     return _inputBuffer[_inputPtr++]; [EOL] }
protected char getNextChar(String eofMsg) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(eofMsg); [EOL]         } [EOL]     } [EOL]     return _inputBuffer[_inputPtr++]; [EOL] }
protected char getNextChar(String eofMsg) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(eofMsg); [EOL]         } [EOL]     } [EOL]     return _inputBuffer[_inputPtr++]; [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL]     int outputPtr = 0; [EOL]     final int outputEnd = buffer.length - 3; [EOL]     int outputCount = 0; [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 break; [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (outputPtr > outputEnd) { [EOL]             outputCount += outputPtr; [EOL]             out.write(buffer, 0, outputPtr); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]         buffer[outputPtr++] = (byte) decodedData; [EOL]     } [EOL]     _tokenIncomplete = false; [EOL]     if (outputPtr > 0) { [EOL]         outputCount += outputPtr; [EOL]         out.write(buffer, 0, outputPtr); [EOL]     } [EOL]     return outputCount; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException { [EOL]     boolean negative = (ch == INT_MINUS); [EOL]     int ptr = _inputPtr; [EOL]     int startPtr = ptr - 1; [EOL]     final int inputLen = _inputEnd; [EOL]     dummy_loop: do { [EOL]         if (negative) { [EOL]             if (ptr >= _inputEnd) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = _inputBuffer[ptr++]; [EOL]             if (ch > INT_9 || ch < INT_0) { [EOL]                 _inputPtr = ptr; [EOL]                 return _handleInvalidNumberStart(ch, true); [EOL]             } [EOL]         } [EOL]         if (ch == INT_0) { [EOL]             break dummy_loop; [EOL]         } [EOL]         int intLen = 1; [EOL]         int_loop: while (true) { [EOL]             if (ptr >= _inputEnd) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = (int) _inputBuffer[ptr++]; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 break int_loop; [EOL]             } [EOL]             ++intLen; [EOL]         } [EOL]         int fractLen = 0; [EOL]         if (ch == INT_DECIMAL_POINT) { [EOL]             fract_loop: while (true) { [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]                 if (ch < INT_0 || ch > INT_9) { [EOL]                     break fract_loop; [EOL]                 } [EOL]                 ++fractLen; [EOL]             } [EOL]             if (fractLen == 0) { [EOL]                 reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); [EOL]             } [EOL]         } [EOL]         int expLen = 0; [EOL]         if (ch == INT_e || ch == INT_E) { [EOL]             if (ptr >= inputLen) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = (int) _inputBuffer[ptr++]; [EOL]             if (ch == INT_MINUS || ch == INT_PLUS) { [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]             } [EOL]             while (ch <= INT_9 && ch >= INT_0) { [EOL]                 ++expLen; [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]             } [EOL]             if (expLen == 0) { [EOL]                 reportUnexpectedNumberChar(ch, "Exponent indicator not followed by a digit"); [EOL]             } [EOL]         } [EOL]         --ptr; [EOL]         _inputPtr = ptr; [EOL]         int len = ptr - startPtr; [EOL]         _textBuffer.resetWithShared(_inputBuffer, startPtr, len); [EOL]         return reset(negative, intLen, fractLen, expLen); [EOL]     } while (false); [EOL]     _inputPtr = negative ? (startPtr + 1) : startPtr; [EOL]     return parseNumberText2(negative); [EOL] }
private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]     } [EOL]     int intLen = 0; [EOL]     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("No digit following minus sign"); [EOL]     if (c == '0') { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     boolean eof = false; [EOL]     int_loop: while (c >= '0' && c <= '9') { [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             c = CHAR_NULL; [EOL]             eof = true; [EOL]             break int_loop; [EOL]         } [EOL]         c = _inputBuffer[_inputPtr++]; [EOL]     } [EOL]     if (intLen == 0) { [EOL]         reportInvalidNumber("Missing integer part (next char " + _getCharDesc(c) + ")"); [EOL]     } [EOL]     int fractLen = 0; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return reset(negative, intLen, fractLen, expLen); [EOL] }
private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == '\n') { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] }
protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == '\n') { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] }
protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == '\n') { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] }
protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == '\n') { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidToken(matchStr.substring(0, i)); [EOL]             } [EOL]         } [EOL]         if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr]; [EOL]     if (c < '0' || c == ']' || c == '}') { [EOL]         return; [EOL]     } [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL]     return; [EOL] }
protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException { [EOL]     _reportInvalidToken(matchedPart, "'null', 'true', 'false' or NaN"); [EOL] }
protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException { [EOL]     StringBuilder sb = new StringBuilder(matchedPart); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         sb.append(c); [EOL]     } [EOL]     _reportError("Unrecognized token '" + sb.toString() + "': was expecting "); [EOL] }
protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException { [EOL]     StringBuilder sb = new StringBuilder(matchedPart); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         sb.append(c); [EOL]     } [EOL]     _reportError("Unrecognized token '" + sb.toString() + "': was expecting "); [EOL] }
protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException { [EOL]     StringBuilder sb = new StringBuilder(matchedPart); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         sb.append(c); [EOL]     } [EOL]     _reportError("Unrecognized token '" + sb.toString() + "': was expecting "); [EOL] }
private InternCache() { [EOL]     super(MAX_ENTRIES, 0.8f, true); [EOL] }
@Override [EOL] protected boolean removeEldestEntry(Map.Entry<String, String> eldest) { [EOL]     return size() > MAX_ENTRIES; [EOL] }
@Override [EOL] protected boolean removeEldestEntry(Map.Entry<String, String> eldest) { [EOL]     return size() > MAX_ENTRIES; [EOL] }
public synchronized String intern(String input) { [EOL]     String result = get(input); [EOL]     if (result == null) { [EOL]         result = input.intern(); [EOL]         put(result, result); [EOL]     } [EOL]     return result; [EOL] }
public synchronized String intern(String input) { [EOL]     String result = get(input); [EOL]     if (result == null) { [EOL]         result = input.intern(); [EOL]         put(result, result); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '['; [EOL]     } [EOL] }
@Override [EOL] public void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = ']'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] }
@Override [EOL] public void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = ']'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] }
@Override [EOL] public void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = ']'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] }
@Override [EOL] public void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = ']'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(text); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int len = text.length(); [EOL]     int room = _outputEnd - _outputTail; [EOL]     if (room == 0) { [EOL]         _flushBuffer(); [EOL]         room = _outputEnd - _outputTail; [EOL]     } [EOL]     if (room >= len) { [EOL]         text.getChars(0, len, _outputBuffer, _outputTail); [EOL]         _outputTail += len; [EOL]     } else { [EOL]         writeRawLong(text); [EOL]     } [EOL] }
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int len = text.length(); [EOL]     int room = _outputEnd - _outputTail; [EOL]     if (room == 0) { [EOL]         _flushBuffer(); [EOL]         room = _outputEnd - _outputTail; [EOL]     } [EOL]     if (room >= len) { [EOL]         text.getChars(0, len, _outputBuffer, _outputTail); [EOL]         _outputTail += len; [EOL]     } else { [EOL]         writeRawLong(text); [EOL]     } [EOL] }
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int len = text.length(); [EOL]     int room = _outputEnd - _outputTail; [EOL]     if (room == 0) { [EOL]         _flushBuffer(); [EOL]         room = _outputEnd - _outputTail; [EOL]     } [EOL]     if (room >= len) { [EOL]         text.getChars(0, len, _outputBuffer, _outputTail); [EOL]         _outputTail += len; [EOL]     } else { [EOL]         writeRawLong(text); [EOL]     } [EOL] }
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int len = text.length(); [EOL]     int room = _outputEnd - _outputTail; [EOL]     if (room == 0) { [EOL]         _flushBuffer(); [EOL]         room = _outputEnd - _outputTail; [EOL]     } [EOL]     if (room >= len) { [EOL]         text.getChars(0, len, _outputBuffer, _outputTail); [EOL]         _outputTail += len; [EOL]     } else { [EOL]         writeRawLong(text); [EOL]     } [EOL] }
@Override [EOL] public void writeRaw(char c) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = c; [EOL] }
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     return bytes; [EOL] }
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     return bytes; [EOL] }
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     return bytes; [EOL] }
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     return bytes; [EOL] }
@Override [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]         writeRaw(value.toPlainString()); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] }
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { [EOL]     int inputPtr = 0; [EOL]     int inputEnd = 0; [EOL]     int lastFullOffset = -3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (bytesLeft > 2) { [EOL]         if (inputPtr > lastFullOffset) { [EOL]             inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL]             inputPtr = 0; [EOL]             if (inputEnd < 3) { [EOL]                 break; [EOL]             } [EOL]             lastFullOffset = inputEnd - 3; [EOL]         } [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL]         b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL]         bytesLeft -= 3; [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     if (bytesLeft > 0) { [EOL]         inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL]         inputPtr = 0; [EOL]         if (inputEnd > 0) { [EOL]             if (_outputTail > safeOutputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL]             int amount; [EOL]             if (inputPtr < inputEnd) { [EOL]                 b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL]                 amount = 2; [EOL]             } else { [EOL]                 amount = 1; [EOL]             } [EOL]             _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL]             bytesLeft -= amount; [EOL]         } [EOL]     } [EOL]     return bytesLeft; [EOL] }
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { [EOL]     int inputPtr = 0; [EOL]     int inputEnd = 0; [EOL]     int lastFullOffset = -3; [EOL]     int bytesDone = 0; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (true) { [EOL]         if (inputPtr > lastFullOffset) { [EOL]             inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); [EOL]             inputPtr = 0; [EOL]             if (inputEnd < 3) { [EOL]                 break; [EOL]             } [EOL]             lastFullOffset = inputEnd - 3; [EOL]         } [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL]         b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL]         bytesDone += 3; [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     if (inputPtr < inputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL]         int amount = 1; [EOL]         if (inputPtr < inputEnd) { [EOL]             b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL]             amount = 2; [EOL]         } [EOL]         bytesDone += amount; [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL]     } [EOL]     return bytesDone; [EOL] }
private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { [EOL]     int i = 0; [EOL]     while (inputPtr < inputEnd) { [EOL]         readBuffer[i++] = readBuffer[inputPtr++]; [EOL]     } [EOL]     inputPtr = 0; [EOL]     inputEnd = i; [EOL]     maxRead = Math.min(maxRead, readBuffer.length); [EOL]     do { [EOL]         int length = maxRead - inputEnd; [EOL]         if (length == 0) { [EOL]             break; [EOL]         } [EOL]         int count = in.read(readBuffer, inputEnd, length); [EOL]         if (count < 0) { [EOL]             return inputEnd; [EOL]         } [EOL]         inputEnd += count; [EOL]     } while (inputEnd < 3); [EOL]     return inputEnd; [EOL] }
private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { [EOL]     int i = 0; [EOL]     while (inputPtr < inputEnd) { [EOL]         readBuffer[i++] = readBuffer[inputPtr++]; [EOL]     } [EOL]     inputPtr = 0; [EOL]     inputEnd = i; [EOL]     maxRead = Math.min(maxRead, readBuffer.length); [EOL]     do { [EOL]         int length = maxRead - inputEnd; [EOL]         if (length == 0) { [EOL]             break; [EOL]         } [EOL]         int count = in.read(readBuffer, inputEnd, length); [EOL]         if (count < 0) { [EOL]             return inputEnd; [EOL]         } [EOL]         inputEnd += count; [EOL]     } while (inputEnd < 3); [EOL]     return inputEnd; [EOL] }
private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { [EOL]     int i = 0; [EOL]     while (inputPtr < inputEnd) { [EOL]         readBuffer[i++] = readBuffer[inputPtr++]; [EOL]     } [EOL]     inputPtr = 0; [EOL]     inputEnd = i; [EOL]     maxRead = Math.min(maxRead, readBuffer.length); [EOL]     do { [EOL]         int length = maxRead - inputEnd; [EOL]         if (length == 0) { [EOL]             break; [EOL]         } [EOL]         int count = in.read(readBuffer, inputEnd, length); [EOL]         if (count < 0) { [EOL]             return inputEnd; [EOL]         } [EOL]         inputEnd += count; [EOL]     } while (inputEnd < 3); [EOL]     return inputEnd; [EOL] }
private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { [EOL]     int i = 0; [EOL]     while (inputPtr < inputEnd) { [EOL]         readBuffer[i++] = readBuffer[inputPtr++]; [EOL]     } [EOL]     inputPtr = 0; [EOL]     inputEnd = i; [EOL]     maxRead = Math.min(maxRead, readBuffer.length); [EOL]     do { [EOL]         int length = maxRead - inputEnd; [EOL]         if (length == 0) { [EOL]             break; [EOL]         } [EOL]         int count = in.read(readBuffer, inputEnd, length); [EOL]         if (count < 0) { [EOL]             return inputEnd; [EOL]         } [EOL]         inputEnd += count; [EOL]     } while (inputEnd < 3); [EOL]     return inputEnd; [EOL] }
private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { [EOL]     int i = 0; [EOL]     while (inputPtr < inputEnd) { [EOL]         readBuffer[i++] = readBuffer[inputPtr++]; [EOL]     } [EOL]     inputPtr = 0; [EOL]     inputEnd = i; [EOL]     maxRead = Math.min(maxRead, readBuffer.length); [EOL]     do { [EOL]         int length = maxRead - inputEnd; [EOL]         if (length == 0) { [EOL]             break; [EOL]         } [EOL]         int count = in.read(readBuffer, inputEnd, length); [EOL]         if (count < 0) { [EOL]             return inputEnd; [EOL]         } [EOL]         inputEnd += count; [EOL]     } while (inputEnd < 3); [EOL]     return inputEnd; [EOL] }
protected void _flushBuffer() throws IOException { [EOL]     int len = _outputTail - _outputHead; [EOL]     if (len > 0) { [EOL]         int offset = _outputHead; [EOL]         _outputTail = _outputHead = 0; [EOL]         _writer.write(_outputBuffer, offset, len); [EOL]     } [EOL] }
protected void _flushBuffer() throws IOException { [EOL]     int len = _outputTail - _outputHead; [EOL]     if (len > 0) { [EOL]         int offset = _outputHead; [EOL]         _outputTail = _outputHead = 0; [EOL]         _writer.write(_outputBuffer, offset, len); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] encodeAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     int outputEnd = outputBuffer.length; [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         int c = text.charAt(inputPtr++); [EOL]         while (c <= 0x7F) { [EOL]             if (outputPtr >= outputEnd) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputEnd = outputBuffer.length; [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) c; [EOL]             if (inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]             c = text.charAt(inputPtr++); [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } else { [EOL]                 if (c > SURR1_LAST) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 c = _convertSurrogate(c, text.charAt(inputPtr++)); [EOL]                 if (c > 0x10FFFF) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] encodeAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     int outputEnd = outputBuffer.length; [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         int c = text.charAt(inputPtr++); [EOL]         while (c <= 0x7F) { [EOL]             if (outputPtr >= outputEnd) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputEnd = outputBuffer.length; [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) c; [EOL]             if (inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]             c = text.charAt(inputPtr++); [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } else { [EOL]                 if (c > SURR1_LAST) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 c = _convertSurrogate(c, text.charAt(inputPtr++)); [EOL]                 if (c > 0x10FFFF) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] encodeAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     int outputEnd = outputBuffer.length; [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         int c = text.charAt(inputPtr++); [EOL]         while (c <= 0x7F) { [EOL]             if (outputPtr >= outputEnd) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputEnd = outputBuffer.length; [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) c; [EOL]             if (inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]             c = text.charAt(inputPtr++); [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } else { [EOL]                 if (c > SURR1_LAST) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 c = _convertSurrogate(c, text.charAt(inputPtr++)); [EOL]                 if (c > 0x10FFFF) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] encodeAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     int outputEnd = outputBuffer.length; [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         int c = text.charAt(inputPtr++); [EOL]         while (c <= 0x7F) { [EOL]             if (outputPtr >= outputEnd) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputEnd = outputBuffer.length; [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) c; [EOL]             if (inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]             c = text.charAt(inputPtr++); [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } else { [EOL]                 if (c > SURR1_LAST) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 c = _convertSurrogate(c, text.charAt(inputPtr++)); [EOL]                 if (c > 0x10FFFF) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
@SuppressWarnings("resource") [EOL] public byte[] encodeAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     int outputEnd = outputBuffer.length; [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         int c = text.charAt(inputPtr++); [EOL]         while (c <= 0x7F) { [EOL]             if (outputPtr >= outputEnd) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputEnd = outputBuffer.length; [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) c; [EOL]             if (inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]             c = text.charAt(inputPtr++); [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } else { [EOL]                 if (c > SURR1_LAST) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 c = _convertSurrogate(c, text.charAt(inputPtr++)); [EOL]                 if (c > 0x10FFFF) { [EOL]                     _illegalSurrogate(c); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputEnd) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputEnd = outputBuffer.length; [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputEnd) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputEnd = outputBuffer.length; [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public JsonFactory disable(JsonParser.Feature f) { [EOL]     _parserFeatures &= ~f.getMask(); [EOL]     return this; [EOL] }
public JsonFactory disable(JsonParser.Feature f) { [EOL]     _parserFeatures &= ~f.getMask(); [EOL]     return this; [EOL] }
public JsonFactory setInputDecorator(InputDecorator d) { [EOL]     _inputDecorator = d; [EOL]     return this; [EOL] }
public JsonFactory setInputDecorator(InputDecorator d) { [EOL]     _inputDecorator = d; [EOL]     return this; [EOL] }
public JsonFactory setRootValueSeparator(String sep) { [EOL]     _rootValueSeparator = (sep == null) ? null : new SerializedString(sep); [EOL]     return this; [EOL] }
public JsonFactory setRootValueSeparator(String sep) { [EOL]     _rootValueSeparator = (sep == null) ? null : new SerializedString(sep); [EOL]     return this; [EOL] }
public JsonParser createParser(InputStream in) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(in, false); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(InputStream in) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(in, false); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(InputStream in) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(in, false); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(Reader r) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(r, false); [EOL]     if (_inputDecorator != null) { [EOL]         r = _inputDecorator.decorate(ctxt, r); [EOL]     } [EOL]     return _createParser(r, ctxt); [EOL] }
public JsonParser createParser(Reader r) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(r, false); [EOL]     if (_inputDecorator != null) { [EOL]         r = _inputDecorator.decorate(ctxt, r); [EOL]     } [EOL]     return _createParser(r, ctxt); [EOL] }
public JsonParser createParser(Reader r) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(r, false); [EOL]     if (_inputDecorator != null) { [EOL]         r = _inputDecorator.decorate(ctxt, r); [EOL]     } [EOL]     return _createParser(r, ctxt); [EOL] }
public JsonParser createParser(byte[] data) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, 0, data.length, ctxt); [EOL] }
public JsonParser createParser(byte[] data) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, 0, data.length, ctxt); [EOL] }
public JsonParser createParser(byte[] data) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, 0, data.length, ctxt); [EOL] }
public JsonParser createParser(byte[] data) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, 0, data.length, ctxt); [EOL] }
