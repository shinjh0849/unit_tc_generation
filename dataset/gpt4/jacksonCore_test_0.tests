public void testCoreVersions() throws Exception { [EOL]     assertVersion(new JsonFactory().version()); [EOL]     JsonParser jp = new ReaderBasedJsonParser(getIOContext(), 0, null, null, CharsToNameCanonicalizer.createRoot()); [EOL]     assertVersion(jp.version()); [EOL]     jp.close(); [EOL]     JsonGenerator jgen = new WriterBasedJsonGenerator(getIOContext(), 0, null, null); [EOL]     assertVersion(jgen.version()); [EOL]     jgen.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testSimpleObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeFieldName("first"); [EOL]     gen.writeNumber(-901); [EOL]     gen.writeFieldName("sec"); [EOL]     gen.writeBoolean(false); [EOL]     gen.writeFieldName("3rd!"); [EOL]     gen.writeString("yee-haw"); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("first", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(-901, jp.getIntValue()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("sec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("3rd!", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("yee-haw", jp.getText()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleObjectWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartObject(); [EOL]     gen.writeFieldName("first"); [EOL]     gen.writeNumber(-901); [EOL]     gen.writeFieldName("sec"); [EOL]     gen.writeBoolean(false); [EOL]     gen.writeFieldName("3rd!"); [EOL]     gen.writeString("yee-haw"); [EOL]     gen.writeEndObject(); [EOL]     gen.close(); [EOL]     String docStr = sw.toString(); [EOL]     JsonParser jp = createParserUsingReader(docStr); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("first", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(-901, jp.getIntValue()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("sec", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertEquals(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     assertEquals("3rd!", jp.getText()); [EOL]     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("yee-haw", jp.getText()); [EOL]     assertEquals(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     assertEquals(null, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testIntParsingWithStrings() throws Exception { [EOL]     assertEquals(3, NumberInput.parseInt("3")); [EOL]     assertEquals(0, NumberInput.parseInt("0")); [EOL]     assertEquals(-3, NumberInput.parseInt("-3")); [EOL]     assertEquals(27, NumberInput.parseInt("27")); [EOL]     assertEquals(-31, NumberInput.parseInt("-31")); [EOL]     assertEquals(271, NumberInput.parseInt("271")); [EOL]     assertEquals(-131, NumberInput.parseInt("-131")); [EOL]     assertEquals(2709, NumberInput.parseInt("2709")); [EOL]     assertEquals(-9999, NumberInput.parseInt("-9999")); [EOL]     assertEquals(Integer.MIN_VALUE, NumberInput.parseInt("" + Integer.MIN_VALUE)); [EOL]     assertEquals(Integer.MAX_VALUE, NumberInput.parseInt("" + Integer.MAX_VALUE)); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testReleaseContentBytes() throws Exception { [EOL]     byte[] input = "[1]foobar".getBytes("UTF-8"); [EOL]     JsonParser jp = new JsonFactory().createParser(input); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     assertEquals(6, jp.releaseBuffered(out)); [EOL]     assertArrayEquals("foobar".getBytes("UTF-8"), out.toByteArray()); [EOL]     jp.close(); [EOL] }
public void testReleaseContentBytes() throws Exception { [EOL]     byte[] input = "[1]foobar".getBytes("UTF-8"); [EOL]     JsonParser jp = new JsonFactory().createParser(input); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL]     assertEquals(6, jp.releaseBuffered(out)); [EOL]     assertArrayEquals("foobar".getBytes("UTF-8"), out.toByteArray()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testLeadingZeroesUTF8() throws Exception { [EOL]     _testLeadingZeroes(true, false); [EOL]     _testLeadingZeroes(true, true); [EOL] }
public void testUtf8Name3Bytes() throws Exception { [EOL]     final String[] NAMES = UTF8_3BYTE_STRINGS; [EOL]     for (int i = 0; i < NAMES.length; ++i) { [EOL]         String NAME = NAMES[i]; [EOL]         String DOC = "{ \"" + NAME + "\" : true }"; [EOL]         JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8Name3Bytes() throws Exception { [EOL]     final String[] NAMES = UTF8_3BYTE_STRINGS; [EOL]     for (int i = 0; i < NAMES.length; ++i) { [EOL]         String NAME = NAMES[i]; [EOL]         String DOC = "{ \"" + NAME + "\" : true }"; [EOL]         JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8Name3Bytes() throws Exception { [EOL]     final String[] NAMES = UTF8_3BYTE_STRINGS; [EOL]     for (int i = 0; i < NAMES.length; ++i) { [EOL]         String NAME = NAMES[i]; [EOL]         String DOC = "{ \"" + NAME + "\" : true }"; [EOL]         JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testUtf8Name2Bytes() throws Exception { [EOL]     final String[] NAMES = UTF8_2BYTE_STRINGS; [EOL]     for (int i = 0; i < NAMES.length; ++i) { [EOL]         String NAME = NAMES[i]; [EOL]         String DOC = "{ \"" + NAME + "\" : 0 }"; [EOL]         JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testUtf8Name2Bytes() throws Exception { [EOL]     final String[] NAMES = UTF8_2BYTE_STRINGS; [EOL]     for (int i = 0; i < NAMES.length; ++i) { [EOL]         String NAME = NAMES[i]; [EOL]         String DOC = "{ \"" + NAME + "\" : 0 }"; [EOL]         JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testAllocations() throws Exception { [EOL]     IOContext ctxt = new IOContext(new BufferRecycler(), "N/A", true); [EOL]     assertNotNull(ctxt.allocReadIOBuffer()); [EOL]     try { [EOL]         ctxt.allocReadIOBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseReadIOBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseReadIOBuffer(null); [EOL]     assertNotNull(ctxt.allocWriteEncodingBuffer()); [EOL]     try { [EOL]         ctxt.allocWriteEncodingBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseWriteEncodingBuffer(new byte[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseWriteEncodingBuffer(null); [EOL]     assertNotNull(ctxt.allocTokenBuffer()); [EOL]     try { [EOL]         ctxt.allocTokenBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseTokenBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseTokenBuffer(null); [EOL]     assertNotNull(ctxt.allocConcatBuffer()); [EOL]     try { [EOL]         ctxt.allocConcatBuffer(); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseConcatBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseConcatBuffer(null); [EOL]     assertNotNull(ctxt.allocNameCopyBuffer(100)); [EOL]     try { [EOL]         ctxt.allocNameCopyBuffer(100); [EOL]     } catch (IllegalStateException e) { [EOL]         verifyException(e, "second time"); [EOL]     } [EOL]     try { [EOL]         ctxt.releaseNameCopyBuffer(new char[1]); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "not owned"); [EOL]     } [EOL]     ctxt.releaseNameCopyBuffer(null); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testCoreVersions() throws Exception { [EOL]     assertVersion(new JsonFactory().version()); [EOL]     JsonParser jp = new ReaderBasedJsonParser(getIOContext(), 0, null, null, CharsToNameCanonicalizer.createRoot()); [EOL]     assertVersion(jp.version()); [EOL]     jp.close(); [EOL]     JsonGenerator jgen = new WriterBasedJsonGenerator(getIOContext(), 0, null, null); [EOL]     assertVersion(jgen.version()); [EOL]     jgen.close(); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLongAppend() { [EOL]     final int len = TextBuffer.MAX_SEGMENT_LEN * 3 / 2; [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         sb.append('x'); [EOL]     } [EOL]     final String STR = sb.toString(); [EOL]     final String EXP = "a" + STR + "c"; [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR, 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL]     tb = new TextBuffer(new BufferRecycler()); [EOL]     tb.append('a'); [EOL]     tb.append(STR.toCharArray(), 0, len); [EOL]     tb.append('c'); [EOL]     assertEquals(len + 2, tb.size()); [EOL]     assertEquals(EXP, tb.contentsAsString()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testLonger() { [EOL]     TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL]     for (int i = 0; i < 2000; ++i) { [EOL]         tb.append("abc", 0, 3); [EOL]     } [EOL]     String str = tb.contentsAsString(); [EOL]     assertEquals(6000, str.length()); [EOL]     assertEquals(6000, tb.contentsAsArray().length); [EOL]     tb.resetWithShared(new char[] { 'a' }, 0, 1); [EOL]     assertEquals(1, tb.toString().length()); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testUtf8RawStrings() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 750000, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeRawUTF8String(str, 0, str.length); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8RawStrings() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 750000, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeRawUTF8String(str, 0, str.length); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8RawStrings() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 750000, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeRawUTF8String(str, 0, str.length); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8RawStrings() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 750000, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeRawUTF8String(str, 0, str.length); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8RawStrings() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 750000, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeRawUTF8String(str, 0, str.length); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testUtf8RawStrings() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 750000, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeRawUTF8String(str, 0, str.length); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testUtf8RawStrings() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 750000, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeRawUTF8String(str, 0, str.length); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testUtf8RawStrings() throws Exception { [EOL]     List<byte[]> strings = generateStrings(new Random(28), 750000, false); [EOL]     ByteArrayOutputStream out = new ByteArrayOutputStream(16000); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jgen = jf.createGenerator(out, JsonEncoding.UTF8); [EOL]     jgen.writeStartArray(); [EOL]     for (byte[] str : strings) { [EOL]         jgen.writeRawUTF8String(str, 0, str.length); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL]     jgen.close(); [EOL]     byte[] json = out.toByteArray(); [EOL]     JsonParser jp = jf.createParser(json); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     for (byte[] inputBytes : strings) { [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String string = jp.getText(); [EOL]         byte[] outputBytes = string.getBytes("UTF-8"); [EOL]         assertEquals(inputBytes.length, outputBytes.length); [EOL]         assertArrayEquals(inputBytes, outputBytes); [EOL]     } [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testBase64Variant() throws Exception { [EOL]     Base64Variant orig = Base64Variants.PEM; [EOL]     byte[] stuff = jdkSerialize(orig); [EOL]     Base64Variant back = jdkDeserialize(stuff); [EOL]     assertSame(orig, back); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] }
public void testLeadingZeroesReader() throws Exception { [EOL]     _testLeadingZeroes(false, false); [EOL]     _testLeadingZeroes(false, true); [EOL] }
public void testQuotesRequired() throws Exception { [EOL]     _testQuotesRequired(false); [EOL]     _testQuotesRequired(true); [EOL] }
public void testQuotesRequired() throws Exception { [EOL]     _testQuotesRequired(false); [EOL]     _testQuotesRequired(true); [EOL] }
public void testQuotesRequired() throws Exception { [EOL]     _testQuotesRequired(false); [EOL]     _testQuotesRequired(true); [EOL] }
public void testQuotesRequired() throws Exception { [EOL]     _testQuotesRequired(false); [EOL]     _testQuotesRequired(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testInvalidArrayWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     try { [EOL]         gen.writeEndObject(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an object"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testInvalidArrayWrite() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]     gen.writeStartArray(); [EOL]     try { [EOL]         gen.writeEndObject(); [EOL]         fail("Expected an exception for mismatched array/object write"); [EOL]     } catch (JsonGenerationException e) { [EOL]         verifyException(e, "Current context not an object"); [EOL]     } [EOL]     gen.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testCommentsEnabled() throws Exception { [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false); [EOL]     _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true); [EOL]     _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true); [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testLongerRandomMultiChunk() throws Exception { [EOL]     for (int round = 0; round < 70; ++round) { [EOL]         String content = generateRandom(73000 + round); [EOL]         doTestLongerRandomMulti(content, false, round); [EOL]         doTestLongerRandomMulti(content, true, round); [EOL]     } [EOL] }
public void testQuoteAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     char[] result = encoder.quoteAsString("foobar"); [EOL]     assertArrayEquals("foobar".toCharArray(), result); [EOL]     result = encoder.quoteAsString("\"x\""); [EOL]     assertArrayEquals("\\\"x\\\"".toCharArray(), result); [EOL] }
public void testQuoteAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     char[] result = encoder.quoteAsString("foobar"); [EOL]     assertArrayEquals("foobar".toCharArray(), result); [EOL]     result = encoder.quoteAsString("\"x\""); [EOL]     assertArrayEquals("\\\"x\\\"".toCharArray(), result); [EOL] }
public void testQuoteAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     char[] result = encoder.quoteAsString("foobar"); [EOL]     assertArrayEquals("foobar".toCharArray(), result); [EOL]     result = encoder.quoteAsString("\"x\""); [EOL]     assertArrayEquals("\\\"x\\\"".toCharArray(), result); [EOL] }
public void testQuoteAsString() throws Exception { [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     char[] result = encoder.quoteAsString("foobar"); [EOL]     assertArrayEquals("foobar".toCharArray(), result); [EOL]     result = encoder.quoteAsString("\"x\""); [EOL]     assertArrayEquals("\\\"x\\\"".toCharArray(), result); [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testQuoteAsUTF8() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     JsonStringEncoder encoder = new JsonStringEncoder(); [EOL]     int[] lengths = new int[] { 5, 19, 200, 7000, 21000, 37000 }; [EOL]     for (int length : lengths) { [EOL]         String str = generateRandom(length); [EOL]         StringWriter sw = new StringWriter(length * 2); [EOL]         JsonGenerator jgen = f.createGenerator(sw); [EOL]         jgen.writeString(str); [EOL]         jgen.close(); [EOL]         String encoded = sw.toString(); [EOL]         encoded = encoded.substring(1, encoded.length() - 1); [EOL]         byte[] expected = encoded.getBytes("UTF-8"); [EOL]         byte[] actual = encoder.quoteAsUTF8(str); [EOL]         assertArrayEquals(expected, actual); [EOL]     } [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testTokenAccess() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     _testTokenAccess(jf, false); [EOL]     _testTokenAccess(jf, true); [EOL] }
public void testInvalidMissingFieldName() throws Exception { [EOL]     final String DOC = "[  : 3 ] "; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected a parsing error for odd character"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "Unexpected character"); [EOL]     } [EOL]     jp.close(); [EOL] }
public void testUnclosedArray() throws Exception { [EOL]     @SuppressWarnings("resource") [EOL]     JsonParser jp = createParserUsingReader("[ 1, 2"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         fail("Expected an exception for unclosed ARRAY"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "expected close marker for ARRAY"); [EOL]     } [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testTabsDefault() throws Exception { [EOL]     _testTabsDefault(false); [EOL]     _testTabsDefault(true); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testConfigDefaults() throws IOException { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonGenerator jg = jf.createGenerator(new StringWriter()); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL]     assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL]     jg.close(); [EOL] }
public void testCopy() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL]     jf.enable(JsonParser.Feature.ALLOW_COMMENTS); [EOL]     jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII); [EOL]     assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     JsonFactory jf2 = jf.copy(); [EOL]     assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL] }
public void testCopy() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL]     jf.enable(JsonParser.Feature.ALLOW_COMMENTS); [EOL]     jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII); [EOL]     assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     JsonFactory jf2 = jf.copy(); [EOL]     assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL] }
public void testCopy() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL]     jf.enable(JsonParser.Feature.ALLOW_COMMENTS); [EOL]     jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII); [EOL]     assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     JsonFactory jf2 = jf.copy(); [EOL]     assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testSimpleValidArray() throws Exception { [EOL]     JsonFactory jsonF = new JsonFactory(); [EOL]     DataFormatDetector detector = new DataFormatDetector(jsonF); [EOL]     final String ARRAY_JSON = "[ 1, 2 ]"; [EOL]     DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes("UTF-8"))); [EOL]     assertTrue(matcher.hasMatch()); [EOL]     assertEquals("JSON", matcher.getMatchedFormatName()); [EOL]     assertSame(jsonF, matcher.getMatch()); [EOL]     assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL]     JsonParser jp = matcher.createParserWithMatch(); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] }
public void testCopy() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL]     jf.enable(JsonParser.Feature.ALLOW_COMMENTS); [EOL]     jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII); [EOL]     assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     JsonFactory jf2 = jf.copy(); [EOL]     assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL] }
public void testCopy() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL]     jf.enable(JsonParser.Feature.ALLOW_COMMENTS); [EOL]     jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII); [EOL]     assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     JsonFactory jf2 = jf.copy(); [EOL]     assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL] }
public void testCopy() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL]     jf.enable(JsonParser.Feature.ALLOW_COMMENTS); [EOL]     jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII); [EOL]     assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL]     JsonFactory jf2 = jf.copy(); [EOL]     assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL]     assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL] }
public void testGeneratorFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL] }
public void testGeneratorFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL] }
public void testGeneratorFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL] }
public void testGeneratorFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL] }
public void testGeneratorFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL] }
public void testGeneratorFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL] }
public void testGeneratorFeatures() throws Exception { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     assertNull(f.getCodec()); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true); [EOL]     assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL]     f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false); [EOL]     assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES)); [EOL] }
public void testUtf8Name2Bytes() throws Exception { [EOL]     final String[] NAMES = UTF8_2BYTE_STRINGS; [EOL]     for (int i = 0; i < NAMES.length; ++i) { [EOL]         String NAME = NAMES[i]; [EOL]         String DOC = "{ \"" + NAME + "\" : 0 }"; [EOL]         JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(NAME, jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] }
