public CoreFunction(int functionCode, Expression[] args) { [EOL]     super(args); [EOL]     this.functionCode = functionCode; [EOL] }
public Expression getArg1() { [EOL]     return args[0]; [EOL] }
public Expression getArg1() { [EOL]     return args[0]; [EOL] }
public Expression getArg1() { [EOL]     return args[0]; [EOL] }
public Expression getArg2() { [EOL]     return args[1]; [EOL] }
public Expression getArg3() { [EOL]     return args[2]; [EOL] }
public Expression getArg3() { [EOL]     return args[2]; [EOL] }
public int getArgumentCount() { [EOL]     if (args == null) { [EOL]         return 0; [EOL]     } [EOL]     return args.length; [EOL] }
public int getArgumentCount() { [EOL]     if (args == null) { [EOL]         return 0; [EOL]     } [EOL]     return args.length; [EOL] }
public int getArgumentCount() { [EOL]     if (args == null) { [EOL]         return 0; [EOL]     } [EOL]     return args.length; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
protected Object functionName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().toString(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().toString(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().toString(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().toString(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().toString(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().toString(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
private Object functionFormatNumber(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     double number = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     String pattern = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     DecimalFormatSymbols symbols = null; [EOL]     if (ac == 3) { [EOL]         String symbolsName = InfoSetUtil.stringValue(getArg3().computeValue(context)); [EOL]         symbols = context.getJXPathContext().getDecimalFormatSymbols(symbolsName); [EOL]     } else { [EOL]         NodePointer pointer = context.getCurrentNodePointer(); [EOL]         Locale locale; [EOL]         if (pointer != null) { [EOL]             locale = pointer.getLocale(); [EOL]         } else { [EOL]             locale = context.getJXPathContext().getLocale(); [EOL]         } [EOL]         symbols = new DecimalFormatSymbols(locale); [EOL]     } [EOL]     DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(); [EOL]     format.setDecimalFormatSymbols(symbols); [EOL]     format.applyLocalizedPattern(pattern); [EOL]     return format.format(number); [EOL] }
private Object functionFormatNumber(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     double number = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     String pattern = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     DecimalFormatSymbols symbols = null; [EOL]     if (ac == 3) { [EOL]         String symbolsName = InfoSetUtil.stringValue(getArg3().computeValue(context)); [EOL]         symbols = context.getJXPathContext().getDecimalFormatSymbols(symbolsName); [EOL]     } else { [EOL]         NodePointer pointer = context.getCurrentNodePointer(); [EOL]         Locale locale; [EOL]         if (pointer != null) { [EOL]             locale = pointer.getLocale(); [EOL]         } else { [EOL]             locale = context.getJXPathContext().getLocale(); [EOL]         } [EOL]         symbols = new DecimalFormatSymbols(locale); [EOL]     } [EOL]     DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(); [EOL]     format.setDecimalFormatSymbols(symbols); [EOL]     format.applyLocalizedPattern(pattern); [EOL]     return format.format(number); [EOL] }
private Object functionFormatNumber(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     double number = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     String pattern = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     DecimalFormatSymbols symbols = null; [EOL]     if (ac == 3) { [EOL]         String symbolsName = InfoSetUtil.stringValue(getArg3().computeValue(context)); [EOL]         symbols = context.getJXPathContext().getDecimalFormatSymbols(symbolsName); [EOL]     } else { [EOL]         NodePointer pointer = context.getCurrentNodePointer(); [EOL]         Locale locale; [EOL]         if (pointer != null) { [EOL]             locale = pointer.getLocale(); [EOL]         } else { [EOL]             locale = context.getJXPathContext().getLocale(); [EOL]         } [EOL]         symbols = new DecimalFormatSymbols(locale); [EOL]     } [EOL]     DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(); [EOL]     format.setDecimalFormatSymbols(symbols); [EOL]     format.applyLocalizedPattern(pattern); [EOL]     return format.format(number); [EOL] }
private Object functionFormatNumber(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     double number = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     String pattern = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     DecimalFormatSymbols symbols = null; [EOL]     if (ac == 3) { [EOL]         String symbolsName = InfoSetUtil.stringValue(getArg3().computeValue(context)); [EOL]         symbols = context.getJXPathContext().getDecimalFormatSymbols(symbolsName); [EOL]     } else { [EOL]         NodePointer pointer = context.getCurrentNodePointer(); [EOL]         Locale locale; [EOL]         if (pointer != null) { [EOL]             locale = pointer.getLocale(); [EOL]         } else { [EOL]             locale = context.getJXPathContext().getLocale(); [EOL]         } [EOL]         symbols = new DecimalFormatSymbols(locale); [EOL]     } [EOL]     DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(); [EOL]     format.setDecimalFormatSymbols(symbols); [EOL]     format.applyLocalizedPattern(pattern); [EOL]     return format.format(number); [EOL] }
public JDOMNodePointer(Object node, Locale locale) { [EOL]     super(null, locale); [EOL]     this.node = node; [EOL] }
public JDOMNodePointer(Object node, Locale locale) { [EOL]     super(null, locale); [EOL]     this.node = node; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL]     Object node1 = pointer1.getBaseValue(); [EOL]     Object node2 = pointer2.getBaseValue(); [EOL]     if (node1 == node2) { [EOL]         return 0; [EOL]     } [EOL]     if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) { [EOL]         return -1; [EOL]     } else if (!(node1 instanceof Attribute) && (node2 instanceof Attribute)) { [EOL]         return 1; [EOL]     } else if ((node1 instanceof Attribute) && (node2 instanceof Attribute)) { [EOL]         List list = ((Element) getNode()).getAttributes(); [EOL]         int length = list.size(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             Object n = list.get(i); [EOL]             if (n == node1) { [EOL]                 return -1; [EOL]             } else if (n == node2) { [EOL]                 return 1; [EOL]             } [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (!(node instanceof Element)) { [EOL]         throw new RuntimeException("JXPath internal error: " + "compareChildNodes called for " + node); [EOL]     } [EOL]     List children = ((Element) node).getContent(); [EOL]     int length = children.size(); [EOL]     for (int i = 0; i < length; i++) { [EOL]         Object n = children.get(i); [EOL]         if (n == node1) { [EOL]             return -1; [EOL]         } else if (n == node2) { [EOL]             return 1; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public Object getBaseValue() { [EOL]     return node; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof JDOMNodePointer)) { [EOL]         return false; [EOL]     } [EOL]     JDOMNodePointer other = (JDOMNodePointer) object; [EOL]     return node == other.node; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof JDOMNodePointer)) { [EOL]         return false; [EOL]     } [EOL]     JDOMNodePointer other = (JDOMNodePointer) object; [EOL]     return node == other.node; [EOL] }
public JXPathTypeConversionException(String message) { [EOL]     super(message); [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
private String unescape(String string) { [EOL]     int index = string.indexOf("&apos;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\'" + string.substring(index + 6); [EOL]         index = string.indexOf("&apos;"); [EOL]     } [EOL]     index = string.indexOf("&quot;"); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "\"" + string.substring(index + 6); [EOL]         index = string.indexOf("&quot;"); [EOL]     } [EOL]     return string; [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName_Without_CoreFunctions() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     if (jj_2_1(2147483647)) { [EOL]         nc1 = NCName(); [EOL]         jj_consume_token(79); [EOL]         nc2 = NCName(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NCName: [EOL]                 nc1 = NCName_Without_CoreFunctions(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[4] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName_Without_CoreFunctions() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     if (jj_2_1(2147483647)) { [EOL]         nc1 = NCName(); [EOL]         jj_consume_token(79); [EOL]         nc2 = NCName(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NCName: [EOL]                 nc1 = NCName_Without_CoreFunctions(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[4] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName_Without_CoreFunctions() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     if (jj_2_1(2147483647)) { [EOL]         nc1 = NCName(); [EOL]         jj_consume_token(79); [EOL]         nc2 = NCName(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NCName: [EOL]                 nc1 = NCName_Without_CoreFunctions(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[4] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object QName_Without_CoreFunctions() throws ParseException { [EOL]     String nc1, nc2 = null; [EOL]     if (jj_2_1(2147483647)) { [EOL]         nc1 = NCName(); [EOL]         jj_consume_token(79); [EOL]         nc2 = NCName(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NCName: [EOL]                 nc1 = NCName_Without_CoreFunctions(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[4] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     if (nc2 == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(null, nc1); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.qname(nc1, nc2); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AbsoluteLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     if (jj_2_2(2147483647)) { [EOL]         LocationStep(steps); [EOL]         label_1: while (true) { [EOL]             switch(jj_nt.kind) { [EOL]                 case SLASH: [EOL]                 case SLASHSLASH: [EOL]                     ; [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[6] = jj_gen; [EOL]                     break label_1; [EOL]             } [EOL]             LocationStep(steps); [EOL]         } [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]                 jj_consume_token(SLASH); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[7] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(true, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AbsoluteLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     if (jj_2_2(2147483647)) { [EOL]         LocationStep(steps); [EOL]         label_1: while (true) { [EOL]             switch(jj_nt.kind) { [EOL]                 case SLASH: [EOL]                 case SLASHSLASH: [EOL]                     ; [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[6] = jj_gen; [EOL]                     break label_1; [EOL]             } [EOL]             LocationStep(steps); [EOL]         } [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]                 jj_consume_token(SLASH); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[7] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(true, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AbsoluteLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     if (jj_2_2(2147483647)) { [EOL]         LocationStep(steps); [EOL]         label_1: while (true) { [EOL]             switch(jj_nt.kind) { [EOL]                 case SLASH: [EOL]                 case SLASHSLASH: [EOL]                     ; [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[6] = jj_gen; [EOL]                     break label_1; [EOL]             } [EOL]             LocationStep(steps); [EOL]         } [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]                 jj_consume_token(SLASH); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[7] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(true, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public void NodeTest(ArrayList steps) throws ParseException { [EOL]     int axis; [EOL]     int type = -1; [EOL]     String instruction = null; [EOL]     Object name = null; [EOL]     Object s; [EOL]     Object p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 86: [EOL]         case 88: [EOL]             axis = AxisSpecifier(); [EOL]             if (jj_2_3(2147483647)) { [EOL]                 type = NodeType(); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(81); [EOL]             } else if (jj_2_4(2147483647)) { [EOL]                 jj_consume_token(PI); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(Literal); [EOL]                 instruction = unescape(token.image.substring(1, token.image.length() - 1)); [EOL]                 jj_consume_token(81); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                     case 88: [EOL]                         name = WildcardName(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[10] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case 82: [EOL]             jj_consume_token(82); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case 83: [EOL]             jj_consume_token(83); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[11] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     label_3: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[12] = jj_gen; [EOL]                 break label_3; [EOL]         } [EOL]         p = Predicate(); [EOL]         ps.add(p); [EOL]     } [EOL]     if (name != null) { [EOL]         s = compiler.nodeNameTest(name); [EOL]     } else if (instruction != null) { [EOL]         s = compiler.processingInstructionTest(instruction); [EOL]     } else { [EOL]         s = compiler.nodeTypeTest(type); [EOL]     } [EOL]     steps.add(compiler.step(axis, s, ps.toArray())); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object MultiplicativeExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = UnaryExpr(); [EOL]     label_14: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case MOD: [EOL]             case DIV: [EOL]             case 88: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[32] = jj_gen; [EOL]                 break label_14; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case 88: [EOL]                 jj_consume_token(88); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.multiply(ex, r); [EOL]                 break; [EOL]             case DIV: [EOL]                 jj_consume_token(DIV); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.divide(ex, r); [EOL]                 break; [EOL]             case MOD: [EOL]                 jj_consume_token(MOD); [EOL]                 r = UnaryExpr(); [EOL]                 ex = compiler.mod(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[33] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final private boolean jj_3R_45() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_45() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_45() { [EOL]     if (jj_scan_token(FUNCTION_FALSE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_142() { [EOL]     if (jj_scan_token(AXIS_PARENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_142() { [EOL]     if (jj_scan_token(AXIS_PARENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_142() { [EOL]     if (jj_scan_token(AXIS_PARENT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_192() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_192() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_192() { [EOL]     if (jj_scan_token(SLASH)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
private static void jj_la1_0() { [EOL]     jj_la1_0 = new int[] { 0xf8000000, 0x78000000, 0x0, 0x0, 0x78000000, 0xf80000c0, 0xc0, 0x40, 0xc0, 0xc0, 0xf8000000, 0xf8000000, 0x0, 0x0, 0x0, 0x0, 0x160000, 0xf8000000, 0x0, 0xf81604c0, 0x100, 0xf80000c0, 0x0, 0xc0, 0x8000000, 0x10000000, 0x1800, 0x1800, 0x1e000, 0x1e000, 0x200, 0x400, 0x60000000, 0x60000000, 0xf81604c0, 0xf8000000, 0xf8000000, 0x0, 0x80000000 }; [EOL] }
private static void jj_la1_1() { [EOL]     jj_la1_1 = new int[] { 0xffff0007, 0x0, 0xffff0000, 0x0, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0xffff0007, 0xffffffff, 0x0, 0xfff8, 0xfff8, 0x0, 0x0, 0xffff0007, 0x0, 0xffffffff, 0x0, 0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffffff, 0xffff0007, 0xffff0007, 0x0, 0x7 }; [EOL] }
private static void jj_la1_2() { [EOL]     jj_la1_2 = new int[] { 0x7fff, 0x4000, 0x3fff, 0x8000, 0x4000, 0x14c7fff, 0x0, 0x0, 0x0, 0x0, 0x1007fff, 0x14c7fff, 0x100000, 0x0, 0x0, 0x400000, 0x10000, 0x7fff, 0x800000, 0x14d7fff, 0x0, 0x14c7fff, 0x100000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1000000, 0x1000000, 0x14d7fff, 0x1007fff, 0x1007fff, 0x8000, 0x0 }; [EOL] }
public XPathParser(java.io.Reader stream) { [EOL]     jj_input_stream = new SimpleCharStream(stream, 1, 1); [EOL]     token_source = new XPathParserTokenManager(jj_input_stream); [EOL]     token = new Token(); [EOL]     token.next = jj_nt = token_source.getNextToken(); [EOL]     jj_gen = 0; [EOL]     for (int i = 0; i < 39; i++) jj_la1[i] = -1; [EOL]     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls(); [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
private String parenthesize(Expression expression, boolean left) { [EOL]     if (!(expression instanceof CoreOperation)) { [EOL]         return expression.toString(); [EOL]     } [EOL]     CoreOperation op = (CoreOperation) expression; [EOL]     int myPrecedence = getPrecedence(); [EOL]     int thePrecedence = op.getPrecedence(); [EOL]     boolean needParens = true; [EOL]     if (myPrecedence < thePrecedence) { [EOL]         needParens = false; [EOL]     } else if (myPrecedence == thePrecedence) { [EOL]         if (isSymmetric()) { [EOL]             needParens = false; [EOL]         } else { [EOL]             needParens = !left; [EOL]         } [EOL]     } [EOL]     if (needParens) { [EOL]         return "(" + expression.toString() + ")"; [EOL]     } else { [EOL]         return expression.toString(); [EOL]     } [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static NodePointer interpretSimpleLocationPath(EvalContext context, NodePointer root, Step[] steps) { [EOL]     NodePointer pointer = doStep(context, root, steps, 0); [EOL]     return pointer; [EOL] }
public static NodePointer interpretSimpleLocationPath(EvalContext context, NodePointer root, Step[] steps) { [EOL]     NodePointer pointer = doStep(context, root, steps, 0); [EOL]     return pointer; [EOL] }
private static NodePointer doStep(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     if (parent == null) { [EOL]         return null; [EOL]     } [EOL]     if (currentStep == steps.length) { [EOL]         return parent; [EOL]     } [EOL]     parent = valuePointer(parent); [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     if (parent instanceof PropertyOwnerPointer) { [EOL]         if (predicates == null || predicates.length == 0) { [EOL]             return doStepNoPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL]         } else { [EOL]             return doStepPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL]         } [EOL]     } else { [EOL]         if (predicates == null || predicates.length == 0) { [EOL]             return doStepNoPredicatesStandard(context, parent, steps, currentStep); [EOL]         } else { [EOL]             return doStepPredicatesStandard(context, parent, steps, currentStep); [EOL]         } [EOL]     } [EOL] }
private static NodePointer doStepNoPredicatesPropertyOwner(EvalContext context, PropertyOwnerPointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     NodePointer childPointer = createChildPointerForStep(parentPointer, step); [EOL]     if (!childPointer.isActual()) { [EOL]         return createNullPointer(context, parentPointer, steps, currentStep); [EOL]     } else if (currentStep == steps.length - 1) { [EOL]         return childPointer; [EOL]     } else if (childPointer.isCollection()) { [EOL]         int bestQuality = 0; [EOL]         childPointer = (NodePointer) childPointer.clone(); [EOL]         NodePointer bestMatch = null; [EOL]         int count = childPointer.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             childPointer.setIndex(i); [EOL]             NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1); [EOL]             int quality = computeQuality(pointer); [EOL]             if (quality == PERFECT_MATCH) { [EOL]                 return pointer; [EOL]             } else if (quality > bestQuality) { [EOL]                 bestQuality = quality; [EOL]                 bestMatch = (NodePointer) pointer.clone(); [EOL]             } [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             return bestMatch; [EOL]         } [EOL]         return createNullPointer(context, childPointer, steps, currentStep); [EOL]     } else { [EOL]         return doStep(context, childPointer, steps, currentStep + 1); [EOL]     } [EOL] }
private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     if (step.getAxis() == Compiler.AXIS_SELF) { [EOL]         return doStep(context, parentPointer, steps, currentStep + 1); [EOL]     } [EOL]     int bestQuality = 0; [EOL]     NodePointer bestMatch = null; [EOL]     NodeIterator it = getNodeIterator(context, parentPointer, step); [EOL]     if (it != null) { [EOL]         for (int i = 1; it.setPosition(i); i++) { [EOL]             NodePointer childPointer = it.getNodePointer(); [EOL]             if (steps.length == currentStep + 1) { [EOL]                 return childPointer; [EOL]             } [EOL]             NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1); [EOL]             int quality = computeQuality(pointer); [EOL]             if (quality == PERFECT_MATCH) { [EOL]                 return pointer; [EOL]             } else if (quality > bestQuality) { [EOL]                 bestQuality = quality; [EOL]                 bestMatch = (NodePointer) pointer.clone(); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         return bestMatch; [EOL]     } [EOL]     return createNullPointer(context, parentPointer, steps, currentStep); [EOL] }
private static NodePointer doStepPredicatesPropertyOwner(EvalContext context, PropertyOwnerPointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     NodePointer childPointer = createChildPointerForStep(parentPointer, step); [EOL]     if (!childPointer.isActual()) { [EOL]         return createNullPointer(context, parentPointer, steps, currentStep); [EOL]     } [EOL]     return doPredicate(context, childPointer, steps, currentStep, predicates, 0); [EOL] }
private static NodePointer doStepPredicatesPropertyOwner(EvalContext context, PropertyOwnerPointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     NodePointer childPointer = createChildPointerForStep(parentPointer, step); [EOL]     if (!childPointer.isActual()) { [EOL]         return createNullPointer(context, parentPointer, steps, currentStep); [EOL]     } [EOL]     return doPredicate(context, childPointer, steps, currentStep, predicates, 0); [EOL] }
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] }
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] }
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] }
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] }
private static NodePointer doPredicate(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (currentPredicate == predicates.length) { [EOL]         return doStep(context, parent, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         return doPredicateName(context, parent, steps, currentStep, predicates, currentPredicate); [EOL]     } else { [EOL]         return doPredicateIndex(context, parent, steps, currentStep, predicates, currentPredicate); [EOL]     } [EOL] }
private static NodePointer doPredicate(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (currentPredicate == predicates.length) { [EOL]         return doStep(context, parent, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         return doPredicateName(context, parent, steps, currentStep, predicates, currentPredicate); [EOL]     } else { [EOL]         return doPredicateIndex(context, parent, steps, currentStep, predicates, currentPredicate); [EOL]     } [EOL] }
private static NodePointer doPredicate(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (currentPredicate == predicates.length) { [EOL]         return doStep(context, parent, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         return doPredicateName(context, parent, steps, currentStep, predicates, currentPredicate); [EOL]     } else { [EOL]         return doPredicateIndex(context, parent, steps, currentStep, predicates, currentPredicate); [EOL]     } [EOL] }
private static NodePointer doPredicateName(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     String key = keyFromPredicate(context, predicate); [EOL]     NodePointer child = valuePointer(parent); [EOL]     if (child instanceof PropertyOwnerPointer) { [EOL]         PropertyPointer pointer = ((PropertyOwnerPointer) child).getPropertyPointer(); [EOL]         pointer.setPropertyName(key); [EOL]         if (pointer.isActual()) { [EOL]             return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); [EOL]         } [EOL]     } else if (child.isCollection()) { [EOL]         NodePointer bestMatch = null; [EOL]         int bestQuality = 0; [EOL]         child = (NodePointer) child.clone(); [EOL]         int count = child.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             child.setIndex(i); [EOL]             NodePointer valuePointer = valuePointer(child); [EOL]             NodePointer pointer; [EOL]             if ((valuePointer instanceof PropertyOwnerPointer) || valuePointer.isCollection()) { [EOL]                 pointer = doPredicateName(context, valuePointer, steps, currentStep, predicates, currentPredicate); [EOL]             } else if (isNameAttributeEqual(valuePointer, key)) { [EOL]                 pointer = doPredicate(context, valuePointer, steps, currentStep, predicates, currentPredicate + 1); [EOL]             } else { [EOL]                 pointer = null; [EOL]             } [EOL]             if (pointer != null) { [EOL]                 int quality = computeQuality(pointer); [EOL]                 if (quality == PERFECT_MATCH) { [EOL]                     return pointer; [EOL]                 } [EOL]                 if (quality > bestQuality) { [EOL]                     bestMatch = (NodePointer) pointer.clone(); [EOL]                     bestQuality = quality; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             return bestMatch; [EOL]         } [EOL]     } else { [EOL]         NodePointer found = doPredicatesStandard(context, Collections.singletonList(child), steps, currentStep, predicates, currentPredicate); [EOL]         if (found != null) { [EOL]             return found; [EOL]         } [EOL]     } [EOL]     return createNullPointerForPredicates(context, child, steps, currentStep, predicates, currentPredicate); [EOL] }
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (parents.size() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (currentPredicate == predicates.length) { [EOL]         NodePointer pointer = (NodePointer) parents.get(0); [EOL]         return doStep(context, pointer, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         String key = keyFromPredicate(context, predicate); [EOL]         List newList = new ArrayList(); [EOL]         for (int i = 0; i < parents.size(); i++) { [EOL]             NodePointer pointer = (NodePointer) parents.get(i); [EOL]             if (isNameAttributeEqual(pointer, key)) { [EOL]                 newList.add(pointer); [EOL]             } [EOL]         } [EOL]         if (newList.size() == 0) { [EOL]             return null; [EOL]         } [EOL]         return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } else { [EOL]         int index = indexFromPredicate(context, predicate); [EOL]         if (index < 0 || index >= parents.size()) { [EOL]             return null; [EOL]         } [EOL]         NodePointer ptr = (NodePointer) parents.get(index); [EOL]         return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL] }
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (parents.size() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (currentPredicate == predicates.length) { [EOL]         NodePointer pointer = (NodePointer) parents.get(0); [EOL]         return doStep(context, pointer, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         String key = keyFromPredicate(context, predicate); [EOL]         List newList = new ArrayList(); [EOL]         for (int i = 0; i < parents.size(); i++) { [EOL]             NodePointer pointer = (NodePointer) parents.get(i); [EOL]             if (isNameAttributeEqual(pointer, key)) { [EOL]                 newList.add(pointer); [EOL]             } [EOL]         } [EOL]         if (newList.size() == 0) { [EOL]             return null; [EOL]         } [EOL]         return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } else { [EOL]         int index = indexFromPredicate(context, predicate); [EOL]         if (index < 0 || index >= parents.size()) { [EOL]             return null; [EOL]         } [EOL]         NodePointer ptr = (NodePointer) parents.get(index); [EOL]         return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL] }
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (parents.size() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (currentPredicate == predicates.length) { [EOL]         NodePointer pointer = (NodePointer) parents.get(0); [EOL]         return doStep(context, pointer, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         String key = keyFromPredicate(context, predicate); [EOL]         List newList = new ArrayList(); [EOL]         for (int i = 0; i < parents.size(); i++) { [EOL]             NodePointer pointer = (NodePointer) parents.get(i); [EOL]             if (isNameAttributeEqual(pointer, key)) { [EOL]                 newList.add(pointer); [EOL]             } [EOL]         } [EOL]         if (newList.size() == 0) { [EOL]             return null; [EOL]         } [EOL]         return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } else { [EOL]         int index = indexFromPredicate(context, predicate); [EOL]         if (index < 0 || index >= parents.size()) { [EOL]             return null; [EOL]         } [EOL]         NodePointer ptr = (NodePointer) parents.get(index); [EOL]         return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL] }
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (parents.size() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (currentPredicate == predicates.length) { [EOL]         NodePointer pointer = (NodePointer) parents.get(0); [EOL]         return doStep(context, pointer, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         String key = keyFromPredicate(context, predicate); [EOL]         List newList = new ArrayList(); [EOL]         for (int i = 0; i < parents.size(); i++) { [EOL]             NodePointer pointer = (NodePointer) parents.get(i); [EOL]             if (isNameAttributeEqual(pointer, key)) { [EOL]                 newList.add(pointer); [EOL]             } [EOL]         } [EOL]         if (newList.size() == 0) { [EOL]             return null; [EOL]         } [EOL]         return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } else { [EOL]         int index = indexFromPredicate(context, predicate); [EOL]         if (index < 0 || index >= parents.size()) { [EOL]             return null; [EOL]         } [EOL]         NodePointer ptr = (NodePointer) parents.get(index); [EOL]         return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL] }
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (parents.size() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (currentPredicate == predicates.length) { [EOL]         NodePointer pointer = (NodePointer) parents.get(0); [EOL]         return doStep(context, pointer, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         String key = keyFromPredicate(context, predicate); [EOL]         List newList = new ArrayList(); [EOL]         for (int i = 0; i < parents.size(); i++) { [EOL]             NodePointer pointer = (NodePointer) parents.get(i); [EOL]             if (isNameAttributeEqual(pointer, key)) { [EOL]                 newList.add(pointer); [EOL]             } [EOL]         } [EOL]         if (newList.size() == 0) { [EOL]             return null; [EOL]         } [EOL]         return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } else { [EOL]         int index = indexFromPredicate(context, predicate); [EOL]         if (index < 0 || index >= parents.size()) { [EOL]             return null; [EOL]         } [EOL]         NodePointer ptr = (NodePointer) parents.get(index); [EOL]         return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL] }
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (parents.size() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (currentPredicate == predicates.length) { [EOL]         NodePointer pointer = (NodePointer) parents.get(0); [EOL]         return doStep(context, pointer, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         String key = keyFromPredicate(context, predicate); [EOL]         List newList = new ArrayList(); [EOL]         for (int i = 0; i < parents.size(); i++) { [EOL]             NodePointer pointer = (NodePointer) parents.get(i); [EOL]             if (isNameAttributeEqual(pointer, key)) { [EOL]                 newList.add(pointer); [EOL]             } [EOL]         } [EOL]         if (newList.size() == 0) { [EOL]             return null; [EOL]         } [EOL]         return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } else { [EOL]         int index = indexFromPredicate(context, predicate); [EOL]         if (index < 0 || index >= parents.size()) { [EOL]             return null; [EOL]         } [EOL]         NodePointer ptr = (NodePointer) parents.get(index); [EOL]         return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL] }
private static NodePointer doPredicateIndex(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     int index = indexFromPredicate(context, predicate); [EOL]     NodePointer pointer = parent; [EOL]     if (isCollectionElement(pointer, index)) { [EOL]         pointer = (NodePointer) pointer.clone(); [EOL]         pointer.setIndex(index); [EOL]         return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL]     return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, currentPredicate); [EOL] }
private static int indexFromPredicate(EvalContext context, Expression predicate) { [EOL]     Object value = predicate.computeValue(context); [EOL]     if (value instanceof EvalContext) { [EOL]         value = ((EvalContext) value).getSingleNodePointer(); [EOL]     } [EOL]     if (value instanceof NodePointer) { [EOL]         value = ((NodePointer) value).getValue(); [EOL]     } [EOL]     if (value == null) { [EOL]         throw new JXPathException("Predicate value is null: " + predicate); [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1; [EOL]     } else if (InfoSetUtil.booleanValue(value)) { [EOL]         return 0; [EOL]     } [EOL]     return -1; [EOL] }
private static int indexFromPredicate(EvalContext context, Expression predicate) { [EOL]     Object value = predicate.computeValue(context); [EOL]     if (value instanceof EvalContext) { [EOL]         value = ((EvalContext) value).getSingleNodePointer(); [EOL]     } [EOL]     if (value instanceof NodePointer) { [EOL]         value = ((NodePointer) value).getValue(); [EOL]     } [EOL]     if (value == null) { [EOL]         throw new JXPathException("Predicate value is null: " + predicate); [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1; [EOL]     } else if (InfoSetUtil.booleanValue(value)) { [EOL]         return 0; [EOL]     } [EOL]     return -1; [EOL] }
private static int indexFromPredicate(EvalContext context, Expression predicate) { [EOL]     Object value = predicate.computeValue(context); [EOL]     if (value instanceof EvalContext) { [EOL]         value = ((EvalContext) value).getSingleNodePointer(); [EOL]     } [EOL]     if (value instanceof NodePointer) { [EOL]         value = ((NodePointer) value).getValue(); [EOL]     } [EOL]     if (value == null) { [EOL]         throw new JXPathException("Predicate value is null: " + predicate); [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1; [EOL]     } else if (InfoSetUtil.booleanValue(value)) { [EOL]         return 0; [EOL]     } [EOL]     return -1; [EOL] }
private static int indexFromPredicate(EvalContext context, Expression predicate) { [EOL]     Object value = predicate.computeValue(context); [EOL]     if (value instanceof EvalContext) { [EOL]         value = ((EvalContext) value).getSingleNodePointer(); [EOL]     } [EOL]     if (value instanceof NodePointer) { [EOL]         value = ((NodePointer) value).getValue(); [EOL]     } [EOL]     if (value == null) { [EOL]         throw new JXPathException("Predicate value is null: " + predicate); [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1; [EOL]     } else if (InfoSetUtil.booleanValue(value)) { [EOL]         return 0; [EOL]     } [EOL]     return -1; [EOL] }
private static int indexFromPredicate(EvalContext context, Expression predicate) { [EOL]     Object value = predicate.computeValue(context); [EOL]     if (value instanceof EvalContext) { [EOL]         value = ((EvalContext) value).getSingleNodePointer(); [EOL]     } [EOL]     if (value instanceof NodePointer) { [EOL]         value = ((NodePointer) value).getValue(); [EOL]     } [EOL]     if (value == null) { [EOL]         throw new JXPathException("Predicate value is null: " + predicate); [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1; [EOL]     } else if (InfoSetUtil.booleanValue(value)) { [EOL]         return 0; [EOL]     } [EOL]     return -1; [EOL] }
private static int indexFromPredicate(EvalContext context, Expression predicate) { [EOL]     Object value = predicate.computeValue(context); [EOL]     if (value instanceof EvalContext) { [EOL]         value = ((EvalContext) value).getSingleNodePointer(); [EOL]     } [EOL]     if (value instanceof NodePointer) { [EOL]         value = ((NodePointer) value).getValue(); [EOL]     } [EOL]     if (value == null) { [EOL]         throw new JXPathException("Predicate value is null: " + predicate); [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1; [EOL]     } else if (InfoSetUtil.booleanValue(value)) { [EOL]         return 0; [EOL]     } [EOL]     return -1; [EOL] }
private static String keyFromPredicate(EvalContext context, Expression predicate) { [EOL]     Expression expr = ((NameAttributeTest) predicate).getNameTestExpression(); [EOL]     return InfoSetUtil.stringValue(expr.computeValue(context)); [EOL] }
private static String keyFromPredicate(EvalContext context, Expression predicate) { [EOL]     Expression expr = ((NameAttributeTest) predicate).getNameTestExpression(); [EOL]     return InfoSetUtil.stringValue(expr.computeValue(context)); [EOL] }
private static int computeQuality(NodePointer pointer) { [EOL]     int quality = PERFECT_MATCH; [EOL]     while (pointer != null && !pointer.isActual()) { [EOL]         quality--; [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return quality; [EOL] }
private static int computeQuality(NodePointer pointer) { [EOL]     int quality = PERFECT_MATCH; [EOL]     while (pointer != null && !pointer.isActual()) { [EOL]         quality--; [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return quality; [EOL] }
private static int computeQuality(NodePointer pointer) { [EOL]     int quality = PERFECT_MATCH; [EOL]     while (pointer != null && !pointer.isActual()) { [EOL]         quality--; [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return quality; [EOL] }
private static int computeQuality(NodePointer pointer) { [EOL]     int quality = PERFECT_MATCH; [EOL]     while (pointer != null && !pointer.isActual()) { [EOL]         quality--; [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return quality; [EOL] }
private static boolean isNameAttributeEqual(NodePointer pointer, String name) { [EOL]     NodeIterator it = pointer.attributeIterator(QNAME_NAME); [EOL]     return it != null && it.setPosition(1) && name.equals(it.getNodePointer().getValue()); [EOL] }
private static boolean isNameAttributeEqual(NodePointer pointer, String name) { [EOL]     NodeIterator it = pointer.attributeIterator(QNAME_NAME); [EOL]     return it != null && it.setPosition(1) && name.equals(it.getNodePointer().getValue()); [EOL] }
private static boolean isNameAttributeEqual(NodePointer pointer, String name) { [EOL]     NodeIterator it = pointer.attributeIterator(QNAME_NAME); [EOL]     return it != null && it.setPosition(1) && name.equals(it.getNodePointer().getValue()); [EOL] }
private static boolean isNameAttributeEqual(NodePointer pointer, String name) { [EOL]     NodeIterator it = pointer.attributeIterator(QNAME_NAME); [EOL]     return it != null && it.setPosition(1) && name.equals(it.getNodePointer().getValue()); [EOL] }
private static boolean isCollectionElement(NodePointer pointer, int index) { [EOL]     return pointer.isActual() && (index == 0 || (pointer.isCollection() && index >= 0 && index < pointer.getLength())); [EOL] }
private static boolean isCollectionElement(NodePointer pointer, int index) { [EOL]     return pointer.isActual() && (index == 0 || (pointer.isCollection() && index >= 0 && index < pointer.getLength())); [EOL] }
private static boolean isCollectionElement(NodePointer pointer, int index) { [EOL]     return pointer.isActual() && (index == 0 || (pointer.isCollection() && index >= 0 && index < pointer.getLength())); [EOL] }
private static boolean isCollectionElement(NodePointer pointer, int index) { [EOL]     return pointer.isActual() && (index == 0 || (pointer.isCollection() && index >= 0 && index < pointer.getLength())); [EOL] }
private static boolean isCollectionElement(NodePointer pointer, int index) { [EOL]     return pointer.isActual() && (index == 0 || (pointer.isCollection() && index >= 0 && index < pointer.getLength())); [EOL] }
private static NodePointer valuePointer(NodePointer pointer) { [EOL]     return pointer == null ? null : pointer.getValuePointer(); [EOL] }
private static NodePointer valuePointer(NodePointer pointer) { [EOL]     return pointer == null ? null : pointer.getValuePointer(); [EOL] }
public static NodePointer createNullPointer(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     if (currentStep == steps.length) { [EOL]         return parent; [EOL]     } [EOL]     parent = valuePointer(parent); [EOL]     Step step = steps[currentStep]; [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         pointer.setPropertyName(name.toString()); [EOL]         pointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         parent = pointer; [EOL]     } [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, 0); [EOL] }
public static NodePointer createNullPointer(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     if (currentStep == steps.length) { [EOL]         return parent; [EOL]     } [EOL]     parent = valuePointer(parent); [EOL]     Step step = steps[currentStep]; [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         pointer.setPropertyName(name.toString()); [EOL]         pointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         parent = pointer; [EOL]     } [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, 0); [EOL] }
public static NodePointer createNullPointer(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     if (currentStep == steps.length) { [EOL]         return parent; [EOL]     } [EOL]     parent = valuePointer(parent); [EOL]     Step step = steps[currentStep]; [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         pointer.setPropertyName(name.toString()); [EOL]         pointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         parent = pointer; [EOL]     } [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, 0); [EOL] }
public static NodePointer createNullPointer(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     if (currentStep == steps.length) { [EOL]         return parent; [EOL]     } [EOL]     parent = valuePointer(parent); [EOL]     Step step = steps[currentStep]; [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         pointer.setPropertyName(name.toString()); [EOL]         pointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         parent = pointer; [EOL]     } [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, 0); [EOL] }
private static NodePointer createNullPointerForPredicates(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     for (int i = currentPredicate; i < predicates.length; i++) { [EOL]         Expression predicate = predicates[i]; [EOL]         if (predicate instanceof NameAttributeTest) { [EOL]             String key = keyFromPredicate(context, predicate); [EOL]             parent = valuePointer(parent); [EOL]             NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]             pointer.setNameAttributeValue(key); [EOL]             parent = pointer; [EOL]         } else { [EOL]             int index = indexFromPredicate(context, predicate); [EOL]             if (parent instanceof NullPropertyPointer) { [EOL]                 parent.setIndex(index); [EOL]             } else { [EOL]                 parent = new NullElementPointer(parent, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep + 1); [EOL] }
private static NodePointer createNullPointerForPredicates(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     for (int i = currentPredicate; i < predicates.length; i++) { [EOL]         Expression predicate = predicates[i]; [EOL]         if (predicate instanceof NameAttributeTest) { [EOL]             String key = keyFromPredicate(context, predicate); [EOL]             parent = valuePointer(parent); [EOL]             NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]             pointer.setNameAttributeValue(key); [EOL]             parent = pointer; [EOL]         } else { [EOL]             int index = indexFromPredicate(context, predicate); [EOL]             if (parent instanceof NullPropertyPointer) { [EOL]                 parent.setIndex(index); [EOL]             } else { [EOL]                 parent = new NullElementPointer(parent, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep + 1); [EOL] }
private static NodePointer createNullPointerForPredicates(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     for (int i = currentPredicate; i < predicates.length; i++) { [EOL]         Expression predicate = predicates[i]; [EOL]         if (predicate instanceof NameAttributeTest) { [EOL]             String key = keyFromPredicate(context, predicate); [EOL]             parent = valuePointer(parent); [EOL]             NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]             pointer.setNameAttributeValue(key); [EOL]             parent = pointer; [EOL]         } else { [EOL]             int index = indexFromPredicate(context, predicate); [EOL]             if (parent instanceof NullPropertyPointer) { [EOL]                 parent.setIndex(index); [EOL]             } else { [EOL]                 parent = new NullElementPointer(parent, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep + 1); [EOL] }
private static NodeIterator getNodeIterator(EvalContext context, NodePointer pointer, Step step) { [EOL]     if (step.getAxis() == Compiler.AXIS_CHILD) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]         return pointer.childIterator(nodeTest, false, null); [EOL]     } else { [EOL]         if (!(step.getNodeTest() instanceof NodeNameTest)) { [EOL]             throw new UnsupportedOperationException("Not supported node test for attributes: " + step.getNodeTest()); [EOL]         } [EOL]         return pointer.attributeIterator(((NodeNameTest) step.getNodeTest()).getNodeName()); [EOL]     } [EOL] }
public PropertyDescriptor getPropertyDescriptor(String propertyName) { [EOL]     if (propertyNames == null) { [EOL]         PropertyDescriptor[] pds = getPropertyDescriptors(); [EOL]         String[] names = new String[pds.length]; [EOL]         for (int i = 0; i < pds.length; i++) { [EOL]             names[i] = pds[i].getName(); [EOL]         } [EOL]         propertyNames = names; [EOL]     } [EOL]     for (int i = 0; i < propertyNames.length; i++) { [EOL]         if (propertyNames[i] == propertyName) { [EOL]             return propertyDescriptors[i]; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < propertyNames.length; i++) { [EOL]         if (propertyNames[i].equals(propertyName)) { [EOL]             return propertyDescriptors[i]; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public void setValue(Object value) { [EOL]     if (parent == null || parent.isContainer()) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property " + asPath() + ", the target object is null"); [EOL]     } else if (parent instanceof PropertyOwnerPointer && ((PropertyOwnerPointer) parent).isDynamicPropertyDeclarationSupported()) { [EOL]         PropertyPointer propertyPointer = ((PropertyOwnerPointer) parent).getPropertyPointer(); [EOL]         propertyPointer.setPropertyName(propertyName); [EOL]         propertyPointer.setValue(value); [EOL]     } else { [EOL]         throw new JXPathInvalidAccessException("Cannot set property " + asPath() + ", path does not match a changeable location"); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (parent == null || parent.isContainer()) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property " + asPath() + ", the target object is null"); [EOL]     } else if (parent instanceof PropertyOwnerPointer && ((PropertyOwnerPointer) parent).isDynamicPropertyDeclarationSupported()) { [EOL]         PropertyPointer propertyPointer = ((PropertyOwnerPointer) parent).getPropertyPointer(); [EOL]         propertyPointer.setPropertyName(propertyName); [EOL]         propertyPointer.setValue(value); [EOL]     } else { [EOL]         throw new JXPathInvalidAccessException("Cannot set property " + asPath() + ", path does not match a changeable location"); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (parent == null || parent.isContainer()) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property " + asPath() + ", the target object is null"); [EOL]     } else if (parent instanceof PropertyOwnerPointer && ((PropertyOwnerPointer) parent).isDynamicPropertyDeclarationSupported()) { [EOL]         PropertyPointer propertyPointer = ((PropertyOwnerPointer) parent).getPropertyPointer(); [EOL]         propertyPointer.setPropertyName(propertyName); [EOL]         propertyPointer.setValue(value); [EOL]     } else { [EOL]         throw new JXPathInvalidAccessException("Cannot set property " + asPath() + ", path does not match a changeable location"); [EOL]     } [EOL] }
public String[] getPropertyNames() { [EOL]     return new String[0]; [EOL] }
public String asPath() { [EOL]     if (!byNameAttribute) { [EOL]         return super.asPath(); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         buffer.append(getImmediateParentPointer().asPath()); [EOL]         buffer.append("[@name='"); [EOL]         buffer.append(escape(getPropertyName())); [EOL]         buffer.append("']"); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
public String asPath() { [EOL]     if (!byNameAttribute) { [EOL]         return super.asPath(); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         buffer.append(getImmediateParentPointer().asPath()); [EOL]         buffer.append("[@name='"); [EOL]         buffer.append(escape(getPropertyName())); [EOL]         buffer.append("']"); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
public String asPath() { [EOL]     if (!byNameAttribute) { [EOL]         return super.asPath(); [EOL]     } else { [EOL]         StringBuffer buffer = new StringBuffer(); [EOL]         buffer.append(getImmediateParentPointer().asPath()); [EOL]         buffer.append("[@name='"); [EOL]         buffer.append(escape(getPropertyName())); [EOL]         buffer.append("']"); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]         return buffer.toString(); [EOL]     } [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
public boolean isLeaf() { [EOL]     return true; [EOL] }
public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
protected int getPrecedence() { [EOL]     return 3; [EOL] }
protected boolean isSymmetric() { [EOL]     return false; [EOL] }
public String getSymbol() { [EOL]     return ">="; [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public boolean isCollection() { [EOL]     return false; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof BeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     BeanPointer other = (BeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     if (bean instanceof Number || bean instanceof String || bean instanceof Boolean) { [EOL]         return bean.equals(other.bean); [EOL]     } [EOL]     return bean == other.bean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof BeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     BeanPointer other = (BeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     if (bean instanceof Number || bean instanceof String || bean instanceof Boolean) { [EOL]         return bean.equals(other.bean); [EOL]     } [EOL]     return bean == other.bean; [EOL] }
public void setValue(Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         handler.setProperty(getBean(), getPropertyName(), value); [EOL]     } else { [EOL]         ValueUtils.setValue(handler.getProperty(getBean(), getPropertyName()), index, value); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         handler.setProperty(getBean(), getPropertyName(), value); [EOL]     } else { [EOL]         ValueUtils.setValue(handler.getProperty(getBean(), getPropertyName()), index, value); [EOL]     } [EOL] }
public int compare(Object o1, Object o2) { [EOL]     return ((Comparable) o2).compareTo(o1); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
private boolean constructIterator() { [EOL]     HashSet set = new HashSet(); [EOL]     ArrayList list = new ArrayList(); [EOL]     while (nextSet()) { [EOL]         while (nextNode()) { [EOL]             NodePointer pointer = getCurrentNodePointer(); [EOL]             if (!set.contains(pointer)) { [EOL]                 set.add(pointer); [EOL]                 list.add(pointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     if (getDocumentOrder() == 1) { [EOL]         Collections.sort(list); [EOL]     } else { [EOL]         Collections.sort(list, REVERSE_COMPARATOR); [EOL]     } [EOL]     pointerIterator = list.iterator(); [EOL]     return true; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public NodeSet getNodeSet() { [EOL]     if (position != 0) { [EOL]         throw new JXPathException("Simultaneous operations: " + "should not request pointer list while " + "iterating over an EvalContext"); [EOL]     } [EOL]     BasicNodeSet set = new BasicNodeSet(); [EOL]     while (nextSet()) { [EOL]         while (nextNode()) { [EOL]             set.add((Pointer) getCurrentNodePointer().clone()); [EOL]         } [EOL]     } [EOL]     return set; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public JXPathCompiledExpression(String xpath, Expression expression) { [EOL]     this.xpath = xpath; [EOL]     this.expression = expression; [EOL] }
public JXPathCompiledExpression(String xpath, Expression expression) { [EOL]     this.xpath = xpath; [EOL]     this.expression = expression; [EOL] }
protected Expression getExpression() { [EOL]     return expression; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if ((namespace == null && this.namespace != null) || (namespace != null && !namespace.equals(this.namespace))) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (parameters.length >= 1) { [EOL]         Object target = TypeUtils.convert(parameters[0], Object.class); [EOL]         if (target != null) { [EOL]             Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL]             if (method != null) { [EOL]                 return new MethodFunction(method); [EOL]             } [EOL]             if (target instanceof NodeSet) { [EOL]                 target = ((NodeSet) target).getPointers(); [EOL]             } [EOL]             method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL]             if (method != null) { [EOL]                 return new MethodFunction(method); [EOL]             } [EOL]             if (target instanceof Collection) { [EOL]                 Iterator iter = ((Collection) target).iterator(); [EOL]                 if (iter.hasNext()) { [EOL]                     target = iter.next(); [EOL]                     if (target instanceof Pointer) { [EOL]                         target = ((Pointer) target).getValue(); [EOL]                     } [EOL]                 } else { [EOL]                     target = null; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (target != null) { [EOL]             Method method = MethodLookupUtils.lookupMethod(target.getClass(), name, parameters); [EOL]             if (method != null) { [EOL]                 return new MethodFunction(method); [EOL]             } [EOL]         } [EOL]     } [EOL]     String fullName = classPrefix + name; [EOL]     int inx = fullName.lastIndexOf('.'); [EOL]     if (inx == -1) { [EOL]         return null; [EOL]     } [EOL]     String className = fullName.substring(0, inx); [EOL]     String methodName = fullName.substring(inx + 1); [EOL]     Class functionClass; [EOL]     try { [EOL]         functionClass = Class.forName(className); [EOL]     } catch (ClassNotFoundException ex) { [EOL]         throw new JXPathException("Cannot invoke extension function " + (namespace != null ? namespace + ":" + name : name), ex); [EOL]     } [EOL]     if (methodName.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, methodName, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public boolean canConvert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         return true; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         return true; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType)) { [EOL]         return true; [EOL]     } [EOL]     if (toType.isAssignableFrom(fromType)) { [EOL]         return true; [EOL]     } [EOL]     if (toType == String.class) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof Boolean) { [EOL]         if (toType == boolean.class || Number.class.isAssignableFrom(toType)) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof Number) { [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         if (toType.isPrimitive()) { [EOL]             return true; [EOL]         } [EOL]         if (toType == Boolean.class || toType == Character.class || toType == Byte.class || toType == Short.class || toType == Integer.class || toType == Long.class || toType == Float.class || toType == Double.class) { [EOL]             return true; [EOL]         } [EOL]     } else if (fromType.isArray()) { [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             int length = Array.getLength(object); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 if (!canConvert(value, cType)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             return canCreateCollection(toType); [EOL]         } else { [EOL]             if (Array.getLength(object) > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return canConvert(value, toType); [EOL]             } else { [EOL]                 return canConvert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             while (it.hasNext()) { [EOL]                 Object value = it.next(); [EOL]                 if (!canConvert(value, cType)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             return canCreateCollection(toType); [EOL]         } else { [EOL]             if (((Collection) object).size() > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return canConvert(value, toType); [EOL]             } else { [EOL]                 return canConvert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return canConvert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return canConvert(((Pointer) object).getValue(), toType); [EOL]     } [EOL]     return ConvertUtils.lookup(toType) != null; [EOL] }
public Object convert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         if (toType.isPrimitive()) { [EOL]             return convertNullToPrimitive(toType); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         if (object instanceof NodeSet) { [EOL]             return convert(((NodeSet) object).getValues(), toType); [EOL]         } else if (object instanceof Pointer) { [EOL]             return convert(((Pointer) object).getValue(), toType); [EOL]         } [EOL]         return object; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL]         return object; [EOL]     } [EOL]     if (fromType.isArray()) { [EOL]         int length = Array.getLength(object); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 collection.add(Array.get(object, i)); [EOL]             } [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         int length = ((Collection) object).size(); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = it.next(); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             collection.addAll((Collection) object); [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return convert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return convert(((Pointer) object).getValue(), toType); [EOL]     } else if (toType == String.class) { [EOL]         return object.toString(); [EOL]     } else if (object instanceof Boolean) { [EOL]         if (toType == boolean.class) { [EOL]             return object; [EOL]         } [EOL]         boolean value = ((Boolean) object).booleanValue(); [EOL]         return allocateNumber(toType, value ? 1 : 0); [EOL]     } else if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         if (toType == boolean.class || toType == Boolean.class) { [EOL]             return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return allocateNumber(toType, value); [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return object; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         Object value = convertStringToPrimitive(object, toType); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     Converter converter = ConvertUtils.lookup(toType); [EOL]     if (converter != null) { [EOL]         return converter.convert(toType, object); [EOL]     } [EOL]     throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertNullToPrimitive(Class toType) { [EOL]     if (toType == boolean.class) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (toType == char.class) { [EOL]         return new Character('\0'); [EOL]     } [EOL]     if (toType == byte.class) { [EOL]         return new Byte((byte) 0); [EOL]     } [EOL]     if (toType == short.class) { [EOL]         return new Short((short) 0); [EOL]     } [EOL]     if (toType == int.class) { [EOL]         return new Integer(0); [EOL]     } [EOL]     if (toType == long.class) { [EOL]         return new Long(0L); [EOL]     } [EOL]     if (toType == float.class) { [EOL]         return new Float(0.0f); [EOL]     } [EOL]     if (toType == double.class) { [EOL]         return new Double(0.0); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
public void declareVariable(String varName, Object value) { [EOL]     vars.put(varName, value); [EOL] }
public void undeclareVariable(String varName) { [EOL]     vars.remove(varName); [EOL] }
public void undeclareVariable(String varName) { [EOL]     vars.remove(varName); [EOL] }
public CoreOperationLessThanOrEqual(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public String getSymbol() { [EOL]     return "<="; [EOL] }
public void backup(int amount) { [EOL]     inBuf += amount; [EOL]     if ((bufpos -= amount) < 0) [EOL]         bufpos += bufsize; [EOL] }
public void backup(int amount) { [EOL]     inBuf += amount; [EOL]     if ((bufpos -= amount) < 0) [EOL]         bufpos += bufsize; [EOL] }
public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) { [EOL]     inputStream = dstream; [EOL]     line = startline; [EOL]     column = startcolumn - 1; [EOL]     available = bufsize = buffersize; [EOL]     buffer = new char[buffersize]; [EOL]     bufline = new int[buffersize]; [EOL]     bufcolumn = new int[buffersize]; [EOL] }
public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) { [EOL]     this(dstream, startline, startcolumn, 4096); [EOL] }
public boolean isDynamicPropertyDeclarationSupported() { [EOL]     return true; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
private int getLength() { [EOL]     int length; [EOL]     try { [EOL]         length = propertyNodePointer.getLength(); [EOL]     } catch (Throwable t) { [EOL]         length = 0; [EOL]     } [EOL]     return length; [EOL] }
private int getLength() { [EOL]     int length; [EOL]     try { [EOL]         length = propertyNodePointer.getLength(); [EOL]     } catch (Throwable t) { [EOL]         length = 0; [EOL]     } [EOL]     return length; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (byNamespace == null) { [EOL]         prepareCache(); [EOL]     } [EOL]     Object candidates = byNamespace.get(namespace); [EOL]     if (candidates instanceof Functions) { [EOL]         return ((Functions) candidates).getFunction(namespace, name, parameters); [EOL]     } else if (candidates instanceof List) { [EOL]         List list = (List) candidates; [EOL]         int count = list.size(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters); [EOL]             if (function != null) { [EOL]                 return function; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (byNamespace == null) { [EOL]         prepareCache(); [EOL]     } [EOL]     Object candidates = byNamespace.get(namespace); [EOL]     if (candidates instanceof Functions) { [EOL]         return ((Functions) candidates).getFunction(namespace, name, parameters); [EOL]     } else if (candidates instanceof List) { [EOL]         List list = (List) candidates; [EOL]         int count = list.size(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters); [EOL]             if (function != null) { [EOL]                 return function; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (byNamespace == null) { [EOL]         prepareCache(); [EOL]     } [EOL]     Object candidates = byNamespace.get(namespace); [EOL]     if (candidates instanceof Functions) { [EOL]         return ((Functions) candidates).getFunction(namespace, name, parameters); [EOL]     } else if (candidates instanceof List) { [EOL]         List list = (List) candidates; [EOL]         int count = list.size(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters); [EOL]             if (function != null) { [EOL]                 return function; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (byNamespace == null) { [EOL]         prepareCache(); [EOL]     } [EOL]     Object candidates = byNamespace.get(namespace); [EOL]     if (candidates instanceof Functions) { [EOL]         return ((Functions) candidates).getFunction(namespace, name, parameters); [EOL]     } else if (candidates instanceof List) { [EOL]         List list = (List) candidates; [EOL]         int count = list.size(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Function function = ((Functions) list.get(i)).getFunction(namespace, name, parameters); [EOL]             if (function != null) { [EOL]                 return function; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private void prepareCache() { [EOL]     byNamespace = new HashMap(); [EOL]     int count = allFunctions.size(); [EOL]     for (int i = 0; i < count; i++) { [EOL]         Functions funcs = (Functions) allFunctions.get(i); [EOL]         Set namespaces = funcs.getUsedNamespaces(); [EOL]         for (Iterator it = namespaces.iterator(); it.hasNext(); ) { [EOL]             String ns = (String) it.next(); [EOL]             Object candidates = byNamespace.get(ns); [EOL]             if (candidates == null) { [EOL]                 byNamespace.put(ns, funcs); [EOL]             } else if (candidates instanceof Functions) { [EOL]                 List lst = new ArrayList(); [EOL]                 lst.add(candidates); [EOL]                 lst.add(funcs); [EOL]                 byNamespace.put(ns, lst); [EOL]             } else { [EOL]                 ((List) candidates).add(funcs); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void prepareCache() { [EOL]     byNamespace = new HashMap(); [EOL]     int count = allFunctions.size(); [EOL]     for (int i = 0; i < count; i++) { [EOL]         Functions funcs = (Functions) allFunctions.get(i); [EOL]         Set namespaces = funcs.getUsedNamespaces(); [EOL]         for (Iterator it = namespaces.iterator(); it.hasNext(); ) { [EOL]             String ns = (String) it.next(); [EOL]             Object candidates = byNamespace.get(ns); [EOL]             if (candidates == null) { [EOL]                 byNamespace.put(ns, funcs); [EOL]             } else if (candidates instanceof Functions) { [EOL]                 List lst = new ArrayList(); [EOL]                 lst.add(candidates); [EOL]                 lst.add(funcs); [EOL]                 byNamespace.put(ns, lst); [EOL]             } else { [EOL]                 ((List) candidates).add(funcs); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void prepareCache() { [EOL]     byNamespace = new HashMap(); [EOL]     int count = allFunctions.size(); [EOL]     for (int i = 0; i < count; i++) { [EOL]         Functions funcs = (Functions) allFunctions.get(i); [EOL]         Set namespaces = funcs.getUsedNamespaces(); [EOL]         for (Iterator it = namespaces.iterator(); it.hasNext(); ) { [EOL]             String ns = (String) it.next(); [EOL]             Object candidates = byNamespace.get(ns); [EOL]             if (candidates == null) { [EOL]                 byNamespace.put(ns, funcs); [EOL]             } else if (candidates instanceof Functions) { [EOL]                 List lst = new ArrayList(); [EOL]                 lst.add(candidates); [EOL]                 lst.add(funcs); [EOL]                 byNamespace.put(ns, lst); [EOL]             } else { [EOL]                 ((List) candidates).add(funcs); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void prepareCache() { [EOL]     byNamespace = new HashMap(); [EOL]     int count = allFunctions.size(); [EOL]     for (int i = 0; i < count; i++) { [EOL]         Functions funcs = (Functions) allFunctions.get(i); [EOL]         Set namespaces = funcs.getUsedNamespaces(); [EOL]         for (Iterator it = namespaces.iterator(); it.hasNext(); ) { [EOL]             String ns = (String) it.next(); [EOL]             Object candidates = byNamespace.get(ns); [EOL]             if (candidates == null) { [EOL]                 byNamespace.put(ns, funcs); [EOL]             } else if (candidates instanceof Functions) { [EOL]                 List lst = new ArrayList(); [EOL]                 lst.add(candidates); [EOL]                 lst.add(funcs); [EOL]                 byNamespace.put(ns, lst); [EOL]             } else { [EOL]                 ((List) candidates).add(funcs); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void prepareCache() { [EOL]     byNamespace = new HashMap(); [EOL]     int count = allFunctions.size(); [EOL]     for (int i = 0; i < count; i++) { [EOL]         Functions funcs = (Functions) allFunctions.get(i); [EOL]         Set namespaces = funcs.getUsedNamespaces(); [EOL]         for (Iterator it = namespaces.iterator(); it.hasNext(); ) { [EOL]             String ns = (String) it.next(); [EOL]             Object candidates = byNamespace.get(ns); [EOL]             if (candidates == null) { [EOL]                 byNamespace.put(ns, funcs); [EOL]             } else if (candidates instanceof Functions) { [EOL]                 List lst = new ArrayList(); [EOL]                 lst.add(candidates); [EOL]                 lst.add(funcs); [EOL]                 byNamespace.put(ns, lst); [EOL]             } else { [EOL]                 ((List) candidates).add(funcs); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public Object mod(Object left, Object right) { [EOL]     return new CoreOperationMod((Expression) left, (Expression) right); [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public int getPropertyIndex() { [EOL]     if (propertyIndex == UNSPECIFIED_PROPERTY) { [EOL]         String[] names = getPropertyNames(); [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             if (names[i].equals(name)) { [EOL]                 propertyIndex = i; [EOL]                 name = null; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return super.getPropertyIndex(); [EOL] }
public int getPropertyIndex() { [EOL]     if (propertyIndex == UNSPECIFIED_PROPERTY) { [EOL]         String[] names = getPropertyNames(); [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             if (names[i].equals(name)) { [EOL]                 propertyIndex = i; [EOL]                 name = null; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return super.getPropertyIndex(); [EOL] }
public CoreOperationMultiply(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
protected int getPrecedence() { [EOL]     return 5; [EOL] }
public String getSymbol() { [EOL]     return "*"; [EOL] }
public CoreOperationMod(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public String getSymbol() { [EOL]     return "mod"; [EOL] }
protected Step(int axis, NodeTest nodeTest, Expression[] predicates) { [EOL]     this.axis = axis; [EOL]     this.nodeTest = nodeTest; [EOL]     this.predicates = predicates; [EOL] }
public int getAxis() { [EOL]     return axis; [EOL] }
public NodeTest getNodeTest() { [EOL]     return nodeTest; [EOL] }
public Expression[] getPredicates() { [EOL]     return predicates; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     String uri = (String) namespaceMap.get(prefix); [EOL]     if (uri == null && pointer != null) { [EOL]         uri = pointer.getNamespaceURI(prefix); [EOL]     } [EOL]     if (uri == null && parent != null) { [EOL]         return parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return uri; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public String getPrefix(String namespaceURI) { [EOL]     if (reverseMap == null) { [EOL]         reverseMap = new HashMap(); [EOL]         NodeIterator ni = pointer.namespaceIterator(); [EOL]         if (ni != null) { [EOL]             for (int position = 1; ni.setPosition(position); position++) { [EOL]                 NodePointer nsPointer = ni.getNodePointer(); [EOL]                 String uri = nsPointer.getNamespaceURI(); [EOL]                 String prefix = nsPointer.getName().getName(); [EOL]                 if (!"".equals(prefix)) { [EOL]                     reverseMap.put(uri, prefix); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Iterator it = namespaceMap.entrySet().iterator(); [EOL]         while (it.hasNext()) { [EOL]             Map.Entry entry = (Map.Entry) it.next(); [EOL]             reverseMap.put(entry.getValue(), entry.getKey()); [EOL]         } [EOL]     } [EOL]     String prefix = (String) reverseMap.get(namespaceURI); [EOL]     if (prefix == null && parent != null) { [EOL]         return parent.getPrefix(namespaceURI); [EOL]     } [EOL]     return prefix; [EOL] }
public static JXPathContext newContext(Object contextBean) { [EOL]     return getContextFactory().newContext(null, contextBean); [EOL] }
public static JXPathContext newContext(Object contextBean) { [EOL]     return getContextFactory().newContext(null, contextBean); [EOL] }
public static JXPathContext newContext(JXPathContext parentContext, Object contextBean) { [EOL]     return getContextFactory().newContext(parentContext, contextBean); [EOL] }
public static JXPathContext newContext(JXPathContext parentContext, Object contextBean) { [EOL]     return getContextFactory().newContext(parentContext, contextBean); [EOL] }
public static JXPathContext newContext(JXPathContext parentContext, Object contextBean) { [EOL]     return getContextFactory().newContext(parentContext, contextBean); [EOL] }
private static JXPathContextFactory getContextFactory() { [EOL]     if (contextFactory == null) { [EOL]         contextFactory = JXPathContextFactory.newInstance(); [EOL]     } [EOL]     return contextFactory; [EOL] }
private static JXPathContextFactory getContextFactory() { [EOL]     if (contextFactory == null) { [EOL]         contextFactory = JXPathContextFactory.newInstance(); [EOL]     } [EOL]     return contextFactory; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public Functions getFunctions() { [EOL]     if (functions != null) { [EOL]         return functions; [EOL]     } [EOL]     if (parentContext == null) { [EOL]         return GENERIC_FUNCTIONS; [EOL]     } [EOL]     return null; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getLocale(); [EOL]         } else { [EOL]             locale = Locale.getDefault(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getLocale(); [EOL]         } else { [EOL]             locale = Locale.getDefault(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getLocale(); [EOL]         } else { [EOL]             locale = Locale.getDefault(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] }
public void setDecimalFormatSymbols(String name, DecimalFormatSymbols symbols) { [EOL]     if (decimalFormats == null) { [EOL]         decimalFormats = new HashMap(); [EOL]     } [EOL]     decimalFormats.put(name, symbols); [EOL] }
public void setDecimalFormatSymbols(String name, DecimalFormatSymbols symbols) { [EOL]     if (decimalFormats == null) { [EOL]         decimalFormats = new HashMap(); [EOL]     } [EOL]     decimalFormats.put(name, symbols); [EOL] }
public DecimalFormatSymbols getDecimalFormatSymbols(String name) { [EOL]     if (decimalFormats == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getDecimalFormatSymbols(name); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return (DecimalFormatSymbols) decimalFormats.get(name); [EOL] }
public DecimalFormatSymbols getDecimalFormatSymbols(String name) { [EOL]     if (decimalFormats == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getDecimalFormatSymbols(name); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return (DecimalFormatSymbols) decimalFormats.get(name); [EOL] }
public DecimalFormatSymbols getDecimalFormatSymbols(String name) { [EOL]     if (decimalFormats == null) { [EOL]         if (parentContext != null) { [EOL]             return parentContext.getDecimalFormatSymbols(name); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return (DecimalFormatSymbols) decimalFormats.get(name); [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL]     try { [EOL]         Object target; [EOL]         Object[] args; [EOL]         if (Modifier.isStatic(method.getModifiers())) { [EOL]             target = null; [EOL]             if (parameters == null) { [EOL]                 parameters = EMPTY_ARRAY; [EOL]             } [EOL]             int pi = 0; [EOL]             Class[] types = method.getParameterTypes(); [EOL]             if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]                 pi = 1; [EOL]             } [EOL]             args = new Object[parameters.length + pi]; [EOL]             if (pi == 1) { [EOL]                 args[0] = context; [EOL]             } [EOL]             for (int i = 0; i < parameters.length; i++) { [EOL]                 args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL]             } [EOL]         } else { [EOL]             int pi = 0; [EOL]             Class[] types = method.getParameterTypes(); [EOL]             if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]                 pi = 1; [EOL]             } [EOL]             target = TypeUtils.convert(parameters[0], method.getDeclaringClass()); [EOL]             args = new Object[parameters.length - 1 + pi]; [EOL]             if (pi == 1) { [EOL]                 args[0] = context; [EOL]             } [EOL]             for (int i = 1; i < parameters.length; i++) { [EOL]                 args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i + pi - 1]); [EOL]             } [EOL]         } [EOL]         return method.invoke(target, args); [EOL]     } catch (Throwable ex) { [EOL]         if (ex instanceof InvocationTargetException) { [EOL]             ex = ((InvocationTargetException) ex).getTargetException(); [EOL]         } [EOL]         throw new JXPathInvalidAccessException("Cannot invoke " + method, ex); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     this.value = value; [EOL]     if (parent.isContainer()) { [EOL]         parent.setValue(value); [EOL]     } else if (parent != null) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             throw new UnsupportedOperationException("Cannot setValue of an object that is not " + "some other object's property"); [EOL]         } else { [EOL]             throw new JXPathInvalidAccessException("The specified collection element does not exist: " + this); [EOL]         } [EOL]     } else { [EOL]         throw new UnsupportedOperationException("Cannot replace the root object"); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     this.value = value; [EOL]     if (parent.isContainer()) { [EOL]         parent.setValue(value); [EOL]     } else if (parent != null) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             throw new UnsupportedOperationException("Cannot setValue of an object that is not " + "some other object's property"); [EOL]         } else { [EOL]             throw new JXPathInvalidAccessException("The specified collection element does not exist: " + this); [EOL]         } [EOL]     } else { [EOL]         throw new UnsupportedOperationException("Cannot replace the root object"); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     this.value = value; [EOL]     if (parent.isContainer()) { [EOL]         parent.setValue(value); [EOL]     } else if (parent != null) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             throw new UnsupportedOperationException("Cannot setValue of an object that is not " + "some other object's property"); [EOL]         } else { [EOL]             throw new JXPathInvalidAccessException("The specified collection element does not exist: " + this); [EOL]         } [EOL]     } else { [EOL]         throw new UnsupportedOperationException("Cannot replace the root object"); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     this.value = value; [EOL]     if (parent.isContainer()) { [EOL]         parent.setValue(value); [EOL]     } else if (parent != null) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             throw new UnsupportedOperationException("Cannot setValue of an object that is not " + "some other object's property"); [EOL]         } else { [EOL]             throw new JXPathInvalidAccessException("The specified collection element does not exist: " + this); [EOL]         } [EOL]     } else { [EOL]         throw new UnsupportedOperationException("Cannot replace the root object"); [EOL]     } [EOL] }
protected boolean isSimpleStep(Step step) { [EOL]     if (step.getAxis() == Compiler.AXIS_SELF) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         if (!(nodeTest instanceof NodeTypeTest)) { [EOL]             return false; [EOL]         } [EOL]         int nodeType = ((NodeTypeTest) nodeTest).getNodeType(); [EOL]         if (nodeType != Compiler.NODE_TYPE_NODE) { [EOL]             return false; [EOL]         } [EOL]         return areBasicPredicates(step.getPredicates()); [EOL]     } else if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         if (((NodeNameTest) nodeTest).isWildcard()) { [EOL]             return false; [EOL]         } [EOL]         return areBasicPredicates(step.getPredicates()); [EOL]     } [EOL]     return false; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public void remove() { [EOL]     if (actual) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             variables.undeclareVariable(name.toString()); [EOL]         } else { [EOL]             if (index < 0) { [EOL]                 throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]             } [EOL]             Object collection = getBaseValue(); [EOL]             if (collection != null && index < getLength()) { [EOL]                 collection = ValueUtils.remove(collection, index); [EOL]                 variables.declareVariable(name.toString(), collection); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void remove() { [EOL]     if (actual) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             variables.undeclareVariable(name.toString()); [EOL]         } else { [EOL]             if (index < 0) { [EOL]                 throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]             } [EOL]             Object collection = getBaseValue(); [EOL]             if (collection != null && index < getLength()) { [EOL]                 collection = ValueUtils.remove(collection, index); [EOL]                 variables.declareVariable(name.toString(), collection); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void remove() { [EOL]     if (actual) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             variables.undeclareVariable(name.toString()); [EOL]         } else { [EOL]             if (index < 0) { [EOL]                 throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]             } [EOL]             Object collection = getBaseValue(); [EOL]             if (collection != null && index < getLength()) { [EOL]                 collection = ValueUtils.remove(collection, index); [EOL]                 variables.declareVariable(name.toString(), collection); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void remove() { [EOL]     if (actual) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             variables.undeclareVariable(name.toString()); [EOL]         } else { [EOL]             if (index < 0) { [EOL]                 throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]             } [EOL]             Object collection = getBaseValue(); [EOL]             if (collection != null && index < getLength()) { [EOL]                 collection = ValueUtils.remove(collection, index); [EOL]                 variables.declareVariable(name.toString(), collection); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void remove() { [EOL]     if (actual) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             variables.undeclareVariable(name.toString()); [EOL]         } else { [EOL]             if (index < 0) { [EOL]                 throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]             } [EOL]             Object collection = getBaseValue(); [EOL]             if (collection != null && index < getLength()) { [EOL]                 collection = ValueUtils.remove(collection, index); [EOL]                 variables.declareVariable(name.toString(), collection); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public int compareTo(Object object) { [EOL]     NodePointer pointer = (NodePointer) object; [EOL]     if (parent == pointer.parent) { [EOL]         if (parent == null) { [EOL]             return 0; [EOL]         } [EOL]         return parent.compareChildNodePointers(this, pointer); [EOL]     } [EOL]     int depth1 = 0; [EOL]     NodePointer p1 = this; [EOL]     while (p1 != null) { [EOL]         depth1++; [EOL]         p1 = p1.parent; [EOL]     } [EOL]     int depth2 = 0; [EOL]     NodePointer p2 = pointer; [EOL]     while (p2 != null) { [EOL]         depth2++; [EOL]         p2 = p2.parent; [EOL]     } [EOL]     return compareNodePointers(this, depth1, pointer, depth2); [EOL] }
public int compareTo(Object object) { [EOL]     NodePointer pointer = (NodePointer) object; [EOL]     if (parent == pointer.parent) { [EOL]         if (parent == null) { [EOL]             return 0; [EOL]         } [EOL]         return parent.compareChildNodePointers(this, pointer); [EOL]     } [EOL]     int depth1 = 0; [EOL]     NodePointer p1 = this; [EOL]     while (p1 != null) { [EOL]         depth1++; [EOL]         p1 = p1.parent; [EOL]     } [EOL]     int depth2 = 0; [EOL]     NodePointer p2 = pointer; [EOL]     while (p2 != null) { [EOL]         depth2++; [EOL]         p2 = p2.parent; [EOL]     } [EOL]     return compareNodePointers(this, depth1, pointer, depth2); [EOL] }
public int compareTo(Object object) { [EOL]     NodePointer pointer = (NodePointer) object; [EOL]     if (parent == pointer.parent) { [EOL]         if (parent == null) { [EOL]             return 0; [EOL]         } [EOL]         return parent.compareChildNodePointers(this, pointer); [EOL]     } [EOL]     int depth1 = 0; [EOL]     NodePointer p1 = this; [EOL]     while (p1 != null) { [EOL]         depth1++; [EOL]         p1 = p1.parent; [EOL]     } [EOL]     int depth2 = 0; [EOL]     NodePointer p2 = pointer; [EOL]     while (p2 != null) { [EOL]         depth2++; [EOL]         p2 = p2.parent; [EOL]     } [EOL]     return compareNodePointers(this, depth1, pointer, depth2); [EOL] }
public int compareTo(Object object) { [EOL]     NodePointer pointer = (NodePointer) object; [EOL]     if (parent == pointer.parent) { [EOL]         if (parent == null) { [EOL]             return 0; [EOL]         } [EOL]         return parent.compareChildNodePointers(this, pointer); [EOL]     } [EOL]     int depth1 = 0; [EOL]     NodePointer p1 = this; [EOL]     while (p1 != null) { [EOL]         depth1++; [EOL]         p1 = p1.parent; [EOL]     } [EOL]     int depth2 = 0; [EOL]     NodePointer p2 = pointer; [EOL]     while (p2 != null) { [EOL]         depth2++; [EOL]         p2 = p2.parent; [EOL]     } [EOL]     return compareNodePointers(this, depth1, pointer, depth2); [EOL] }
public QName getName() { [EOL]     return new QName(JDOMNodePointer.getPrefix(attr), JDOMNodePointer.getLocalName(attr)); [EOL] }
public QName getName() { [EOL]     return new QName(JDOMNodePointer.getPrefix(attr), JDOMNodePointer.getLocalName(attr)); [EOL] }
public String getNamespaceURI() { [EOL]     String uri = attr.getNamespaceURI(); [EOL]     if (uri != null && uri.equals("")) { [EOL]         uri = null; [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI() { [EOL]     String uri = attr.getNamespaceURI(); [EOL]     if (uri != null && uri.equals("")) { [EOL]         uri = null; [EOL]     } [EOL]     return uri; [EOL] }
public String getNamespaceURI() { [EOL]     String uri = attr.getNamespaceURI(); [EOL]     if (uri != null && uri.equals("")) { [EOL]         uri = null; [EOL]     } [EOL]     return uri; [EOL] }
public boolean isActual() { [EOL]     return true; [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]             buffer.append('/'); [EOL]         } [EOL]     } [EOL]     buffer.append('@'); [EOL]     buffer.append(getName()); [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]             buffer.append('/'); [EOL]         } [EOL]     } [EOL]     buffer.append('@'); [EOL]     buffer.append(getName()); [EOL]     return buffer.toString(); [EOL] }
public static Object remove(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         Object smaller = Array.newInstance(collection.getClass().getComponentType(), length - 1); [EOL]         if (index > 0) { [EOL]             System.arraycopy(collection, 0, smaller, 0, index); [EOL]         } [EOL]         if (index < length - 1) { [EOL]             System.arraycopy(collection, index + 1, smaller, index, length - index - 1); [EOL]         } [EOL]         return smaller; [EOL]     } else if (collection instanceof List) { [EOL]         int size = ((List) collection).size(); [EOL]         if (index < size) { [EOL]             ((List) collection).remove(index); [EOL]         } [EOL]         return collection; [EOL]     } else if (collection instanceof Collection) { [EOL]         Iterator it = ((Collection) collection).iterator(); [EOL]         for (int i = 0; i < index; i++) { [EOL]             if (!it.hasNext()) { [EOL]                 break; [EOL]             } [EOL]             it.next(); [EOL]         } [EOL]         if (it.hasNext()) { [EOL]             it.next(); [EOL]             it.remove(); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot remove " + collection.getClass().getName() + "[" + index + "]"); [EOL]     } [EOL] }
public static Object remove(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         Object smaller = Array.newInstance(collection.getClass().getComponentType(), length - 1); [EOL]         if (index > 0) { [EOL]             System.arraycopy(collection, 0, smaller, 0, index); [EOL]         } [EOL]         if (index < length - 1) { [EOL]             System.arraycopy(collection, index + 1, smaller, index, length - index - 1); [EOL]         } [EOL]         return smaller; [EOL]     } else if (collection instanceof List) { [EOL]         int size = ((List) collection).size(); [EOL]         if (index < size) { [EOL]             ((List) collection).remove(index); [EOL]         } [EOL]         return collection; [EOL]     } else if (collection instanceof Collection) { [EOL]         Iterator it = ((Collection) collection).iterator(); [EOL]         for (int i = 0; i < index; i++) { [EOL]             if (!it.hasNext()) { [EOL]                 break; [EOL]             } [EOL]             it.next(); [EOL]         } [EOL]         if (it.hasNext()) { [EOL]             it.next(); [EOL]             it.remove(); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot remove " + collection.getClass().getName() + "[" + index + "]"); [EOL]     } [EOL] }
public static Object remove(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         Object smaller = Array.newInstance(collection.getClass().getComponentType(), length - 1); [EOL]         if (index > 0) { [EOL]             System.arraycopy(collection, 0, smaller, 0, index); [EOL]         } [EOL]         if (index < length - 1) { [EOL]             System.arraycopy(collection, index + 1, smaller, index, length - index - 1); [EOL]         } [EOL]         return smaller; [EOL]     } else if (collection instanceof List) { [EOL]         int size = ((List) collection).size(); [EOL]         if (index < size) { [EOL]             ((List) collection).remove(index); [EOL]         } [EOL]         return collection; [EOL]     } else if (collection instanceof Collection) { [EOL]         Iterator it = ((Collection) collection).iterator(); [EOL]         for (int i = 0; i < index; i++) { [EOL]             if (!it.hasNext()) { [EOL]                 break; [EOL]             } [EOL]             it.next(); [EOL]         } [EOL]         if (it.hasNext()) { [EOL]             it.next(); [EOL]             it.remove(); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot remove " + collection.getClass().getName() + "[" + index + "]"); [EOL]     } [EOL] }
public static Object remove(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         Object smaller = Array.newInstance(collection.getClass().getComponentType(), length - 1); [EOL]         if (index > 0) { [EOL]             System.arraycopy(collection, 0, smaller, 0, index); [EOL]         } [EOL]         if (index < length - 1) { [EOL]             System.arraycopy(collection, index + 1, smaller, index, length - index - 1); [EOL]         } [EOL]         return smaller; [EOL]     } else if (collection instanceof List) { [EOL]         int size = ((List) collection).size(); [EOL]         if (index < size) { [EOL]             ((List) collection).remove(index); [EOL]         } [EOL]         return collection; [EOL]     } else if (collection instanceof Collection) { [EOL]         Iterator it = ((Collection) collection).iterator(); [EOL]         for (int i = 0; i < index; i++) { [EOL]             if (!it.hasNext()) { [EOL]                 break; [EOL]             } [EOL]             it.next(); [EOL]         } [EOL]         if (it.hasNext()) { [EOL]             it.next(); [EOL]             it.remove(); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot remove " + collection.getClass().getName() + "[" + index + "]"); [EOL]     } [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor) { [EOL]     Object value; [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getReadMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No read method"); [EOL]         } [EOL]         value = method.invoke(bean, new Object[0]); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot access property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL]     return value; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private static Method getAccessibleMethodFromInterfaceNest(Class clazz, String methodName, Class[] parameterTypes) { [EOL]     Method method = null; [EOL]     Class[] interfaces = clazz.getInterfaces(); [EOL]     for (int i = 0; i < interfaces.length; i++) { [EOL]         if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         try { [EOL]             method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]         } catch (NoSuchMethodException e) { [EOL]             ; [EOL]         } [EOL]         if (method != null) { [EOL]             break; [EOL]         } [EOL]         method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]         if (method != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return (method); [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public ParentContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     return currentNodePointer; [EOL] }
public void reset() { [EOL]     super.reset(); [EOL]     setStarted = false; [EOL] }
public boolean nextNode() { [EOL]     if (setStarted) { [EOL]         return false; [EOL]     } [EOL]     setStarted = true; [EOL]     NodePointer thisLocation = parentContext.getCurrentNodePointer(); [EOL]     currentNodePointer = thisLocation.getImmediateParentPointer(); [EOL]     while (currentNodePointer != null && currentNodePointer.isContainer()) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]     } [EOL]     if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) { [EOL]         position++; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (setStarted) { [EOL]         return false; [EOL]     } [EOL]     setStarted = true; [EOL]     NodePointer thisLocation = parentContext.getCurrentNodePointer(); [EOL]     currentNodePointer = thisLocation.getImmediateParentPointer(); [EOL]     while (currentNodePointer != null && currentNodePointer.isContainer()) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]     } [EOL]     if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) { [EOL]         position++; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (setStarted) { [EOL]         return false; [EOL]     } [EOL]     setStarted = true; [EOL]     NodePointer thisLocation = parentContext.getCurrentNodePointer(); [EOL]     currentNodePointer = thisLocation.getImmediateParentPointer(); [EOL]     while (currentNodePointer != null && currentNodePointer.isContainer()) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]     } [EOL]     if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) { [EOL]         position++; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean nextNode() { [EOL]     if (setStarted) { [EOL]         return false; [EOL]     } [EOL]     setStarted = true; [EOL]     NodePointer thisLocation = parentContext.getCurrentNodePointer(); [EOL]     currentNodePointer = thisLocation.getImmediateParentPointer(); [EOL]     while (currentNodePointer != null && currentNodePointer.isContainer()) { [EOL]         currentNodePointer = currentNodePointer.getImmediateParentPointer(); [EOL]     } [EOL]     if (currentNodePointer != null && currentNodePointer.testNode(nodeTest)) { [EOL]         position++; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public ContainerPointer(Container container, Locale locale) { [EOL]     super(null, locale); [EOL]     this.container = container; [EOL] }
public ContainerPointer(Container container, Locale locale) { [EOL]     super(null, locale); [EOL]     this.container = container; [EOL] }
public ContainerPointer(NodePointer parent, Container container) { [EOL]     super(parent); [EOL]     this.container = container; [EOL] }
public ContainerPointer(NodePointer parent, Container container) { [EOL]     super(parent); [EOL]     this.container = container; [EOL] }
public ContainerPointer(NodePointer parent, Container container) { [EOL]     super(parent); [EOL]     this.container = container; [EOL] }
public ContainerPointer(NodePointer parent, Container container) { [EOL]     super(parent); [EOL]     this.container = container; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     return "/"; [EOL] }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(0, active0, active1); [EOL]         return 1; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 46: [EOL]             if ((active1 & 0x80000L) != 0L) [EOL]                 return jjStopAtPos(1, 83); [EOL]             break; [EOL]         case 47: [EOL]             if ((active0 & 0x80L) != 0L) [EOL]                 return jjStopAtPos(1, 7); [EOL]             break; [EOL]         case 61: [EOL]             if ((active0 & 0x1000L) != 0L) [EOL]                 return jjStopAtPos(1, 12); [EOL]             else if ((active0 & 0x4000L) != 0L) [EOL]                 return jjStopAtPos(1, 14); [EOL]             else if ((active0 & 0x10000L) != 0L) [EOL]                 return jjStopAtPos(1, 16); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL]         case 100: [EOL]             if ((active0 & 0x8000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 51, 12); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL]         case 104: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL]         case 114: [EOL]             if ((active0 & 0x8000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 27, 12); [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(0, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(0, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(1, active0, active1); [EOL]         return 2; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL]         case 100: [EOL]             if ((active0 & 0x10000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 28, 12); [EOL]             else if ((active0 & 0x20000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 29, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL]         case 109: [EOL]             if ((active1 & 0x200L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 73, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active1 & 0x8L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 67, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL]         case 118: [EOL]             if ((active0 & 0x40000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 30, 12); [EOL]             break; [EOL]         case 120: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL]         case 121: [EOL]             if ((active0 & 0x10000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 52, 12); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(1, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(4, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(5, active0, active1); [EOL]         return 6; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL]         case 58: [EOL]             if ((active0 & 0x1000000000L) != 0L) [EOL]                 return jjStopAtPos(6, 36); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x800L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 75, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL]         case 110: [EOL]             if ((active1 & 0x4L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 66, 12); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 33, 12); [EOL]             break; [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(5, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(5, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(6, active0, active1); [EOL]         return 7; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x2000000000L) != 0L) [EOL]                 return jjStopAtPos(7, 37); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 110: [EOL]             if ((active0 & 0x2000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 49, 12); [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL]         case 115: [EOL]             if ((active0 & 0x800000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 59, 12); [EOL]             break; [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 122: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(6, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public XPathParserTokenManager(SimpleCharStream stream) { [EOL]     if (SimpleCharStream.staticFlag) [EOL]         throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."); [EOL]     input_stream = stream; [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public XPathParserTokenManager(SimpleCharStream stream) { [EOL]     if (SimpleCharStream.staticFlag) [EOL]         throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."); [EOL]     input_stream = stream; [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public DOMNodePointer(Node node, Locale locale) { [EOL]     super(null, locale); [EOL]     this.node = node; [EOL] }
public DOMNodePointer(Node node, Locale locale) { [EOL]     super(null, locale); [EOL]     this.node = node; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DOMNodePointer)) { [EOL]         return false; [EOL]     } [EOL]     DOMNodePointer other = (DOMNodePointer) object; [EOL]     return node == other.node; [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL]     Node node1 = (Node) pointer1.getBaseValue(); [EOL]     Node node2 = (Node) pointer2.getBaseValue(); [EOL]     if (node1 == node2) { [EOL]         return 0; [EOL]     } [EOL]     int t1 = node1.getNodeType(); [EOL]     int t2 = node2.getNodeType(); [EOL]     if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) { [EOL]         return -1; [EOL]     } else if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) { [EOL]         return 1; [EOL]     } else if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) { [EOL]         NamedNodeMap map = ((Node) getNode()).getAttributes(); [EOL]         int length = map.getLength(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             Node n = map.item(i); [EOL]             if (n == node1) { [EOL]                 return -1; [EOL]             } else if (n == node2) { [EOL]                 return 1; [EOL]             } [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     Node current = node.getFirstChild(); [EOL]     while (current != null) { [EOL]         if (current == node1) { [EOL]             return -1; [EOL]         } else if (current == node2) { [EOL]             return 1; [EOL]         } [EOL]         current = current.getNextSibling(); [EOL]     } [EOL]     return 0; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Function getFunction(String namespace, String name, Object[] parameters) { [EOL]     if (!namespace.equals(this.namespace)) { [EOL]         return null; [EOL]     } [EOL]     if (parameters == null) { [EOL]         parameters = EMPTY_ARRAY; [EOL]     } [EOL]     if (name.equals("new")) { [EOL]         Constructor constructor = MethodLookupUtils.lookupConstructor(functionClass, parameters); [EOL]         if (constructor != null) { [EOL]             return new ConstructorFunction(constructor); [EOL]         } [EOL]     } else { [EOL]         Method method = MethodLookupUtils.lookupStaticMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]         method = MethodLookupUtils.lookupMethod(functionClass, name, parameters); [EOL]         if (method != null) { [EOL]             return new MethodFunction(method); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     Object[] parameters = null; [EOL]     if (args != null) { [EOL]         parameters = new Object[args.length]; [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             parameters[i] = convert(args[i].compute(context)); [EOL]         } [EOL]     } [EOL]     Function function = context.getRootContext().getFunction(functionName, parameters); [EOL]     if (function == null) { [EOL]         throw new JXPathFunctionNotFoundException("No such function: " + functionName + Arrays.asList(parameters)); [EOL]     } [EOL]     return function.invoke(context, parameters); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     Object[] parameters = null; [EOL]     if (args != null) { [EOL]         parameters = new Object[args.length]; [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             parameters[i] = convert(args[i].compute(context)); [EOL]         } [EOL]     } [EOL]     Function function = context.getRootContext().getFunction(functionName, parameters); [EOL]     if (function == null) { [EOL]         throw new JXPathFunctionNotFoundException("No such function: " + functionName + Arrays.asList(parameters)); [EOL]     } [EOL]     return function.invoke(context, parameters); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     Object[] parameters = null; [EOL]     if (args != null) { [EOL]         parameters = new Object[args.length]; [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             parameters[i] = convert(args[i].compute(context)); [EOL]         } [EOL]     } [EOL]     Function function = context.getRootContext().getFunction(functionName, parameters); [EOL]     if (function == null) { [EOL]         throw new JXPathFunctionNotFoundException("No such function: " + functionName + Arrays.asList(parameters)); [EOL]     } [EOL]     return function.invoke(context, parameters); [EOL] }
private Object convert(Object object) { [EOL]     if (object instanceof EvalContext) { [EOL]         return ((EvalContext) object).getValue(); [EOL]     } [EOL]     return object; [EOL] }
private Object convert(Object object) { [EOL]     if (object instanceof EvalContext) { [EOL]         return ((EvalContext) object).getValue(); [EOL]     } [EOL]     return object; [EOL] }
public boolean setPosition(int position) { [EOL]     while (this.position < position) { [EOL]         if (!next()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     while (this.position > position) { [EOL]         if (!previous()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     while (this.position < position) { [EOL]         if (!next()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     while (this.position > position) { [EOL]         if (!previous()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     while (this.position < position) { [EOL]         if (!next()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     while (this.position > position) { [EOL]         if (!previous()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     while (this.position < position) { [EOL]         if (!next()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     while (this.position > position) { [EOL]         if (!previous()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         if (position == 0) { [EOL]             child = null; [EOL]         } else if (child == null) { [EOL]             child = node.getLastChild(); [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } else { [EOL]         child = child.getNextSibling(); [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         if (position == 0) { [EOL]             child = null; [EOL]         } else if (child == null) { [EOL]             child = node.getLastChild(); [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } else { [EOL]         child = child.getNextSibling(); [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         if (position == 0) { [EOL]             child = null; [EOL]         } else if (child == null) { [EOL]             child = node.getLastChild(); [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } else { [EOL]         child = child.getNextSibling(); [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         if (position == 0) { [EOL]             child = null; [EOL]         } else if (child == null) { [EOL]             child = node.getLastChild(); [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } else { [EOL]         child = child.getNextSibling(); [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         if (position == 0) { [EOL]             child = null; [EOL]         } else if (child == null) { [EOL]             child = node.getLastChild(); [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } else { [EOL]         child = child.getNextSibling(); [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         if (position == 0) { [EOL]             child = null; [EOL]         } else if (child == null) { [EOL]             child = node.getLastChild(); [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } else { [EOL]         child = child.getNextSibling(); [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         if (position == 0) { [EOL]             child = null; [EOL]         } else if (child == null) { [EOL]             child = node.getLastChild(); [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } else { [EOL]         child = child.getNextSibling(); [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] }
public String getNamespaceURI() { [EOL]     String prefix = DOMNodePointer.getPrefix(attr); [EOL]     if (prefix == null) { [EOL]         return null; [EOL]     } [EOL]     return parent.getNamespaceURI(prefix); [EOL] }
public String getNamespaceURI() { [EOL]     String prefix = DOMNodePointer.getPrefix(attr); [EOL]     if (prefix == null) { [EOL]         return null; [EOL]     } [EOL]     return parent.getNamespaceURI(prefix); [EOL] }
public int hashCode() { [EOL]     return System.identityHashCode(attr); [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Node) { [EOL]         return new DOMNodePointer((Node) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Node) { [EOL]         return new DOMNodePointer((Node) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public boolean isCollection() { [EOL]     return true; [EOL] }
public boolean isContainer() { [EOL]     return index != WHOLE_COLLECTION; [EOL] }
public boolean isContainer() { [EOL]     return index != WHOLE_COLLECTION; [EOL] }
public Object getImmediateNode() { [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         return ValueUtils.getValue(collection, index); [EOL]     } else { [EOL]         return ValueUtils.getValue(collection); [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         return ValueUtils.getValue(collection, index); [EOL]     } else { [EOL]         return ValueUtils.getValue(collection); [EOL]     } [EOL] }
public ConstructorFunction(Constructor constructor) { [EOL]     this.constructor = constructor; [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL]     try { [EOL]         Object[] args; [EOL]         if (parameters == null) { [EOL]             parameters = EMPTY_ARRAY; [EOL]         } [EOL]         int pi = 0; [EOL]         Class[] types = constructor.getParameterTypes(); [EOL]         if (types.length > 0 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]             pi = 1; [EOL]         } [EOL]         args = new Object[parameters.length + pi]; [EOL]         if (pi == 1) { [EOL]             args[0] = context; [EOL]         } [EOL]         for (int i = 0; i < parameters.length; i++) { [EOL]             args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL]         } [EOL]         return constructor.newInstance(args); [EOL]     } catch (Throwable ex) { [EOL]         if (ex instanceof InvocationTargetException) { [EOL]             ex = ((InvocationTargetException) ex).getTargetException(); [EOL]         } [EOL]         throw new JXPathInvalidAccessException("Cannot invoke constructor " + constructor, ex); [EOL]     } [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL]     try { [EOL]         Object[] args; [EOL]         if (parameters == null) { [EOL]             parameters = EMPTY_ARRAY; [EOL]         } [EOL]         int pi = 0; [EOL]         Class[] types = constructor.getParameterTypes(); [EOL]         if (types.length > 0 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]             pi = 1; [EOL]         } [EOL]         args = new Object[parameters.length + pi]; [EOL]         if (pi == 1) { [EOL]             args[0] = context; [EOL]         } [EOL]         for (int i = 0; i < parameters.length; i++) { [EOL]             args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL]         } [EOL]         return constructor.newInstance(args); [EOL]     } catch (Throwable ex) { [EOL]         if (ex instanceof InvocationTargetException) { [EOL]             ex = ((InvocationTargetException) ex).getTargetException(); [EOL]         } [EOL]         throw new JXPathInvalidAccessException("Cannot invoke constructor " + constructor, ex); [EOL]     } [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL]     try { [EOL]         Object[] args; [EOL]         if (parameters == null) { [EOL]             parameters = EMPTY_ARRAY; [EOL]         } [EOL]         int pi = 0; [EOL]         Class[] types = constructor.getParameterTypes(); [EOL]         if (types.length > 0 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]             pi = 1; [EOL]         } [EOL]         args = new Object[parameters.length + pi]; [EOL]         if (pi == 1) { [EOL]             args[0] = context; [EOL]         } [EOL]         for (int i = 0; i < parameters.length; i++) { [EOL]             args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL]         } [EOL]         return constructor.newInstance(args); [EOL]     } catch (Throwable ex) { [EOL]         if (ex instanceof InvocationTargetException) { [EOL]             ex = ((InvocationTargetException) ex).getTargetException(); [EOL]         } [EOL]         throw new JXPathInvalidAccessException("Cannot invoke constructor " + constructor, ex); [EOL]     } [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL]     try { [EOL]         Object[] args; [EOL]         if (parameters == null) { [EOL]             parameters = EMPTY_ARRAY; [EOL]         } [EOL]         int pi = 0; [EOL]         Class[] types = constructor.getParameterTypes(); [EOL]         if (types.length > 0 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]             pi = 1; [EOL]         } [EOL]         args = new Object[parameters.length + pi]; [EOL]         if (pi == 1) { [EOL]             args[0] = context; [EOL]         } [EOL]         for (int i = 0; i < parameters.length; i++) { [EOL]             args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL]         } [EOL]         return constructor.newInstance(args); [EOL]     } catch (Throwable ex) { [EOL]         if (ex instanceof InvocationTargetException) { [EOL]             ex = ((InvocationTargetException) ex).getTargetException(); [EOL]         } [EOL]         throw new JXPathInvalidAccessException("Cannot invoke constructor " + constructor, ex); [EOL]     } [EOL] }
public DOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     attributes = new ArrayList(); [EOL]     Node node = (Node) parent.getNode(); [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             Attr attr = getAttribute((Element) node, name); [EOL]             if (attr != null) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } else { [EOL]             NamedNodeMap map = node.getAttributes(); [EOL]             int count = map.getLength(); [EOL]             for (int i = 0; i < count; i++) { [EOL]                 Attr attr = (Attr) map.item(i); [EOL]                 if (testAttr(attr, name)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public DOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     attributes = new ArrayList(); [EOL]     Node node = (Node) parent.getNode(); [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             Attr attr = getAttribute((Element) node, name); [EOL]             if (attr != null) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } else { [EOL]             NamedNodeMap map = node.getAttributes(); [EOL]             int count = map.getLength(); [EOL]             for (int i = 0; i < count; i++) { [EOL]                 Attr attr = (Attr) map.item(i); [EOL]                 if (testAttr(attr, name)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public DOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     attributes = new ArrayList(); [EOL]     Node node = (Node) parent.getNode(); [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             Attr attr = getAttribute((Element) node, name); [EOL]             if (attr != null) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } else { [EOL]             NamedNodeMap map = node.getAttributes(); [EOL]             int count = map.getLength(); [EOL]             for (int i = 0; i < count; i++) { [EOL]                 Attr attr = (Attr) map.item(i); [EOL]                 if (testAttr(attr, name)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private boolean testAttr(Attr attr, QName testName) { [EOL]     String nodePrefix = DOMNodePointer.getPrefix(attr); [EOL]     String nodeLocalName = DOMNodePointer.getLocalName(attr); [EOL]     if (nodePrefix != null && nodePrefix.equals("xmlns")) { [EOL]         return false; [EOL]     } [EOL]     if (nodePrefix == null && nodeLocalName.equals("xmlns")) { [EOL]         return false; [EOL]     } [EOL]     String testLocalName = name.getName(); [EOL]     if (testLocalName.equals("*") || testLocalName.equals(nodeLocalName)) { [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (equalStrings(testPrefix, nodePrefix)) { [EOL]             return true; [EOL]         } [EOL]         String testNS = null; [EOL]         if (testPrefix != null) { [EOL]             testNS = parent.getNamespaceURI(testPrefix); [EOL]         } [EOL]         String nodeNS = null; [EOL]         if (nodePrefix != null) { [EOL]             nodeNS = parent.getNamespaceURI(nodePrefix); [EOL]         } [EOL]         return equalStrings(testNS, nodeNS); [EOL]     } [EOL]     return false; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
private Attr getAttribute(Element element, QName name) { [EOL]     String testPrefix = name.getPrefix(); [EOL]     String testNS = null; [EOL]     if (testPrefix != null) { [EOL]         testNS = parent.getNamespaceURI(testPrefix); [EOL]     } [EOL]     if (testNS != null) { [EOL]         Attr attr = element.getAttributeNodeNS(testNS, name.getName()); [EOL]         if (attr != null) { [EOL]             return attr; [EOL]         } [EOL]         NamedNodeMap nnm = element.getAttributes(); [EOL]         for (int i = 0; i < nnm.getLength(); i++) { [EOL]             attr = (Attr) nnm.item(i); [EOL]             if (testAttr(attr, name)) { [EOL]                 return attr; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } else { [EOL]         return element.getAttributeNode(name.getName()); [EOL]     } [EOL] }
public boolean isActual() { [EOL]     if (!isActualProperty()) { [EOL]         return false; [EOL]     } [EOL]     return super.isActual(); [EOL] }
public boolean isActual() { [EOL]     if (!isActualProperty()) { [EOL]         return false; [EOL]     } [EOL]     return super.isActual(); [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Container) { [EOL]         return new ContainerPointer((Container) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL]     if (bean instanceof Container) { [EOL]         return new ContainerPointer((Container) bean, locale); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Container) { [EOL]         return new ContainerPointer(parent, (Container) bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Container) { [EOL]         return new ContainerPointer(parent, (Container) bean); [EOL]     } [EOL]     return null; [EOL] }
protected JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean) { [EOL]     this(parentContext, contextBean, null); [EOL] }
protected JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean) { [EOL]     this(parentContext, contextBean, null); [EOL] }
protected JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean) { [EOL]     this(parentContext, contextBean, null); [EOL] }
protected JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean) { [EOL]     this(parentContext, contextBean, null); [EOL] }
public JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean, Pointer contextPointer) { [EOL]     super(parentContext, contextBean); [EOL]     synchronized (nodeFactories) { [EOL]         createNodeFactoryArray(); [EOL]     } [EOL]     if (contextPointer != null) { [EOL]         this.contextPointer = contextPointer; [EOL]         this.rootPointer = NodePointer.newNodePointer(new QName(null, "root"), contextPointer.getRootNode(), getLocale()); [EOL]     } else { [EOL]         this.contextPointer = NodePointer.newNodePointer(new QName(null, "root"), contextBean, getLocale()); [EOL]         this.rootPointer = this.contextPointer; [EOL]     } [EOL]     NamespaceResolver parentNR = null; [EOL]     if (parentContext instanceof JXPathContextReferenceImpl) { [EOL]         parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver(); [EOL]     } [EOL]     namespaceResolver = new NamespaceResolver(parentNR); [EOL]     namespaceResolver.setNamespaceContextPointer((NodePointer) this.contextPointer); [EOL] }
public JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean, Pointer contextPointer) { [EOL]     super(parentContext, contextBean); [EOL]     synchronized (nodeFactories) { [EOL]         createNodeFactoryArray(); [EOL]     } [EOL]     if (contextPointer != null) { [EOL]         this.contextPointer = contextPointer; [EOL]         this.rootPointer = NodePointer.newNodePointer(new QName(null, "root"), contextPointer.getRootNode(), getLocale()); [EOL]     } else { [EOL]         this.contextPointer = NodePointer.newNodePointer(new QName(null, "root"), contextBean, getLocale()); [EOL]         this.rootPointer = this.contextPointer; [EOL]     } [EOL]     NamespaceResolver parentNR = null; [EOL]     if (parentContext instanceof JXPathContextReferenceImpl) { [EOL]         parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver(); [EOL]     } [EOL]     namespaceResolver = new NamespaceResolver(parentNR); [EOL]     namespaceResolver.setNamespaceContextPointer((NodePointer) this.contextPointer); [EOL] }
public JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean, Pointer contextPointer) { [EOL]     super(parentContext, contextBean); [EOL]     synchronized (nodeFactories) { [EOL]         createNodeFactoryArray(); [EOL]     } [EOL]     if (contextPointer != null) { [EOL]         this.contextPointer = contextPointer; [EOL]         this.rootPointer = NodePointer.newNodePointer(new QName(null, "root"), contextPointer.getRootNode(), getLocale()); [EOL]     } else { [EOL]         this.contextPointer = NodePointer.newNodePointer(new QName(null, "root"), contextBean, getLocale()); [EOL]         this.rootPointer = this.contextPointer; [EOL]     } [EOL]     NamespaceResolver parentNR = null; [EOL]     if (parentContext instanceof JXPathContextReferenceImpl) { [EOL]         parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver(); [EOL]     } [EOL]     namespaceResolver = new NamespaceResolver(parentNR); [EOL]     namespaceResolver.setNamespaceContextPointer((NodePointer) this.contextPointer); [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Pointer createPath(String xpath, Expression expr) { [EOL]     try { [EOL]         Object result = expr.computeValue(getEvalContext()); [EOL]         Pointer pointer = null; [EOL]         if (result instanceof Pointer) { [EOL]             pointer = (Pointer) result; [EOL]         } else if (result instanceof EvalContext) { [EOL]             EvalContext ctx = (EvalContext) result; [EOL]             pointer = ctx.getSingleNodePointer(); [EOL]         } else { [EOL]             checkSimplePath(expr); [EOL]             throw new JXPathException("Cannot create path:" + xpath); [EOL]         } [EOL]         return ((NodePointer) pointer).createPath(this); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPath(String xpath, Expression expr) { [EOL]     try { [EOL]         Object result = expr.computeValue(getEvalContext()); [EOL]         Pointer pointer = null; [EOL]         if (result instanceof Pointer) { [EOL]             pointer = (Pointer) result; [EOL]         } else if (result instanceof EvalContext) { [EOL]             EvalContext ctx = (EvalContext) result; [EOL]             pointer = ctx.getSingleNodePointer(); [EOL]         } else { [EOL]             checkSimplePath(expr); [EOL]             throw new JXPathException("Cannot create path:" + xpath); [EOL]         } [EOL]         return ((NodePointer) pointer).createPath(this); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPath(String xpath, Expression expr) { [EOL]     try { [EOL]         Object result = expr.computeValue(getEvalContext()); [EOL]         Pointer pointer = null; [EOL]         if (result instanceof Pointer) { [EOL]             pointer = (Pointer) result; [EOL]         } else if (result instanceof EvalContext) { [EOL]             EvalContext ctx = (EvalContext) result; [EOL]             pointer = ctx.getSingleNodePointer(); [EOL]         } else { [EOL]             checkSimplePath(expr); [EOL]             throw new JXPathException("Cannot create path:" + xpath); [EOL]         } [EOL]         return ((NodePointer) pointer).createPath(this); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPath(String xpath, Expression expr) { [EOL]     try { [EOL]         Object result = expr.computeValue(getEvalContext()); [EOL]         Pointer pointer = null; [EOL]         if (result instanceof Pointer) { [EOL]             pointer = (Pointer) result; [EOL]         } else if (result instanceof EvalContext) { [EOL]             EvalContext ctx = (EvalContext) result; [EOL]             pointer = ctx.getSingleNodePointer(); [EOL]         } else { [EOL]             checkSimplePath(expr); [EOL]             throw new JXPathException("Cannot create path:" + xpath); [EOL]         } [EOL]         return ((NodePointer) pointer).createPath(this); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
public CoreOperationNegate(Expression arg) { [EOL]     super(new Expression[] { arg }); [EOL] }
protected int getPrecedence() { [EOL]     return 6; [EOL] }
public String getSymbol() { [EOL]     return "-"; [EOL] }
protected int getPrecedence() { [EOL]     return 7; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         while (--index >= 0) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean previous() { [EOL]     position--; [EOL]     if (!reverse) { [EOL]         while (--index >= 0) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
