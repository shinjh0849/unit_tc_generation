@Override [EOL] public Version version() { [EOL]     return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; [EOL] }
@Override [EOL] public PropertyName findRootName(AnnotatedClass ac) { [EOL]     JsonRootName ann = ac.getAnnotation(JsonRootName.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     return new PropertyName(ann.value()); [EOL] }
@Override [EOL] public PropertyName findRootName(AnnotatedClass ac) { [EOL]     JsonRootName ann = ac.getAnnotation(JsonRootName.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     return new PropertyName(ann.value()); [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.keyUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.keyUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.keyUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationContentConverter(AnnotatedMember a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationContentConverter(AnnotatedMember a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationContentConverter(AnnotatedMember a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) { [EOL]     JsonPOJOBuilder ann = ac.getAnnotation(JsonPOJOBuilder.class); [EOL]     return (ann == null) ? null : new JsonPOJOBuilder.Value(ann); [EOL] }
protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) { [EOL]     TypeResolverBuilder<?> b; [EOL]     JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class); [EOL]     JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class); [EOL]     if (resAnn != null) { [EOL]         if (info == null) { [EOL]             return null; [EOL]         } [EOL]         b = config.typeResolverBuilderInstance(ann, resAnn.value()); [EOL]     } else { [EOL]         if (info == null) { [EOL]             return null; [EOL]         } [EOL]         if (info.use() == JsonTypeInfo.Id.NONE) { [EOL]             return _constructNoTypeResolverBuilder(); [EOL]         } [EOL]         b = _constructStdTypeResolverBuilder(); [EOL]     } [EOL]     JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class); [EOL]     TypeIdResolver idRes = (idResInfo == null) ? null : config.typeIdResolverInstance(ann, idResInfo.value()); [EOL]     if (idRes != null) { [EOL]         idRes.init(baseType); [EOL]     } [EOL]     b = b.init(info.use(), idRes); [EOL]     JsonTypeInfo.As inclusion = info.include(); [EOL]     if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) { [EOL]         inclusion = JsonTypeInfo.As.PROPERTY; [EOL]     } [EOL]     b = b.inclusion(inclusion); [EOL]     b = b.typeProperty(info.property()); [EOL]     Class<?> defaultImpl = info.defaultImpl(); [EOL]     if (defaultImpl != JsonTypeInfo.None.class) { [EOL]         b = b.defaultImpl(defaultImpl); [EOL]     } [EOL]     b = b.typeIdVisibility(info.visible()); [EOL]     return b; [EOL] }
protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() { [EOL]     return StdTypeResolverBuilder.noTypeInfoBuilder(); [EOL] }
public ObjectIdInfo withAlwaysAsId(boolean state) { [EOL]     if (_alwaysAsId == state) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectIdInfo(_propertyName, _scope, _generator, state); [EOL] }
public ObjectIdInfo withAlwaysAsId(boolean state) { [EOL]     if (_alwaysAsId == state) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectIdInfo(_propertyName, _scope, _generator, state); [EOL] }
public final boolean isEnabled(DeserializationFeature feat) { [EOL]     return (_featureFlags & feat.getMask()) != 0; [EOL] }
public final boolean isEnabled(DeserializationFeature feat) { [EOL]     return (_featureFlags & feat.getMask()) != 0; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
public final JavaType constructType(Class<?> cls) { [EOL]     return _config.constructType(cls); [EOL] }
public final JavaType constructType(Class<?> cls) { [EOL]     return _config.constructType(cls); [EOL] }
public Date parseDate(String dateStr) throws IllegalArgumentException { [EOL]     try { [EOL]         return getDateFormat().parse(dateStr); [EOL]     } catch (ParseException e) { [EOL]         throw new IllegalArgumentException("Failed to parse Date value '" + dateStr + "': " + e.getMessage()); [EOL]     } [EOL] }
public Date parseDate(String dateStr) throws IllegalArgumentException { [EOL]     try { [EOL]         return getDateFormat().parse(dateStr); [EOL]     } catch (ParseException e) { [EOL]         throw new IllegalArgumentException("Failed to parse Date value '" + dateStr + "': " + e.getMessage()); [EOL]     } [EOL] }
public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); [EOL]     if (h != null) { [EOL]         while (h != null) { [EOL]             if (h.value().handleUnknownProperty(this, jp, deser, instanceOrClass, propName)) { [EOL]                 return true; [EOL]             } [EOL]             h = h.next(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); [EOL]     if (h != null) { [EOL]         while (h != null) { [EOL]             if (h.value().handleUnknownProperty(this, jp, deser, instanceOrClass, propName)) { [EOL]                 return true; [EOL]             } [EOL]             h = h.next(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); [EOL]     if (h != null) { [EOL]         while (h != null) { [EOL]             if (h.value().handleUnknownProperty(this, jp, deser, instanceOrClass, propName)) { [EOL]                 return true; [EOL]             } [EOL]             h = h.next(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public JsonMappingException weirdStringException(String value, Class<?> instClass, String msg) { [EOL]     return InvalidFormatException.from(_parser, "Can not construct instance of " + instClass.getName() + " from String value '" + _valueDesc() + "': " + msg, value, instClass); [EOL] }
protected DateFormat getDateFormat() { [EOL]     if (_dateFormat != null) { [EOL]         return _dateFormat; [EOL]     } [EOL]     DateFormat df = _config.getDateFormat(); [EOL]     _dateFormat = df = (DateFormat) df.clone(); [EOL]     return df; [EOL] }
protected DateFormat getDateFormat() { [EOL]     if (_dateFormat != null) { [EOL]         return _dateFormat; [EOL]     } [EOL]     DateFormat df = _config.getDateFormat(); [EOL]     _dateFormat = df = (DateFormat) df.clone(); [EOL]     return df; [EOL] }
protected String _valueDesc() { [EOL]     try { [EOL]         return _desc(_parser.getText()); [EOL]     } catch (Exception e) { [EOL]         return "[N/A]"; [EOL]     } [EOL] }
protected String _valueDesc() { [EOL]     try { [EOL]         return _desc(_parser.getText()); [EOL]     } catch (Exception e) { [EOL]         return "[N/A]"; [EOL]     } [EOL] }
protected String _desc(String desc) { [EOL]     if (desc.length() > MAX_ERROR_STR_LEN) { [EOL]         desc = desc.substring(0, MAX_ERROR_STR_LEN) + "]...[" + desc.substring(desc.length() - MAX_ERROR_STR_LEN); [EOL]     } [EOL]     return desc; [EOL] }
protected String _desc(String desc) { [EOL]     if (desc.length() > MAX_ERROR_STR_LEN) { [EOL]         desc = desc.substring(0, MAX_ERROR_STR_LEN) + "]...[" + desc.substring(desc.length() - MAX_ERROR_STR_LEN); [EOL]     } [EOL]     return desc; [EOL] }
protected String _desc(String desc) { [EOL]     if (desc.length() > MAX_ERROR_STR_LEN) { [EOL]         desc = desc.substring(0, MAX_ERROR_STR_LEN) + "]...[" + desc.substring(desc.length() - MAX_ERROR_STR_LEN); [EOL]     } [EOL]     return desc; [EOL] }
@Override [EOL] public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { [EOL]     String value = ISO8601Utils.format(date); [EOL]     toAppendTo.append(value); [EOL]     return toAppendTo; [EOL] }
@Override [EOL] public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { [EOL]     String value = ISO8601Utils.format(date); [EOL]     toAppendTo.append(value); [EOL]     return toAppendTo; [EOL] }
@Override [EOL] public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { [EOL]     String value = ISO8601Utils.format(date); [EOL]     toAppendTo.append(value); [EOL]     return toAppendTo; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public JsonDeserializer<Object> deserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<?> deser; [EOL]     if (deserDef instanceof JsonDeserializer) { [EOL]         deser = (JsonDeserializer<?>) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned deserializer definition of type " + deserDef.getClass().getName() + "; expected type JsonDeserializer or Class<JsonDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<JsonDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return (JsonDeserializer<Object>) deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public boolean isExplicitlyIncluded() { [EOL]     return _anyExplicitNames(_fields) || _anyExplicitNames(_getters) || _anyExplicitNames(_setters) || _anyExplicitNames(_ctorParameters); [EOL] }
@Override [EOL] public boolean isExplicitlyIncluded() { [EOL]     return _anyExplicitNames(_fields) || _anyExplicitNames(_getters) || _anyExplicitNames(_setters) || _anyExplicitNames(_ctorParameters); [EOL] }
@Override [EOL] public boolean isExplicitlyIncluded() { [EOL]     return _anyExplicitNames(_fields) || _anyExplicitNames(_getters) || _anyExplicitNames(_setters) || _anyExplicitNames(_ctorParameters); [EOL] }
@Override [EOL] public boolean isExplicitlyIncluded() { [EOL]     return _anyExplicitNames(_fields) || _anyExplicitNames(_getters) || _anyExplicitNames(_setters) || _anyExplicitNames(_ctorParameters); [EOL] }
@Override [EOL] public boolean isExplicitlyIncluded() { [EOL]     return _anyExplicitNames(_fields) || _anyExplicitNames(_getters) || _anyExplicitNames(_setters) || _anyExplicitNames(_ctorParameters); [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if (_setters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod setter = _setters.value; [EOL]     Linked<AnnotatedMethod> next = _setters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextSetter = next.value; [EOL]         Class<?> setterClass = setter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextSetter.getDeclaringClass(); [EOL]         if (setterClass != nextClass) { [EOL]             if (setterClass.isAssignableFrom(nextClass)) { [EOL]                 setter = nextSetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(setterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting setter definitions for property \"" + getName() + "\": " + setter.getFullName() + " vs " + nextSetter.getFullName()); [EOL]     } [EOL]     return setter; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if (_setters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod setter = _setters.value; [EOL]     Linked<AnnotatedMethod> next = _setters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextSetter = next.value; [EOL]         Class<?> setterClass = setter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextSetter.getDeclaringClass(); [EOL]         if (setterClass != nextClass) { [EOL]             if (setterClass.isAssignableFrom(nextClass)) { [EOL]                 setter = nextSetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(setterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting setter definitions for property \"" + getName() + "\": " + setter.getFullName() + " vs " + nextSetter.getFullName()); [EOL]     } [EOL]     return setter; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if (_setters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod setter = _setters.value; [EOL]     Linked<AnnotatedMethod> next = _setters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextSetter = next.value; [EOL]         Class<?> setterClass = setter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextSetter.getDeclaringClass(); [EOL]         if (setterClass != nextClass) { [EOL]             if (setterClass.isAssignableFrom(nextClass)) { [EOL]                 setter = nextSetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(setterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting setter definitions for property \"" + getName() + "\": " + setter.getFullName() + " vs " + nextSetter.getFullName()); [EOL]     } [EOL]     return setter; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if (_setters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod setter = _setters.value; [EOL]     Linked<AnnotatedMethod> next = _setters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextSetter = next.value; [EOL]         Class<?> setterClass = setter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextSetter.getDeclaringClass(); [EOL]         if (setterClass != nextClass) { [EOL]             if (setterClass.isAssignableFrom(nextClass)) { [EOL]                 setter = nextSetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(setterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting setter definitions for property \"" + getName() + "\": " + setter.getFullName() + " vs " + nextSetter.getFullName()); [EOL]     } [EOL]     return setter; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if (_setters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod setter = _setters.value; [EOL]     Linked<AnnotatedMethod> next = _setters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextSetter = next.value; [EOL]         Class<?> setterClass = setter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextSetter.getDeclaringClass(); [EOL]         if (setterClass != nextClass) { [EOL]             if (setterClass.isAssignableFrom(nextClass)) { [EOL]                 setter = nextSetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(setterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting setter definitions for property \"" + getName() + "\": " + setter.getFullName() + " vs " + nextSetter.getFullName()); [EOL]     } [EOL]     return setter; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     if (_fields == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedField field = _fields.value; [EOL]     Linked<AnnotatedField> next = _fields.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedField nextField = next.value; [EOL]         Class<?> fieldClass = field.getDeclaringClass(); [EOL]         Class<?> nextClass = nextField.getDeclaringClass(); [EOL]         if (fieldClass != nextClass) { [EOL]             if (fieldClass.isAssignableFrom(nextClass)) { [EOL]                 field = nextField; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(fieldClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Multiple fields representing property \"" + getName() + "\": " + field.getFullName() + " vs " + nextField.getFullName()); [EOL]     } [EOL]     return field; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
private <T> boolean _anyExplicitNames(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.explicitName != null && n.explicitName.length() > 0) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private <T> boolean _anyExplicitNames(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.explicitName != null && n.explicitName.length() > 0) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private <T> boolean _anyExplicitNames(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.explicitName != null && n.explicitName.length() > 0) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private <T> boolean _anyExplicitNames(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.explicitName != null && n.explicitName.length() > 0) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private <T> boolean _anyExplicitNames(Linked<T> n) { [EOL]     for (; n != null; n = n.next) { [EOL]         if (n.explicitName != null && n.explicitName.length() > 0) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
public Linked<T> trimByVisibility() { [EOL]     if (next == null) { [EOL]         return this; [EOL]     } [EOL]     Linked<T> newNext = next.trimByVisibility(); [EOL]     if (explicitName != null) { [EOL]         if (newNext.explicitName == null) { [EOL]             return withNext(null); [EOL]         } [EOL]         return withNext(newNext); [EOL]     } [EOL]     if (newNext.explicitName != null) { [EOL]         return newNext; [EOL]     } [EOL]     if (isVisible == newNext.isVisible) { [EOL]         return withNext(newNext); [EOL]     } [EOL]     return isVisible ? withNext(null) : newNext; [EOL] }
@Override [EOL] public JsonParser.NumberType numberType() { [EOL]     return JsonParser.NumberType.DOUBLE; [EOL] }
@Override [EOL] public boolean isFloatingPointNumber() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean isDouble() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE); [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return Double.valueOf(_value); [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return Double.valueOf(_value); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return decimalValue().toBigInteger(); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return decimalValue().toBigInteger(); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final double otherValue = ((DoubleNode) o)._value; [EOL]     return Double.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final double otherValue = ((DoubleNode) o)._value; [EOL]     return Double.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final double otherValue = ((DoubleNode) o)._value; [EOL]     return Double.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final double otherValue = ((DoubleNode) o)._value; [EOL]     return Double.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final double otherValue = ((DoubleNode) o)._value; [EOL]     return Double.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     long l = Double.doubleToLongBits(_value); [EOL]     return ((int) l) ^ (int) (l >> 32); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     long l = Double.doubleToLongBits(_value); [EOL]     return ((int) l) ^ (int) (l >> 32); [EOL] }
public Object build(DeserializationContext ctxt, PropertyValueBuffer buffer) throws IOException { [EOL]     Object bean = _valueInstantiator.createFromObjectWith(ctxt, buffer.getParameters(_defaultValues)); [EOL]     bean = buffer.handleIdValue(ctxt, bean); [EOL]     for (PropertyValue pv = buffer.buffered(); pv != null; pv = pv.next) { [EOL]         pv.assign(bean); [EOL]     } [EOL]     return bean; [EOL] }
public Object build(DeserializationContext ctxt, PropertyValueBuffer buffer) throws IOException { [EOL]     Object bean = _valueInstantiator.createFromObjectWith(ctxt, buffer.getParameters(_defaultValues)); [EOL]     bean = buffer.handleIdValue(ctxt, bean); [EOL]     for (PropertyValue pv = buffer.buffered(); pv != null; pv = pv.next) { [EOL]         pv.assign(bean); [EOL]     } [EOL]     return bean; [EOL] }
public Object build(DeserializationContext ctxt, PropertyValueBuffer buffer) throws IOException { [EOL]     Object bean = _valueInstantiator.createFromObjectWith(ctxt, buffer.getParameters(_defaultValues)); [EOL]     bean = buffer.handleIdValue(ctxt, bean); [EOL]     for (PropertyValue pv = buffer.buffered(); pv != null; pv = pv.next) { [EOL]         pv.assign(bean); [EOL]     } [EOL]     return bean; [EOL] }
protected JsonNode() { [EOL] }
@Override [EOL] public int size() { [EOL]     return 0; [EOL] }
@Override [EOL] public final boolean isContainerNode() { [EOL]     final JsonNodeType type = getNodeType(); [EOL]     return type == JsonNodeType.OBJECT || type == JsonNodeType.ARRAY; [EOL] }
@Override [EOL] public final boolean isContainerNode() { [EOL]     final JsonNodeType type = getNodeType(); [EOL]     return type == JsonNodeType.OBJECT || type == JsonNodeType.ARRAY; [EOL] }
@Override [EOL] public final boolean isContainerNode() { [EOL]     final JsonNodeType type = getNodeType(); [EOL]     return type == JsonNodeType.OBJECT || type == JsonNodeType.ARRAY; [EOL] }
@Override [EOL] public Iterator<String> fieldNames() { [EOL]     return EmptyIterator.instance(); [EOL] }
public final boolean isNumber() { [EOL]     return getNodeType() == JsonNodeType.NUMBER; [EOL] }
public boolean isBigDecimal() { [EOL]     return false; [EOL] }
public boolean isBigInteger() { [EOL]     return false; [EOL] }
public Number numberValue() { [EOL]     return null; [EOL] }
public int intValue() { [EOL]     return 0; [EOL] }
public long longValue() { [EOL]     return 0L; [EOL] }
public BigDecimal decimalValue() { [EOL]     return BigDecimal.ZERO; [EOL] }
public BigInteger bigIntegerValue() { [EOL]     return BigInteger.ZERO; [EOL] }
public int asInt() { [EOL]     return asInt(0); [EOL] }
public int asInt(int defaultValue) { [EOL]     return defaultValue; [EOL] }
public long asLong() { [EOL]     return asLong(0L); [EOL] }
public long asLong(long defaultValue) { [EOL]     return defaultValue; [EOL] }
public double asDouble() { [EOL]     return asDouble(0.0); [EOL] }
public double asDouble(double defaultValue) { [EOL]     return defaultValue; [EOL] }
public Iterator<JsonNode> elements() { [EOL]     return EmptyIterator.instance(); [EOL] }
public final List<JsonNode> findValues(String fieldName) { [EOL]     List<JsonNode> result = findValues(fieldName, null); [EOL]     if (result == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     return result; [EOL] }
public final List<String> findValuesAsText(String fieldName) { [EOL]     List<String> result = findValuesAsText(fieldName, null); [EOL]     if (result == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     return result; [EOL] }
public final List<JsonNode> findParents(String fieldName) { [EOL]     List<JsonNode> result = findParents(fieldName, null); [EOL]     if (result == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     return result; [EOL] }
public static String canBeABeanType(Class<?> type) { [EOL]     if (type.isAnnotation()) { [EOL]         return "annotation"; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return "array"; [EOL]     } [EOL]     if (type.isEnum()) { [EOL]         return "enum"; [EOL]     } [EOL]     if (type.isPrimitive()) { [EOL]         return "primitive"; [EOL]     } [EOL]     return null; [EOL] }
public static String canBeABeanType(Class<?> type) { [EOL]     if (type.isAnnotation()) { [EOL]         return "annotation"; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return "array"; [EOL]     } [EOL]     if (type.isEnum()) { [EOL]         return "enum"; [EOL]     } [EOL]     if (type.isPrimitive()) { [EOL]         return "primitive"; [EOL]     } [EOL]     return null; [EOL] }
public static String canBeABeanType(Class<?> type) { [EOL]     if (type.isAnnotation()) { [EOL]         return "annotation"; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return "array"; [EOL]     } [EOL]     if (type.isEnum()) { [EOL]         return "enum"; [EOL]     } [EOL]     if (type.isPrimitive()) { [EOL]         return "primitive"; [EOL]     } [EOL]     return null; [EOL] }
public static String canBeABeanType(Class<?> type) { [EOL]     if (type.isAnnotation()) { [EOL]         return "annotation"; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return "array"; [EOL]     } [EOL]     if (type.isEnum()) { [EOL]         return "enum"; [EOL]     } [EOL]     if (type.isPrimitive()) { [EOL]         return "primitive"; [EOL]     } [EOL]     return null; [EOL] }
public static String canBeABeanType(Class<?> type) { [EOL]     if (type.isAnnotation()) { [EOL]         return "annotation"; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return "array"; [EOL]     } [EOL]     if (type.isEnum()) { [EOL]         return "enum"; [EOL]     } [EOL]     if (type.isPrimitive()) { [EOL]         return "primitive"; [EOL]     } [EOL]     return null; [EOL] }
public static String isLocalType(Class<?> type, boolean allowNonStatic) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return "local/anonymous"; [EOL]         } [EOL]         if (!allowNonStatic) { [EOL]             if (type.getEnclosingClass() != null) { [EOL]                 if (!Modifier.isStatic(type.getModifiers())) { [EOL]                     return "non-static member class"; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static String isLocalType(Class<?> type, boolean allowNonStatic) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return "local/anonymous"; [EOL]         } [EOL]         if (!allowNonStatic) { [EOL]             if (type.getEnclosingClass() != null) { [EOL]                 if (!Modifier.isStatic(type.getModifiers())) { [EOL]                     return "non-static member class"; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static String isLocalType(Class<?> type, boolean allowNonStatic) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return "local/anonymous"; [EOL]         } [EOL]         if (!allowNonStatic) { [EOL]             if (type.getEnclosingClass() != null) { [EOL]                 if (!Modifier.isStatic(type.getModifiers())) { [EOL]                     return "non-static member class"; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static String isLocalType(Class<?> type, boolean allowNonStatic) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return "local/anonymous"; [EOL]         } [EOL]         if (!allowNonStatic) { [EOL]             if (type.getEnclosingClass() != null) { [EOL]                 if (!Modifier.isStatic(type.getModifiers())) { [EOL]                     return "non-static member class"; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static String isLocalType(Class<?> type, boolean allowNonStatic) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return "local/anonymous"; [EOL]         } [EOL]         if (!allowNonStatic) { [EOL]             if (type.getEnclosingClass() != null) { [EOL]                 if (!Modifier.isStatic(type.getModifiers())) { [EOL]                     return "non-static member class"; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static String isLocalType(Class<?> type, boolean allowNonStatic) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return "local/anonymous"; [EOL]         } [EOL]         if (!allowNonStatic) { [EOL]             if (type.getEnclosingClass() != null) { [EOL]                 if (!Modifier.isStatic(type.getModifiers())) { [EOL]                     return "non-static member class"; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static boolean isConcrete(Class<?> type) { [EOL]     int mod = type.getModifiers(); [EOL]     return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0; [EOL] }
public static boolean isConcrete(Class<?> type) { [EOL]     int mod = type.getModifiers(); [EOL]     return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0; [EOL] }
public static boolean isConcrete(Class<?> type) { [EOL]     int mod = type.getModifiers(); [EOL]     return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0; [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s) { [EOL]     if (!s.isEmpty()) { [EOL]         return findEnumType(s.iterator().next()); [EOL]     } [EOL]     return EnumTypeLocator.instance.enumTypeFor(s); [EOL] }
public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s) { [EOL]     if (!s.isEmpty()) { [EOL]         return findEnumType(s.iterator().next()); [EOL]     } [EOL]     return EnumTypeLocator.instance.enumTypeFor(s); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static Class<? extends Enum<?>> findEnumType(Enum<?> en) { [EOL]     Class<?> ec = en.getClass(); [EOL]     if (ec.getSuperclass() != Enum.class) { [EOL]         ec = ec.getSuperclass(); [EOL]     } [EOL]     return (Class<? extends Enum<?>>) ec; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static Class<? extends Enum<?>> findEnumType(Enum<?> en) { [EOL]     Class<?> ec = en.getClass(); [EOL]     if (ec.getSuperclass() != Enum.class) { [EOL]         ec = ec.getSuperclass(); [EOL]     } [EOL]     return (Class<? extends Enum<?>>) ec; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static Class<? extends Enum<?>> findEnumType(Class<?> cls) { [EOL]     if (cls.getSuperclass() != Enum.class) { [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL]     return (Class<? extends Enum<?>>) cls; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static Class<? extends Enum<?>> findEnumType(Class<?> cls) { [EOL]     if (cls.getSuperclass() != Enum.class) { [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL]     return (Class<? extends Enum<?>>) cls; [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
public static TypeNameIdResolver construct(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (forSer == forDeser) [EOL]         throw new IllegalArgumentException(); [EOL]     HashMap<String, String> typeToId = null; [EOL]     HashMap<String, JavaType> idToType = null; [EOL]     if (forSer) { [EOL]         typeToId = new HashMap<String, String>(); [EOL]     } [EOL]     if (forDeser) { [EOL]         idToType = new HashMap<String, JavaType>(); [EOL]     } [EOL]     if (subtypes != null) { [EOL]         for (NamedType t : subtypes) { [EOL]             Class<?> cls = t.getType(); [EOL]             String id = t.hasName() ? t.getName() : _defaultTypeId(cls); [EOL]             if (forSer) { [EOL]                 typeToId.put(cls.getName(), id); [EOL]             } [EOL]             if (forDeser) { [EOL]                 JavaType prev = idToType.get(id); [EOL]                 if (prev != null) { [EOL]                     if (cls.isAssignableFrom(prev.getRawClass())) { [EOL]                         continue; [EOL]                     } [EOL]                 } [EOL]                 idToType.put(id, config.constructType(cls)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new TypeNameIdResolver(config, baseType, typeToId, idToType); [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     Class<?> cls = value.getClass(); [EOL]     final String key = cls.getName(); [EOL]     String name; [EOL]     synchronized (_typeToId) { [EOL]         name = _typeToId.get(key); [EOL]         if (name == null) { [EOL]             if (_config.isAnnotationProcessingEnabled()) { [EOL]                 BeanDescription beanDesc = _config.introspectClassAnnotations(cls); [EOL]                 name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo()); [EOL]             } [EOL]             if (name == null) { [EOL]                 name = _defaultTypeId(cls); [EOL]             } [EOL]             _typeToId.put(key, name); [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     Class<?> cls = value.getClass(); [EOL]     final String key = cls.getName(); [EOL]     String name; [EOL]     synchronized (_typeToId) { [EOL]         name = _typeToId.get(key); [EOL]         if (name == null) { [EOL]             if (_config.isAnnotationProcessingEnabled()) { [EOL]                 BeanDescription beanDesc = _config.introspectClassAnnotations(cls); [EOL]                 name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo()); [EOL]             } [EOL]             if (name == null) { [EOL]                 name = _defaultTypeId(cls); [EOL]             } [EOL]             _typeToId.put(key, name); [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     Class<?> cls = value.getClass(); [EOL]     final String key = cls.getName(); [EOL]     String name; [EOL]     synchronized (_typeToId) { [EOL]         name = _typeToId.get(key); [EOL]         if (name == null) { [EOL]             if (_config.isAnnotationProcessingEnabled()) { [EOL]                 BeanDescription beanDesc = _config.introspectClassAnnotations(cls); [EOL]                 name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo()); [EOL]             } [EOL]             if (name == null) { [EOL]                 name = _defaultTypeId(cls); [EOL]             } [EOL]             _typeToId.put(key, name); [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     Class<?> cls = value.getClass(); [EOL]     final String key = cls.getName(); [EOL]     String name; [EOL]     synchronized (_typeToId) { [EOL]         name = _typeToId.get(key); [EOL]         if (name == null) { [EOL]             if (_config.isAnnotationProcessingEnabled()) { [EOL]                 BeanDescription beanDesc = _config.introspectClassAnnotations(cls); [EOL]                 name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo()); [EOL]             } [EOL]             if (name == null) { [EOL]                 name = _defaultTypeId(cls); [EOL]             } [EOL]             _typeToId.put(key, name); [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
@Override [EOL] public CollectionType withContentTypeHandler(Object h) { [EOL]     return new CollectionType(_class, _elementType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public CollectionType withContentTypeHandler(Object h) { [EOL]     return new CollectionType(_class, _elementType.withTypeHandler(h), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public void serializeContents(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> enumSer = _elementSerializer; [EOL]     for (Enum<?> en : value) { [EOL]         if (enumSer == null) { [EOL]             enumSer = provider.findValueSerializer(en.getDeclaringClass(), _property); [EOL]         } [EOL]         enumSer.serialize(en, jgen, provider); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> enumSer = _elementSerializer; [EOL]     for (Enum<?> en : value) { [EOL]         if (enumSer == null) { [EOL]             enumSer = provider.findValueSerializer(en.getDeclaringClass(), _property); [EOL]         } [EOL]         enumSer.serialize(en, jgen, provider); [EOL]     } [EOL] }
public boolean couldDeserialize() { [EOL]     return getMutator() != null; [EOL] }
public boolean couldDeserialize() { [EOL]     return getMutator() != null; [EOL] }
public SerializerFactoryConfig withAdditionalSerializers(Serializers additional) { [EOL]     if (additional == null) { [EOL]         throw new IllegalArgumentException("Can not pass null Serializers"); [EOL]     } [EOL]     Serializers[] all = ArrayBuilders.insertInListNoDup(_additionalSerializers, additional); [EOL]     return new SerializerFactoryConfig(all, _additionalKeySerializers, _modifiers); [EOL] }
public SerializerFactoryConfig withAdditionalSerializers(Serializers additional) { [EOL]     if (additional == null) { [EOL]         throw new IllegalArgumentException("Can not pass null Serializers"); [EOL]     } [EOL]     Serializers[] all = ArrayBuilders.insertInListNoDup(_additionalSerializers, additional); [EOL]     return new SerializerFactoryConfig(all, _additionalKeySerializers, _modifiers); [EOL] }
public boolean hasKeySerializers() { [EOL]     return _additionalKeySerializers.length > 0; [EOL] }
public boolean hasKeySerializers() { [EOL]     return _additionalKeySerializers.length > 0; [EOL] }
public void addSerializer(JsonSerializer<?> ser) { [EOL]     Class<?> cls = ser.handledType(); [EOL]     if (cls == null || cls == Object.class) { [EOL]         throw new IllegalArgumentException("JsonSerializer of type " + ser.getClass().getName() + " does not define valid handledType() -- must either register with method that takes type argument " + " or make serializer extend 'com.fasterxml.jackson.databind.ser.std.StdSerializer'"); [EOL]     } [EOL]     _addSerializer(cls, ser); [EOL] }
public void addSerializer(JsonSerializer<?> ser) { [EOL]     Class<?> cls = ser.handledType(); [EOL]     if (cls == null || cls == Object.class) { [EOL]         throw new IllegalArgumentException("JsonSerializer of type " + ser.getClass().getName() + " does not define valid handledType() -- must either register with method that takes type argument " + " or make serializer extend 'com.fasterxml.jackson.databind.ser.std.StdSerializer'"); [EOL]     } [EOL]     _addSerializer(cls, ser); [EOL] }
public void addSerializer(JsonSerializer<?> ser) { [EOL]     Class<?> cls = ser.handledType(); [EOL]     if (cls == null || cls == Object.class) { [EOL]         throw new IllegalArgumentException("JsonSerializer of type " + ser.getClass().getName() + " does not define valid handledType() -- must either register with method that takes type argument " + " or make serializer extend 'com.fasterxml.jackson.databind.ser.std.StdSerializer'"); [EOL]     } [EOL]     _addSerializer(cls, ser); [EOL] }
private void _addSerializer(Class<?> cls, JsonSerializer<?> ser) { [EOL]     ClassKey key = new ClassKey(cls); [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings == null) { [EOL]             _interfaceMappings = new HashMap<ClassKey, JsonSerializer<?>>(); [EOL]         } [EOL]         _interfaceMappings.put(key, ser); [EOL]     } else { [EOL]         if (_classMappings == null) { [EOL]             _classMappings = new HashMap<ClassKey, JsonSerializer<?>>(); [EOL]         } [EOL]         _classMappings.put(key, ser); [EOL]     } [EOL] }
private void _addSerializer(Class<?> cls, JsonSerializer<?> ser) { [EOL]     ClassKey key = new ClassKey(cls); [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings == null) { [EOL]             _interfaceMappings = new HashMap<ClassKey, JsonSerializer<?>>(); [EOL]         } [EOL]         _interfaceMappings.put(key, ser); [EOL]     } else { [EOL]         if (_classMappings == null) { [EOL]             _classMappings = new HashMap<ClassKey, JsonSerializer<?>>(); [EOL]         } [EOL]         _classMappings.put(key, ser); [EOL]     } [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> _findInterfaceMapping(Class<?> cls, ClassKey key) { [EOL]     for (Class<?> iface : cls.getInterfaces()) { [EOL]         key.reset(iface); [EOL]         JsonSerializer<?> ser = _interfaceMappings.get(key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         ser = _findInterfaceMapping(iface, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> _findInterfaceMapping(Class<?> cls, ClassKey key) { [EOL]     for (Class<?> iface : cls.getInterfaces()) { [EOL]         key.reset(iface); [EOL]         JsonSerializer<?> ser = _interfaceMappings.get(key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         ser = _findInterfaceMapping(iface, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> _findInterfaceMapping(Class<?> cls, ClassKey key) { [EOL]     for (Class<?> iface : cls.getInterfaces()) { [EOL]         key.reset(iface); [EOL]         JsonSerializer<?> ser = _interfaceMappings.get(key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         ser = _findInterfaceMapping(iface, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, JavaType type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property); [EOL]     if (map != result.map) { [EOL]         _dynamicSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, JavaType type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property); [EOL]     if (map != result.map) { [EOL]         _dynamicSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
private DeserializationConfig(DeserializationConfig src, LinkedNode<DeserializationProblemHandler> problemHandlers) { [EOL]     super(src); [EOL]     _deserFeatures = src._deserFeatures; [EOL]     _problemHandlers = problemHandlers; [EOL]     _nodeFactory = src._nodeFactory; [EOL] }
public DeserializationConfig withHandler(DeserializationProblemHandler h) { [EOL]     if (LinkedNode.contains(_problemHandlers, h)) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers)); [EOL] }
public DeserializationConfig withHandler(DeserializationProblemHandler h) { [EOL]     if (LinkedNode.contains(_problemHandlers, h)) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers)); [EOL] }
public DeserializationConfig withNoProblemHandlers() { [EOL]     if (_problemHandlers == null) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, (LinkedNode<DeserializationProblemHandler>) null); [EOL] }
public DeserializationConfig withNoProblemHandlers() { [EOL]     if (_problemHandlers == null) { [EOL]         return this; [EOL]     } [EOL]     return new DeserializationConfig(this, (LinkedNode<DeserializationProblemHandler>) null); [EOL] }
public LinkedNode<DeserializationProblemHandler> getProblemHandlers() { [EOL]     return _problemHandlers; [EOL] }
public LinkedNode<DeserializationProblemHandler> getProblemHandlers() { [EOL]     return _problemHandlers; [EOL] }
public final JsonNodeFactory getNodeFactory() { [EOL]     return _nodeFactory; [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T extends BeanDescription> T introspectForBuilder(JavaType type) { [EOL]     return (T) getClassIntrospector().forDeserializationWithBuilder(this, type, this); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T extends BeanDescription> T introspectForBuilder(JavaType type) { [EOL]     return (T) getClassIntrospector().forDeserializationWithBuilder(this, type, this); [EOL] }
public void add(Annotation ann) { [EOL]     _add(ann); [EOL] }
public void add(Annotation ann) { [EOL]     _add(ann); [EOL] }
public TypeParser(TypeFactory f) { [EOL]     _factory = f; [EOL] }
public TypeParser(TypeFactory f) { [EOL]     _factory = f; [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
public AnnotatedParameter(AnnotatedWithParams owner, Type type, AnnotationMap annotations, int index) { [EOL]     super(annotations); [EOL]     _owner = owner; [EOL]     _type = type; [EOL]     _index = index; [EOL] }
public AnnotatedParameter(AnnotatedWithParams owner, Type type, AnnotationMap annotations, int index) { [EOL]     super(annotations); [EOL]     _owner = owner; [EOL]     _type = type; [EOL]     _index = index; [EOL] }
public AnnotatedParameter(AnnotatedWithParams owner, Type type, AnnotationMap annotations, int index) { [EOL]     super(annotations); [EOL]     _owner = owner; [EOL]     _type = type; [EOL]     _index = index; [EOL] }
public AnnotatedParameter(AnnotatedWithParams owner, Type type, AnnotationMap annotations, int index) { [EOL]     super(annotations); [EOL]     _owner = owner; [EOL]     _type = type; [EOL]     _index = index; [EOL] }
@Override [EOL] public AnnotatedParameter withAnnotations(AnnotationMap ann) { [EOL]     if (ann == _annotations) { [EOL]         return this; [EOL]     } [EOL]     return _owner.replaceParameterAnnotations(_index, ann); [EOL] }
@Override [EOL] public AnnotatedParameter withAnnotations(AnnotationMap ann) { [EOL]     if (ann == _annotations) { [EOL]         return this; [EOL]     } [EOL]     return _owner.replaceParameterAnnotations(_index, ann); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return (_annotations == null) ? null : _annotations.get(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return (_annotations == null) ? null : _annotations.get(acls); [EOL] }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat() { [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { [EOL]     if (_formatISO8601 == null) { [EOL]         _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]     } [EOL]     return _formatISO8601.format(date, toAppendTo, fieldPosition); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) { [EOL]     if (_formatISO8601 == null) { [EOL]         _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]     } [EOL]     return _formatISO8601.format(date, toAppendTo, fieldPosition); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { [EOL]     if (_formatRFC1123 == null) { [EOL]         _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123); [EOL]     } [EOL]     return _formatRFC1123.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final DateFormat _cloneFormat(DateFormat df) { [EOL]     return _cloneFormat(df, _timezone); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected SettableBeanProperty(SettableBeanProperty src, String newName) { [EOL]     _propName = newName; [EOL]     _type = src._type; [EOL]     _wrapperName = src._wrapperName; [EOL]     _isRequired = src._isRequired; [EOL]     _contextAnnotations = src._contextAnnotations; [EOL]     _valueDeserializer = src._valueDeserializer; [EOL]     _valueTypeDeserializer = src._valueTypeDeserializer; [EOL]     _nullProvider = src._nullProvider; [EOL]     _managedReferenceName = src._managedReferenceName; [EOL]     _propertyIndex = src._propertyIndex; [EOL]     _viewMatcher = src._viewMatcher; [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } [EOL]     if (_valueTypeDeserializer != null) { [EOL]         return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } [EOL]     if (_valueTypeDeserializer != null) { [EOL]         return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } [EOL]     if (_valueTypeDeserializer != null) { [EOL]         return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> StdDelegatingSerializer(Class<T> cls, Converter<T, ?> converter) { [EOL]     super(cls, false); [EOL]     _converter = (Converter<Object, ?>) converter; [EOL]     _delegateType = null; [EOL]     _delegateSerializer = null; [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> StdDelegatingSerializer(Class<T> cls, Converter<T, ?> converter) { [EOL]     super(cls, false); [EOL]     _converter = (Converter<Object, ?>) converter; [EOL]     _delegateType = null; [EOL]     _delegateSerializer = null; [EOL] }
@SuppressWarnings("unchecked") [EOL] public StdDelegatingSerializer(Converter<Object, ?> converter, JavaType delegateType, JsonSerializer<?> delegateSerializer) { [EOL]     super(delegateType); [EOL]     _converter = converter; [EOL]     _delegateType = delegateType; [EOL]     _delegateSerializer = (JsonSerializer<Object>) delegateSerializer; [EOL] }
@SuppressWarnings("unchecked") [EOL] public StdDelegatingSerializer(Converter<Object, ?> converter, JavaType delegateType, JsonSerializer<?> delegateSerializer) { [EOL]     super(delegateType); [EOL]     _converter = converter; [EOL]     _delegateType = delegateType; [EOL]     _delegateSerializer = (JsonSerializer<Object>) delegateSerializer; [EOL] }
@SuppressWarnings("unchecked") [EOL] public StdDelegatingSerializer(Converter<Object, ?> converter, JavaType delegateType, JsonSerializer<?> delegateSerializer) { [EOL]     super(delegateType); [EOL]     _converter = converter; [EOL]     _delegateType = delegateType; [EOL]     _delegateSerializer = (JsonSerializer<Object>) delegateSerializer; [EOL] }
@SuppressWarnings("unchecked") [EOL] public StdDelegatingSerializer(Converter<Object, ?> converter, JavaType delegateType, JsonSerializer<?> delegateSerializer) { [EOL]     super(delegateType); [EOL]     _converter = converter; [EOL]     _delegateType = delegateType; [EOL]     _delegateSerializer = (JsonSerializer<Object>) delegateSerializer; [EOL] }
protected StdDelegatingSerializer withDelegate(Converter<Object, ?> converter, JavaType delegateType, JsonSerializer<?> delegateSerializer) { [EOL]     if (getClass() != StdDelegatingSerializer.class) { [EOL]         throw new IllegalStateException("Sub-class " + getClass().getName() + " must override 'withDelegate'"); [EOL]     } [EOL]     return new StdDelegatingSerializer(converter, delegateType, delegateSerializer); [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     if ((_delegateSerializer != null) && (_delegateSerializer instanceof ResolvableSerializer)) { [EOL]         ((ResolvableSerializer) _delegateSerializer).resolve(provider); [EOL]     } [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     if ((_delegateSerializer != null) && (_delegateSerializer instanceof ResolvableSerializer)) { [EOL]         ((ResolvableSerializer) _delegateSerializer).resolve(provider); [EOL]     } [EOL] }
@Override [EOL] public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     if ((_delegateSerializer != null) && (_delegateSerializer instanceof ResolvableSerializer)) { [EOL]         ((ResolvableSerializer) _delegateSerializer).resolve(provider); [EOL]     } [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateSerializer != null) { [EOL]         if (_delegateSerializer instanceof ContextualSerializer) { [EOL]             JsonSerializer<?> ser = ((ContextualSerializer) _delegateSerializer).createContextual(provider, property); [EOL]             if (ser == _delegateSerializer) { [EOL]                 return this; [EOL]             } [EOL]             return withDelegate(_converter, _delegateType, ser); [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _delegateType; [EOL]     if (delegateType == null) { [EOL]         delegateType = _converter.getOutputType(provider.getTypeFactory()); [EOL]     } [EOL]     return withDelegate(_converter, delegateType, provider.findValueSerializer(delegateType, property)); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateSerializer != null) { [EOL]         if (_delegateSerializer instanceof ContextualSerializer) { [EOL]             JsonSerializer<?> ser = ((ContextualSerializer) _delegateSerializer).createContextual(provider, property); [EOL]             if (ser == _delegateSerializer) { [EOL]                 return this; [EOL]             } [EOL]             return withDelegate(_converter, _delegateType, ser); [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _delegateType; [EOL]     if (delegateType == null) { [EOL]         delegateType = _converter.getOutputType(provider.getTypeFactory()); [EOL]     } [EOL]     return withDelegate(_converter, delegateType, provider.findValueSerializer(delegateType, property)); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateSerializer != null) { [EOL]         if (_delegateSerializer instanceof ContextualSerializer) { [EOL]             JsonSerializer<?> ser = ((ContextualSerializer) _delegateSerializer).createContextual(provider, property); [EOL]             if (ser == _delegateSerializer) { [EOL]                 return this; [EOL]             } [EOL]             return withDelegate(_converter, _delegateType, ser); [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _delegateType; [EOL]     if (delegateType == null) { [EOL]         delegateType = _converter.getOutputType(provider.getTypeFactory()); [EOL]     } [EOL]     return withDelegate(_converter, delegateType, provider.findValueSerializer(delegateType, property)); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateSerializer != null) { [EOL]         if (_delegateSerializer instanceof ContextualSerializer) { [EOL]             JsonSerializer<?> ser = ((ContextualSerializer) _delegateSerializer).createContextual(provider, property); [EOL]             if (ser == _delegateSerializer) { [EOL]                 return this; [EOL]             } [EOL]             return withDelegate(_converter, _delegateType, ser); [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _delegateType; [EOL]     if (delegateType == null) { [EOL]         delegateType = _converter.getOutputType(provider.getTypeFactory()); [EOL]     } [EOL]     return withDelegate(_converter, delegateType, provider.findValueSerializer(delegateType, property)); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     Object delegateValue = convertValue(value); [EOL]     if (delegateValue == null) { [EOL]         provider.defaultSerializeNull(jgen); [EOL]         return; [EOL]     } [EOL]     _delegateSerializer.serialize(delegateValue, jgen, provider); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     Object delegateValue = convertValue(value); [EOL]     if (delegateValue == null) { [EOL]         provider.defaultSerializeNull(jgen); [EOL]         return; [EOL]     } [EOL]     _delegateSerializer.serialize(delegateValue, jgen, provider); [EOL] }
protected Object convertValue(Object value) { [EOL]     return _converter.convert(value); [EOL] }
@Override [EOL] public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     return setAndReturn(instance, deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         Object result = _setter.invoke(instance, value); [EOL]         return (result == null) ? instance : result; [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]         return null; [EOL]     } [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         Object result = _setter.invoke(instance, value); [EOL]         return (result == null) ? instance : result; [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]         return null; [EOL]     } [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         Object result = _setter.invoke(instance, value); [EOL]         return (result == null) ? instance : result; [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]         return null; [EOL]     } [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         Object result = _setter.invoke(instance, value); [EOL]         return (result == null) ? instance : result; [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]         return null; [EOL]     } [EOL] }
private NullNode() { [EOL] }
public static NullNode getInstance() { [EOL]     return instance; [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.NULL; [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_NULL; [EOL] }
@Override [EOL] public String asText() { [EOL]     return "null"; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     return (o == this); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     return (o == this); [EOL] }
protected BeanSerializer(BeanSerializerBase src, ObjectIdWriter objectIdWriter) { [EOL]     super(src, objectIdWriter); [EOL] }
@Override [EOL] public BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) { [EOL]     return new BeanSerializer(this, objectIdWriter); [EOL] }
@Override [EOL] public BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) { [EOL]     return new BeanSerializer(this, objectIdWriter); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, true); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, true); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, true); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
public JsonSerializerMap(Map<TypeKey, JsonSerializer<Object>> serializers) { [EOL]     int size = findSize(serializers.size()); [EOL]     _size = size; [EOL]     int hashMask = (size - 1); [EOL]     Bucket[] buckets = new Bucket[size]; [EOL]     for (Map.Entry<TypeKey, JsonSerializer<Object>> entry : serializers.entrySet()) { [EOL]         TypeKey key = entry.getKey(); [EOL]         int index = key.hashCode() & hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, entry.getValue()); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
public JsonSerializerMap(Map<TypeKey, JsonSerializer<Object>> serializers) { [EOL]     int size = findSize(serializers.size()); [EOL]     _size = size; [EOL]     int hashMask = (size - 1); [EOL]     Bucket[] buckets = new Bucket[size]; [EOL]     for (Map.Entry<TypeKey, JsonSerializer<Object>> entry : serializers.entrySet()) { [EOL]         TypeKey key = entry.getKey(); [EOL]         int index = key.hashCode() & hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, entry.getValue()); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
public JsonSerializerMap(Map<TypeKey, JsonSerializer<Object>> serializers) { [EOL]     int size = findSize(serializers.size()); [EOL]     _size = size; [EOL]     int hashMask = (size - 1); [EOL]     Bucket[] buckets = new Bucket[size]; [EOL]     for (Map.Entry<TypeKey, JsonSerializer<Object>> entry : serializers.entrySet()) { [EOL]         TypeKey key = entry.getKey(); [EOL]         int index = key.hashCode() & hashMask; [EOL]         buckets[index] = new Bucket(buckets[index], key, entry.getValue()); [EOL]     } [EOL]     _buckets = buckets; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 64) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 8; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 64) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 8; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 64) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 8; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
private final static int findSize(int size) { [EOL]     int needed = (size <= 64) ? (size + size) : (size + (size >> 2)); [EOL]     int result = 8; [EOL]     while (result < needed) { [EOL]         result += result; [EOL]     } [EOL]     return result; [EOL] }
public JsonSerializer<Object> find(TypeKey key) { [EOL]     int index = key.hashCode() & (_buckets.length - 1); [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (key.equals(bucket.key)) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JsonSerializer<Object> find(TypeKey key) { [EOL]     int index = key.hashCode() & (_buckets.length - 1); [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (key.equals(bucket.key)) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JsonSerializer<Object> find(TypeKey key) { [EOL]     int index = key.hashCode() & (_buckets.length - 1); [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (key.equals(bucket.key)) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JsonSerializer<Object> find(TypeKey key) { [EOL]     int index = key.hashCode() & (_buckets.length - 1); [EOL]     Bucket bucket = _buckets[index]; [EOL]     if (bucket == null) { [EOL]         return null; [EOL]     } [EOL]     if (key.equals(bucket.key)) { [EOL]         return bucket.value; [EOL]     } [EOL]     while ((bucket = bucket.next) != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Bucket(Bucket next, TypeKey key, JsonSerializer<Object> value) { [EOL]     this.next = next; [EOL]     this.key = key; [EOL]     this.value = value; [EOL] }
public Bucket(Bucket next, TypeKey key, JsonSerializer<Object> value) { [EOL]     this.next = next; [EOL]     this.key = key; [EOL]     this.value = value; [EOL] }
public TypeIdResolver typeIdResolverInstance(Annotated annotated, Class<? extends TypeIdResolver> resolverClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeIdResolver builder = hi.typeIdResolverInstance(this, annotated, resolverClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers()); [EOL] }
public TypeIdResolver typeIdResolverInstance(Annotated annotated, Class<? extends TypeIdResolver> resolverClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeIdResolver builder = hi.typeIdResolverInstance(this, annotated, resolverClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers()); [EOL] }
public TypeIdResolver typeIdResolverInstance(Annotated annotated, Class<? extends TypeIdResolver> resolverClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeIdResolver builder = hi.typeIdResolverInstance(this, annotated, resolverClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers()); [EOL] }
public NullifyingDeserializer() { [EOL]     super(Object.class); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     jp.skipChildren(); [EOL]     return null; [EOL] }
@Override [EOL] public final boolean has(int index) { [EOL]     return false; [EOL] }
@Override [EOL] public final JsonNode path(String fieldName) { [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public final boolean has(String fieldName) { [EOL]     return false; [EOL] }
@Override [EOL] public final List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     return foundSoFar; [EOL] }
public static StdTypeResolverBuilder noTypeInfoBuilder() { [EOL]     return new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, null); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public Class<?> getDefaultImpl() { [EOL]     return _defaultImpl; [EOL] }
@Override [EOL] public Class<?> getDefaultImpl() { [EOL]     return _defaultImpl; [EOL] }
public StdSubtypeResolver() { [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedClass type, MapperConfig<?> config, AnnotationIntrospector ai) { [EOL]     HashMap<NamedType, NamedType> subtypes = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         Class<?> rawBase = type.getRawType(); [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, subtypes); [EOL]             } [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(type.getRawType(), null); [EOL]     _collectAndResolve(type, rootType, config, ai, subtypes); [EOL]     return new ArrayList<NamedType>(subtypes.values()); [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedClass type, MapperConfig<?> config, AnnotationIntrospector ai) { [EOL]     HashMap<NamedType, NamedType> subtypes = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         Class<?> rawBase = type.getRawType(); [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, subtypes); [EOL]             } [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(type.getRawType(), null); [EOL]     _collectAndResolve(type, rootType, config, ai, subtypes); [EOL]     return new ArrayList<NamedType>(subtypes.values()); [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
private ArrayType(JavaType componentType, Object emptyInstance, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(emptyInstance.getClass(), componentType.hashCode(), valueHandler, typeHandler, asStatic); [EOL]     _componentType = componentType; [EOL]     _emptyArray = emptyInstance; [EOL] }
private ArrayType(JavaType componentType, Object emptyInstance, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(emptyInstance.getClass(), componentType.hashCode(), valueHandler, typeHandler, asStatic); [EOL]     _componentType = componentType; [EOL]     _emptyArray = emptyInstance; [EOL] }
public static ArrayType construct(JavaType componentType, Object valueHandler, Object typeHandler) { [EOL]     Object emptyInstance = Array.newInstance(componentType.getRawClass(), 0); [EOL]     return new ArrayType(componentType, emptyInstance, null, null, false); [EOL] }
public static ArrayType construct(JavaType componentType, Object valueHandler, Object typeHandler) { [EOL]     Object emptyInstance = Array.newInstance(componentType.getRawClass(), 0); [EOL]     return new ArrayType(componentType, emptyInstance, null, null, false); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _componentType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return construct(_componentType.narrowBy(contentClass), _valueHandler, _typeHandler); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _componentType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return construct(_componentType.narrowBy(contentClass), _valueHandler, _typeHandler); [EOL] }
@Override [EOL] public boolean isContainerType() { [EOL]     return true; [EOL] }
@Override [EOL] public String toString() { [EOL]     return "[array type, component type: " + _componentType + "]"; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     ArrayType other = (ArrayType) o; [EOL]     return _componentType.equals(other._componentType); [EOL] }
public StringArrayDeserializer() { [EOL]     super(String[].class); [EOL]     _elementDeserializer = null; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StringArrayDeserializer(JsonDeserializer<?> deser) { [EOL]     super(String[].class); [EOL]     _elementDeserializer = (JsonDeserializer<String>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected StringArrayDeserializer(JsonDeserializer<?> deser) { [EOL]     super(String[].class); [EOL]     _elementDeserializer = (JsonDeserializer<String>) deser; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
@Override [EOL] public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     if (_elementDeserializer != null) { [EOL]         return _deserializeCustom(jp, ctxt); [EOL]     } [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             value = jp.getText(); [EOL]         } else if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else { [EOL]             value = _parseString(jp, ctxt); [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] chunk = buffer.resetAndStart(); [EOL]     final JsonDeserializer<String> deser = _elementDeserializer; [EOL]     int ix = 0; [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = buffer.appendCompletedChunk(chunk); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); [EOL]     ctxt.returnObjectBuffer(buffer); [EOL]     return result; [EOL] }
private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]             String str = jp.getText(); [EOL]             if (str.length() == 0) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) }; [EOL] }
private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]             String str = jp.getText(); [EOL]             if (str.length() == 0) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) }; [EOL] }
private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]             String str = jp.getText(); [EOL]             if (str.length() == 0) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) }; [EOL] }
private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]             String str = jp.getText(); [EOL]             if (str.length() == 0) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) }; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (deser != null && this.isDefaultDeserializer(deser)) { [EOL]         deser = null; [EOL]     } [EOL]     if (_elementDeserializer != deser) { [EOL]         return new StringArrayDeserializer(deser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (deser != null && this.isDefaultDeserializer(deser)) { [EOL]         deser = null; [EOL]     } [EOL]     if (_elementDeserializer != deser) { [EOL]         return new StringArrayDeserializer(deser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (deser != null && this.isDefaultDeserializer(deser)) { [EOL]         deser = null; [EOL]     } [EOL]     if (_elementDeserializer != deser) { [EOL]         return new StringArrayDeserializer(deser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (deser != null && this.isDefaultDeserializer(deser)) { [EOL]         deser = null; [EOL]     } [EOL]     if (_elementDeserializer != deser) { [EOL]         return new StringArrayDeserializer(deser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (deser != null && this.isDefaultDeserializer(deser)) { [EOL]         deser = null; [EOL]     } [EOL]     if (_elementDeserializer != deser) { [EOL]         return new StringArrayDeserializer(deser); [EOL]     } [EOL]     return this; [EOL] }
public void setObjectIdReader(ObjectIdReader r) { [EOL]     _objectIdReader = r; [EOL] }
public void setObjectIdReader(ObjectIdReader r) { [EOL]     _objectIdReader = r; [EOL] }
public void setPOJOBuilder(AnnotatedMethod buildMethod, JsonPOJOBuilder.Value config) { [EOL]     _buildMethod = buildMethod; [EOL]     _builderConfig = config; [EOL] }
public void setPOJOBuilder(AnnotatedMethod buildMethod, JsonPOJOBuilder.Value config) { [EOL]     _buildMethod = buildMethod; [EOL]     _builderConfig = config; [EOL] }
public AnnotatedMethod getBuildMethod() { [EOL]     return _buildMethod; [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> build() { [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BeanDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName) { [EOL]     if (_buildMethod == null) { [EOL]         throw new IllegalArgumentException("Builder class " + _beanDesc.getBeanClass().getName() + " does not have build method '" + expBuildMethodName + "()'"); [EOL]     } [EOL]     Class<?> rawBuildType = _buildMethod.getRawReturnType(); [EOL]     if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) { [EOL]         throw new IllegalArgumentException("Build method '" + _buildMethod.getFullName() + " has bad return type (" + rawBuildType.getName() + "), not compatible with POJO type (" + valueType.getRawClass().getName() + ")"); [EOL]     } [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BuilderBasedDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName) { [EOL]     if (_buildMethod == null) { [EOL]         throw new IllegalArgumentException("Builder class " + _beanDesc.getBeanClass().getName() + " does not have build method '" + expBuildMethodName + "()'"); [EOL]     } [EOL]     Class<?> rawBuildType = _buildMethod.getRawReturnType(); [EOL]     if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) { [EOL]         throw new IllegalArgumentException("Build method '" + _buildMethod.getFullName() + " has bad return type (" + rawBuildType.getName() + "), not compatible with POJO type (" + valueType.getRawClass().getName() + ")"); [EOL]     } [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BuilderBasedDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName) { [EOL]     if (_buildMethod == null) { [EOL]         throw new IllegalArgumentException("Builder class " + _beanDesc.getBeanClass().getName() + " does not have build method '" + expBuildMethodName + "()'"); [EOL]     } [EOL]     Class<?> rawBuildType = _buildMethod.getRawReturnType(); [EOL]     if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) { [EOL]         throw new IllegalArgumentException("Build method '" + _buildMethod.getFullName() + " has bad return type (" + rawBuildType.getName() + "), not compatible with POJO type (" + valueType.getRawClass().getName() + ")"); [EOL]     } [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BuilderBasedDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName) { [EOL]     if (_buildMethod == null) { [EOL]         throw new IllegalArgumentException("Builder class " + _beanDesc.getBeanClass().getName() + " does not have build method '" + expBuildMethodName + "()'"); [EOL]     } [EOL]     Class<?> rawBuildType = _buildMethod.getRawReturnType(); [EOL]     if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) { [EOL]         throw new IllegalArgumentException("Build method '" + _buildMethod.getFullName() + " has bad return type (" + rawBuildType.getName() + "), not compatible with POJO type (" + valueType.getRawClass().getName() + ")"); [EOL]     } [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BuilderBasedDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName) { [EOL]     if (_buildMethod == null) { [EOL]         throw new IllegalArgumentException("Builder class " + _beanDesc.getBeanClass().getName() + " does not have build method '" + expBuildMethodName + "()'"); [EOL]     } [EOL]     Class<?> rawBuildType = _buildMethod.getRawReturnType(); [EOL]     if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) { [EOL]         throw new IllegalArgumentException("Build method '" + _buildMethod.getFullName() + " has bad return type (" + rawBuildType.getName() + "), not compatible with POJO type (" + valueType.getRawClass().getName() + ")"); [EOL]     } [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BuilderBasedDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName) { [EOL]     if (_buildMethod == null) { [EOL]         throw new IllegalArgumentException("Builder class " + _beanDesc.getBeanClass().getName() + " does not have build method '" + expBuildMethodName + "()'"); [EOL]     } [EOL]     Class<?> rawBuildType = _buildMethod.getRawReturnType(); [EOL]     if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) { [EOL]         throw new IllegalArgumentException("Build method '" + _buildMethod.getFullName() + " has bad return type (" + rawBuildType.getName() + "), not compatible with POJO type (" + valueType.getRawClass().getName() + ")"); [EOL]     } [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BuilderBasedDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public JsonDeserializer<?> buildBuilderBased(JavaType valueType, String expBuildMethodName) { [EOL]     if (_buildMethod == null) { [EOL]         throw new IllegalArgumentException("Builder class " + _beanDesc.getBeanClass().getName() + " does not have build method '" + expBuildMethodName + "()'"); [EOL]     } [EOL]     Class<?> rawBuildType = _buildMethod.getRawReturnType(); [EOL]     if (!valueType.getRawClass().isAssignableFrom(rawBuildType)) { [EOL]         throw new IllegalArgumentException("Build method '" + _buildMethod.getFullName() + " has bad return type (" + rawBuildType.getName() + "), not compatible with POJO type (" + valueType.getRawClass().getName() + ")"); [EOL]     } [EOL]     Collection<SettableBeanProperty> props = _properties.values(); [EOL]     BeanPropertyMap propertyMap = new BeanPropertyMap(props); [EOL]     propertyMap.assignIndexes(); [EOL]     boolean anyViews = !_defaultViewInclusion; [EOL]     if (!anyViews) { [EOL]         for (SettableBeanProperty prop : props) { [EOL]             if (prop.hasViews()) { [EOL]                 anyViews = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_objectIdReader != null) { [EOL]         ObjectIdValueProperty prop = new ObjectIdValueProperty(_objectIdReader, true); [EOL]         propertyMap = propertyMap.withProperty(prop); [EOL]     } [EOL]     return new BuilderBasedDeserializer(this, _beanDesc, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown, anyViews); [EOL] }
public final T appendCompletedChunk(T fullChunk, int fullChunkLength) { [EOL]     Node<T> next = new Node<T>(fullChunk, fullChunkLength); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     _bufferedEntryCount += fullChunkLength; [EOL]     int nextLen = fullChunkLength; [EOL]     if (nextLen < SMALL_CHUNK_SIZE) { [EOL]         nextLen += nextLen; [EOL]     } else { [EOL]         nextLen += (nextLen >> 2); [EOL]     } [EOL]     return _constructArray(nextLen); [EOL] }
public final T appendCompletedChunk(T fullChunk, int fullChunkLength) { [EOL]     Node<T> next = new Node<T>(fullChunk, fullChunkLength); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     _bufferedEntryCount += fullChunkLength; [EOL]     int nextLen = fullChunkLength; [EOL]     if (nextLen < SMALL_CHUNK_SIZE) { [EOL]         nextLen += nextLen; [EOL]     } else { [EOL]         nextLen += (nextLen >> 2); [EOL]     } [EOL]     return _constructArray(nextLen); [EOL] }
public T completeAndClearBuffer(T lastChunk, int lastChunkEntries) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     T resultArray = _constructArray(totalSize); [EOL]     int ptr = 0; [EOL]     for (Node<T> n = _bufferHead; n != null; n = n.next()) { [EOL]         ptr = n.copyData(resultArray, ptr); [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL]     return resultArray; [EOL] }
public T completeAndClearBuffer(T lastChunk, int lastChunkEntries) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     T resultArray = _constructArray(totalSize); [EOL]     int ptr = 0; [EOL]     for (Node<T> n = _bufferHead; n != null; n = n.next()) { [EOL]         ptr = n.copyData(resultArray, ptr); [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL]     return resultArray; [EOL] }
public T completeAndClearBuffer(T lastChunk, int lastChunkEntries) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     T resultArray = _constructArray(totalSize); [EOL]     int ptr = 0; [EOL]     for (Node<T> n = _bufferHead; n != null; n = n.next()) { [EOL]         ptr = n.copyData(resultArray, ptr); [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL]     return resultArray; [EOL] }
public Node(T data, int dataLen) { [EOL]     _data = data; [EOL]     _dataLength = dataLen; [EOL] }
public int copyData(T dst, int ptr) { [EOL]     System.arraycopy(_data, 0, dst, ptr, _dataLength); [EOL]     ptr += _dataLength; [EOL]     return ptr; [EOL] }
public int copyData(T dst, int ptr) { [EOL]     System.arraycopy(_data, 0, dst, ptr, _dataLength); [EOL]     ptr += _dataLength; [EOL]     return ptr; [EOL] }
public Node<T> next() { [EOL]     return _next; [EOL] }
public Node<T> next() { [EOL]     return _next; [EOL] }
public void linkNext(Node<T> next) { [EOL]     if (_next != null) { [EOL]         throw new IllegalStateException(); [EOL]     } [EOL]     _next = next; [EOL] }
public void linkNext(Node<T> next) { [EOL]     if (_next != null) { [EOL]         throw new IllegalStateException(); [EOL]     } [EOL]     _next = next; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     MapLikeType other = (MapLikeType) o; [EOL]     return (_class == other._class) && _keyType.equals(other._keyType) && _valueType.equals(other._valueType); [EOL] }
public SimpleModule addKeyDeserializer(Class<?> type, KeyDeserializer deser) { [EOL]     if (_keyDeserializers == null) { [EOL]         _keyDeserializers = new SimpleKeyDeserializers(); [EOL]     } [EOL]     _keyDeserializers.addDeserializer(type, deser); [EOL]     return this; [EOL] }
public SimpleModule addKeyDeserializer(Class<?> type, KeyDeserializer deser) { [EOL]     if (_keyDeserializers == null) { [EOL]         _keyDeserializers = new SimpleKeyDeserializers(); [EOL]     } [EOL]     _keyDeserializers.addDeserializer(type, deser); [EOL]     return this; [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(cls, 0, valueHandler, typeHandler, asStatic); [EOL]     if (typeNames == null || typeNames.length == 0) { [EOL]         _typeNames = null; [EOL]         _typeParameters = null; [EOL]     } else { [EOL]         _typeNames = typeNames; [EOL]         _typeParameters = typeParams; [EOL]     } [EOL] }
protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(cls, 0, valueHandler, typeHandler, asStatic); [EOL]     if (typeNames == null || typeNames.length == 0) { [EOL]         _typeNames = null; [EOL]         _typeParameters = null; [EOL]     } else { [EOL]         _typeNames = typeNames; [EOL]         _typeParameters = typeParams; [EOL]     } [EOL] }
protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(cls, 0, valueHandler, typeHandler, asStatic); [EOL]     if (typeNames == null || typeNames.length == 0) { [EOL]         _typeNames = null; [EOL]         _typeParameters = null; [EOL]     } else { [EOL]         _typeNames = typeNames; [EOL]         _typeParameters = typeParams; [EOL]     } [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
public static SimpleType construct(Class<?> cls) { [EOL]     if (Map.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Map (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(cls)) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for a Collection (class: " + cls.getName() + ")"); [EOL]     } [EOL]     if (cls.isArray()) { [EOL]         throw new IllegalArgumentException("Can not construct SimpleType for an array (class: " + cls.getName() + ")"); [EOL]     } [EOL]     return new SimpleType(cls); [EOL] }
@Override [EOL] public SimpleType withStaticTyping() { [EOL]     return _asStatic ? this : new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public SimpleType withStaticTyping() { [EOL]     return _asStatic ? this : new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] }
@Override [EOL] public JavaType containedType(int index) { [EOL]     if (index < 0 || _typeParameters == null || index >= _typeParameters.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeParameters[index]; [EOL] }
private TypeFactory() { [EOL]     _parser = new TypeParser(this); [EOL]     _modifiers = null; [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == expType) { [EOL]         int count = type.containedTypeCount(); [EOL]         if (count == 0) [EOL]             return null; [EOL]         JavaType[] result = new JavaType[count]; [EOL]         for (int i = 0; i < count; ++i) { [EOL]             result[i] = type.containedType(i); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return findTypeParameters(raw, expType, new TypeBindings(this, type)); [EOL] }
public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == expType) { [EOL]         int count = type.containedTypeCount(); [EOL]         if (count == 0) [EOL]             return null; [EOL]         JavaType[] result = new JavaType[count]; [EOL]         for (int i = 0; i < count; ++i) { [EOL]             result[i] = type.containedType(i); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return findTypeParameters(raw, expType, new TypeBindings(this, type)); [EOL] }
public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == expType) { [EOL]         int count = type.containedTypeCount(); [EOL]         if (count == 0) [EOL]             return null; [EOL]         JavaType[] result = new JavaType[count]; [EOL]         for (int i = 0; i < count; ++i) { [EOL]             result[i] = type.containedType(i); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return findTypeParameters(raw, expType, new TypeBindings(this, type)); [EOL] }
public JavaType constructType(TypeReference<?> typeRef) { [EOL]     return _constructType(typeRef.getType(), null); [EOL] }
public JavaType constructType(TypeReference<?> typeRef) { [EOL]     return _constructType(typeRef.getType(), null); [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
public ArrayType constructArrayType(Class<?> elementType) { [EOL]     return ArrayType.construct(_constructType(elementType, null), null, null); [EOL] }
public ArrayType constructArrayType(Class<?> elementType) { [EOL]     return ArrayType.construct(_constructType(elementType, null), null, null); [EOL] }
public ArrayType constructArrayType(Class<?> elementType) { [EOL]     return ArrayType.construct(_constructType(elementType, null), null, null); [EOL] }
public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { [EOL]     TypeVariable<?>[] typeVars = rawType.getTypeParameters(); [EOL]     if (typeVars.length != parameterTypes.length) { [EOL]         throw new IllegalArgumentException("Parameter type mismatch for " + rawType.getName() + ": expected " + typeVars.length + " parameters, was given " + parameterTypes.length); [EOL]     } [EOL]     String[] names = new String[typeVars.length]; [EOL]     for (int i = 0, len = typeVars.length; i < len; ++i) { [EOL]         names[i] = typeVars[i].getName(); [EOL]     } [EOL]     JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false); [EOL]     return resultType; [EOL] }
public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { [EOL]     TypeVariable<?>[] typeVars = rawType.getTypeParameters(); [EOL]     if (typeVars.length != parameterTypes.length) { [EOL]         throw new IllegalArgumentException("Parameter type mismatch for " + rawType.getName() + ": expected " + typeVars.length + " parameters, was given " + parameterTypes.length); [EOL]     } [EOL]     String[] names = new String[typeVars.length]; [EOL]     for (int i = 0, len = typeVars.length; i < len; ++i) { [EOL]         names[i] = typeVars[i].getName(); [EOL]     } [EOL]     JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false); [EOL]     return resultType; [EOL] }
public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { [EOL]     TypeVariable<?>[] typeVars = rawType.getTypeParameters(); [EOL]     if (typeVars.length != parameterTypes.length) { [EOL]         throw new IllegalArgumentException("Parameter type mismatch for " + rawType.getName() + ": expected " + typeVars.length + " parameters, was given " + parameterTypes.length); [EOL]     } [EOL]     String[] names = new String[typeVars.length]; [EOL]     for (int i = 0, len = typeVars.length; i < len; ++i) { [EOL]         names[i] = typeVars[i].getName(); [EOL]     } [EOL]     JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false); [EOL]     return resultType; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL]     Class<?> rawType = (Class<?>) type.getRawType(); [EOL]     Type[] args = type.getActualTypeArguments(); [EOL]     int paramCount = (args == null) ? 0 : args.length; [EOL]     JavaType[] pt; [EOL]     if (paramCount == 0) { [EOL]         pt = NO_TYPES; [EOL]     } else { [EOL]         pt = new JavaType[paramCount]; [EOL]         for (int i = 0; i < paramCount; ++i) { [EOL]             pt[i] = _constructType(args[i], context); [EOL]         } [EOL]     } [EOL]     if (Map.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL]         if (mapParams.length != 2) { [EOL]             throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL]         } [EOL]         return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL]         if (collectionParams.length != 1) { [EOL]             throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL]         } [EOL]         return CollectionType.construct(rawType, collectionParams[0]); [EOL]     } [EOL]     if (paramCount == 0) { [EOL]         return new SimpleType(rawType); [EOL]     } [EOL]     return constructSimpleType(rawType, pt); [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL]     Class<?> rawType = (Class<?>) type.getRawType(); [EOL]     Type[] args = type.getActualTypeArguments(); [EOL]     int paramCount = (args == null) ? 0 : args.length; [EOL]     JavaType[] pt; [EOL]     if (paramCount == 0) { [EOL]         pt = NO_TYPES; [EOL]     } else { [EOL]         pt = new JavaType[paramCount]; [EOL]         for (int i = 0; i < paramCount; ++i) { [EOL]             pt[i] = _constructType(args[i], context); [EOL]         } [EOL]     } [EOL]     if (Map.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL]         if (mapParams.length != 2) { [EOL]             throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL]         } [EOL]         return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL]         if (collectionParams.length != 1) { [EOL]             throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL]         } [EOL]         return CollectionType.construct(rawType, collectionParams[0]); [EOL]     } [EOL]     if (paramCount == 0) { [EOL]         return new SimpleType(rawType); [EOL]     } [EOL]     return constructSimpleType(rawType, pt); [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL]     Class<?> rawType = (Class<?>) type.getRawType(); [EOL]     Type[] args = type.getActualTypeArguments(); [EOL]     int paramCount = (args == null) ? 0 : args.length; [EOL]     JavaType[] pt; [EOL]     if (paramCount == 0) { [EOL]         pt = NO_TYPES; [EOL]     } else { [EOL]         pt = new JavaType[paramCount]; [EOL]         for (int i = 0; i < paramCount; ++i) { [EOL]             pt[i] = _constructType(args[i], context); [EOL]         } [EOL]     } [EOL]     if (Map.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL]         if (mapParams.length != 2) { [EOL]             throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL]         } [EOL]         return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL]         if (collectionParams.length != 1) { [EOL]             throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL]         } [EOL]         return CollectionType.construct(rawType, collectionParams[0]); [EOL]     } [EOL]     if (paramCount == 0) { [EOL]         return new SimpleType(rawType); [EOL]     } [EOL]     return constructSimpleType(rawType, pt); [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL]     Class<?> rawType = (Class<?>) type.getRawType(); [EOL]     Type[] args = type.getActualTypeArguments(); [EOL]     int paramCount = (args == null) ? 0 : args.length; [EOL]     JavaType[] pt; [EOL]     if (paramCount == 0) { [EOL]         pt = NO_TYPES; [EOL]     } else { [EOL]         pt = new JavaType[paramCount]; [EOL]         for (int i = 0; i < paramCount; ++i) { [EOL]             pt[i] = _constructType(args[i], context); [EOL]         } [EOL]     } [EOL]     if (Map.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL]         if (mapParams.length != 2) { [EOL]             throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL]         } [EOL]         return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL]         if (collectionParams.length != 1) { [EOL]             throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL]         } [EOL]         return CollectionType.construct(rawType, collectionParams[0]); [EOL]     } [EOL]     if (paramCount == 0) { [EOL]         return new SimpleType(rawType); [EOL]     } [EOL]     return constructSimpleType(rawType, pt); [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL]     Class<?> rawType = (Class<?>) type.getRawType(); [EOL]     Type[] args = type.getActualTypeArguments(); [EOL]     int paramCount = (args == null) ? 0 : args.length; [EOL]     JavaType[] pt; [EOL]     if (paramCount == 0) { [EOL]         pt = NO_TYPES; [EOL]     } else { [EOL]         pt = new JavaType[paramCount]; [EOL]         for (int i = 0; i < paramCount; ++i) { [EOL]             pt[i] = _constructType(args[i], context); [EOL]         } [EOL]     } [EOL]     if (Map.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL]         if (mapParams.length != 2) { [EOL]             throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL]         } [EOL]         return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL]         if (collectionParams.length != 1) { [EOL]             throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL]         } [EOL]         return CollectionType.construct(rawType, collectionParams[0]); [EOL]     } [EOL]     if (paramCount == 0) { [EOL]         return new SimpleType(rawType); [EOL]     } [EOL]     return constructSimpleType(rawType, pt); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
public JsonParser asParser(JsonParser src) { [EOL]     Parser p = new Parser(_first, src.getCodec()); [EOL]     p.setLocation(src.getTokenLocation()); [EOL]     return p; [EOL] }
public JsonParser asParser(JsonParser src) { [EOL]     Parser p = new Parser(_first, src.getCodec()); [EOL]     p.setLocation(src.getTokenLocation()); [EOL]     return p; [EOL] }
@Override [EOL] public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.FIELD_NAME, name); [EOL]     _writeContext.writeFieldName(name.getValue()); [EOL] }
@Override [EOL] public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.FIELD_NAME, name); [EOL]     _writeContext.writeFieldName(name.getValue()); [EOL] }
public void setLocation(JsonLocation l) { [EOL]     _location = l; [EOL] }
public void setLocation(JsonLocation l) { [EOL]     _location = l; [EOL] }
@Override [EOL] public float getFloatValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().floatValue(); [EOL] }
public StdKeySerializer() { [EOL]     super(Object.class); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof Date) { [EOL]         provider.defaultSerializeDateKey((Date) value, jgen); [EOL]     } else { [EOL]         jgen.writeFieldName(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof Date) { [EOL]         provider.defaultSerializeDateKey((Date) value, jgen); [EOL]     } else { [EOL]         jgen.writeFieldName(value.toString()); [EOL]     } [EOL] }
protected void _assertSubclass(Class<?> subclass, Class<?> superClass) { [EOL]     if (!_class.isAssignableFrom(subclass)) { [EOL]         throw new IllegalArgumentException("Class " + subclass.getName() + " is not assignable to " + _class.getName()); [EOL]     } [EOL] }
@Override [EOL] public final int hashCode() { [EOL]     return _hashCode; [EOL] }
@Override [EOL] public String asText() { [EOL]     return (_value == null) ? "null" : _value.toString(); [EOL] }
@Override [EOL] public String asText() { [EOL]     return (_value == null) ? "null" : _value.toString(); [EOL] }
@Override [EOL] public int asInt(int defaultValue) { [EOL]     if (_value instanceof Number) { [EOL]         return ((Number) _value).intValue(); [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public int asInt(int defaultValue) { [EOL]     if (_value instanceof Number) { [EOL]         return ((Number) _value).intValue(); [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public long asLong(long defaultValue) { [EOL]     if (_value instanceof Number) { [EOL]         return ((Number) _value).longValue(); [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public long asLong(long defaultValue) { [EOL]     if (_value instanceof Number) { [EOL]         return ((Number) _value).longValue(); [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public double asDouble(double defaultValue) { [EOL]     if (_value instanceof Number) { [EOL]         return ((Number) _value).doubleValue(); [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public double asDouble(double defaultValue) { [EOL]     if (_value instanceof Number) { [EOL]         return ((Number) _value).doubleValue(); [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     POJONode other = (POJONode) o; [EOL]     if (_value == null) { [EOL]         return other._value == null; [EOL]     } [EOL]     return _value.equals(other._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     POJONode other = (POJONode) o; [EOL]     if (_value == null) { [EOL]         return other._value == null; [EOL]     } [EOL]     return _value.equals(other._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     POJONode other = (POJONode) o; [EOL]     if (_value == null) { [EOL]         return other._value == null; [EOL]     } [EOL]     return _value.equals(other._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     POJONode other = (POJONode) o; [EOL]     if (_value == null) { [EOL]         return other._value == null; [EOL]     } [EOL]     return _value.equals(other._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     POJONode other = (POJONode) o; [EOL]     if (_value == null) { [EOL]         return other._value == null; [EOL]     } [EOL]     return _value.equals(other._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     POJONode other = (POJONode) o; [EOL]     if (_value == null) { [EOL]         return other._value == null; [EOL]     } [EOL]     return _value.equals(other._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     POJONode other = (POJONode) o; [EOL]     if (_value == null) { [EOL]         return other._value == null; [EOL]     } [EOL]     return _value.equals(other._value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value.hashCode(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(_value); [EOL] }
public DateSerializer() { [EOL]     this(false, null); [EOL] }
public DateSerializer(boolean useTimestamp, DateFormat customFormat) { [EOL]     super(Date.class, useTimestamp, customFormat); [EOL] }
public DateSerializer(boolean useTimestamp, DateFormat customFormat) { [EOL]     super(Date.class, useTimestamp, customFormat); [EOL] }
@Override [EOL] public JavaType getOutputType(TypeFactory typeFactory) { [EOL]     JavaType[] types = typeFactory.findTypeParameters(getClass(), Converter.class); [EOL]     if (types == null || types.length < 2) { [EOL]         throw new IllegalStateException("Can not find OUT type parameter for Converter of type " + getClass().getName()); [EOL]     } [EOL]     return types[1]; [EOL] }
@Override [EOL] public JavaType getOutputType(TypeFactory typeFactory) { [EOL]     JavaType[] types = typeFactory.findTypeParameters(getClass(), Converter.class); [EOL]     if (types == null || types.length < 2) { [EOL]         throw new IllegalStateException("Can not find OUT type parameter for Converter of type " + getClass().getName()); [EOL]     } [EOL]     return types[1]; [EOL] }
public ContainerSerializer<?> withValueTypeSerializer(TypeSerializer vts) { [EOL]     if (vts == null) [EOL]         return this; [EOL]     return _withValueTypeSerializer(vts); [EOL] }
public ContainerSerializer<?> withValueTypeSerializer(TypeSerializer vts) { [EOL]     if (vts == null) [EOL]         return this; [EOL]     return _withValueTypeSerializer(vts); [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper addHandler(DeserializationProblemHandler h) { [EOL]     _deserializationConfig = _deserializationConfig.withHandler(h); [EOL]     return this; [EOL] }
public ObjectMapper addHandler(DeserializationProblemHandler h) { [EOL]     _deserializationConfig = _deserializationConfig.withHandler(h); [EOL]     return this; [EOL] }
public ObjectMapper clearProblemHandlers() { [EOL]     _deserializationConfig = _deserializationConfig.withNoProblemHandlers(); [EOL]     return this; [EOL] }
@Override [EOL] public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig cfg = getDeserializationConfig(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); [EOL]     if (n == null) { [EOL]         n = getNodeFactory().nullNode(); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     T result = (T) n; [EOL]     return result; [EOL] }
@Override [EOL] public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig cfg = getDeserializationConfig(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); [EOL]     if (n == null) { [EOL]         n = getNodeFactory().nullNode(); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     T result = (T) n; [EOL]     return result; [EOL] }
@Override [EOL] public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig cfg = getDeserializationConfig(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); [EOL]     if (n == null) { [EOL]         n = getNodeFactory().nullNode(); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     T result = (T) n; [EOL]     return result; [EOL] }
@Override [EOL] public ObjectNode createObjectNode() { [EOL]     return _deserializationConfig.getNodeFactory().objectNode(); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(String content, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(Reader src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); [EOL] }
public String writeValueAsString(Object value) throws JsonProcessingException { [EOL]     SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(sw), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     return sw.getAndClear(); [EOL] }
public ObjectWriter writerWithType(TypeReference<?> rootType) { [EOL]     return new ObjectWriter(this, getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), null); [EOL] }
public ObjectWriter writerWithType(TypeReference<?> rootType) { [EOL]     return new ObjectWriter(this, getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), null); [EOL] }
public ObjectWriter writer(Base64Variant defaultBase64) { [EOL]     return new ObjectWriter(this, getSerializationConfig().with(defaultBase64)); [EOL] }
public ObjectWriter writer(Base64Variant defaultBase64) { [EOL]     return new ObjectWriter(this, getSerializationConfig().with(defaultBase64)); [EOL] }
public ObjectReader reader() { [EOL]     return new ObjectReader(this, getDeserializationConfig()).with(_injectableValues); [EOL] }
public ObjectReader reader() { [EOL]     return new ObjectReader(this, getDeserializationConfig()).with(_injectableValues); [EOL] }
public ObjectReader reader(DeserializationFeature feature) { [EOL]     return new ObjectReader(this, getDeserializationConfig().with(feature)); [EOL] }
public ObjectReader reader(DeserializationFeature feature) { [EOL]     return new ObjectReader(this, getDeserializationConfig().with(feature)); [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL]             result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationConfig cfg = getDeserializationConfig(); [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]             if (cfg.useRootWrapping()) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]             } else { [EOL]                 result = deser.deserialize(jp, ctxt); [EOL]             } [EOL]         } [EOL]         jp.clearCurrentToken(); [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, DeserializationConfig config, JavaType rootType, JsonDeserializer<Object> deser) throws IOException, JsonParseException, JsonMappingException { [EOL]     String expName = config.getRootName(); [EOL]     if (expName == null) { [EOL]         SerializedString sstr = _rootNames.findRootName(rootType, config); [EOL]         expName = sstr.getValue(); [EOL]     } [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not START_OBJECT (needed to unwrap root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw JsonMappingException.from(jp, "Current token not FIELD_NAME (to contain expected root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     String actualName = jp.getCurrentName(); [EOL]     if (!expName.equals(actualName)) { [EOL]         throw JsonMappingException.from(jp, "Root name '" + actualName + "' does not match expected ('" + expName + "') for type " + rootType); [EOL]     } [EOL]     jp.nextToken(); [EOL]     Object result = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw JsonMappingException.from(jp, "Current token not END_OBJECT (to match wrapper object with root name '" + expName + "'), but " + jp.getCurrentToken()); [EOL]     } [EOL]     return result; [EOL] }
public CalendarSerializer() { [EOL]     this(false, null); [EOL] }
public CalendarSerializer(boolean useTimestamp, DateFormat customFormat) { [EOL]     super(Calendar.class, useTimestamp, customFormat); [EOL] }
public CalendarSerializer(boolean useTimestamp, DateFormat customFormat) { [EOL]     super(Calendar.class, useTimestamp, customFormat); [EOL] }
public CalendarSerializer(boolean useTimestamp, DateFormat customFormat) { [EOL]     super(Calendar.class, useTimestamp, customFormat); [EOL] }
@Override [EOL] public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value.getTime(), jgen); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value.getTime(), jgen); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value.getTime(), jgen); [EOL]     } [EOL] }
public boolean canCreateFromInt() { [EOL]     return false; [EOL] }
public boolean canCreateUsingDefault() { [EOL]     return getDefaultCreator() != null; [EOL] }
public boolean canCreateUsingDefault() { [EOL]     return getDefaultCreator() != null; [EOL] }
public AnnotatedWithParams getDefaultCreator() { [EOL]     return null; [EOL] }
public AnnotatedWithParams getDelegateCreator() { [EOL]     return null; [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return _value ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE; [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return _value ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE; [EOL] }
@Override [EOL] public String transform(String name) { [EOL]     return name; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
protected NonTypedScalarSerializerBase(Class<T> t) { [EOL]     super(t); [EOL] }
protected StdDeserializer(JavaType valueType) { [EOL]     _valueClass = (valueType == null) ? null : valueType.getRawClass(); [EOL] }
protected StdDeserializer(JavaType valueType) { [EOL]     _valueClass = (valueType == null) ? null : valueType.getRawClass(); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getNumberType() == NumberType.LONG) { [EOL]         return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE; [EOL]     } [EOL]     String str = jp.getText(); [EOL]     if ("0.0".equals(str) || "0".equals(str)) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return Boolean.TRUE; [EOL] }
protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getNumberType() == NumberType.LONG) { [EOL]         return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE; [EOL]     } [EOL]     String str = jp.getText(); [EOL]     if ("0.0".equals(str) || "0".equals(str)) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return Boolean.TRUE; [EOL] }
protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getNumberType() == NumberType.LONG) { [EOL]         return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE; [EOL]     } [EOL]     String str = jp.getText(); [EOL]     if ("0.0".equals(str) || "0".equals(str)) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return Boolean.TRUE; [EOL] }
protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getNumberType() == NumberType.LONG) { [EOL]         return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE; [EOL]     } [EOL]     String str = jp.getText(); [EOL]     if ("0.0".equals(str) || "0".equals(str)) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return Boolean.TRUE; [EOL] }
protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getNumberType() == NumberType.LONG) { [EOL]         return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE; [EOL]     } [EOL]     String str = jp.getText(); [EOL]     if ("0.0".equals(str) || "0".equals(str)) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return Boolean.TRUE; [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getLongValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Long) getEmptyValue(); [EOL]         } [EOL]         try { [EOL]             return Long.valueOf(NumberInput.parseLong(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Long) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final static double parseDouble(String numStr) throws NumberFormatException { [EOL]     if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) { [EOL]         return Double.MIN_VALUE; [EOL]     } [EOL]     return Double.parseDouble(numStr); [EOL] }
protected final static double parseDouble(String numStr) throws NumberFormatException { [EOL]     if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) { [EOL]         return Double.MIN_VALUE; [EOL]     } [EOL]     return Double.parseDouble(numStr); [EOL] }
protected final static double parseDouble(String numStr) throws NumberFormatException { [EOL]     if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) { [EOL]         return Double.MIN_VALUE; [EOL]     } [EOL]     return Double.parseDouble(numStr); [EOL] }
protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException { [EOL]     return ctxt.findContextualValueDeserializer(type, property); [EOL] }
protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (instanceOrClass == null) { [EOL]         instanceOrClass = getValueClass(); [EOL]     } [EOL]     if (ctxt.handleUnknownProperty(jp, this, instanceOrClass, propName)) { [EOL]         return; [EOL]     } [EOL]     ctxt.reportUnknownProperty(instanceOrClass, propName, this); [EOL]     jp.skipChildren(); [EOL] }
protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (instanceOrClass == null) { [EOL]         instanceOrClass = getValueClass(); [EOL]     } [EOL]     if (ctxt.handleUnknownProperty(jp, this, instanceOrClass, propName)) { [EOL]         return; [EOL]     } [EOL]     ctxt.reportUnknownProperty(instanceOrClass, propName, this); [EOL]     jp.skipChildren(); [EOL] }
public SerializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins) { [EOL]     super(base, str, mixins); [EOL]     _serFeatures = collectFeatureDefaults(SerializationFeature.class); [EOL]     _filterProvider = null; [EOL] }
public SerializationConfig(BaseSettings base, SubtypeResolver str, Map<ClassKey, Class<?>> mixins) { [EOL]     super(base, str, mixins); [EOL]     _serFeatures = collectFeatureDefaults(SerializationFeature.class); [EOL]     _filterProvider = null; [EOL] }
@Override [EOL] public SerializationConfig with(Base64Variant base64) { [EOL]     return _withBase(_base.with(base64)); [EOL] }
@Override [EOL] public SerializationConfig with(Base64Variant base64) { [EOL]     return _withBase(_base.with(base64)); [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) { [EOL]         vchecker = vchecker.withGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) { [EOL]         vchecker = vchecker.withIsGetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public InetAddressDeserializer() { [EOL]     super(InetAddress.class); [EOL] }
@Override [EOL] protected InetAddress _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return InetAddress.getByName(value); [EOL] }
@Override [EOL] protected InetAddress _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return InetAddress.getByName(value); [EOL] }
public AtomicBooleanDeserializer() { [EOL]     super(AtomicBoolean.class); [EOL] }
@Override [EOL] public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt)); [EOL] }
@Override [EOL] public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt)); [EOL] }
@Override [EOL] public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt)); [EOL] }
protected DateTimeSerializerBase(Class<T> type, boolean useTimestamp, DateFormat customFormat) { [EOL]     super(type); [EOL]     _useTimestamp = useTimestamp; [EOL]     _customFormat = customFormat; [EOL] }
protected DateTimeSerializerBase(Class<T> type, boolean useTimestamp, DateFormat customFormat) { [EOL]     super(type); [EOL]     _useTimestamp = useTimestamp; [EOL]     _customFormat = customFormat; [EOL] }
protected DateTimeSerializerBase(Class<T> type, boolean useTimestamp, DateFormat customFormat) { [EOL]     super(type); [EOL]     _useTimestamp = useTimestamp; [EOL]     _customFormat = customFormat; [EOL] }
protected FieldProperty(FieldProperty src, String newName) { [EOL]     super(src, newName); [EOL]     _annotated = src._annotated; [EOL]     _field = src._field; [EOL] }
@Override [EOL] public FieldProperty withName(String newName) { [EOL]     return new FieldProperty(this, newName); [EOL] }
@Override [EOL] public FieldProperty withName(String newName) { [EOL]     return new FieldProperty(this, newName); [EOL] }
protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = src._ignorableProps; [EOL]     _ignoreAllUnknown = (unwrapper != null) || src._ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _objectIdReader = src._objectIdReader; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     if (unwrapper != null) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             _unwrappedPropertyHandler.renameAll(unwrapper); [EOL]         } [EOL]         _beanProperties = src._beanProperties.renameAll(unwrapper); [EOL]     } else { [EOL]         _beanProperties = src._beanProperties; [EOL]     } [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = false; [EOL] }
protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = src._ignorableProps; [EOL]     _ignoreAllUnknown = (unwrapper != null) || src._ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _objectIdReader = src._objectIdReader; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     if (unwrapper != null) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             _unwrappedPropertyHandler.renameAll(unwrapper); [EOL]         } [EOL]         _beanProperties = src._beanProperties.renameAll(unwrapper); [EOL]     } else { [EOL]         _beanProperties = src._beanProperties; [EOL]     } [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = false; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromString()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     return _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL] }
public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromString()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     return _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL] }
public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromString()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     return _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL] }
public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromString()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     return _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getNumberType()) { [EOL]         case FLOAT: [EOL]         case DOUBLE: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromDouble()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON floating-point number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getNumberType()) { [EOL]         case FLOAT: [EOL]         case DOUBLE: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromDouble()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON floating-point number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getNumberType()) { [EOL]         case FLOAT: [EOL]         case DOUBLE: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromDouble()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON floating-point number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getNumberType()) { [EOL]         case FLOAT: [EOL]         case DOUBLE: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromDouble()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON floating-point number"); [EOL] }
public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromBoolean()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE); [EOL]     return _valueInstantiator.createFromBoolean(ctxt, value); [EOL] }
public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromBoolean()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE); [EOL]     return _valueInstantiator.createFromBoolean(ctxt, value); [EOL] }
public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (!_valueInstantiator.canCreateFromBoolean()) { [EOL]             Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]             if (_injectables != null) { [EOL]                 injectValues(ctxt, bean); [EOL]             } [EOL]             return bean; [EOL]         } [EOL]     } [EOL]     boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE); [EOL]     return _valueInstantiator.createFromBoolean(ctxt, value); [EOL] }
@Override [EOL] protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (_ignoreAllUnknown || (_ignorableProps != null && _ignorableProps.contains(propName))) { [EOL]         jp.skipChildren(); [EOL]         return; [EOL]     } [EOL]     super.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] }
@Override [EOL] protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (_ignoreAllUnknown || (_ignorableProps != null && _ignorableProps.contains(propName))) { [EOL]         jp.skipChildren(); [EOL]         return; [EOL]     } [EOL]     super.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] }
@Override [EOL] protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (_ignoreAllUnknown || (_ignorableProps != null && _ignorableProps.contains(propName))) { [EOL]         jp.skipChildren(); [EOL]         return; [EOL]     } [EOL]     super.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, fieldName); [EOL] }
public BuilderBasedDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews) { [EOL]     super(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL]     _buildMethod = builder.getBuildMethod(); [EOL]     if (_objectIdReader != null) { [EOL]         throw new IllegalArgumentException("Can not use Object Id with Builder-based deserialization (type " + beanDesc.getType() + ")"); [EOL]     } [EOL] }
public BuilderBasedDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc, BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs, HashSet<String> ignorableProps, boolean ignoreAllUnknown, boolean hasViews) { [EOL]     super(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL]     _buildMethod = builder.getBuildMethod(); [EOL]     if (_objectIdReader != null) { [EOL]         throw new IllegalArgumentException("Can not use Object Id with Builder-based deserialization (type " + beanDesc.getType() + ")"); [EOL]     } [EOL] }
protected final Object finishBuild(DeserializationContext ctxt, Object builder) throws IOException { [EOL]     try { [EOL]         return _buildMethod.getMember().invoke(builder); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL] }
protected final Object finishBuild(DeserializationContext ctxt, Object builder) throws IOException { [EOL]     try { [EOL]         return _buildMethod.getMember().invoke(builder); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL] }
protected final Object finishBuild(DeserializationContext ctxt, Object builder) throws IOException { [EOL]     try { [EOL]         return _buildMethod.getMember().invoke(builder); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]         if (_vanillaProcessing) { [EOL]             return finishBuild(ctxt, vanillaDeserialize(jp, ctxt, t)); [EOL]         } [EOL]         Object builder = deserializeFromObject(jp, ctxt); [EOL]         return finishBuild(ctxt, builder); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return finishBuild(ctxt, deserializeFromString(jp, ctxt)); [EOL]         case VALUE_NUMBER_INT: [EOL]             return finishBuild(ctxt, deserializeFromNumber(jp, ctxt)); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return finishBuild(ctxt, deserializeFromDouble(jp, ctxt)); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return finishBuild(ctxt, deserializeFromBoolean(jp, ctxt)); [EOL]         case START_ARRAY: [EOL]             return finishBuild(ctxt, deserializeFromArray(jp, ctxt)); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             return finishBuild(ctxt, deserializeFromObject(jp, ctxt)); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]         if (_vanillaProcessing) { [EOL]             return finishBuild(ctxt, vanillaDeserialize(jp, ctxt, t)); [EOL]         } [EOL]         Object builder = deserializeFromObject(jp, ctxt); [EOL]         return finishBuild(ctxt, builder); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return finishBuild(ctxt, deserializeFromString(jp, ctxt)); [EOL]         case VALUE_NUMBER_INT: [EOL]             return finishBuild(ctxt, deserializeFromNumber(jp, ctxt)); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return finishBuild(ctxt, deserializeFromDouble(jp, ctxt)); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return finishBuild(ctxt, deserializeFromBoolean(jp, ctxt)); [EOL]         case START_ARRAY: [EOL]             return finishBuild(ctxt, deserializeFromArray(jp, ctxt)); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             return finishBuild(ctxt, deserializeFromObject(jp, ctxt)); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]         if (_vanillaProcessing) { [EOL]             return finishBuild(ctxt, vanillaDeserialize(jp, ctxt, t)); [EOL]         } [EOL]         Object builder = deserializeFromObject(jp, ctxt); [EOL]         return finishBuild(ctxt, builder); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return finishBuild(ctxt, deserializeFromString(jp, ctxt)); [EOL]         case VALUE_NUMBER_INT: [EOL]             return finishBuild(ctxt, deserializeFromNumber(jp, ctxt)); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return finishBuild(ctxt, deserializeFromDouble(jp, ctxt)); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return finishBuild(ctxt, deserializeFromBoolean(jp, ctxt)); [EOL]         case START_ARRAY: [EOL]             return finishBuild(ctxt, deserializeFromArray(jp, ctxt)); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             return finishBuild(ctxt, deserializeFromObject(jp, ctxt)); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]         if (_vanillaProcessing) { [EOL]             return finishBuild(ctxt, vanillaDeserialize(jp, ctxt, t)); [EOL]         } [EOL]         Object builder = deserializeFromObject(jp, ctxt); [EOL]         return finishBuild(ctxt, builder); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return finishBuild(ctxt, deserializeFromString(jp, ctxt)); [EOL]         case VALUE_NUMBER_INT: [EOL]             return finishBuild(ctxt, deserializeFromNumber(jp, ctxt)); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return finishBuild(ctxt, deserializeFromDouble(jp, ctxt)); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return finishBuild(ctxt, deserializeFromBoolean(jp, ctxt)); [EOL]         case START_ARRAY: [EOL]             return finishBuild(ctxt, deserializeFromArray(jp, ctxt)); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             return finishBuild(ctxt, deserializeFromObject(jp, ctxt)); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         jp.nextToken(); [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.FIELD_NAME) { [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     throw ctxt.mappingException(ObjectNode.class); [EOL] }
@Override [EOL] public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         jp.nextToken(); [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.FIELD_NAME) { [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     throw ctxt.mappingException(ObjectNode.class); [EOL] }
@Override [EOL] public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         jp.nextToken(); [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.FIELD_NAME) { [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     throw ctxt.mappingException(ObjectNode.class); [EOL] }
@Override [EOL] public JsonNode getNullValue() { [EOL]     return NullNode.getInstance(); [EOL] }
protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     ArrayNode node = nodeFactory.arrayNode(); [EOL]     while (true) { [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw ctxt.mappingException("Unexpected end-of-input when binding data into ArrayNode"); [EOL]         } [EOL]         switch(t) { [EOL]             case START_OBJECT: [EOL]                 node.add(deserializeObject(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 node.add(deserializeArray(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]             case END_ARRAY: [EOL]                 return node; [EOL]             case VALUE_STRING: [EOL]                 node.add(nodeFactory.textNode(jp.getText())); [EOL]                 break; [EOL]             default: [EOL]                 node.add(deserializeAny(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]         } [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
@Override [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config) { [EOL]     if (_factoryConfig == config) { [EOL]         return this; [EOL]     } [EOL]     if (getClass() != BeanDeserializerFactory.class) { [EOL]         throw new IllegalStateException("Subtype of BeanDeserializerFactory (" + getClass().getName() + ") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with " + "additional deserializer definitions"); [EOL]     } [EOL]     return new BeanDeserializerFactory(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@Override [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config) { [EOL]     if (_factoryConfig == config) { [EOL]         return this; [EOL]     } [EOL]     if (getClass() != BeanDeserializerFactory.class) { [EOL]         throw new IllegalStateException("Subtype of BeanDeserializerFactory (" + getClass().getName() + ") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with " + "additional deserializer definitions"); [EOL]     } [EOL]     return new BeanDeserializerFactory(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@Override [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config) { [EOL]     if (_factoryConfig == config) { [EOL]         return this; [EOL]     } [EOL]     if (getClass() != BeanDeserializerFactory.class) { [EOL]         throw new IllegalStateException("Subtype of BeanDeserializerFactory (" + getClass().getName() + ") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with " + "additional deserializer definitions"); [EOL]     } [EOL]     return new BeanDeserializerFactory(config); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return (JsonDeserializer<Object>) deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@Override [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return custom; [EOL]     } [EOL]     if (type.isThrowable()) { [EOL]         return buildThrowableDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isAbstract()) { [EOL]         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc); [EOL]         if (concreteType != null) { [EOL]             beanDesc = config.introspect(concreteType); [EOL]             return buildBeanDeserializer(ctxt, concreteType, beanDesc); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         return null; [EOL]     } [EOL]     return buildBeanDeserializer(ctxt, type, beanDesc); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@Override [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException { [EOL]     JavaType builderType = ctxt.constructType(builderClass); [EOL]     BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType); [EOL]     return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (AtomicReference.class.isAssignableFrom(cls)) { [EOL]         TypeFactory tf = ctxt.getTypeFactory(); [EOL]         JavaType[] params = tf.findTypeParameters(type, AtomicReference.class); [EOL]         JavaType referencedType; [EOL]         if (params == null || params.length < 1) { [EOL]             referencedType = TypeFactory.unknownType(); [EOL]         } else { [EOL]             referencedType = params[0]; [EOL]         } [EOL]         return new JdkDeserializers.AtomicReferenceDeserializer(referencedType); [EOL]     } [EOL]     return findOptionalStdDeserializer(ctxt, type, beanDesc); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, beanDesc); [EOL]     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL]     builder.setValueInstantiator(valueInstantiator); [EOL]     addBeanProps(ctxt, beanDesc, builder); [EOL]     addObjectIdReader(ctxt, beanDesc, builder); [EOL]     addReferenceProperties(ctxt, beanDesc, builder); [EOL]     addInjectables(ctxt, beanDesc, builder); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> deserializer; [EOL]     if (type.isAbstract() && !valueInstantiator.canInstantiate()) { [EOL]         deserializer = builder.buildAbstract(); [EOL]     } else { [EOL]         deserializer = builder.build(); [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer); [EOL]         } [EOL]     } [EOL]     return (JsonDeserializer<Object>) deserializer; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException { [EOL]     ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc); [EOL]     builder.setValueInstantiator(valueInstantiator); [EOL]     addBeanProps(ctxt, builderDesc, builder); [EOL]     addObjectIdReader(ctxt, builderDesc, builder); [EOL]     addReferenceProperties(ctxt, builderDesc, builder); [EOL]     addInjectables(ctxt, builderDesc, builder); [EOL]     JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig(); [EOL]     final String buildMethodName = (builderConfig == null) ? "build" : builderConfig.buildMethodName; [EOL]     AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null); [EOL]     if (buildMethod != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(buildMethod.getMember()); [EOL]         } [EOL]     } [EOL]     builder.setPOJOBuilder(buildMethod, builderConfig); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, builderDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deserializer = mod.modifyDeserializer(config, builderDesc, deserializer); [EOL]         } [EOL]     } [EOL]     return (JsonDeserializer<Object>) deserializer; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { [EOL]     return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     boolean ignoreAny = false; [EOL]     { [EOL]         Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); [EOL]         if (B != null) { [EOL]             ignoreAny = B.booleanValue(); [EOL]             builder.setIgnoreUnknownProperties(ignoreAny); [EOL]         } [EOL]     } [EOL]     Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]     for (String propName : ignored) { [EOL]         builder.addIgnorable(propName); [EOL]     } [EOL]     AnnotatedMethod anySetter = beanDesc.findAnySetter(); [EOL]     if (anySetter != null) { [EOL]         builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); [EOL]     } [EOL]     if (anySetter == null) { [EOL]         Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); [EOL]         if (ignored2 != null) { [EOL]             for (String propName : ignored2) { [EOL]                 builder.addIgnorable(propName); [EOL]             } [EOL]         } [EOL]     } [EOL]     final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS)); [EOL]     List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); [EOL]         } [EOL]     } [EOL]     for (BeanPropertyDefinition propDef : propDefs) { [EOL]         SettableBeanProperty prop = null; [EOL]         if (propDef.hasConstructorParameter()) { [EOL]             final String name = propDef.getName(); [EOL]             if (creatorProps != null) { [EOL]                 for (SettableBeanProperty cp : creatorProps) { [EOL]                     if (name.equals(cp.getName())) { [EOL]                         prop = cp; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (prop == null) { [EOL]                 throw ctxt.mappingException("Could not find creator property with name '" + name + "' (in class " + beanDesc.getBeanClass().getName() + ")"); [EOL]             } [EOL]             builder.addCreatorProperty(prop); [EOL]             continue; [EOL]         } [EOL]         if (propDef.hasSetter()) { [EOL]             Type propertyType = propDef.getSetter().getGenericParameterType(0); [EOL]             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL]         } else if (propDef.hasField()) { [EOL]             Type propertyType = propDef.getField().getGenericType(); [EOL]             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL]         } else if (useGettersAsSetters && propDef.hasGetter()) { [EOL]             AnnotatedMethod getter = propDef.getGetter(); [EOL]             Class<?> rawPropertyType = getter.getRawType(); [EOL]             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { [EOL]                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef); [EOL]             } [EOL]         } [EOL]         if (prop != null) { [EOL]             Class<?>[] views = propDef.findViews(); [EOL]             if (views == null) { [EOL]                 if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) { [EOL]                     views = NO_VIEWS; [EOL]                 } [EOL]             } [EOL]             prop.setViews(views); [EOL]             builder.addProperty(prop); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException { [EOL]     ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(Math.max(4, propDefsIn.size())); [EOL]     HashMap<Class<?>, Boolean> ignoredTypes = new HashMap<Class<?>, Boolean>(); [EOL]     for (BeanPropertyDefinition property : propDefsIn) { [EOL]         String name = property.getName(); [EOL]         if (ignored.contains(name)) { [EOL]             continue; [EOL]         } [EOL]         if (!property.hasConstructorParameter()) { [EOL]             Class<?> rawPropertyType = null; [EOL]             if (property.hasSetter()) { [EOL]                 rawPropertyType = property.getSetter().getRawParameterType(0); [EOL]             } else if (property.hasField()) { [EOL]                 rawPropertyType = property.getField().getRawType(); [EOL]             } [EOL]             if ((rawPropertyType != null) && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) { [EOL]                 builder.addIgnorable(name); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         result.add(property); [EOL]     } [EOL]     return result; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<String, AnnotatedMember> refs = beanDesc.findBackReferenceProperties(); [EOL]     if (refs != null) { [EOL]         for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) { [EOL]             String name = en.getKey(); [EOL]             AnnotatedMember m = en.getValue(); [EOL]             Type genericType; [EOL]             if (m instanceof AnnotatedMethod) { [EOL]                 genericType = ((AnnotatedMethod) m).getGenericParameterType(0); [EOL]             } else { [EOL]                 genericType = m.getRawType(); [EOL]             } [EOL]             SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), m); [EOL]             builder.addBackReferenceProperty(name, constructSettableProperty(ctxt, beanDesc, propDef, genericType)); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<String, AnnotatedMember> refs = beanDesc.findBackReferenceProperties(); [EOL]     if (refs != null) { [EOL]         for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) { [EOL]             String name = en.getKey(); [EOL]             AnnotatedMember m = en.getValue(); [EOL]             Type genericType; [EOL]             if (m instanceof AnnotatedMethod) { [EOL]                 genericType = ((AnnotatedMethod) m).getGenericParameterType(0); [EOL]             } else { [EOL]                 genericType = m.getRawType(); [EOL]             } [EOL]             SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), m); [EOL]             builder.addBackReferenceProperty(name, constructSettableProperty(ctxt, beanDesc, propDef, genericType)); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<Object, AnnotatedMember> raw = beanDesc.findInjectables(); [EOL]     if (raw != null) { [EOL]         boolean fixAccess = ctxt.canOverrideAccessModifiers(); [EOL]         for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) { [EOL]             AnnotatedMember m = entry.getValue(); [EOL]             if (fixAccess) { [EOL]                 m.fixAccess(); [EOL]             } [EOL]             builder.addInjectable(m.getName(), beanDesc.resolveType(m.getGenericType()), beanDesc.getClassAnnotations(), m, entry.getKey()); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<Object, AnnotatedMember> raw = beanDesc.findInjectables(); [EOL]     if (raw != null) { [EOL]         boolean fixAccess = ctxt.canOverrideAccessModifiers(); [EOL]         for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) { [EOL]             AnnotatedMember m = entry.getValue(); [EOL]             if (fixAccess) { [EOL]                 m.fixAccess(); [EOL]             } [EOL]             builder.addInjectable(m.getName(), beanDesc.resolveType(m.getGenericType()), beanDesc.getClassAnnotations(), m, entry.getKey()); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<Object, AnnotatedMember> raw = beanDesc.findInjectables(); [EOL]     if (raw != null) { [EOL]         boolean fixAccess = ctxt.canOverrideAccessModifiers(); [EOL]         for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) { [EOL]             AnnotatedMember m = entry.getValue(); [EOL]             if (fixAccess) { [EOL]                 m.fixAccess(); [EOL]             } [EOL]             builder.addInjectable(m.getName(), beanDesc.resolveType(m.getGenericType()), beanDesc.getClassAnnotations(), m, entry.getKey()); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException { [EOL]     AnnotatedMember mutator = propDef.getMutator(); [EOL]     if (ctxt.canOverrideAccessModifiers()) { [EOL]         mutator.fixAccess(); [EOL]     } [EOL]     JavaType t0 = beanDesc.resolveType(jdkType); [EOL]     BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.isRequired()); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, mutator); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator); [EOL]     type = modifyTypeByAnnotation(ctxt, mutator, type); [EOL]     TypeDeserializer typeDeser = type.getTypeHandler(); [EOL]     SettableBeanProperty prop; [EOL]     if (mutator instanceof AnnotatedMethod) { [EOL]         prop = new MethodProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator); [EOL]     } else { [EOL]         prop = new FieldProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedField) mutator); [EOL]     } [EOL]     if (propDeser != null) { [EOL]         prop = prop.withValueDeserializer(propDeser); [EOL]     } [EOL]     AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType(); [EOL]     if (ref != null && ref.isManagedReference()) { [EOL]         prop.setManagedReferenceName(ref.getName()); [EOL]     } [EOL]     return prop; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected boolean isPotentialBeanType(Class<?> type) { [EOL]     String typeStr = ClassUtil.canBeABeanType(type); [EOL]     if (typeStr != null) { [EOL]         throw new IllegalArgumentException("Can not deserialize Class " + type.getName() + " (of type " + typeStr + ") as a Bean"); [EOL]     } [EOL]     if (ClassUtil.isProxyType(type)) { [EOL]         throw new IllegalArgumentException("Can not deserialize Proxy class " + type.getName() + " as a Bean"); [EOL]     } [EOL]     typeStr = ClassUtil.isLocalType(type, true); [EOL]     if (typeStr != null) { [EOL]         throw new IllegalArgumentException("Can not deserialize Class " + type.getName() + " (of type " + typeStr + ") as a Bean"); [EOL]     } [EOL]     return true; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected boolean isPotentialBeanType(Class<?> type) { [EOL]     String typeStr = ClassUtil.canBeABeanType(type); [EOL]     if (typeStr != null) { [EOL]         throw new IllegalArgumentException("Can not deserialize Class " + type.getName() + " (of type " + typeStr + ") as a Bean"); [EOL]     } [EOL]     if (ClassUtil.isProxyType(type)) { [EOL]         throw new IllegalArgumentException("Can not deserialize Proxy class " + type.getName() + " as a Bean"); [EOL]     } [EOL]     typeStr = ClassUtil.isLocalType(type, true); [EOL]     if (typeStr != null) { [EOL]         throw new IllegalArgumentException("Can not deserialize Class " + type.getName() + " (of type " + typeStr + ") as a Bean"); [EOL]     } [EOL]     return true; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected boolean isPotentialBeanType(Class<?> type) { [EOL]     String typeStr = ClassUtil.canBeABeanType(type); [EOL]     if (typeStr != null) { [EOL]         throw new IllegalArgumentException("Can not deserialize Class " + type.getName() + " (of type " + typeStr + ") as a Bean"); [EOL]     } [EOL]     if (ClassUtil.isProxyType(type)) { [EOL]         throw new IllegalArgumentException("Can not deserialize Proxy class " + type.getName() + " as a Bean"); [EOL]     } [EOL]     typeStr = ClassUtil.isLocalType(type, true); [EOL]     if (typeStr != null) { [EOL]         throw new IllegalArgumentException("Can not deserialize Class " + type.getName() + " (of type " + typeStr + ") as a Bean"); [EOL]     } [EOL]     return true; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected boolean isPotentialBeanType(Class<?> type) { [EOL]     String typeStr = ClassUtil.canBeABeanType(type); [EOL]     if (typeStr != null) { [EOL]         throw new IllegalArgumentException("Can not deserialize Class " + type.getName() + " (of type " + typeStr + ") as a Bean"); [EOL]     } [EOL]     if (ClassUtil.isProxyType(type)) { [EOL]         throw new IllegalArgumentException("Can not deserialize Proxy class " + type.getName() + " as a Bean"); [EOL]     } [EOL]     typeStr = ClassUtil.isLocalType(type, true); [EOL]     if (typeStr != null) { [EOL]         throw new IllegalArgumentException("Can not deserialize Class " + type.getName() + " (of type " + typeStr + ") as a Bean"); [EOL]     } [EOL]     return true; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes) { [EOL]     Boolean status = ignoredTypes.get(type); [EOL]     if (status == null) { [EOL]         BeanDescription desc = config.introspectClassAnnotations(type); [EOL]         status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo()); [EOL]         if (status == null) { [EOL]             status = Boolean.FALSE; [EOL]         } [EOL]     } [EOL]     return status; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public Std(String name, JavaType type, PropertyName wrapperName, Annotations contextAnnotations, AnnotatedMember member, boolean isRequired) { [EOL]     _name = name; [EOL]     _type = type; [EOL]     _wrapperName = wrapperName; [EOL]     _isRequired = isRequired; [EOL]     _member = member; [EOL]     _contextAnnotations = contextAnnotations; [EOL] }
public Std(String name, JavaType type, PropertyName wrapperName, Annotations contextAnnotations, AnnotatedMember member, boolean isRequired) { [EOL]     _name = name; [EOL]     _type = type; [EOL]     _wrapperName = wrapperName; [EOL]     _isRequired = isRequired; [EOL]     _member = member; [EOL]     _contextAnnotations = contextAnnotations; [EOL] }
public ToStringSerializer() { [EOL]     super(Object.class); [EOL] }
@SuppressWarnings("unchecked") [EOL] public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType) { [EOL]     if (keyType == null) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     Class<?> cls = keyType.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return DEFAULT_STRING_SERIALIZER; [EOL]     } [EOL]     if (cls == Object.class) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     if (Date.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) DateKeySerializer.instance; [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) CalendarKeySerializer.instance; [EOL]     } [EOL]     return DEFAULT_KEY_SERIALIZER; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType) { [EOL]     if (keyType == null) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     Class<?> cls = keyType.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return DEFAULT_STRING_SERIALIZER; [EOL]     } [EOL]     if (cls == Object.class) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     if (Date.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) DateKeySerializer.instance; [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) CalendarKeySerializer.instance; [EOL]     } [EOL]     return DEFAULT_KEY_SERIALIZER; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType) { [EOL]     if (keyType == null) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     Class<?> cls = keyType.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return DEFAULT_STRING_SERIALIZER; [EOL]     } [EOL]     if (cls == Object.class) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     if (Date.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) DateKeySerializer.instance; [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) CalendarKeySerializer.instance; [EOL]     } [EOL]     return DEFAULT_KEY_SERIALIZER; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType) { [EOL]     if (keyType == null) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     Class<?> cls = keyType.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return DEFAULT_STRING_SERIALIZER; [EOL]     } [EOL]     if (cls == Object.class) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     if (Date.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) DateKeySerializer.instance; [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) CalendarKeySerializer.instance; [EOL]     } [EOL]     return DEFAULT_KEY_SERIALIZER; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType) { [EOL]     if (keyType == null) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     Class<?> cls = keyType.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return DEFAULT_STRING_SERIALIZER; [EOL]     } [EOL]     if (cls == Object.class) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     if (Date.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) DateKeySerializer.instance; [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) CalendarKeySerializer.instance; [EOL]     } [EOL]     return DEFAULT_KEY_SERIALIZER; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType) { [EOL]     if (keyType == null) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     Class<?> cls = keyType.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return DEFAULT_STRING_SERIALIZER; [EOL]     } [EOL]     if (cls == Object.class) { [EOL]         return DEFAULT_KEY_SERIALIZER; [EOL]     } [EOL]     if (Date.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) DateKeySerializer.instance; [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(cls)) { [EOL]         return (JsonSerializer<Object>) CalendarKeySerializer.instance; [EOL]     } [EOL]     return DEFAULT_KEY_SERIALIZER; [EOL] }
public StringKeySerializer() { [EOL]     super(String.class); [EOL] }
@Override [EOL] public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeFieldName(value); [EOL] }
protected PropertyValue(PropertyValue next, Object value) { [EOL]     this.next = next; [EOL]     this.value = value; [EOL] }
public Regular(PropertyValue next, Object value, SettableBeanProperty prop) { [EOL]     super(next, value); [EOL]     _property = prop; [EOL] }
public Regular(PropertyValue next, Object value, SettableBeanProperty prop) { [EOL]     super(next, value); [EOL]     _property = prop; [EOL] }
@Override [EOL] public void assign(Object bean) throws IOException, JsonProcessingException { [EOL]     _property.set(bean, value); [EOL] }
@Override [EOL] public void assign(Object bean) throws IOException, JsonProcessingException { [EOL]     _property.set(bean, value); [EOL] }
@Override [EOL] public void assign(Object bean) throws IOException, JsonProcessingException { [EOL]     _property.set(bean, value); [EOL] }
@Override [EOL] public void assign(Object bean) throws IOException, JsonProcessingException { [EOL]     _property.set(bean, value); [EOL] }
@Override [EOL] public final SerializerFactory withAdditionalSerializers(Serializers additional) { [EOL]     return withConfig(_factoryConfig.withAdditionalSerializers(additional)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> type = javaType.getRawClass(); [EOL]     if (Iterator.class.isAssignableFrom(type)) { [EOL]         return buildIteratorSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (Iterable.class.isAssignableFrom(type)) { [EOL]         return buildIterableSerializer(config, javaType, beanDesc, staticTyping); [EOL]     } [EOL]     if (CharSequence.class.isAssignableFrom(type)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL]             JavaType keyType = type.getKeyType(); [EOL]             EnumValues enums = null; [EOL]             if (keyType.isEnumType()) { [EOL]                 @SuppressWarnings("unchecked") [EOL]                 Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL]                 enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL]             } [EOL]             ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL]         } else { [EOL]             ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = prov.getAnnotationIntrospector(); [EOL]     Object serDef = intr.findKeySerializer(a); [EOL]     if (serDef != null) { [EOL]         return prov.serializerInstance(a, serDef); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = prov.getAnnotationIntrospector(); [EOL]     Object serDef = intr.findKeySerializer(a); [EOL]     if (serDef != null) { [EOL]         return prov.serializerInstance(a, serDef); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = prov.getAnnotationIntrospector(); [EOL]     Object serDef = intr.findContentSerializer(a); [EOL]     if (serDef != null) { [EOL]         return prov.serializerInstance(a, serDef); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<Object> _findContentSerializer(SerializerProvider prov, Annotated a) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = prov.getAnnotationIntrospector(); [EOL]     Object serDef = intr.findContentSerializer(a); [EOL]     if (serDef != null) { [EOL]         return prov.serializerInstance(a, serDef); [EOL]     } [EOL]     return null; [EOL] }
public final void addOrOverride(Annotation a) { [EOL]     _annotations.add(a); [EOL] }
public final void addOrOverride(Annotation a) { [EOL]     _annotations.add(a); [EOL] }
public UnknownSerializer() { [EOL]     super(Object.class); [EOL] }
@Override [EOL] public Class<?> getRawType() { [EOL]     return _class; [EOL] }
public Annotations getAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations; [EOL] }
public Annotations getAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addConstructorMixIns(Class<?> mixin) { [EOL]     MemberKey[] ctorKeys = null; [EOL]     int ctorCount = (_constructors == null) ? 0 : _constructors.size(); [EOL]     for (Constructor<?> ctor : mixin.getDeclaredConstructors()) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             if (_defaultConstructor != null) { [EOL]                 _addMixOvers(ctor, _defaultConstructor, false); [EOL]             } [EOL]         } else { [EOL]             if (ctorKeys == null) { [EOL]                 ctorKeys = new MemberKey[ctorCount]; [EOL]                 for (int i = 0; i < ctorCount; ++i) { [EOL]                     ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated()); [EOL]                 } [EOL]             } [EOL]             MemberKey key = new MemberKey(ctor); [EOL]             for (int i = 0; i < ctorCount; ++i) { [EOL]                 if (!key.equals(ctorKeys[i])) { [EOL]                     continue; [EOL]                 } [EOL]                 _addMixOvers(ctor, _constructors.get(i), true); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addFactoryMixIns(Class<?> mixin) { [EOL]     MemberKey[] methodKeys = null; [EOL]     int methodCount = _creatorMethods.size(); [EOL]     for (Method m : mixin.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (m.getParameterTypes().length == 0) { [EOL]             continue; [EOL]         } [EOL]         if (methodKeys == null) { [EOL]             methodKeys = new MemberKey[methodCount]; [EOL]             for (int i = 0; i < methodCount; ++i) { [EOL]                 methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated()); [EOL]             } [EOL]         } [EOL]         MemberKey key = new MemberKey(m); [EOL]         for (int i = 0; i < methodCount; ++i) { [EOL]             if (!key.equals(methodKeys[i])) { [EOL]                 continue; [EOL]             } [EOL]             _addMixOvers(m, _creatorMethods.get(i), true); [EOL]             break; [EOL]         } [EOL]     } [EOL] }
protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     if (mixInCls != null) { [EOL]         _addMethodMixIns(cls, methods, mixInCls, mixIns); [EOL]     } [EOL]     if (cls == null) { [EOL]         return; [EOL]     } [EOL]     for (Method m : cls.getDeclaredMethods()) { [EOL]         if (!_isIncludableMemberMethod(m)) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedMethod old = methods.find(m); [EOL]         if (old == null) { [EOL]             AnnotatedMethod newM = _constructMethod(m); [EOL]             methods.add(newM); [EOL]             old = mixIns.remove(m); [EOL]             if (old != null) { [EOL]                 _addMixOvers(old.getAnnotated(), newM, false); [EOL]             } [EOL]         } else { [EOL]             _addMixUnders(m, old); [EOL]             if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) { [EOL]                 methods.add(old.withMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     if (mixInCls != null) { [EOL]         _addMethodMixIns(cls, methods, mixInCls, mixIns); [EOL]     } [EOL]     if (cls == null) { [EOL]         return; [EOL]     } [EOL]     for (Method m : cls.getDeclaredMethods()) { [EOL]         if (!_isIncludableMemberMethod(m)) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedMethod old = methods.find(m); [EOL]         if (old == null) { [EOL]             AnnotatedMethod newM = _constructMethod(m); [EOL]             methods.add(newM); [EOL]             old = mixIns.remove(m); [EOL]             if (old != null) { [EOL]                 _addMixOvers(old.getAnnotated(), newM, false); [EOL]             } [EOL]         } else { [EOL]             _addMixUnders(m, old); [EOL]             if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) { [EOL]                 methods.add(old.withMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     if (mixInCls != null) { [EOL]         _addMethodMixIns(cls, methods, mixInCls, mixIns); [EOL]     } [EOL]     if (cls == null) { [EOL]         return; [EOL]     } [EOL]     for (Method m : cls.getDeclaredMethods()) { [EOL]         if (!_isIncludableMemberMethod(m)) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedMethod old = methods.find(m); [EOL]         if (old == null) { [EOL]             AnnotatedMethod newM = _constructMethod(m); [EOL]             methods.add(newM); [EOL]             old = mixIns.remove(m); [EOL]             if (old != null) { [EOL]                 _addMixOvers(old.getAnnotated(), newM, false); [EOL]             } [EOL]         } else { [EOL]             _addMixUnders(m, old); [EOL]             if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) { [EOL]                 methods.add(old.withMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     if (mixInCls != null) { [EOL]         _addMethodMixIns(cls, methods, mixInCls, mixIns); [EOL]     } [EOL]     if (cls == null) { [EOL]         return; [EOL]     } [EOL]     for (Method m : cls.getDeclaredMethods()) { [EOL]         if (!_isIncludableMemberMethod(m)) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedMethod old = methods.find(m); [EOL]         if (old == null) { [EOL]             AnnotatedMethod newM = _constructMethod(m); [EOL]             methods.add(newM); [EOL]             old = mixIns.remove(m); [EOL]             if (old != null) { [EOL]                 _addMixOvers(old.getAnnotated(), newM, false); [EOL]             } [EOL]         } else { [EOL]             _addMixUnders(m, old); [EOL]             if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) { [EOL]                 methods.add(old.withMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMixUnders(Method src, AnnotatedMethod target) { [EOL]     _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations()); [EOL] }
protected void _addMixUnders(Method src, AnnotatedMethod target) { [EOL]     _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations()); [EOL] }
protected void _addMixUnders(Method src, AnnotatedMethod target) { [EOL]     _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations()); [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config, Class<?> enumClass, AnnotatedMethod factory) { [EOL]     Class<?> paramClass = factory.getRawParameterType(0); [EOL]     if (paramClass == String.class) { [EOL]         paramClass = null; [EOL]     } else if (paramClass == Integer.TYPE || paramClass == Integer.class) { [EOL]         paramClass = Integer.class; [EOL]     } else if (paramClass == Long.TYPE || paramClass == Long.class) { [EOL]         paramClass = Long.class; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String or int/Integer/long/Long"); [EOL]     } [EOL]     if (config.canOverrideAccessModifiers()) { [EOL]         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]     } [EOL]     return new FactoryBasedDeserializer(enumClass, factory, paramClass); [EOL] }
public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config, Class<?> enumClass, AnnotatedMethod factory) { [EOL]     Class<?> paramClass = factory.getRawParameterType(0); [EOL]     if (paramClass == String.class) { [EOL]         paramClass = null; [EOL]     } else if (paramClass == Integer.TYPE || paramClass == Integer.class) { [EOL]         paramClass = Integer.class; [EOL]     } else if (paramClass == Long.TYPE || paramClass == Long.class) { [EOL]         paramClass = Long.class; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String or int/Integer/long/Long"); [EOL]     } [EOL]     if (config.canOverrideAccessModifiers()) { [EOL]         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]     } [EOL]     return new FactoryBasedDeserializer(enumClass, factory, paramClass); [EOL] }
public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config, Class<?> enumClass, AnnotatedMethod factory) { [EOL]     Class<?> paramClass = factory.getRawParameterType(0); [EOL]     if (paramClass == String.class) { [EOL]         paramClass = null; [EOL]     } else if (paramClass == Integer.TYPE || paramClass == Integer.class) { [EOL]         paramClass = Integer.class; [EOL]     } else if (paramClass == Long.TYPE || paramClass == Long.class) { [EOL]         paramClass = Long.class; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String or int/Integer/long/Long"); [EOL]     } [EOL]     if (config.canOverrideAccessModifiers()) { [EOL]         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]     } [EOL]     return new FactoryBasedDeserializer(enumClass, factory, paramClass); [EOL] }
public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config, Class<?> enumClass, AnnotatedMethod factory) { [EOL]     Class<?> paramClass = factory.getRawParameterType(0); [EOL]     if (paramClass == String.class) { [EOL]         paramClass = null; [EOL]     } else if (paramClass == Integer.TYPE || paramClass == Integer.class) { [EOL]         paramClass = Integer.class; [EOL]     } else if (paramClass == Long.TYPE || paramClass == Long.class) { [EOL]         paramClass = Long.class; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String or int/Integer/long/Long"); [EOL]     } [EOL]     if (config.canOverrideAccessModifiers()) { [EOL]         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]     } [EOL]     return new FactoryBasedDeserializer(enumClass, factory, paramClass); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) { [EOL]         String name = jp.getText(); [EOL]         Enum<?> result = _resolver.findEnum(name); [EOL]         if (result == null) { [EOL]             if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]                 if (name.length() == 0 || name.trim().length() == 0) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 throw ctxt.weirdStringException(name, _resolver.getEnumClass(), "value not one of declared Enum instance names"); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     if (curr == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) { [EOL]             throw ctxt.mappingException("Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)"); [EOL]         } [EOL]         int index = jp.getIntValue(); [EOL]         Enum<?> result = _resolver.getEnum(index); [EOL]         if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]             throw ctxt.weirdNumberException(Integer.valueOf(index), _resolver.getEnumClass(), "index value outside legal index range [0.." + _resolver.lastValidIndex() + "]"); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     throw ctxt.mappingException(_resolver.getEnumClass()); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object value; [EOL]     if (_inputType == null) { [EOL]         value = jp.getText(); [EOL]     } else if (_inputType == Integer.class) { [EOL]         value = Integer.valueOf(jp.getValueAsInt()); [EOL]     } else if (_inputType == Long.class) { [EOL]         value = Long.valueOf(jp.getValueAsLong()); [EOL]     } else { [EOL]         throw ctxt.mappingException(_enumClass); [EOL]     } [EOL]     try { [EOL]         return _factory.invoke(_enumClass, value); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public BasicBeanDescription forDeserializationWithBuilder(DeserializationConfig cfg, JavaType type, MixInResolver r) { [EOL]     return BasicBeanDescription.forDeserialization(collectPropertiesWithBuilder(cfg, type, r, false)); [EOL] }
protected POJOPropertiesCollector collectPropertiesWithBuilder(MapperConfig<?> config, JavaType type, MixInResolver r, boolean forSerialization) { [EOL]     boolean useAnnotations = config.isAnnotationProcessingEnabled(); [EOL]     AnnotationIntrospector ai = useAnnotations ? config.getAnnotationIntrospector() : null; [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), ai, r); [EOL]     JsonPOJOBuilder.Value builderConfig = (ai == null) ? null : ai.findPOJOBuilderConfig(ac); [EOL]     String mutatorPrefix = (builderConfig == null) ? "with" : builderConfig.withPrefix; [EOL]     return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect(); [EOL] }
protected POJOPropertiesCollector collectPropertiesWithBuilder(MapperConfig<?> config, JavaType type, MixInResolver r, boolean forSerialization) { [EOL]     boolean useAnnotations = config.isAnnotationProcessingEnabled(); [EOL]     AnnotationIntrospector ai = useAnnotations ? config.getAnnotationIntrospector() : null; [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), ai, r); [EOL]     JsonPOJOBuilder.Value builderConfig = (ai == null) ? null : ai.findPOJOBuilderConfig(ac); [EOL]     String mutatorPrefix = (builderConfig == null) ? "with" : builderConfig.withPrefix; [EOL]     return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect(); [EOL] }
protected POJOPropertiesCollector collectPropertiesWithBuilder(MapperConfig<?> config, JavaType type, MixInResolver r, boolean forSerialization) { [EOL]     boolean useAnnotations = config.isAnnotationProcessingEnabled(); [EOL]     AnnotationIntrospector ai = useAnnotations ? config.getAnnotationIntrospector() : null; [EOL]     AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), ai, r); [EOL]     JsonPOJOBuilder.Value builderConfig = (ai == null) ? null : ai.findPOJOBuilderConfig(ac); [EOL]     String mutatorPrefix = (builderConfig == null) ? "with" : builderConfig.withPrefix; [EOL]     return constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix).collect(); [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.indexOf('<') > 0) { [EOL]         JavaType t = _typeFactory.constructFromCanonical(id); [EOL]         return t; [EOL]     } [EOL]     try { [EOL]         Class<?> cls = ClassUtil.findClass(id); [EOL]         return _typeFactory.constructSpecializedType(_baseType, cls); [EOL]     } catch (ClassNotFoundException e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): no such class found"); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.indexOf('<') > 0) { [EOL]         JavaType t = _typeFactory.constructFromCanonical(id); [EOL]         return t; [EOL]     } [EOL]     try { [EOL]         Class<?> cls = ClassUtil.findClass(id); [EOL]         return _typeFactory.constructSpecializedType(_baseType, cls); [EOL]     } catch (ClassNotFoundException e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): no such class found"); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.indexOf('<') > 0) { [EOL]         JavaType t = _typeFactory.constructFromCanonical(id); [EOL]         return t; [EOL]     } [EOL]     try { [EOL]         Class<?> cls = ClassUtil.findClass(id); [EOL]         return _typeFactory.constructSpecializedType(_baseType, cls); [EOL]     } catch (ClassNotFoundException e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): no such class found"); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException("Invalid type id '" + id + "' (for id type 'Id.class'): " + e.getMessage(), e); [EOL]     } [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional) { [EOL]     if (additional == null) { [EOL]         throw new IllegalArgumentException("Can not pass null Deserializers"); [EOL]     } [EOL]     Deserializers[] all = ArrayBuilders.insertInListNoDup(_additionalDeserializers, additional); [EOL]     return new DeserializerFactoryConfig(all, _additionalKeyDeserializers, _modifiers, _abstractTypeResolvers, _valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional) { [EOL]     if (additional == null) { [EOL]         throw new IllegalArgumentException("Can not pass null Deserializers"); [EOL]     } [EOL]     Deserializers[] all = ArrayBuilders.insertInListNoDup(_additionalDeserializers, additional); [EOL]     return new DeserializerFactoryConfig(all, _additionalKeyDeserializers, _modifiers, _abstractTypeResolvers, _valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]     if (modifier == null) { [EOL]         throw new IllegalArgumentException("Can not pass null modifier"); [EOL]     } [EOL]     BeanDeserializerModifier[] all = ArrayBuilders.insertInListNoDup(_modifiers, modifier); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, _additionalKeyDeserializers, all, _abstractTypeResolvers, _valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]     if (modifier == null) { [EOL]         throw new IllegalArgumentException("Can not pass null modifier"); [EOL]     } [EOL]     BeanDeserializerModifier[] all = ArrayBuilders.insertInListNoDup(_modifiers, modifier); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, _additionalKeyDeserializers, all, _abstractTypeResolvers, _valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasDeserializerModifiers() { [EOL]     return _modifiers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasDeserializerModifiers() { [EOL]     return _modifiers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasValueInstantiators() { [EOL]     return _valueInstantiators.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasValueInstantiators() { [EOL]     return _valueInstantiators.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasValueInstantiators() { [EOL]     return _valueInstantiators.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasValueInstantiators() { [EOL]     return _valueInstantiators.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasValueInstantiators() { [EOL]     return _valueInstantiators.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<Deserializers> deserializers() { [EOL]     return ArrayBuilders.arrayAsIterable(_additionalDeserializers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<Deserializers> deserializers() { [EOL]     return ArrayBuilders.arrayAsIterable(_additionalDeserializers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<BeanDeserializerModifier> deserializerModifiers() { [EOL]     return ArrayBuilders.arrayAsIterable(_modifiers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<BeanDeserializerModifier> deserializerModifiers() { [EOL]     return ArrayBuilders.arrayAsIterable(_modifiers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<BeanDeserializerModifier> deserializerModifiers() { [EOL]     return ArrayBuilders.arrayAsIterable(_modifiers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public InvalidFormatException(String msg, JsonLocation loc, Object value, Class<?> targetType) { [EOL]     super(msg, loc); [EOL]     _value = value; [EOL]     _targetType = targetType; [EOL] }
public InvalidFormatException(String msg, JsonLocation loc, Object value, Class<?> targetType) { [EOL]     super(msg, loc); [EOL]     _value = value; [EOL]     _targetType = targetType; [EOL] }
public static InvalidFormatException from(JsonParser jp, String msg, Object value, Class<?> targetType) { [EOL]     return new InvalidFormatException(msg, jp.getTokenLocation(), value, targetType); [EOL] }
public static InvalidFormatException from(JsonParser jp, String msg, Object value, Class<?> targetType) { [EOL]     return new InvalidFormatException(msg, jp.getTokenLocation(), value, targetType); [EOL] }
public Object getValue() { [EOL]     return _value; [EOL] }
public Object getValue() { [EOL]     return _value; [EOL] }
public Class<?> getTargetType() { [EOL]     return _targetType; [EOL] }
protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findSerializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); [EOL]             return new StdDelegatingSerializer(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findSerializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); [EOL]             return new StdDelegatingSerializer(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider, BeanPropertyWriter prop) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null) { [EOL]         Object convDef = intr.findSerializationConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); [EOL]             JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop); [EOL]             return new StdDelegatingSerializer(conv, delegateType, ser); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix) { [EOL]     _config = config; [EOL]     _forSerialization = forSerialization; [EOL]     _type = type; [EOL]     _classDef = classDef; [EOL]     _mutatorPrefix = (mutatorPrefix == null) ? "set" : mutatorPrefix; [EOL]     _annotationIntrospector = config.isAnnotationProcessingEnabled() ? _config.getAnnotationIntrospector() : null; [EOL]     if (_annotationIntrospector == null) { [EOL]         _visibilityChecker = _config.getDefaultVisibilityChecker(); [EOL]     } else { [EOL]         _visibilityChecker = _annotationIntrospector.findAutoDetectVisibility(classDef, _config.getDefaultVisibilityChecker()); [EOL]     } [EOL] }
protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix) { [EOL]     _config = config; [EOL]     _forSerialization = forSerialization; [EOL]     _type = type; [EOL]     _classDef = classDef; [EOL]     _mutatorPrefix = (mutatorPrefix == null) ? "set" : mutatorPrefix; [EOL]     _annotationIntrospector = config.isAnnotationProcessingEnabled() ? _config.getAnnotationIntrospector() : null; [EOL]     if (_annotationIntrospector == null) { [EOL]         _visibilityChecker = _config.getDefaultVisibilityChecker(); [EOL]     } else { [EOL]         _visibilityChecker = _annotationIntrospector.findAutoDetectVisibility(classDef, _config.getDefaultVisibilityChecker()); [EOL]     } [EOL] }
public MapperConfig<?> getConfig() { [EOL]     return _config; [EOL] }
public JavaType getType() { [EOL]     return _type; [EOL] }
public AnnotatedClass getClassDef() { [EOL]     return _classDef; [EOL] }
public List<BeanPropertyDefinition> getProperties() { [EOL]     return new ArrayList<BeanPropertyDefinition>(_properties.values()); [EOL] }
public List<BeanPropertyDefinition> getProperties() { [EOL]     return new ArrayList<BeanPropertyDefinition>(_properties.values()); [EOL] }
public Map<Object, AnnotatedMember> getInjectables() { [EOL]     return _injectables; [EOL] }
public Map<Object, AnnotatedMember> getInjectables() { [EOL]     return _injectables; [EOL] }
public AnnotatedMethod getJsonValueMethod() { [EOL]     if (_jsonValueGetters != null) { [EOL]         if (_jsonValueGetters.size() > 1) { [EOL]             reportProblem("Multiple value properties defined (" + _jsonValueGetters.get(0) + " vs " + _jsonValueGetters.get(1) + ")"); [EOL]         } [EOL]         return _jsonValueGetters.get(0); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getJsonValueMethod() { [EOL]     if (_jsonValueGetters != null) { [EOL]         if (_jsonValueGetters.size() > 1) { [EOL]             reportProblem("Multiple value properties defined (" + _jsonValueGetters.get(0) + " vs " + _jsonValueGetters.get(1) + ")"); [EOL]         } [EOL]         return _jsonValueGetters.get(0); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getJsonValueMethod() { [EOL]     if (_jsonValueGetters != null) { [EOL]         if (_jsonValueGetters.size() > 1) { [EOL]             reportProblem("Multiple value properties defined (" + _jsonValueGetters.get(0) + " vs " + _jsonValueGetters.get(1) + ")"); [EOL]         } [EOL]         return _jsonValueGetters.get(0); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getJsonValueMethod() { [EOL]     if (_jsonValueGetters != null) { [EOL]         if (_jsonValueGetters.size() > 1) { [EOL]             reportProblem("Multiple value properties defined (" + _jsonValueGetters.get(0) + " vs " + _jsonValueGetters.get(1) + ")"); [EOL]         } [EOL]         return _jsonValueGetters.get(0); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMember getAnyGetter() { [EOL]     if (_anyGetters != null) { [EOL]         if (_anyGetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-getters' defined (" + _anyGetters.get(0) + " vs " + _anyGetters.get(1) + ")"); [EOL]         } [EOL]         return _anyGetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMember getAnyGetter() { [EOL]     if (_anyGetters != null) { [EOL]         if (_anyGetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-getters' defined (" + _anyGetters.get(0) + " vs " + _anyGetters.get(1) + ")"); [EOL]         } [EOL]         return _anyGetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMember getAnyGetter() { [EOL]     if (_anyGetters != null) { [EOL]         if (_anyGetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-getters' defined (" + _anyGetters.get(0) + " vs " + _anyGetters.get(1) + ")"); [EOL]         } [EOL]         return _anyGetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMember getAnyGetter() { [EOL]     if (_anyGetters != null) { [EOL]         if (_anyGetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-getters' defined (" + _anyGetters.get(0) + " vs " + _anyGetters.get(1) + ")"); [EOL]         } [EOL]         return _anyGetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getAnySetterMethod() { [EOL]     if (_anySetters != null) { [EOL]         if (_anySetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-setters' defined (" + _anySetters.get(0) + " vs " + _anySetters.get(1) + ")"); [EOL]         } [EOL]         return _anySetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getAnySetterMethod() { [EOL]     if (_anySetters != null) { [EOL]         if (_anySetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-setters' defined (" + _anySetters.get(0) + " vs " + _anySetters.get(1) + ")"); [EOL]         } [EOL]         return _anySetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getAnySetterMethod() { [EOL]     if (_anySetters != null) { [EOL]         if (_anySetters.size() > 1) { [EOL]             reportProblem("Multiple 'any-setters' defined (" + _anySetters.get(0) + " vs " + _anySetters.get(1) + ")"); [EOL]         } [EOL]         return _anySetters.getFirst(); [EOL]     } [EOL]     return null; [EOL] }
public Set<String> getIgnoredPropertyNames() { [EOL]     return _ignoredPropertyNames; [EOL] }
public ObjectIdInfo getObjectIdInfo() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(_classDef); [EOL]     if (info != null) { [EOL]         info = _annotationIntrospector.findObjectReferenceInfo(_classDef, info); [EOL]     } [EOL]     return info; [EOL] }
public ObjectIdInfo getObjectIdInfo() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(_classDef); [EOL]     if (info != null) { [EOL]         info = _annotationIntrospector.findObjectReferenceInfo(_classDef, info); [EOL]     } [EOL]     return info; [EOL] }
public ObjectIdInfo getObjectIdInfo() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdInfo info = _annotationIntrospector.findObjectIdInfo(_classDef); [EOL]     if (info != null) { [EOL]         info = _annotationIntrospector.findObjectReferenceInfo(_classDef, info); [EOL]     } [EOL]     return info; [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL]         if (implName == null) { [EOL]             return; [EOL]         } [EOL]         visible = _visibilityChecker.isSetterVisible(m); [EOL]     } else { [EOL]         implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addSetter(m, explName, visible, ignore); [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
public static <ET extends Enum<ET>> EnumResolver<ET> constructUsingMethod(Class<ET> enumCls, Method accessor) { [EOL]     ET[] enumValues = enumCls.getEnumConstants(); [EOL]     HashMap<String, ET> map = new HashMap<String, ET>(); [EOL]     for (int i = enumValues.length; --i >= 0; ) { [EOL]         ET en = enumValues[i]; [EOL]         try { [EOL]             Object o = accessor.invoke(en); [EOL]             if (o != null) { [EOL]                 map.put(o.toString(), en); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             throw new IllegalArgumentException("Failed to access @JsonValue of Enum value " + en + ": " + e.getMessage()); [EOL]         } [EOL]     } [EOL]     return new EnumResolver<ET>(enumCls, enumValues, map); [EOL] }
public static <ET extends Enum<ET>> EnumResolver<ET> constructUsingMethod(Class<ET> enumCls, Method accessor) { [EOL]     ET[] enumValues = enumCls.getEnumConstants(); [EOL]     HashMap<String, ET> map = new HashMap<String, ET>(); [EOL]     for (int i = enumValues.length; --i >= 0; ) { [EOL]         ET en = enumValues[i]; [EOL]         try { [EOL]             Object o = accessor.invoke(en); [EOL]             if (o != null) { [EOL]                 map.put(o.toString(), en); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             throw new IllegalArgumentException("Failed to access @JsonValue of Enum value " + en + ": " + e.getMessage()); [EOL]         } [EOL]     } [EOL]     return new EnumResolver<ET>(enumCls, enumValues, map); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public static EnumResolver<?> constructUnsafeUsingMethod(Class<?> rawEnumCls, Method accessor) { [EOL]     Class<Enum> enumCls = (Class<Enum>) rawEnumCls; [EOL]     return constructUsingMethod(enumCls, accessor); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public static EnumResolver<?> constructUnsafeUsingMethod(Class<?> rawEnumCls, Method accessor) { [EOL]     Class<Enum> enumCls = (Class<Enum>) rawEnumCls; [EOL]     return constructUsingMethod(enumCls, accessor); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public static EnumResolver<?> constructUnsafeUsingMethod(Class<?> rawEnumCls, Method accessor) { [EOL]     Class<Enum> enumCls = (Class<Enum>) rawEnumCls; [EOL]     return constructUsingMethod(enumCls, accessor); [EOL] }
public T getEnum(int index) { [EOL]     if (index < 0 || index >= _enums.length) { [EOL]         return null; [EOL]     } [EOL]     return _enums[index]; [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return _deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     Object result = _deserializeIfNatural(jp, ctxt); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return _deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     Object result = _deserializeIfNatural(jp, ctxt); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return _deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     Object result = _deserializeIfNatural(jp, ctxt); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object id = _objectIdReader.deserializer.deserialize(jp, ctxt); [EOL]     ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator); [EOL]     Object pojo = roid.item; [EOL]     if (pojo == null) { [EOL]         throw new IllegalStateException("Could not resolve Object Id [" + id + "] -- unresolved forward-reference?"); [EOL]     } [EOL]     return pojo; [EOL] }
protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object id = _objectIdReader.deserializer.deserialize(jp, ctxt); [EOL]     ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator); [EOL]     Object pojo = roid.item; [EOL]     if (pojo == null) { [EOL]         throw new IllegalStateException("Could not resolve Object Id [" + id + "] -- unresolved forward-reference?"); [EOL]     } [EOL]     return pojo; [EOL] }
protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) { [EOL]     this(mapper, config, null, null, null, null); [EOL] }
protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) { [EOL]     _config = config; [EOL]     _context = base._context; [EOL]     _rootDeserializers = base._rootDeserializers; [EOL]     _jsonFactory = base._jsonFactory; [EOL]     _rootNames = base._rootNames; [EOL]     _valueType = valueType; [EOL]     _rootDeserializer = rootDeser; [EOL]     _valueToUpdate = valueToUpdate; [EOL]     if (valueToUpdate != null && valueType.isArrayType()) { [EOL]         throw new IllegalArgumentException("Can not update an array value"); [EOL]     } [EOL]     _schema = schema; [EOL]     _injectableValues = injectableValues; [EOL]     _unwrapRoot = config.useRootWrapping(); [EOL]     _dataFormatReaders = dataFormatReaders; [EOL] }
protected ObjectReader(ObjectReader base, DeserializationConfig config, JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate, FormatSchema schema, InjectableValues injectableValues, DataFormatReaders dataFormatReaders) { [EOL]     _config = config; [EOL]     _context = base._context; [EOL]     _rootDeserializers = base._rootDeserializers; [EOL]     _jsonFactory = base._jsonFactory; [EOL]     _rootNames = base._rootNames; [EOL]     _valueType = valueType; [EOL]     _rootDeserializer = rootDeser; [EOL]     _valueToUpdate = valueToUpdate; [EOL]     if (valueToUpdate != null && valueType.isArrayType()) { [EOL]         throw new IllegalArgumentException("Can not update an array value"); [EOL]     } [EOL]     _schema = schema; [EOL]     _injectableValues = injectableValues; [EOL]     _unwrapRoot = config.useRootWrapping(); [EOL]     _dataFormatReaders = dataFormatReaders; [EOL] }
public ObjectReader with(InjectableValues injectableValues) { [EOL]     if (_injectableValues == injectableValues) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate, _schema, injectableValues, _dataFormatReaders); [EOL] }
public ObjectReader with(InjectableValues injectableValues) { [EOL]     if (_injectableValues == injectableValues) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate, _schema, injectableValues, _dataFormatReaders); [EOL] }
public ObjectReader withType(JavaType valueType) { [EOL]     if (valueType != null && valueType.equals(_valueType)) { [EOL]         return this; [EOL]     } [EOL]     JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType); [EOL]     DataFormatReaders det = _dataFormatReaders; [EOL]     if (det != null) { [EOL]         det = det.withType(valueType); [EOL]     } [EOL]     return new ObjectReader(this, _config, valueType, rootDeser, _valueToUpdate, _schema, _injectableValues, det); [EOL] }
public ObjectReader withType(JavaType valueType) { [EOL]     if (valueType != null && valueType.equals(_valueType)) { [EOL]         return this; [EOL]     } [EOL]     JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType); [EOL]     DataFormatReaders det = _dataFormatReaders; [EOL]     if (det != null) { [EOL]         det = det.withType(valueType); [EOL]     } [EOL]     return new ObjectReader(this, _config, valueType, rootDeser, _valueToUpdate, _schema, _injectableValues, det); [EOL] }
public ObjectReader withType(TypeReference<?> valueTypeRef) { [EOL]     return withType(_config.getTypeFactory().constructType(valueTypeRef.getType())); [EOL] }
public ObjectReader withType(TypeReference<?> valueTypeRef) { [EOL]     return withType(_config.getTypeFactory().constructType(valueTypeRef.getType())); [EOL] }
public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(json); [EOL]     } [EOL]     JsonParser jp = _jsonFactory.createParser(json); [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     jp.nextToken(); [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]     return new MappingIterator<T>(_valueType, jp, ctxt, _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate); [EOL] }
public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(json); [EOL]     } [EOL]     JsonParser jp = _jsonFactory.createParser(json); [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     jp.nextToken(); [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]     return new MappingIterator<T>(_valueType, jp, ctxt, _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate); [EOL] }
public <T> MappingIterator<T> readValues(String json) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(json); [EOL]     } [EOL]     JsonParser jp = _jsonFactory.createParser(json); [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     jp.nextToken(); [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]     return new MappingIterator<T>(_valueType, jp, ctxt, _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate); [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser == null) { [EOL]         try { [EOL]             DeserializationContext ctxt = createDeserializationContext(null, _config); [EOL]             deser = ctxt.findRootValueDeserializer(valueType); [EOL]             if (deser != null) { [EOL]                 _rootDeserializers.put(valueType, deser); [EOL]             } [EOL]             return deser; [EOL]         } catch (JsonProcessingException e) { [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException { [EOL]     DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length); [EOL]     if (!match.hasMatch()) { [EOL]         _reportUnkownFormat(_dataFormatReaders, match); [EOL]     } [EOL]     JsonParser jp = match.createParserWithMatch(); [EOL]     return match.getReader()._bindAndClose(jp, _valueToUpdate); [EOL] }
protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException { [EOL]     DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length); [EOL]     if (!match.hasMatch()) { [EOL]         _reportUnkownFormat(_dataFormatReaders, match); [EOL]     } [EOL]     JsonParser jp = match.createParserWithMatch(); [EOL]     return match.getReader()._bindAndClose(jp, _valueToUpdate); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, JavaType rootType, PrettyPrinter pp) { [EOL]     _config = config; [EOL]     _serializerProvider = mapper._serializerProvider; [EOL]     _serializerFactory = mapper._serializerFactory; [EOL]     _jsonFactory = mapper._jsonFactory; [EOL]     if (rootType != null) { [EOL]         rootType = rootType.withStaticTyping(); [EOL]     } [EOL]     _rootType = rootType; [EOL]     _prettyPrinter = pp; [EOL]     _schema = null; [EOL]     _rootSerializer = _prefetchRootSerializer(config, rootType); [EOL] }
protected ObjectWriter(ObjectMapper mapper, SerializationConfig config, JavaType rootType, PrettyPrinter pp) { [EOL]     _config = config; [EOL]     _serializerProvider = mapper._serializerProvider; [EOL]     _serializerFactory = mapper._serializerFactory; [EOL]     _jsonFactory = mapper._jsonFactory; [EOL]     if (rootType != null) { [EOL]         rootType = rootType.withStaticTyping(); [EOL]     } [EOL]     _rootType = rootType; [EOL]     _prettyPrinter = pp; [EOL]     _schema = null; [EOL]     _rootSerializer = _prefetchRootSerializer(config, rootType); [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, _config); [EOL]     } else { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
public ArrayNode(JsonNodeFactory nc) { [EOL]     super(nc); [EOL] }
public ArrayNode(JsonNodeFactory nc) { [EOL]     super(nc); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public ArrayNode deepCopy() { [EOL]     ArrayNode ret = new ArrayNode(_nodeFactory); [EOL]     for (JsonNode element : _children) ret._children.add(element.deepCopy()); [EOL]     return ret; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public ArrayNode deepCopy() { [EOL]     ArrayNode ret = new ArrayNode(_nodeFactory); [EOL]     for (JsonNode element : _children) ret._children.add(element.deepCopy()); [EOL]     return ret; [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.ARRAY; [EOL] }
@Override [EOL] public int size() { [EOL]     return _children.size(); [EOL] }
@Override [EOL] public int size() { [EOL]     return _children.size(); [EOL] }
@Override [EOL] public Iterator<JsonNode> elements() { [EOL]     return _children.iterator(); [EOL] }
@Override [EOL] public Iterator<JsonNode> elements() { [EOL]     return _children.iterator(); [EOL] }
@Override [EOL] public JsonNode get(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.get(index); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode get(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.get(index); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode get(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.get(index); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode get(String fieldName) { [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode path(String fieldName) { [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeStartArray(); [EOL]     for (JsonNode n : _children) { [EOL]         ((BaseJsonNode) n).serialize(jg, provider); [EOL]     } [EOL]     jg.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeStartArray(); [EOL]     for (JsonNode n : _children) { [EOL]         ((BaseJsonNode) n).serialize(jg, provider); [EOL]     } [EOL]     jg.writeEndArray(); [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findValues(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findValues(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findValues(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findValuesAsText(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findValuesAsText(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findValuesAsText(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findValuesAsText(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findParents(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (JsonNode node : _children) { [EOL]         foundSoFar = node.findParents(fieldName, foundSoFar); [EOL]     } [EOL]     return foundSoFar; [EOL] }
public JsonNode set(int index, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     if (index < 0 || index >= _children.size()) { [EOL]         throw new IndexOutOfBoundsException("Illegal index " + index + ", array size " + size()); [EOL]     } [EOL]     return _children.set(index, value); [EOL] }
public JsonNode set(int index, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     if (index < 0 || index >= _children.size()) { [EOL]         throw new IndexOutOfBoundsException("Illegal index " + index + ", array size " + size()); [EOL]     } [EOL]     return _children.set(index, value); [EOL] }
public JsonNode set(int index, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     if (index < 0 || index >= _children.size()) { [EOL]         throw new IndexOutOfBoundsException("Illegal index " + index + ", array size " + size()); [EOL]     } [EOL]     return _children.set(index, value); [EOL] }
public ArrayNode add(JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _add(value); [EOL]     return this; [EOL] }
public ArrayNode add(JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _add(value); [EOL]     return this; [EOL] }
public ArrayNode addAll(ArrayNode other) { [EOL]     _children.addAll(other._children); [EOL]     return this; [EOL] }
public ArrayNode addAll(ArrayNode other) { [EOL]     _children.addAll(other._children); [EOL]     return this; [EOL] }
public ArrayNode addAll(ArrayNode other) { [EOL]     _children.addAll(other._children); [EOL]     return this; [EOL] }
public ArrayNode addAll(Collection<JsonNode> nodes) { [EOL]     _children.addAll(nodes); [EOL]     return this; [EOL] }
public ArrayNode addAll(Collection<JsonNode> nodes) { [EOL]     _children.addAll(nodes); [EOL]     return this; [EOL] }
public ArrayNode insert(int index, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _insert(index, value); [EOL]     return this; [EOL] }
public ArrayNode insert(int index, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _insert(index, value); [EOL]     return this; [EOL] }
public JsonNode remove(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.remove(index); [EOL]     } [EOL]     return null; [EOL] }
public JsonNode remove(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.remove(index); [EOL]     } [EOL]     return null; [EOL] }
public JsonNode remove(int index) { [EOL]     if (index >= 0 && index < _children.size()) { [EOL]         return _children.remove(index); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ArrayNode removeAll() { [EOL]     _children.clear(); [EOL]     return this; [EOL] }
@Override [EOL] public ArrayNode removeAll() { [EOL]     _children.clear(); [EOL]     return this; [EOL] }
public ArrayNode add(int v) { [EOL]     _add(numberNode(v)); [EOL]     return this; [EOL] }
public ArrayNode add(int v) { [EOL]     _add(numberNode(v)); [EOL]     return this; [EOL] }
public ArrayNode add(String v) { [EOL]     if (v == null) { [EOL]         return addNull(); [EOL]     } [EOL]     return _add(textNode(v)); [EOL] }
public ArrayNode add(String v) { [EOL]     if (v == null) { [EOL]         return addNull(); [EOL]     } [EOL]     return _add(textNode(v)); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ArrayNode) o)._children); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _children.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _children.hashCode(); [EOL] }
private ArrayNode _add(JsonNode node) { [EOL]     _children.add(node); [EOL]     return this; [EOL] }
private ArrayNode _add(JsonNode node) { [EOL]     _children.add(node); [EOL]     return this; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef); [EOL]     return findConvertingDeserializer(ctxt, ann, deser); [EOL] }
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef); [EOL]     return findConvertingDeserializer(ctxt, ann, deser); [EOL] }
protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException { [EOL]     Converter<Object, Object> conv = findConverter(ctxt, a); [EOL]     if (conv == null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser); [EOL] }
protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt, Annotated a, JsonDeserializer<Object> deser) throws JsonMappingException { [EOL]     Converter<Object, Object> conv = findConverter(ctxt, a); [EOL]     if (conv == null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser); [EOL] }
protected Converter<Object, Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException { [EOL]     Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a); [EOL]     if (convDef == null) { [EOL]         return null; [EOL]     } [EOL]     return ctxt.converterInstance(a, convDef); [EOL] }
protected Converter<Object, Object> findConverter(DeserializationContext ctxt, Annotated a) throws JsonMappingException { [EOL]     Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a); [EOL]     if (convDef == null) { [EOL]         return null; [EOL]     } [EOL]     return ctxt.converterInstance(a, convDef); [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
public JsonLocation getCurrentLocation() { [EOL]     return _parser.getCurrentLocation(); [EOL] }
public JsonLocation getCurrentLocation() { [EOL]     return _parser.getCurrentLocation(); [EOL] }
protected MinimalClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) { [EOL]     super(baseType, typeFactory); [EOL]     String base = baseType.getRawClass().getName(); [EOL]     int ix = base.lastIndexOf('.'); [EOL]     if (ix < 0) { [EOL]         _basePackageName = ""; [EOL]         _basePackagePrefix = "."; [EOL]     } else { [EOL]         _basePackagePrefix = base.substring(0, ix + 1); [EOL]         _basePackageName = base.substring(0, ix); [EOL]     } [EOL] }
protected MinimalClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) { [EOL]     super(baseType, typeFactory); [EOL]     String base = baseType.getRawClass().getName(); [EOL]     int ix = base.lastIndexOf('.'); [EOL]     if (ix < 0) { [EOL]         _basePackageName = ""; [EOL]         _basePackagePrefix = "."; [EOL]     } else { [EOL]         _basePackagePrefix = base.substring(0, ix + 1); [EOL]         _basePackageName = base.substring(0, ix); [EOL]     } [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     String n = value.getClass().getName(); [EOL]     if (n.startsWith(_basePackagePrefix)) { [EOL]         return n.substring(_basePackagePrefix.length() - 1); [EOL]     } [EOL]     return n; [EOL] }
@Override [EOL] public String idFromValue(Object value) { [EOL]     String n = value.getClass().getName(); [EOL]     if (n.startsWith(_basePackagePrefix)) { [EOL]         return n.substring(_basePackagePrefix.length() - 1); [EOL]     } [EOL]     return n; [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.startsWith(".")) { [EOL]         StringBuilder sb = new StringBuilder(id.length() + _basePackageName.length()); [EOL]         if (_basePackageName.length() == 0) { [EOL]             sb.append(id.substring(1)); [EOL]         } else { [EOL]             sb.append(_basePackageName).append(id); [EOL]         } [EOL]         id = sb.toString(); [EOL]     } [EOL]     return super.typeFromId(id); [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.startsWith(".")) { [EOL]         StringBuilder sb = new StringBuilder(id.length() + _basePackageName.length()); [EOL]         if (_basePackageName.length() == 0) { [EOL]             sb.append(id.substring(1)); [EOL]         } else { [EOL]             sb.append(_basePackageName).append(id); [EOL]         } [EOL]         id = sb.toString(); [EOL]     } [EOL]     return super.typeFromId(id); [EOL] }
@Override [EOL] public JavaType typeFromId(String id) { [EOL]     if (id.startsWith(".")) { [EOL]         StringBuilder sb = new StringBuilder(id.length() + _basePackageName.length()); [EOL]         if (_basePackageName.length() == 0) { [EOL]             sb.append(id.substring(1)); [EOL]         } else { [EOL]             sb.append(_basePackageName).append(id); [EOL]         } [EOL]         id = sb.toString(); [EOL]     } [EOL]     return super.typeFromId(id); [EOL] }
public BinaryNode(byte[] data, int offset, int length) { [EOL]     if (offset == 0 && length == data.length) { [EOL]         _data = data; [EOL]     } else { [EOL]         _data = new byte[length]; [EOL]         System.arraycopy(data, offset, _data, 0, length); [EOL]     } [EOL] }
public BinaryNode(byte[] data, int offset, int length) { [EOL]     if (offset == 0 && length == data.length) { [EOL]         _data = data; [EOL]     } else { [EOL]         _data = new byte[length]; [EOL]         System.arraycopy(data, offset, _data, 0, length); [EOL]     } [EOL] }
public static BinaryNode valueOf(byte[] data) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (data.length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data); [EOL] }
public static BinaryNode valueOf(byte[] data) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (data.length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data); [EOL] }
public static BinaryNode valueOf(byte[] data) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (data.length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data); [EOL] }
public static BinaryNode valueOf(byte[] data, int offset, int length) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data, offset, length); [EOL] }
public static BinaryNode valueOf(byte[] data, int offset, int length) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data, offset, length); [EOL] }
public static BinaryNode valueOf(byte[] data, int offset, int length) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data, offset, length); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return Arrays.equals(((BinaryNode) o)._data, _data); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (_data == null) ? -1 : _data.length; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (_data == null) ? -1 : _data.length; [EOL] }
@Override [EOL] public String toString() { [EOL]     return Base64Variants.getDefaultVariant().encode(_data, true); [EOL] }
public ObjectBuffer() { [EOL] }
public Object[] resetAndStart() { [EOL]     _reset(); [EOL]     if (_freeBuffer == null) { [EOL]         return new Object[INITIAL_CHUNK_SIZE]; [EOL]     } [EOL]     return _freeBuffer; [EOL] }
public Object[] resetAndStart() { [EOL]     _reset(); [EOL]     if (_freeBuffer == null) { [EOL]         return new Object[INITIAL_CHUNK_SIZE]; [EOL]     } [EOL]     return _freeBuffer; [EOL] }
public Object[] appendCompletedChunk(Object[] fullChunk) { [EOL]     Node next = new Node(fullChunk); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     int len = fullChunk.length; [EOL]     _bufferedEntryCount += len; [EOL]     if (len < SMALL_CHUNK_SIZE) { [EOL]         len += len; [EOL]     } else { [EOL]         len += (len >> 2); [EOL]     } [EOL]     return new Object[len]; [EOL] }
public Object[] appendCompletedChunk(Object[] fullChunk) { [EOL]     Node next = new Node(fullChunk); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     int len = fullChunk.length; [EOL]     _bufferedEntryCount += len; [EOL]     if (len < SMALL_CHUNK_SIZE) { [EOL]         len += len; [EOL]     } else { [EOL]         len += (len >> 2); [EOL]     } [EOL]     return new Object[len]; [EOL] }
public Object[] appendCompletedChunk(Object[] fullChunk) { [EOL]     Node next = new Node(fullChunk); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     int len = fullChunk.length; [EOL]     _bufferedEntryCount += len; [EOL]     if (len < SMALL_CHUNK_SIZE) { [EOL]         len += len; [EOL]     } else { [EOL]         len += (len >> 2); [EOL]     } [EOL]     return new Object[len]; [EOL] }
public Object[] appendCompletedChunk(Object[] fullChunk) { [EOL]     Node next = new Node(fullChunk); [EOL]     if (_bufferHead == null) { [EOL]         _bufferHead = _bufferTail = next; [EOL]     } else { [EOL]         _bufferTail.linkNext(next); [EOL]         _bufferTail = next; [EOL]     } [EOL]     int len = fullChunk.length; [EOL]     _bufferedEntryCount += len; [EOL]     if (len < SMALL_CHUNK_SIZE) { [EOL]         len += len; [EOL]     } else { [EOL]         len += (len >> 2); [EOL]     } [EOL]     return new Object[len]; [EOL] }
public <T> T[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, Class<T> componentType) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     @SuppressWarnings("unchecked") [EOL]     T[] result = (T[]) Array.newInstance(componentType, totalSize); [EOL]     _copyTo(result, totalSize, lastChunk, lastChunkEntries); [EOL]     _reset(); [EOL]     return result; [EOL] }
public <T> T[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, Class<T> componentType) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     @SuppressWarnings("unchecked") [EOL]     T[] result = (T[]) Array.newInstance(componentType, totalSize); [EOL]     _copyTo(result, totalSize, lastChunk, lastChunkEntries); [EOL]     _reset(); [EOL]     return result; [EOL] }
protected void _reset() { [EOL]     if (_bufferTail != null) { [EOL]         _freeBuffer = _bufferTail.getData(); [EOL]     } [EOL]     _bufferHead = _bufferTail = null; [EOL]     _bufferedEntryCount = 0; [EOL] }
protected void _reset() { [EOL]     if (_bufferTail != null) { [EOL]         _freeBuffer = _bufferTail.getData(); [EOL]     } [EOL]     _bufferHead = _bufferTail = null; [EOL]     _bufferedEntryCount = 0; [EOL] }
protected final void _copyTo(Object resultArray, int totalSize, Object[] lastChunk, int lastChunkEntries) { [EOL]     int ptr = 0; [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         int len = curr.length; [EOL]         System.arraycopy(curr, 0, resultArray, ptr, len); [EOL]         ptr += len; [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL] }
protected final void _copyTo(Object resultArray, int totalSize, Object[] lastChunk, int lastChunkEntries) { [EOL]     int ptr = 0; [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         int len = curr.length; [EOL]         System.arraycopy(curr, 0, resultArray, ptr, len); [EOL]         ptr += len; [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL] }
protected final void _copyTo(Object resultArray, int totalSize, Object[] lastChunk, int lastChunkEntries) { [EOL]     int ptr = 0; [EOL]     for (Node n = _bufferHead; n != null; n = n.next()) { [EOL]         Object[] curr = n.getData(); [EOL]         int len = curr.length; [EOL]         System.arraycopy(curr, 0, resultArray, ptr, len); [EOL]         ptr += len; [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL] }
public Node(Object[] data) { [EOL]     _data = data; [EOL] }
public Node(Object[] data) { [EOL]     _data = data; [EOL] }
public Node(Object[] data) { [EOL]     _data = data; [EOL] }
public Object[] getData() { [EOL]     return _data; [EOL] }
public Object[] getData() { [EOL]     return _data; [EOL] }
public Node next() { [EOL]     return _next; [EOL] }
public void linkNext(Node next) { [EOL]     if (_next != null) { [EOL]         throw new IllegalStateException(); [EOL]     } [EOL]     _next = next; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
private EmptyIterator() { [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> Iterator<T> instance() { [EOL]     return (Iterator<T>) instance; [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     return false; [EOL] }
public AnnotatedMethod(Method method, AnnotationMap classAnn, AnnotationMap[] paramAnnotations) { [EOL]     super(classAnn, paramAnnotations); [EOL]     if (method == null) { [EOL]         throw new IllegalArgumentException("Can not construct AnnotatedMethod with null Method"); [EOL]     } [EOL]     _method = method; [EOL] }
public AnnotatedMethod(Method method, AnnotationMap classAnn, AnnotationMap[] paramAnnotations) { [EOL]     super(classAnn, paramAnnotations); [EOL]     if (method == null) { [EOL]         throw new IllegalArgumentException("Can not construct AnnotatedMethod with null Method"); [EOL]     } [EOL]     _method = method; [EOL] }
@Override [EOL] public AnnotatedMethod withAnnotations(AnnotationMap ann) { [EOL]     return new AnnotatedMethod(_method, ann, _paramAnnotations); [EOL] }
@Override [EOL] public AnnotatedMethod withAnnotations(AnnotationMap ann) { [EOL]     return new AnnotatedMethod(_method, ann, _paramAnnotations); [EOL] }
@Override [EOL] public Method getAnnotated() { [EOL]     return _method; [EOL] }
@Override [EOL] public String getName() { [EOL]     return _method.getName(); [EOL] }
@Override [EOL] public final Object call1(Object arg) throws Exception { [EOL]     return _method.invoke(null, arg); [EOL] }
@Override [EOL] public final Object call1(Object arg) throws Exception { [EOL]     return _method.invoke(null, arg); [EOL] }
@Override [EOL] public final Object call1(Object arg) throws Exception { [EOL]     return _method.invoke(null, arg); [EOL] }
@Override [EOL] public Class<?> getDeclaringClass() { [EOL]     return _method.getDeclaringClass(); [EOL] }
@Override [EOL] public Method getMember() { [EOL]     return _method; [EOL] }
@Override [EOL] public int getParameterCount() { [EOL]     return getRawParameterTypes().length; [EOL] }
@Override [EOL] public int getParameterCount() { [EOL]     return getRawParameterTypes().length; [EOL] }
public Class<?>[] getRawParameterTypes() { [EOL]     if (_paramClasses == null) { [EOL]         _paramClasses = _method.getParameterTypes(); [EOL]     } [EOL]     return _paramClasses; [EOL] }
public Class<?>[] getRawParameterTypes() { [EOL]     if (_paramClasses == null) { [EOL]         _paramClasses = _method.getParameterTypes(); [EOL]     } [EOL]     return _paramClasses; [EOL] }
@Override [EOL] public Class<?> getRawParameterType(int index) { [EOL]     Class<?>[] types = getRawParameterTypes(); [EOL]     return (index >= types.length) ? null : types[index]; [EOL] }
@Override [EOL] public Type getGenericParameterType(int index) { [EOL]     Type[] types = _method.getGenericParameterTypes(); [EOL]     return (index >= types.length) ? null : types[index]; [EOL] }
@Override [EOL] public Type getGenericParameterType(int index) { [EOL]     Type[] types = _method.getGenericParameterTypes(); [EOL]     return (index >= types.length) ? null : types[index]; [EOL] }
@Override [EOL] public Type getGenericParameterType(int index) { [EOL]     Type[] types = _method.getGenericParameterTypes(); [EOL]     return (index >= types.length) ? null : types[index]; [EOL] }
public Class<?> getRawReturnType() { [EOL]     return _method.getReturnType(); [EOL] }
public BooleanSerializer(boolean forPrimitive) { [EOL]     super(Boolean.class); [EOL]     _forPrimitive = forPrimitive; [EOL] }
public BooleanSerializer(boolean forPrimitive) { [EOL]     super(Boolean.class); [EOL]     _forPrimitive = forPrimitive; [EOL] }
@Override [EOL] public void serialize(Boolean value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeBoolean(value.booleanValue()); [EOL] }
@Override [EOL] public void serialize(Boolean value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeBoolean(value.booleanValue()); [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
@Override [EOL] public void setCodec(ObjectCodec c) { [EOL]     _objectCodec = c; [EOL] }
@Override [EOL] public void setCodec(ObjectCodec c) { [EOL]     _objectCodec = c; [EOL] }
@Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] }
@Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonParser skipChildren() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonParser skipChildren() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonParser skipChildren() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonStreamContext getParsingContext() { [EOL]     return _nodeCursor; [EOL] }
@Override [EOL] public JsonStreamContext getParsingContext() { [EOL]     return _nodeCursor; [EOL] }
@Override [EOL] public JsonLocation getTokenLocation() { [EOL]     return JsonLocation.NA; [EOL] }
@Override [EOL] public JsonLocation getCurrentLocation() { [EOL]     return JsonLocation.NA; [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     JsonNode n = currentNumericNode(); [EOL]     return (n == null) ? null : n.numberType(); [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     JsonNode n = currentNumericNode(); [EOL]     return (n == null) ? null : n.numberType(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return currentNumericNode().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return currentNumericNode().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return currentNumericNode().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return currentNumericNode().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return currentNumericNode().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return currentNumericNode().doubleValue(); [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (!_closed) { [EOL]         JsonNode n = currentNode(); [EOL]         if (n != null) { [EOL]             if (n.isPojo()) { [EOL]                 return ((POJONode) n).getPojo(); [EOL]             } [EOL]             if (n.isBinary()) { [EOL]                 return ((BinaryNode) n).binaryValue(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     if (_valueDeserializer != null) { [EOL]         return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer); [EOL]     } [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt)); [EOL]     } [EOL]     return result; [EOL] }
private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_collectionType.getRawClass()); [EOL]     } [EOL]     JsonDeserializer<String> valueDes = _valueDeserializer; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else { [EOL]         value = (valueDes == null) ? _parseString(jp, ctxt) : valueDes.deserialize(jp, ctxt); [EOL]     } [EOL]     result.add(value); [EOL]     return result; [EOL] }
private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_collectionType.getRawClass()); [EOL]     } [EOL]     JsonDeserializer<String> valueDes = _valueDeserializer; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else { [EOL]         value = (valueDes == null) ? _parseString(jp, ctxt) : valueDes.deserialize(jp, ctxt); [EOL]     } [EOL]     result.add(value); [EOL]     return result; [EOL] }
private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_collectionType.getRawClass()); [EOL]     } [EOL]     JsonDeserializer<String> valueDes = _valueDeserializer; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else { [EOL]         value = (valueDes == null) ? _parseString(jp, ctxt) : valueDes.deserialize(jp, ctxt); [EOL]     } [EOL]     result.add(value); [EOL]     return result; [EOL] }
public FailingSerializer(String msg) { [EOL]     super(Object.class); [EOL]     _msg = msg; [EOL] }
public FailingSerializer(String msg) { [EOL]     super(Object.class); [EOL]     _msg = msg; [EOL] }
public FailingSerializer(String msg) { [EOL]     super(Object.class); [EOL]     _msg = msg; [EOL] }
public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     super(bt, idRes, typePropertyName, typeIdVisible, null); [EOL] }
public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     super(bt, idRes, typePropertyName, typeIdVisible, null); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsWrapperTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsWrapperTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class " + baseTypeName()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL]     } [EOL]     final String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     jp.nextToken(); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_OBJECT, "expected closing END_OBJECT after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class " + baseTypeName()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL]     } [EOL]     final String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     jp.nextToken(); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_OBJECT, "expected closing END_OBJECT after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class " + baseTypeName()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL]     } [EOL]     final String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     jp.nextToken(); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_OBJECT, "expected closing END_OBJECT after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class " + baseTypeName()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL]     } [EOL]     final String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     jp.nextToken(); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_OBJECT, "expected closing END_OBJECT after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT, "need JSON Object to contain As.WRAPPER_OBJECT type information for class " + baseTypeName()); [EOL]     } [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL]     } [EOL]     final String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     jp.nextToken(); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_OBJECT, "expected closing END_OBJECT after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] }
public RootNameLookup() { [EOL] }
public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config) { [EOL]     ClassKey key = new ClassKey(rootType); [EOL]     if (_rootNames == null) { [EOL]         _rootNames = new LRUMap<ClassKey, SerializedString>(20, 200); [EOL]     } else { [EOL]         SerializedString name = _rootNames.get(key); [EOL]         if (name != null) { [EOL]             return name; [EOL]         } [EOL]     } [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(rootType); [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     PropertyName pname = intr.findRootName(ac); [EOL]     String nameStr; [EOL]     if (pname == null || !pname.hasSimpleName()) { [EOL]         nameStr = rootType.getSimpleName(); [EOL]     } else { [EOL]         nameStr = pname.getSimpleName(); [EOL]     } [EOL]     SerializedString name = new SerializedString(nameStr); [EOL]     _rootNames.put(key, name); [EOL]     return name; [EOL] }
public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config) { [EOL]     ClassKey key = new ClassKey(rootType); [EOL]     if (_rootNames == null) { [EOL]         _rootNames = new LRUMap<ClassKey, SerializedString>(20, 200); [EOL]     } else { [EOL]         SerializedString name = _rootNames.get(key); [EOL]         if (name != null) { [EOL]             return name; [EOL]         } [EOL]     } [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(rootType); [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     PropertyName pname = intr.findRootName(ac); [EOL]     String nameStr; [EOL]     if (pname == null || !pname.hasSimpleName()) { [EOL]         nameStr = rootType.getSimpleName(); [EOL]     } else { [EOL]         nameStr = pname.getSimpleName(); [EOL]     } [EOL]     SerializedString name = new SerializedString(nameStr); [EOL]     _rootNames.put(key, name); [EOL]     return name; [EOL] }
public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config) { [EOL]     ClassKey key = new ClassKey(rootType); [EOL]     if (_rootNames == null) { [EOL]         _rootNames = new LRUMap<ClassKey, SerializedString>(20, 200); [EOL]     } else { [EOL]         SerializedString name = _rootNames.get(key); [EOL]         if (name != null) { [EOL]             return name; [EOL]         } [EOL]     } [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(rootType); [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     PropertyName pname = intr.findRootName(ac); [EOL]     String nameStr; [EOL]     if (pname == null || !pname.hasSimpleName()) { [EOL]         nameStr = rootType.getSimpleName(); [EOL]     } else { [EOL]         nameStr = pname.getSimpleName(); [EOL]     } [EOL]     SerializedString name = new SerializedString(nameStr); [EOL]     _rootNames.put(key, name); [EOL]     return name; [EOL] }
public TypeBindings(TypeFactory typeFactory, JavaType type) { [EOL]     this(typeFactory, null, type.getRawClass(), type); [EOL] }
public TypeBindings(TypeFactory typeFactory, JavaType type) { [EOL]     this(typeFactory, null, type.getRawClass(), type); [EOL] }
public JavaType resolveType(Type type) { [EOL]     return _typeFactory._constructType(type, this); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
public JavaType findType(String name) { [EOL]     if (_bindings == null) { [EOL]         _resolve(); [EOL]     } [EOL]     JavaType t = _bindings.get(name); [EOL]     if (t != null) { [EOL]         return t; [EOL]     } [EOL]     if (_placeholders != null && _placeholders.contains(name)) { [EOL]         return UNBOUND; [EOL]     } [EOL]     if (_parentBindings != null) { [EOL]         return _parentBindings.findType(name); [EOL]     } [EOL]     if (_contextClass != null) { [EOL]         Class<?> enclosing = _contextClass.getEnclosingClass(); [EOL]         if (enclosing != null) { [EOL]             if (!Modifier.isStatic(_contextClass.getModifiers())) { [EOL]                 return UNBOUND; [EOL]             } [EOL]         } [EOL]     } [EOL]     String className; [EOL]     if (_contextClass != null) { [EOL]         className = _contextClass.getName(); [EOL]     } else if (_contextType != null) { [EOL]         className = _contextType.toString(); [EOL]     } else { [EOL]         className = "UNKNOWN"; [EOL]     } [EOL]     throw new IllegalArgumentException("Type variable '" + name + "' can not be resolved (with context of class " + className + ")"); [EOL] }
@Override [EOL] public Class<T> handledType() { [EOL]     return _handledType; [EOL] }
@Override [EOL] public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) { [EOL]     return withConfig(_factoryConfig.withAdditionalDeserializers(additional)); [EOL] }
@Override [EOL] public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]     return withConfig(_factoryConfig.withDeserializerModifier(modifier)); [EOL] }
@Override [EOL] public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]     return withConfig(_factoryConfig.withDeserializerModifier(modifier)); [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return JacksonDeserializers.findValueInstantiator(config, beanDesc); [EOL] }
private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return JacksonDeserializers.findValueInstantiator(config, beanDesc); [EOL] }
private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return JacksonDeserializers.findValueInstantiator(config, beanDesc); [EOL] }
protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     boolean fixAccess = ctxt.canOverrideAccessModifiers(); [EOL]     CreatorCollector creators = new CreatorCollector(beanDesc, fixAccess); [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(); [EOL]     vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker); [EOL]     _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL]     if (beanDesc.getType().isConcrete()) { [EOL]         _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL]     } [EOL]     return creators.constructValueInstantiator(config); [EOL] }
protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     boolean fixAccess = ctxt.canOverrideAccessModifiers(); [EOL]     CreatorCollector creators = new CreatorCollector(beanDesc, fixAccess); [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(); [EOL]     vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker); [EOL]     _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL]     if (beanDesc.getType().isConcrete()) { [EOL]         _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL]     } [EOL]     return creators.constructValueInstantiator(config); [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(annotated, config, ai, baseType); [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(annotated, config, ai, baseType); [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     return ctxt.deserializerInstance(ann, deserDef); [EOL] }
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     return ctxt.deserializerInstance(ann, deserDef); [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) { [EOL]     if (jsonValueMethod != null) { [EOL]         Method accessor = jsonValueMethod.getAnnotated(); [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(accessor); [EOL]         } [EOL]         return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor); [EOL]     } [EOL]     if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) { [EOL]         return EnumResolver.constructUnsafeUsingToString(enumClass); [EOL]     } [EOL]     return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector()); [EOL] }
protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) { [EOL]     if (jsonValueMethod != null) { [EOL]         Method accessor = jsonValueMethod.getAnnotated(); [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(accessor); [EOL]         } [EOL]         return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor); [EOL]     } [EOL]     if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) { [EOL]         return EnumResolver.constructUnsafeUsingToString(enumClass); [EOL]     } [EOL]     return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector()); [EOL] }
protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) { [EOL]     if (jsonValueMethod != null) { [EOL]         Method accessor = jsonValueMethod.getAnnotated(); [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(accessor); [EOL]         } [EOL]         return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor); [EOL]     } [EOL]     if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) { [EOL]         return EnumResolver.constructUnsafeUsingToString(enumClass); [EOL]     } [EOL]     return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector()); [EOL] }
protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) { [EOL]     if (jsonValueMethod != null) { [EOL]         Method accessor = jsonValueMethod.getAnnotated(); [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(accessor); [EOL]         } [EOL]         return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor); [EOL]     } [EOL]     if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) { [EOL]         return EnumResolver.constructUnsafeUsingToString(enumClass); [EOL]     } [EOL]     return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector()); [EOL] }
protected DefaultSerializerProvider() { [EOL]     super(); [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException { [EOL]     JsonSerializer<Object> ser; [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         Class<?> cls = value.getClass(); [EOL]         ser = findTypedValueSerializer(cls, true, null); [EOL]         String rootName = _config.getRootName(); [EOL]         if (rootName == null) { [EOL]             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]             if (wrap) { [EOL]                 jgen.writeStartObject(); [EOL]                 jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config)); [EOL]             } [EOL]         } else if (rootName.length() == 0) { [EOL]             wrap = false; [EOL]         } else { [EOL]             wrap = true; [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(rootName); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
@Override [EOL] public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType) { [EOL]     if (_seenObjectIds == null) { [EOL]         _seenObjectIds = new IdentityHashMap<Object, WritableObjectId>(); [EOL]     } else { [EOL]         WritableObjectId oid = _seenObjectIds.get(forPojo); [EOL]         if (oid != null) { [EOL]             return oid; [EOL]         } [EOL]     } [EOL]     ObjectIdGenerator<?> generator = null; [EOL]     if (_objectIdGenerators == null) { [EOL]         _objectIdGenerators = new ArrayList<ObjectIdGenerator<?>>(8); [EOL]     } else { [EOL]         for (int i = 0, len = _objectIdGenerators.size(); i < len; ++i) { [EOL]             ObjectIdGenerator<?> gen = _objectIdGenerators.get(i); [EOL]             if (gen.canUseFor(generatorType)) { [EOL]                 generator = gen; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (generator == null) { [EOL]         generator = generatorType.newForSerialization(this); [EOL]         _objectIdGenerators.add(generator); [EOL]     } [EOL]     WritableObjectId oid = new WritableObjectId(generator); [EOL]     _seenObjectIds.put(forPojo, oid); [EOL]     return oid; [EOL] }
@Override [EOL] public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType) { [EOL]     if (_seenObjectIds == null) { [EOL]         _seenObjectIds = new IdentityHashMap<Object, WritableObjectId>(); [EOL]     } else { [EOL]         WritableObjectId oid = _seenObjectIds.get(forPojo); [EOL]         if (oid != null) { [EOL]             return oid; [EOL]         } [EOL]     } [EOL]     ObjectIdGenerator<?> generator = null; [EOL]     if (_objectIdGenerators == null) { [EOL]         _objectIdGenerators = new ArrayList<ObjectIdGenerator<?>>(8); [EOL]     } else { [EOL]         for (int i = 0, len = _objectIdGenerators.size(); i < len; ++i) { [EOL]             ObjectIdGenerator<?> gen = _objectIdGenerators.get(i); [EOL]             if (gen.canUseFor(generatorType)) { [EOL]                 generator = gen; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (generator == null) { [EOL]         generator = generatorType.newForSerialization(this); [EOL]         _objectIdGenerators.add(generator); [EOL]     } [EOL]     WritableObjectId oid = new WritableObjectId(generator); [EOL]     _seenObjectIds.put(forPojo, oid); [EOL]     return oid; [EOL] }
@Override [EOL] public WritableObjectId findObjectId(Object forPojo, ObjectIdGenerator<?> generatorType) { [EOL]     if (_seenObjectIds == null) { [EOL]         _seenObjectIds = new IdentityHashMap<Object, WritableObjectId>(); [EOL]     } else { [EOL]         WritableObjectId oid = _seenObjectIds.get(forPojo); [EOL]         if (oid != null) { [EOL]             return oid; [EOL]         } [EOL]     } [EOL]     ObjectIdGenerator<?> generator = null; [EOL]     if (_objectIdGenerators == null) { [EOL]         _objectIdGenerators = new ArrayList<ObjectIdGenerator<?>>(8); [EOL]     } else { [EOL]         for (int i = 0, len = _objectIdGenerators.size(); i < len; ++i) { [EOL]             ObjectIdGenerator<?> gen = _objectIdGenerators.get(i); [EOL]             if (gen.canUseFor(generatorType)) { [EOL]                 generator = gen; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (generator == null) { [EOL]         generator = generatorType.newForSerialization(this); [EOL]         _objectIdGenerators.add(generator); [EOL]     } [EOL]     WritableObjectId oid = new WritableObjectId(generator); [EOL]     _seenObjectIds.put(forPojo, oid); [EOL]     return oid; [EOL] }
public Impl() { [EOL]     super(); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]         } else { [EOL]             handleUnknownVanilla(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]         } else { [EOL]             handleUnknownVanilla(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]         } else { [EOL]             handleUnknownVanilla(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
private final Object vanillaDeserialize(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]         } else { [EOL]             handleUnknownVanilla(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
@SuppressWarnings("resource") [EOL] protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 t = jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 while (t == JsonToken.FIELD_NAME) { [EOL]                     jp.nextToken(); [EOL]                     tokens.copyCurrentStructure(jp); [EOL]                     t = jp.nextToken(); [EOL]                 } [EOL]                 tokens.writeEndObject(); [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     tokens.close(); [EOL]                     throw ctxt.mappingException("Can not create polymorphic instances with unwrapped values"); [EOL]                 } [EOL]                 return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]         } [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL]     return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL] }
public SerializerCache() { [EOL] }
public JsonSerializer<Object> typedValueSerializer(JavaType type) { [EOL]     synchronized (this) { [EOL]         return _sharedMap.get(new TypeKey(type, true)); [EOL]     } [EOL] }
public JsonSerializer<Object> typedValueSerializer(JavaType type) { [EOL]     synchronized (this) { [EOL]         return _sharedMap.get(new TypeKey(type, true)); [EOL]     } [EOL] }
public void addTypedSerializer(JavaType type, JsonSerializer<Object> ser) { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(type, true), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]     } [EOL] }
public void addTypedSerializer(JavaType type, JsonSerializer<Object> ser) { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(type, true), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]     } [EOL] }
public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser, SerializerProvider provider) throws JsonMappingException { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(type, false), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]         if (ser instanceof ResolvableSerializer) { [EOL]             ((ResolvableSerializer) ser).resolve(provider); [EOL]         } [EOL]     } [EOL] }
public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser, SerializerProvider provider) throws JsonMappingException { [EOL]     synchronized (this) { [EOL]         if (_sharedMap.put(new TypeKey(type, false), ser) == null) { [EOL]             _readOnlyMap = null; [EOL]         } [EOL]         if (ser instanceof ResolvableSerializer) { [EOL]             ((ResolvableSerializer) ser).resolve(provider); [EOL]         } [EOL]     } [EOL] }
private final static int hash(JavaType type, boolean typed) { [EOL]     int hash = type.hashCode() - 1; [EOL]     if (typed) { [EOL]         --hash; [EOL]     } [EOL]     return hash; [EOL] }
private final static int hash(JavaType type, boolean typed) { [EOL]     int hash = type.hashCode() - 1; [EOL]     if (typed) { [EOL]         --hash; [EOL]     } [EOL]     return hash; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final boolean equals(Object o) { [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     TypeKey other = (TypeKey) o; [EOL]     if (other._isTyped == _isTyped) { [EOL]         if (_class != null) { [EOL]             return other._class == _class; [EOL]         } [EOL]         return _type.equals(other._type); [EOL]     } [EOL]     return false; [EOL] }
public MemberKey(Method m) { [EOL]     this(m.getName(), m.getParameterTypes()); [EOL] }
public MemberKey(Method m) { [EOL]     this(m.getName(), m.getParameterTypes()); [EOL] }
public MemberKey(String name, Class<?>[] argTypes) { [EOL]     _name = name; [EOL]     _argTypes = (argTypes == null) ? NO_CLASSES : argTypes; [EOL] }
public MemberKey(String name, Class<?>[] argTypes) { [EOL]     _name = name; [EOL]     _argTypes = (argTypes == null) ? NO_CLASSES : argTypes; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _name.hashCode() + _argTypes.length; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _name.hashCode() + _argTypes.length; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _name.hashCode() + _argTypes.length; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private BeanPropertyMap(Bucket[] buckets, int size, int index) { [EOL]     _buckets = buckets; [EOL]     _size = size; [EOL]     _hashMask = buckets.length - 1; [EOL]     _nextBucketIndex = index; [EOL] }
private BeanPropertyMap(Bucket[] buckets, int size, int index) { [EOL]     _buckets = buckets; [EOL]     _size = size; [EOL]     _hashMask = buckets.length - 1; [EOL]     _nextBucketIndex = index; [EOL] }
public BeanPropertyMap withProperty(SettableBeanProperty newProperty) { [EOL]     final int bcount = _buckets.length; [EOL]     Bucket[] newBuckets = new Bucket[bcount]; [EOL]     System.arraycopy(_buckets, 0, newBuckets, 0, bcount); [EOL]     final String propName = newProperty.getName(); [EOL]     SettableBeanProperty oldProp = find(newProperty.getName()); [EOL]     if (oldProp == null) { [EOL]         int index = propName.hashCode() & _hashMask; [EOL]         newBuckets[index] = new Bucket(newBuckets[index], propName, newProperty, _nextBucketIndex++); [EOL]         return new BeanPropertyMap(newBuckets, _size + 1, _nextBucketIndex); [EOL]     } [EOL]     BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex); [EOL]     newMap.replace(newProperty); [EOL]     return newMap; [EOL] }
public BeanPropertyMap withProperty(SettableBeanProperty newProperty) { [EOL]     final int bcount = _buckets.length; [EOL]     Bucket[] newBuckets = new Bucket[bcount]; [EOL]     System.arraycopy(_buckets, 0, newBuckets, 0, bcount); [EOL]     final String propName = newProperty.getName(); [EOL]     SettableBeanProperty oldProp = find(newProperty.getName()); [EOL]     if (oldProp == null) { [EOL]         int index = propName.hashCode() & _hashMask; [EOL]         newBuckets[index] = new Bucket(newBuckets[index], propName, newProperty, _nextBucketIndex++); [EOL]         return new BeanPropertyMap(newBuckets, _size + 1, _nextBucketIndex); [EOL]     } [EOL]     BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex); [EOL]     newMap.replace(newProperty); [EOL]     return newMap; [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         if (jp.getText().length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new int[] { _parseIntPrimitive(jp, ctxt) }; [EOL] }
private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         if (jp.getText().length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new int[] { _parseIntPrimitive(jp, ctxt) }; [EOL] }
private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         if (jp.getText().length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new int[] { _parseIntPrimitive(jp, ctxt) }; [EOL] }
private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         if (jp.getText().length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_valueClass); [EOL]     } [EOL]     return new int[] { _parseIntPrimitive(jp, ctxt) }; [EOL] }
public FloatDeser() { [EOL]     super(float[].class); [EOL] }
@Override [EOL] public float[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder(); [EOL]     float[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         float value = _parseFloatPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public float[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder(); [EOL]     float[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         float value = _parseFloatPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public float[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder(); [EOL]     float[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         float value = _parseFloatPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public float[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder(); [EOL]     float[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         float value = _parseFloatPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
public boolean readIdProperty(String propName) throws IOException { [EOL]     if ((_objectIdReader != null) && propName.equals(_objectIdReader.propertyName)) { [EOL]         _idValue = _objectIdReader.deserializer.deserialize(_parser, _context); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean readIdProperty(String propName) throws IOException { [EOL]     if ((_objectIdReader != null) && propName.equals(_objectIdReader.propertyName)) { [EOL]         _idValue = _objectIdReader.deserializer.deserialize(_parser, _context); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean readIdProperty(String propName) throws IOException { [EOL]     if ((_objectIdReader != null) && propName.equals(_objectIdReader.propertyName)) { [EOL]         _idValue = _objectIdReader.deserializer.deserialize(_parser, _context); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public void bufferProperty(SettableBeanProperty prop, Object value) { [EOL]     _buffered = new PropertyValue.Regular(_buffered, value, prop); [EOL] }
public void bufferProperty(SettableBeanProperty prop, Object value) { [EOL]     _buffered = new PropertyValue.Regular(_buffered, value, prop); [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public final TextNode textNode(String text) { [EOL]     return _nodeFactory.textNode(text); [EOL] }
public final TextNode textNode(String text) { [EOL]     return _nodeFactory.textNode(text); [EOL] }
public final TextNode textNode(String text) { [EOL]     return _nodeFactory.textNode(text); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public CollectionDeserializer createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<Object> delegateDeser = null; [EOL]     if ((_valueInstantiator != null) && _valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _collectionType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         delegateDeser = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = _valueDeserializer; [EOL]     valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser); [EOL]     if (valueDeser == null) { [EOL]         valueDeser = ctxt.findContextualValueDeserializer(_collectionType.getContentType(), property); [EOL]     } else { [EOL]         if (valueDeser instanceof ContextualDeserializer) { [EOL]             valueDeser = ((ContextualDeserializer) valueDeser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser = _valueTypeDeserializer; [EOL]     if (valueTypeDeser != null) { [EOL]         valueTypeDeser = valueTypeDeser.forProperty(property); [EOL]     } [EOL]     return withResolved(delegateDeser, valueDeser, valueTypeDeser); [EOL] }
@Override [EOL] public JsonDeserializer<Object> getContentDeserializer() { [EOL]     return _valueDeserializer; [EOL] }
@Override [EOL] public JsonDeserializer<Object> getContentDeserializer() { [EOL]     return _valueDeserializer; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, result); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.add(value); [EOL]     } [EOL]     return result; [EOL] }
protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_collectionType.getRawClass()); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (typeDeser == null) { [EOL]         value = valueDes.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]     } [EOL]     result.add(value); [EOL]     return result; [EOL] }
protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_collectionType.getRawClass()); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (typeDeser == null) { [EOL]         value = valueDes.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]     } [EOL]     result.add(value); [EOL]     return result; [EOL] }
protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_collectionType.getRawClass()); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (typeDeser == null) { [EOL]         value = valueDes.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]     } [EOL]     result.add(value); [EOL]     return result; [EOL] }
protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<Object> result) throws IOException, JsonProcessingException { [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         throw ctxt.mappingException(_collectionType.getRawClass()); [EOL]     } [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (typeDeser == null) { [EOL]         value = valueDes.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]     } [EOL]     result.add(value); [EOL]     return result; [EOL] }
@Override [EOL] public boolean enabledByDefault() { [EOL]     return _defaultState; [EOL] }
@Override [EOL] public boolean enabledByDefault() { [EOL]     return _defaultState; [EOL] }
@Override [EOL] public int getMask() { [EOL]     return (1 << ordinal()); [EOL] }
@Override [EOL] public final void serializeWithType(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     value.serializeWithType(jgen, provider, typeSer); [EOL] }
@Override [EOL] public final void serializeWithType(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     value.serializeWithType(jgen, provider, typeSer); [EOL] }
public IteratorSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property) { [EOL]     super(Iterator.class, elemType, staticTyping, vts, property, null); [EOL] }
public IteratorSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property) { [EOL]     super(Iterator.class, elemType, staticTyping, vts, property, null); [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value.hasNext()) { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         JsonSerializer<Object> prevSerializer = null; [EOL]         Class<?> prevClass = null; [EOL]         do { [EOL]             Object elem = value.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> currSerializer; [EOL]                 if (cc == prevClass) { [EOL]                     currSerializer = prevSerializer; [EOL]                 } else { [EOL]                     currSerializer = provider.findValueSerializer(cc, _property); [EOL]                     prevSerializer = currSerializer; [EOL]                     prevClass = cc; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     currSerializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     currSerializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]         } while (value.hasNext()); [EOL]     } [EOL] }
public JsonSerializer<Object> typedValueSerializer(JavaType type) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(type, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(type); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> typedValueSerializer(JavaType type) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(type, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(type); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeSetterlessGetters(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         if (!property.couldDeserialize() && !property.isExplicitlyIncluded()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
public final boolean isEnabled(MapperFeature feature) { [EOL]     return getConfig().isEnabled(feature); [EOL] }
public final boolean isEnabled(MapperFeature feature) { [EOL]     return getConfig().isEnabled(feature); [EOL] }
public final boolean canOverrideAccessModifiers() { [EOL]     return getConfig().canOverrideAccessModifiers(); [EOL] }
public final boolean canOverrideAccessModifiers() { [EOL]     return getConfig().canOverrideAccessModifiers(); [EOL] }
public EnumMapDeserializer(JavaType mapType, JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser) { [EOL]     super(EnumMap.class); [EOL]     _mapType = mapType; [EOL]     _enumClass = mapType.getKeyType().getRawClass(); [EOL]     _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer; [EOL]     _valueDeserializer = (JsonDeserializer<Object>) valueDeser; [EOL]     _valueTypeDeserializer = valueTypeDeser; [EOL] }
public EnumMapDeserializer(JavaType mapType, JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser) { [EOL]     super(EnumMap.class); [EOL]     _mapType = mapType; [EOL]     _enumClass = mapType.getKeyType().getRawClass(); [EOL]     _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer; [EOL]     _valueDeserializer = (JsonDeserializer<Object>) valueDeser; [EOL]     _valueTypeDeserializer = valueTypeDeser; [EOL] }
public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser) { [EOL]     if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new EnumMapDeserializer(_mapType, keyDeserializer, valueDeserializer, _valueTypeDeserializer); [EOL] }
public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser) { [EOL]     if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new EnumMapDeserializer(_mapType, keyDeserializer, valueDeserializer, _valueTypeDeserializer); [EOL] }
public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser) { [EOL]     if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new EnumMapDeserializer(_mapType, keyDeserializer, valueDeserializer, _valueTypeDeserializer); [EOL] }
public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser) { [EOL]     if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new EnumMapDeserializer(_mapType, keyDeserializer, valueDeserializer, _valueTypeDeserializer); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property); [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     return withResolved(kd, vd, vtd); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property); [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     return withResolved(kd, vd, vtd); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property); [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     return withResolved(kd, vd, vtd); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property); [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     return withResolved(kd, vd, vtd); [EOL] }
@Override [EOL] public boolean isCachable() { [EOL]     return true; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() != JsonToken.START_OBJECT) { [EOL]         throw ctxt.mappingException(EnumMap.class); [EOL]     } [EOL]     EnumMap result = constructMap(); [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((jp.nextToken()) != JsonToken.END_OBJECT) { [EOL]         Enum<?> key = _keyDeserializer.deserialize(jp, ctxt); [EOL]         if (key == null) { [EOL]             if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]                 String value = null; [EOL]                 try { [EOL]                     if (jp.hasCurrentToken()) { [EOL]                         value = jp.getText(); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]                 throw ctxt.weirdStringException(value, _enumClass, "value not one of declared Enum instance names"); [EOL]             } [EOL]             jp.nextToken(); [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         JsonToken t = jp.nextToken(); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL]     return result; [EOL] }
private EnumMap<?, ?> constructMap() { [EOL]     return new EnumMap(_enumClass); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
@Override [EOL] public final T getNullValue() { [EOL]     return _nullValue; [EOL] }
@Override [EOL] public final T getNullValue() { [EOL]     return _nullValue; [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
LocaleKD() { [EOL]     super(Locale.class); [EOL]     _localeDeserializer = new JdkDeserializers.LocaleDeserializer(); [EOL] }
@Override [EOL] protected Locale _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     try { [EOL]         return _localeDeserializer._deserialize(key, ctxt); [EOL]     } catch (IOException e) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "unable to parse key as locale"); [EOL]     } [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
public Object(JsonNode n, NodeCursor p) { [EOL]     super(JsonStreamContext.TYPE_OBJECT, p); [EOL]     _contents = ((ObjectNode) n).fields(); [EOL]     _needEntry = true; [EOL] }
public Object(JsonNode n, NodeCursor p) { [EOL]     super(JsonStreamContext.TYPE_OBJECT, p); [EOL]     _contents = ((ObjectNode) n).fields(); [EOL]     _needEntry = true; [EOL] }
@Override [EOL] public JsonToken nextToken() { [EOL]     if (_needEntry) { [EOL]         if (!_contents.hasNext()) { [EOL]             _currentName = null; [EOL]             _current = null; [EOL]             return null; [EOL]         } [EOL]         _needEntry = false; [EOL]         _current = _contents.next(); [EOL]         _currentName = (_current == null) ? null : _current.getKey(); [EOL]         return JsonToken.FIELD_NAME; [EOL]     } [EOL]     _needEntry = true; [EOL]     return _current.getValue().asToken(); [EOL] }
@Override [EOL] public JsonToken nextToken() { [EOL]     if (_needEntry) { [EOL]         if (!_contents.hasNext()) { [EOL]             _currentName = null; [EOL]             _current = null; [EOL]             return null; [EOL]         } [EOL]         _needEntry = false; [EOL]         _current = _contents.next(); [EOL]         _currentName = (_current == null) ? null : _current.getKey(); [EOL]         return JsonToken.FIELD_NAME; [EOL]     } [EOL]     _needEntry = true; [EOL]     return _current.getValue().asToken(); [EOL] }
@Override [EOL] public JsonToken nextToken() { [EOL]     if (_needEntry) { [EOL]         if (!_contents.hasNext()) { [EOL]             _currentName = null; [EOL]             _current = null; [EOL]             return null; [EOL]         } [EOL]         _needEntry = false; [EOL]         _current = _contents.next(); [EOL]         _currentName = (_current == null) ? null : _current.getKey(); [EOL]         return JsonToken.FIELD_NAME; [EOL]     } [EOL]     _needEntry = true; [EOL]     return _current.getValue().asToken(); [EOL] }
@Override [EOL] public JsonToken endToken() { [EOL]     return JsonToken.END_OBJECT; [EOL] }
@Override [EOL] public JsonNode currentNode() { [EOL]     return (_current == null) ? null : _current.getValue(); [EOL] }
@Override [EOL] public JsonNode currentNode() { [EOL]     return (_current == null) ? null : _current.getValue(); [EOL] }
@Override [EOL] public boolean currentHasChildren() { [EOL]     return ((ContainerNode<?>) currentNode()).size() > 0; [EOL] }
@Override [EOL] public boolean currentHasChildren() { [EOL]     return ((ContainerNode<?>) currentNode()).size() > 0; [EOL] }
public TypeAndSerializer(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     this.type = type; [EOL]     this.serializer = serializer; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     if (type == _type) { [EOL]         return _serializer; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     if (type == _type) { [EOL]         return _serializer; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     return new Double(_type, _serializer, type, serializer); [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     return new Double(_type, _serializer, type, serializer); [EOL] }
public Double(Class<?> type1, JsonSerializer<Object> serializer1, Class<?> type2, JsonSerializer<Object> serializer2) { [EOL]     _type1 = type1; [EOL]     _serializer1 = serializer1; [EOL]     _type2 = type2; [EOL]     _serializer2 = serializer2; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     if (type == _type1) { [EOL]         return _serializer1; [EOL]     } [EOL]     if (type == _type2) { [EOL]         return _serializer2; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     if (type == _type1) { [EOL]         return _serializer1; [EOL]     } [EOL]     if (type == _type2) { [EOL]         return _serializer2; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     if (type == _type1) { [EOL]         return _serializer1; [EOL]     } [EOL]     if (type == _type2) { [EOL]         return _serializer2; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     TypeAndSerializer[] ts = new TypeAndSerializer[2]; [EOL]     ts[0] = new TypeAndSerializer(_type1, _serializer1); [EOL]     ts[1] = new TypeAndSerializer(_type2, _serializer2); [EOL]     return new Multi(ts); [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     TypeAndSerializer[] ts = new TypeAndSerializer[2]; [EOL]     ts[0] = new TypeAndSerializer(_type1, _serializer1); [EOL]     ts[1] = new TypeAndSerializer(_type2, _serializer2); [EOL]     return new Multi(ts); [EOL] }
public Multi(TypeAndSerializer[] entries) { [EOL]     _entries = entries; [EOL] }
public Multi(TypeAndSerializer[] entries) { [EOL]     _entries = entries; [EOL] }
public Multi(TypeAndSerializer[] entries) { [EOL]     _entries = entries; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     for (int i = 0, len = _entries.length; i < len; ++i) { [EOL]         TypeAndSerializer entry = _entries[i]; [EOL]         if (entry.type == type) { [EOL]             return entry.serializer; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     for (int i = 0, len = _entries.length; i < len; ++i) { [EOL]         TypeAndSerializer entry = _entries[i]; [EOL]         if (entry.type == type) { [EOL]             return entry.serializer; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     int len = _entries.length; [EOL]     if (len == MAX_ENTRIES) { [EOL]         return this; [EOL]     } [EOL]     TypeAndSerializer[] entries = new TypeAndSerializer[len + 1]; [EOL]     System.arraycopy(_entries, 0, entries, 0, len); [EOL]     entries[len] = new TypeAndSerializer(type, serializer); [EOL]     return new Multi(entries); [EOL] }
@Override [EOL] public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) { [EOL]     int len = _entries.length; [EOL]     if (len == MAX_ENTRIES) { [EOL]         return this; [EOL]     } [EOL]     TypeAndSerializer[] entries = new TypeAndSerializer[len + 1]; [EOL]     System.arraycopy(_entries, 0, entries, 0, len); [EOL]     entries[len] = new TypeAndSerializer(type, serializer); [EOL]     return new Multi(entries); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         throw ctxt.mappingException(EnumSet.class); [EOL]     } [EOL]     EnumSet result = constructSet(); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             throw ctxt.mappingException(_enumClass); [EOL]         } [EOL]         Enum<?> value = _enumDeserializer.deserialize(jp, ctxt); [EOL]         if (value != null) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         throw ctxt.mappingException(EnumSet.class); [EOL]     } [EOL]     EnumSet result = constructSet(); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             throw ctxt.mappingException(_enumClass); [EOL]         } [EOL]         Enum<?> value = _enumDeserializer.deserialize(jp, ctxt); [EOL]         if (value != null) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         throw ctxt.mappingException(EnumSet.class); [EOL]     } [EOL]     EnumSet result = constructSet(); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             throw ctxt.mappingException(_enumClass); [EOL]         } [EOL]         Enum<?> value = _enumDeserializer.deserialize(jp, ctxt); [EOL]         if (value != null) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         throw ctxt.mappingException(EnumSet.class); [EOL]     } [EOL]     EnumSet result = constructSet(); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             throw ctxt.mappingException(_enumClass); [EOL]         } [EOL]         Enum<?> value = _enumDeserializer.deserialize(jp, ctxt); [EOL]         if (value != null) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeContentsUsing(Collection<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         TypeSerializer typeSer = _valueTypeSerializer; [EOL]         int i = 0; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             try { [EOL]                 if (elem == null) { [EOL]                     provider.defaultSerializeNull(jgen); [EOL]                 } else { [EOL]                     if (typeSer == null) { [EOL]                         ser.serialize(elem, jgen, provider); [EOL]                     } else { [EOL]                         ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]                     } [EOL]                 } [EOL]                 ++i; [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(provider, e, value, i); [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
public void serializeContentsUsing(Collection<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         TypeSerializer typeSer = _valueTypeSerializer; [EOL]         int i = 0; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             try { [EOL]                 if (elem == null) { [EOL]                     provider.defaultSerializeNull(jgen); [EOL]                 } else { [EOL]                     if (typeSer == null) { [EOL]                         ser.serialize(elem, jgen, provider); [EOL]                     } else { [EOL]                         ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]                     } [EOL]                 } [EOL]                 ++i; [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(provider, e, value, i); [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
public void serializeContentsUsing(Collection<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         TypeSerializer typeSer = _valueTypeSerializer; [EOL]         int i = 0; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             try { [EOL]                 if (elem == null) { [EOL]                     provider.defaultSerializeNull(jgen); [EOL]                 } else { [EOL]                     if (typeSer == null) { [EOL]                         ser.serialize(elem, jgen, provider); [EOL]                     } else { [EOL]                         ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]                     } [EOL]                 } [EOL]                 ++i; [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(provider, e, value, i); [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
public void serializeContentsUsing(Collection<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         TypeSerializer typeSer = _valueTypeSerializer; [EOL]         int i = 0; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             try { [EOL]                 if (elem == null) { [EOL]                     provider.defaultSerializeNull(jgen); [EOL]                 } else { [EOL]                     if (typeSer == null) { [EOL]                         ser.serialize(elem, jgen, provider); [EOL]                     } else { [EOL]                         ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]                     } [EOL]                 } [EOL]                 ++i; [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(provider, e, value, i); [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
public void serializeContentsUsing(Collection<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (it.hasNext()) { [EOL]         TypeSerializer typeSer = _valueTypeSerializer; [EOL]         int i = 0; [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             try { [EOL]                 if (elem == null) { [EOL]                     provider.defaultSerializeNull(jgen); [EOL]                 } else { [EOL]                     if (typeSer == null) { [EOL]                         ser.serialize(elem, jgen, provider); [EOL]                     } else { [EOL]                         ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]                     } [EOL]                 } [EOL]                 ++i; [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(provider, e, value, i); [EOL]             } [EOL]         } while (it.hasNext()); [EOL]     } [EOL] }
public void reset(Class<?> clz) { [EOL]     _class = clz; [EOL]     _className = clz.getName(); [EOL]     _hashCode = _className.hashCode(); [EOL] }
public void reset(Class<?> clz) { [EOL]     _class = clz; [EOL]     _className = clz.getName(); [EOL]     _hashCode = _className.hashCode(); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _serializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _serializer) { [EOL]         return this; [EOL]     } [EOL]     return new IndexedStringListSerializer(ser); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
private final void serializeUsingCustom(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         final JsonSerializer<String> ser = _serializer; [EOL]         for (i = 0; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 ser.serialize(str, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
private final void serializeUsingCustom(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         final JsonSerializer<String> ser = _serializer; [EOL]         for (i = 0; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 ser.serialize(str, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
private final void serializeUsingCustom(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         final JsonSerializer<String> ser = _serializer; [EOL]         for (i = 0; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 ser.serialize(str, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public static Collection<Map.Entry<Class<?>, Object>> all() { [EOL]     HashMap<Class<?>, Object> sers = new HashMap<Class<?>, Object>(); [EOL]     final ToStringSerializer sls = ToStringSerializer.instance; [EOL]     sers.put(java.net.URL.class, sls); [EOL]     sers.put(java.net.URI.class, sls); [EOL]     sers.put(Currency.class, sls); [EOL]     sers.put(UUID.class, sls); [EOL]     sers.put(java.util.regex.Pattern.class, sls); [EOL]     sers.put(Locale.class, sls); [EOL]     sers.put(Locale.class, sls); [EOL]     sers.put(AtomicReference.class, AtomicReferenceSerializer.class); [EOL]     sers.put(AtomicBoolean.class, AtomicBooleanSerializer.class); [EOL]     sers.put(AtomicInteger.class, AtomicIntegerSerializer.class); [EOL]     sers.put(AtomicLong.class, AtomicLongSerializer.class); [EOL]     sers.put(File.class, FileSerializer.class); [EOL]     sers.put(Class.class, ClassSerializer.class); [EOL]     sers.put(Void.TYPE, NullSerializer.class); [EOL]     return sers.entrySet(); [EOL] }
public ObjectNode(JsonNodeFactory nc) { [EOL]     super(nc); [EOL] }
public ObjectNode(JsonNodeFactory nc) { [EOL]     super(nc); [EOL] }
@Override [EOL] public JsonNode get(String fieldName) { [EOL]     return _children.get(fieldName); [EOL] }
@Override [EOL] public JsonNode get(String fieldName) { [EOL]     return _children.get(fieldName); [EOL] }
@Override [EOL] public ObjectNode with(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ObjectNode) { [EOL]             return (ObjectNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ObjectNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ObjectNode result = objectNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public ObjectNode with(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ObjectNode) { [EOL]             return (ObjectNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ObjectNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ObjectNode result = objectNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public ObjectNode with(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ObjectNode) { [EOL]             return (ObjectNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ObjectNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ObjectNode result = objectNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValues(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValues(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValues(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValues(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<String>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue().asText()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValuesAsText(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<String>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue().asText()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValuesAsText(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<String>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue().asText()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValuesAsText(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<String>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue().asText()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValuesAsText(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(this); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findParents(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(this); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findParents(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeStartObject(); [EOL]     for (Map.Entry<String, JsonNode> en : _children.entrySet()) { [EOL]         jg.writeFieldName(en.getKey()); [EOL]         ((BaseJsonNode) en.getValue()).serialize(jg, provider); [EOL]     } [EOL]     jg.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeStartObject(); [EOL]     for (Map.Entry<String, JsonNode> en : _children.entrySet()) { [EOL]         jg.writeFieldName(en.getKey()); [EOL]         ((BaseJsonNode) en.getValue()).serialize(jg, provider); [EOL]     } [EOL]     jg.writeEndObject(); [EOL] }
@Override [EOL] public void serializeWithType(JsonGenerator jg, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonProcessingException { [EOL]     typeSer.writeTypePrefixForObject(this, jg); [EOL]     for (Map.Entry<String, JsonNode> en : _children.entrySet()) { [EOL]         jg.writeFieldName(en.getKey()); [EOL]         ((BaseJsonNode) en.getValue()).serialize(jg, provider); [EOL]     } [EOL]     typeSer.writeTypeSuffixForObject(this, jg); [EOL] }
@Override [EOL] public void serializeWithType(JsonGenerator jg, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonProcessingException { [EOL]     typeSer.writeTypePrefixForObject(this, jg); [EOL]     for (Map.Entry<String, JsonNode> en : _children.entrySet()) { [EOL]         jg.writeFieldName(en.getKey()); [EOL]         ((BaseJsonNode) en.getValue()).serialize(jg, provider); [EOL]     } [EOL]     typeSer.writeTypeSuffixForObject(this, jg); [EOL] }
public JsonNode set(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _children.put(fieldName, value); [EOL]     return this; [EOL] }
public JsonNode set(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     _children.put(fieldName, value); [EOL]     return this; [EOL] }
public ObjectNode retain(Collection<String> fieldNames) { [EOL]     _children.keySet().retainAll(fieldNames); [EOL]     return this; [EOL] }
public ObjectNode retain(Collection<String> fieldNames) { [EOL]     _children.keySet().retainAll(fieldNames); [EOL]     return this; [EOL] }
public ObjectNode retain(String... fieldNames) { [EOL]     return retain(Arrays.asList(fieldNames)); [EOL] }
public ObjectNode retain(String... fieldNames) { [EOL]     return retain(Arrays.asList(fieldNames)); [EOL] }
public ObjectNode retain(String... fieldNames) { [EOL]     return retain(Arrays.asList(fieldNames)); [EOL] }
public ObjectNode retain(String... fieldNames) { [EOL]     return retain(Arrays.asList(fieldNames)); [EOL] }
public ObjectNode putNull(String fieldName) { [EOL]     _children.put(fieldName, nullNode()); [EOL]     return this; [EOL] }
public ObjectNode putNull(String fieldName) { [EOL]     _children.put(fieldName, nullNode()); [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, BigDecimal v) { [EOL]     if (v == null) { [EOL]         putNull(fieldName); [EOL]     } else { [EOL]         _children.put(fieldName, numberNode(v)); [EOL]     } [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, BigDecimal v) { [EOL]     if (v == null) { [EOL]         putNull(fieldName); [EOL]     } else { [EOL]         _children.put(fieldName, numberNode(v)); [EOL]     } [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, String v) { [EOL]     if (v == null) { [EOL]         putNull(fieldName); [EOL]     } else { [EOL]         _children.put(fieldName, textNode(v)); [EOL]     } [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, String v) { [EOL]     if (v == null) { [EOL]         putNull(fieldName); [EOL]     } else { [EOL]         _children.put(fieldName, textNode(v)); [EOL]     } [EOL]     return this; [EOL] }
public static String okNameForRegularGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("get")) { [EOL]         if ("getCallbacks".equals(name)) { [EOL]             if (isCglibGetCallbacks(am)) { [EOL]                 return null; [EOL]             } [EOL]         } else if ("getMetaClass".equals(name)) { [EOL]             if (isGroovyMetaClassGetter(am)) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return manglePropertyName(name.substring(3)); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForRegularGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("get")) { [EOL]         if ("getCallbacks".equals(name)) { [EOL]             if (isCglibGetCallbacks(am)) { [EOL]                 return null; [EOL]             } [EOL]         } else if ("getMetaClass".equals(name)) { [EOL]             if (isGroovyMetaClassGetter(am)) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return manglePropertyName(name.substring(3)); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForIsGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("is")) { [EOL]         Class<?> rt = am.getRawType(); [EOL]         if (rt != Boolean.class && rt != Boolean.TYPE) { [EOL]             return null; [EOL]         } [EOL]         return manglePropertyName(name.substring(2)); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForIsGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("is")) { [EOL]         Class<?> rt = am.getRawType(); [EOL]         if (rt != Boolean.class && rt != Boolean.TYPE) { [EOL]             return null; [EOL]         } [EOL]         return manglePropertyName(name.substring(2)); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForMutator(AnnotatedMethod am, String prefix) { [EOL]     String name = am.getName(); [EOL]     if (name.startsWith(prefix)) { [EOL]         return manglePropertyName(name.substring(prefix.length())); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForMutator(AnnotatedMethod am, String prefix) { [EOL]     String name = am.getName(); [EOL]     if (name.startsWith(prefix)) { [EOL]         return manglePropertyName(name.substring(prefix.length())); [EOL]     } [EOL]     return null; [EOL] }
protected static String manglePropertyName(String basename) { [EOL]     int len = basename.length(); [EOL]     if (len == 0) { [EOL]         return null; [EOL]     } [EOL]     StringBuilder sb = null; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         char upper = basename.charAt(i); [EOL]         char lower = Character.toLowerCase(upper); [EOL]         if (upper == lower) { [EOL]             break; [EOL]         } [EOL]         if (sb == null) { [EOL]             sb = new StringBuilder(basename); [EOL]         } [EOL]         sb.setCharAt(i, lower); [EOL]     } [EOL]     return (sb == null) ? basename : sb.toString(); [EOL] }
public MappingJsonFactory(ObjectMapper mapper) { [EOL]     super(mapper); [EOL]     if (mapper == null) { [EOL]         setCodec(new ObjectMapper(this)); [EOL]     } [EOL] }
public MappingJsonFactory(ObjectMapper mapper) { [EOL]     super(mapper); [EOL]     if (mapper == null) { [EOL]         setCodec(new ObjectMapper(this)); [EOL]     } [EOL] }
@Override [EOL] public MatchStrength hasFormat(InputAccessor acc) throws IOException { [EOL]     if (getClass() == MappingJsonFactory.class) { [EOL]         return hasJSONFormat(acc); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return Integer.valueOf(_value); [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return Integer.valueOf(_value); [EOL] }
public CreatorCollector(BeanDescription beanDesc, boolean canFixAccess) { [EOL]     _beanDesc = beanDesc; [EOL]     _canFixAccess = canFixAccess; [EOL] }
public CreatorCollector(BeanDescription beanDesc, boolean canFixAccess) { [EOL]     _beanDesc = beanDesc; [EOL]     _canFixAccess = canFixAccess; [EOL] }
public ValueInstantiator constructValueInstantiator(DeserializationConfig config) { [EOL]     StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType()); [EOL]     JavaType delegateType; [EOL]     if (_delegateCreator == null) { [EOL]         delegateType = null; [EOL]     } else { [EOL]         int ix = 0; [EOL]         if (_delegateArgs != null) { [EOL]             for (int i = 0, len = _delegateArgs.length; i < len; ++i) { [EOL]                 if (_delegateArgs[i] == null) { [EOL]                     ix = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         TypeBindings bindings = _beanDesc.bindingsForBeanType(); [EOL]         delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix)); [EOL]     } [EOL]     inst.configureFromObjectSettings(_defaultConstructor, _delegateCreator, delegateType, _delegateArgs, _propertyBasedCreator, _propertyBasedArgs); [EOL]     inst.configureFromStringCreator(_stringCreator); [EOL]     inst.configureFromIntCreator(_intCreator); [EOL]     inst.configureFromLongCreator(_longCreator); [EOL]     inst.configureFromDoubleCreator(_doubleCreator); [EOL]     inst.configureFromBooleanCreator(_booleanCreator); [EOL]     inst.configureIncompleteParameter(_incompleteParameter); [EOL]     return inst; [EOL] }
public ValueInstantiator constructValueInstantiator(DeserializationConfig config) { [EOL]     StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType()); [EOL]     JavaType delegateType; [EOL]     if (_delegateCreator == null) { [EOL]         delegateType = null; [EOL]     } else { [EOL]         int ix = 0; [EOL]         if (_delegateArgs != null) { [EOL]             for (int i = 0, len = _delegateArgs.length; i < len; ++i) { [EOL]                 if (_delegateArgs[i] == null) { [EOL]                     ix = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         TypeBindings bindings = _beanDesc.bindingsForBeanType(); [EOL]         delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix)); [EOL]     } [EOL]     inst.configureFromObjectSettings(_defaultConstructor, _delegateCreator, delegateType, _delegateArgs, _propertyBasedCreator, _propertyBasedArgs); [EOL]     inst.configureFromStringCreator(_stringCreator); [EOL]     inst.configureFromIntCreator(_intCreator); [EOL]     inst.configureFromLongCreator(_longCreator); [EOL]     inst.configureFromDoubleCreator(_doubleCreator); [EOL]     inst.configureFromBooleanCreator(_booleanCreator); [EOL]     inst.configureIncompleteParameter(_incompleteParameter); [EOL]     return inst; [EOL] }
public ValueInstantiator constructValueInstantiator(DeserializationConfig config) { [EOL]     StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType()); [EOL]     JavaType delegateType; [EOL]     if (_delegateCreator == null) { [EOL]         delegateType = null; [EOL]     } else { [EOL]         int ix = 0; [EOL]         if (_delegateArgs != null) { [EOL]             for (int i = 0, len = _delegateArgs.length; i < len; ++i) { [EOL]                 if (_delegateArgs[i] == null) { [EOL]                     ix = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         TypeBindings bindings = _beanDesc.bindingsForBeanType(); [EOL]         delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix)); [EOL]     } [EOL]     inst.configureFromObjectSettings(_defaultConstructor, _delegateCreator, delegateType, _delegateArgs, _propertyBasedCreator, _propertyBasedArgs); [EOL]     inst.configureFromStringCreator(_stringCreator); [EOL]     inst.configureFromIntCreator(_intCreator); [EOL]     inst.configureFromLongCreator(_longCreator); [EOL]     inst.configureFromDoubleCreator(_doubleCreator); [EOL]     inst.configureFromBooleanCreator(_booleanCreator); [EOL]     inst.configureIncompleteParameter(_incompleteParameter); [EOL]     return inst; [EOL] }
@Deprecated [EOL] public void setDefaultConstructor(AnnotatedConstructor ctor) { [EOL]     _defaultConstructor = _fixAccess(ctor); [EOL] }
@Deprecated [EOL] public void setDefaultConstructor(AnnotatedConstructor ctor) { [EOL]     _defaultConstructor = _fixAccess(ctor); [EOL] }
public void setDefaultCreator(AnnotatedWithParams creator) { [EOL]     if (creator instanceof AnnotatedConstructor) { [EOL]         setDefaultConstructor((AnnotatedConstructor) creator); [EOL]         return; [EOL]     } [EOL]     _defaultConstructor = _fixAccess(creator); [EOL] }
public void setDefaultCreator(AnnotatedWithParams creator) { [EOL]     if (creator instanceof AnnotatedConstructor) { [EOL]         setDefaultConstructor((AnnotatedConstructor) creator); [EOL]         return; [EOL]     } [EOL]     _defaultConstructor = _fixAccess(creator); [EOL] }
public void addDoubleCreator(AnnotatedWithParams creator) { [EOL]     _doubleCreator = verifyNonDup(creator, _doubleCreator, "double"); [EOL] }
public void addDoubleCreator(AnnotatedWithParams creator) { [EOL]     _doubleCreator = verifyNonDup(creator, _doubleCreator, "double"); [EOL] }
public void addDoubleCreator(AnnotatedWithParams creator) { [EOL]     _doubleCreator = verifyNonDup(creator, _doubleCreator, "double"); [EOL] }
public void addBooleanCreator(AnnotatedWithParams creator) { [EOL]     _booleanCreator = verifyNonDup(creator, _booleanCreator, "boolean"); [EOL] }
public void addBooleanCreator(AnnotatedWithParams creator) { [EOL]     _booleanCreator = verifyNonDup(creator, _booleanCreator, "boolean"); [EOL] }
public void addBooleanCreator(AnnotatedWithParams creator) { [EOL]     _booleanCreator = verifyNonDup(creator, _booleanCreator, "boolean"); [EOL] }
public boolean hasDefaultCreator() { [EOL]     return _defaultConstructor != null; [EOL] }
public boolean hasDefaultCreator() { [EOL]     return _defaultConstructor != null; [EOL] }
private <T extends AnnotatedMember> T _fixAccess(T member) { [EOL]     if (member != null && _canFixAccess) { [EOL]         ClassUtil.checkAndFixAccess((Member) member.getAnnotated()); [EOL]     } [EOL]     return member; [EOL] }
private <T extends AnnotatedMember> T _fixAccess(T member) { [EOL]     if (member != null && _canFixAccess) { [EOL]         ClassUtil.checkAndFixAccess((Member) member.getAnnotated()); [EOL]     } [EOL]     return member; [EOL] }
private <T extends AnnotatedMember> T _fixAccess(T member) { [EOL]     if (member != null && _canFixAccess) { [EOL]         ClassUtil.checkAndFixAccess((Member) member.getAnnotated()); [EOL]     } [EOL]     return member; [EOL] }
protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne, String type) { [EOL]     if (oldOne != null) { [EOL]         if (oldOne.getClass() == newOne.getClass()) { [EOL]             throw new IllegalArgumentException("Conflicting " + type + " creators: already had " + oldOne + ", encountered " + newOne); [EOL]         } [EOL]     } [EOL]     return _fixAccess(newOne); [EOL] }
protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne, String type) { [EOL]     if (oldOne != null) { [EOL]         if (oldOne.getClass() == newOne.getClass()) { [EOL]             throw new IllegalArgumentException("Conflicting " + type + " creators: already had " + oldOne + ", encountered " + newOne); [EOL]         } [EOL]     } [EOL]     return _fixAccess(newOne); [EOL] }
protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne, String type) { [EOL]     if (oldOne != null) { [EOL]         if (oldOne.getClass() == newOne.getClass()) { [EOL]             throw new IllegalArgumentException("Conflicting " + type + " creators: already had " + oldOne + ", encountered " + newOne); [EOL]         } [EOL]     } [EOL]     return _fixAccess(newOne); [EOL] }
public void renameAll(NameTransformer transformer) { [EOL]     ArrayList<SettableBeanProperty> oldProps = new ArrayList<SettableBeanProperty>(_properties); [EOL]     Iterator<SettableBeanProperty> it = oldProps.iterator(); [EOL]     _properties.clear(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         _properties.add(prop); [EOL]     } [EOL] }
public void renameAll(NameTransformer transformer) { [EOL]     ArrayList<SettableBeanProperty> oldProps = new ArrayList<SettableBeanProperty>(_properties); [EOL]     Iterator<SettableBeanProperty> it = oldProps.iterator(); [EOL]     _properties.clear(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         _properties.add(prop); [EOL]     } [EOL] }
public void renameAll(NameTransformer transformer) { [EOL]     ArrayList<SettableBeanProperty> oldProps = new ArrayList<SettableBeanProperty>(_properties); [EOL]     Iterator<SettableBeanProperty> it = oldProps.iterator(); [EOL]     _properties.clear(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         _properties.add(prop); [EOL]     } [EOL] }
@Override [EOL] public JsonDeserializer<?> findMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
@Override [EOL] public JsonDeserializer<?> findMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private Match _findFormat(AccessorForReader acc) throws IOException { [EOL]     ObjectReader bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (ObjectReader f : _readers) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.getFactory().hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
public ObjectReader getReader() { [EOL]     return _match; [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     JsonFactory jf = _match.getFactory(); [EOL]     if (_originalStream == null) { [EOL]         return jf.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return jf.createParser(getDataStream()); [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     JsonFactory jf = _match.getFactory(); [EOL]     if (_originalStream == null) { [EOL]         return jf.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return jf.createParser(getDataStream()); [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     JsonFactory jf = _match.getFactory(); [EOL]     if (_originalStream == null) { [EOL]         return jf.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return jf.createParser(getDataStream()); [EOL] }
protected JavaType getType(TypeBindings bindings, TypeVariable<?>[] typeParams) { [EOL]     if (typeParams != null && typeParams.length > 0) { [EOL]         bindings = bindings.childInstance(); [EOL]         for (TypeVariable<?> var : typeParams) { [EOL]             String name = var.getName(); [EOL]             bindings._addPlaceholder(name); [EOL]             Type lowerBound = var.getBounds()[0]; [EOL]             JavaType type = (lowerBound == null) ? TypeFactory.unknownType() : bindings.resolveType(lowerBound); [EOL]             bindings.addBinding(var.getName(), type); [EOL]         } [EOL]     } [EOL]     return bindings.resolveType(getGenericType()); [EOL] }
protected JavaType getType(TypeBindings bindings, TypeVariable<?>[] typeParams) { [EOL]     if (typeParams != null && typeParams.length > 0) { [EOL]         bindings = bindings.childInstance(); [EOL]         for (TypeVariable<?> var : typeParams) { [EOL]             String name = var.getName(); [EOL]             bindings._addPlaceholder(name); [EOL]             Type lowerBound = var.getBounds()[0]; [EOL]             JavaType type = (lowerBound == null) ? TypeFactory.unknownType() : bindings.resolveType(lowerBound); [EOL]             bindings.addBinding(var.getName(), type); [EOL]         } [EOL]     } [EOL]     return bindings.resolveType(getGenericType()); [EOL] }
@Override [EOL] public List<AnnotatedMethod> getFactoryMethods() { [EOL]     List<AnnotatedMethod> candidates = _classInfo.getStaticMethods(); [EOL]     if (candidates.isEmpty()) { [EOL]         return candidates; [EOL]     } [EOL]     ArrayList<AnnotatedMethod> result = new ArrayList<AnnotatedMethod>(); [EOL]     for (AnnotatedMethod am : candidates) { [EOL]         if (isFactoryMethod(am)) { [EOL]             result.add(am); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<AnnotatedMethod> getFactoryMethods() { [EOL]     List<AnnotatedMethod> candidates = _classInfo.getStaticMethods(); [EOL]     if (candidates.isEmpty()) { [EOL]         return candidates; [EOL]     } [EOL]     ArrayList<AnnotatedMethod> result = new ArrayList<AnnotatedMethod>(); [EOL]     for (AnnotatedMethod am : candidates) { [EOL]         if (isFactoryMethod(am)) { [EOL]             result.add(am); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<AnnotatedMethod> getFactoryMethods() { [EOL]     List<AnnotatedMethod> candidates = _classInfo.getStaticMethods(); [EOL]     if (candidates.isEmpty()) { [EOL]         return candidates; [EOL]     } [EOL]     ArrayList<AnnotatedMethod> result = new ArrayList<AnnotatedMethod>(); [EOL]     for (AnnotatedMethod am : candidates) { [EOL]         if (isFactoryMethod(am)) { [EOL]             result.add(am); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public JsonPOJOBuilder.Value findPOJOBuilderConfig() { [EOL]     return (_annotationIntrospector == null) ? null : _annotationIntrospector.findPOJOBuilderConfig(_classInfo); [EOL] }
@Override [EOL] public JsonPOJOBuilder.Value findPOJOBuilderConfig() { [EOL]     return (_annotationIntrospector == null) ? null : _annotationIntrospector.findPOJOBuilderConfig(_classInfo); [EOL] }
public StdValueInstantiator(DeserializationConfig config, JavaType valueType) { [EOL]     _cfgEmptyStringsAsObjects = (config == null) ? false : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT); [EOL]     _valueTypeDesc = (valueType == null) ? "UNKNOWN TYPE" : valueType.toString(); [EOL] }
public StdValueInstantiator(DeserializationConfig config, JavaType valueType) { [EOL]     _cfgEmptyStringsAsObjects = (config == null) ? false : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT); [EOL]     _valueTypeDesc = (valueType == null) ? "UNKNOWN TYPE" : valueType.toString(); [EOL] }
public StdValueInstantiator(DeserializationConfig config, JavaType valueType) { [EOL]     _cfgEmptyStringsAsObjects = (config == null) ? false : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT); [EOL]     _valueTypeDesc = (valueType == null) ? "UNKNOWN TYPE" : valueType.toString(); [EOL] }
public StdValueInstantiator(DeserializationConfig config, JavaType valueType) { [EOL]     _cfgEmptyStringsAsObjects = (config == null) ? false : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT); [EOL]     _valueTypeDesc = (valueType == null) ? "UNKNOWN TYPE" : valueType.toString(); [EOL] }
public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, CreatorProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, CreatorProperty[] constructorArgs) { [EOL]     _defaultCreator = defaultCreator; [EOL]     _delegateCreator = delegateCreator; [EOL]     _delegateType = delegateType; [EOL]     _delegateArguments = delegateArgs; [EOL]     _withArgsCreator = withArgsCreator; [EOL]     _constructorArguments = constructorArgs; [EOL] }
public void configureFromObjectSettings(AnnotatedWithParams defaultCreator, AnnotatedWithParams delegateCreator, JavaType delegateType, CreatorProperty[] delegateArgs, AnnotatedWithParams withArgsCreator, CreatorProperty[] constructorArgs) { [EOL]     _defaultCreator = defaultCreator; [EOL]     _delegateCreator = delegateCreator; [EOL]     _delegateType = delegateType; [EOL]     _delegateArguments = delegateArgs; [EOL]     _withArgsCreator = withArgsCreator; [EOL]     _constructorArguments = constructorArgs; [EOL] }
public void configureFromStringCreator(AnnotatedWithParams creator) { [EOL]     _fromStringCreator = creator; [EOL] }
public void configureFromStringCreator(AnnotatedWithParams creator) { [EOL]     _fromStringCreator = creator; [EOL] }
public void configureFromIntCreator(AnnotatedWithParams creator) { [EOL]     _fromIntCreator = creator; [EOL] }
public void configureFromIntCreator(AnnotatedWithParams creator) { [EOL]     _fromIntCreator = creator; [EOL] }
public void configureFromLongCreator(AnnotatedWithParams creator) { [EOL]     _fromLongCreator = creator; [EOL] }
public void configureFromLongCreator(AnnotatedWithParams creator) { [EOL]     _fromLongCreator = creator; [EOL] }
public void configureFromDoubleCreator(AnnotatedWithParams creator) { [EOL]     _fromDoubleCreator = creator; [EOL] }
public void configureFromDoubleCreator(AnnotatedWithParams creator) { [EOL]     _fromDoubleCreator = creator; [EOL] }
public void configureFromBooleanCreator(AnnotatedWithParams creator) { [EOL]     _fromBooleanCreator = creator; [EOL] }
public void configureIncompleteParameter(AnnotatedParameter parameter) { [EOL]     _incompleteParameter = parameter; [EOL] }
public void configureIncompleteParameter(AnnotatedParameter parameter) { [EOL]     _incompleteParameter = parameter; [EOL] }
@Override [EOL] public boolean canCreateUsingDefault() { [EOL]     return (_defaultCreator != null); [EOL] }
@Override [EOL] public boolean canCreateUsingDefault() { [EOL]     return (_defaultCreator != null); [EOL] }
@Override [EOL] public boolean canCreateUsingDelegate() { [EOL]     return _delegateType != null; [EOL] }
@Override [EOL] public boolean canCreateUsingDelegate() { [EOL]     return _delegateType != null; [EOL] }
@Override [EOL] public boolean canCreateFromObjectWith() { [EOL]     return (_withArgsCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromObjectWith() { [EOL]     return (_withArgsCreator != null); [EOL] }
@Override [EOL] public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config) { [EOL]     return _constructorArguments; [EOL] }
@Override [EOL] public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config) { [EOL]     return _constructorArguments; [EOL] }
@Override [EOL] public Object createUsingDefault(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultCreator == null) { [EOL]         throw new IllegalStateException("No default constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _defaultCreator.call(); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createUsingDefault(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultCreator == null) { [EOL]         throw new IllegalStateException("No default constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _defaultCreator.call(); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createUsingDefault(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultCreator == null) { [EOL]         throw new IllegalStateException("No default constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _defaultCreator.call(); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createUsingDefault(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultCreator == null) { [EOL]         throw new IllegalStateException("No default constructor for " + getValueTypeDesc()); [EOL]     } [EOL]     try { [EOL]         return _defaultCreator.call(); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } [EOL] }
@Override [EOL] public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromStringCreator != null) { [EOL]         try { [EOL]             return _fromStringCreator.call1(value); [EOL]         } catch (Exception e) { [EOL]             throw wrapException(e); [EOL]         } catch (ExceptionInInitializerError e) { [EOL]             throw wrapException(e); [EOL]         } [EOL]     } [EOL]     return _createFromStringFallbacks(ctxt, value); [EOL] }
@Override [EOL] public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromStringCreator != null) { [EOL]         try { [EOL]             return _fromStringCreator.call1(value); [EOL]         } catch (Exception e) { [EOL]             throw wrapException(e); [EOL]         } catch (ExceptionInInitializerError e) { [EOL]             throw wrapException(e); [EOL]         } [EOL]     } [EOL]     return _createFromStringFallbacks(ctxt, value); [EOL] }
@Override [EOL] public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromStringCreator != null) { [EOL]         try { [EOL]             return _fromStringCreator.call1(value); [EOL]         } catch (Exception e) { [EOL]             throw wrapException(e); [EOL]         } catch (ExceptionInInitializerError e) { [EOL]             throw wrapException(e); [EOL]         } [EOL]     } [EOL]     return _createFromStringFallbacks(ctxt, value); [EOL] }
@Override [EOL] public Object createFromString(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromStringCreator != null) { [EOL]         try { [EOL]             return _fromStringCreator.call1(value); [EOL]         } catch (Exception e) { [EOL]             throw wrapException(e); [EOL]         } catch (ExceptionInInitializerError e) { [EOL]             throw wrapException(e); [EOL]         } [EOL]     } [EOL]     return _createFromStringFallbacks(ctxt, value); [EOL] }
@Override [EOL] public Object createFromLong(DeserializationContext ctxt, long value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Long integral number; no single-long-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromLong(DeserializationContext ctxt, long value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Long integral number; no single-long-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromLong(DeserializationContext ctxt, long value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Long integral number; no single-long-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromLong(DeserializationContext ctxt, long value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromLongCreator != null) { [EOL]             return _fromLongCreator.call1(Long.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Long integral number; no single-long-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromDoubleCreator != null) { [EOL]             return _fromDoubleCreator.call1(Double.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Floating-point number; no one-double/Double-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromDoubleCreator != null) { [EOL]             return _fromDoubleCreator.call1(Double.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Floating-point number; no one-double/Double-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromDoubleCreator != null) { [EOL]             return _fromDoubleCreator.call1(Double.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Floating-point number; no one-double/Double-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromDoubleCreator != null) { [EOL]             return _fromDoubleCreator.call1(Double.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Floating-point number; no one-double/Double-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromBooleanCreator != null) { [EOL]             return _fromBooleanCreator.call1(Boolean.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Boolean value; no single-boolean/Boolean-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromBooleanCreator != null) { [EOL]             return _fromBooleanCreator.call1(Boolean.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Boolean value; no single-boolean/Boolean-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromBooleanCreator != null) { [EOL]             return _fromBooleanCreator.call1(Boolean.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Boolean value; no single-boolean/Boolean-arg constructor/factory method"); [EOL] }
@Override [EOL] public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException, JsonProcessingException { [EOL]     try { [EOL]         if (_fromBooleanCreator != null) { [EOL]             return _fromBooleanCreator.call1(Boolean.valueOf(value)); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         throw wrapException(e); [EOL]     } catch (ExceptionInInitializerError e) { [EOL]         throw wrapException(e); [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from Boolean value; no single-boolean/Boolean-arg constructor/factory method"); [EOL] }
@Override [EOL] public AnnotatedParameter getIncompleteParameter() { [EOL]     return _incompleteParameter; [EOL] }
@Override [EOL] public AnnotatedParameter getIncompleteParameter() { [EOL]     return _incompleteParameter; [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
@Override [EOL] public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber(value[i]); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber(value[i]); [EOL]     } [EOL] }
@Override [EOL] public MapType withTypeHandler(Object h) { [EOL]     return new MapType(_class, _keyType, _valueType, _valueHandler, h, _asStatic); [EOL] }
@Override [EOL] public MapType withTypeHandler(Object h) { [EOL]     return new MapType(_class, _keyType, _valueType, _valueHandler, h, _asStatic); [EOL] }
@Override [EOL] public MapType withStaticTyping() { [EOL]     if (_asStatic) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType.withStaticTyping(), _valueType.withStaticTyping(), _valueHandler, _typeHandler, true); [EOL] }
@Override [EOL] public MapType withStaticTyping() { [EOL]     if (_asStatic) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType.withStaticTyping(), _valueType.withStaticTyping(), _valueHandler, _typeHandler, true); [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] protected Duration _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return _dataTypeFactory.newDuration(value); [EOL] }
@Override [EOL] protected Duration _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return _dataTypeFactory.newDuration(value); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return _member.getAnnotation(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return _member.getAnnotation(acls); [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             jgen.writeFieldName(_name); [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     jgen.writeFieldName(_name); [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if (jp.getCurrentToken() == JsonToken.VALUE_STRING && _elementClass == Byte.class) { [EOL]             return deserializeFromBase64(jp, ctxt); [EOL]         } [EOL]         throw ctxt.mappingException(_arrayType.getRawClass()); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (_elementTypeDeserializer == null) { [EOL]         value = _elementDeserializer.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer); [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = new Object[1]; [EOL]     } else { [EOL]         result = (Object[]) Array.newInstance(_elementClass, 1); [EOL]     } [EOL]     result[0] = value; [EOL]     return result; [EOL] }
private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if (jp.getCurrentToken() == JsonToken.VALUE_STRING && _elementClass == Byte.class) { [EOL]             return deserializeFromBase64(jp, ctxt); [EOL]         } [EOL]         throw ctxt.mappingException(_arrayType.getRawClass()); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (_elementTypeDeserializer == null) { [EOL]         value = _elementDeserializer.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer); [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = new Object[1]; [EOL]     } else { [EOL]         result = (Object[]) Array.newInstance(_elementClass, 1); [EOL]     } [EOL]     result[0] = value; [EOL]     return result; [EOL] }
private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if (jp.getCurrentToken() == JsonToken.VALUE_STRING && _elementClass == Byte.class) { [EOL]             return deserializeFromBase64(jp, ctxt); [EOL]         } [EOL]         throw ctxt.mappingException(_arrayType.getRawClass()); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (_elementTypeDeserializer == null) { [EOL]         value = _elementDeserializer.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer); [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = new Object[1]; [EOL]     } else { [EOL]         result = (Object[]) Array.newInstance(_elementClass, 1); [EOL]     } [EOL]     result[0] = value; [EOL]     return result; [EOL] }
private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if ((jp.getCurrentToken() == JsonToken.VALUE_STRING) && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) { [EOL]         if (jp.getCurrentToken() == JsonToken.VALUE_STRING && _elementClass == Byte.class) { [EOL]             return deserializeFromBase64(jp, ctxt); [EOL]         } [EOL]         throw ctxt.mappingException(_arrayType.getRawClass()); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = null; [EOL]     } else if (_elementTypeDeserializer == null) { [EOL]         value = _elementDeserializer.deserialize(jp, ctxt); [EOL]     } else { [EOL]         value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer); [EOL]     } [EOL]     Object[] result; [EOL]     if (_untyped) { [EOL]         result = new Object[1]; [EOL]     } else { [EOL]         result = (Object[]) Array.newInstance(_elementClass, 1); [EOL]     } [EOL]     result[0] = value; [EOL]     return result; [EOL] }
public ObjectIdInfo findObjectIdInfo(Annotated ann) { [EOL]     return null; [EOL] }
public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) { [EOL]     return null; [EOL] }
@Deprecated [EOL] public JsonFormat.Value findFormat(AnnotatedMember member) { [EOL]     return null; [EOL] }
@Deprecated [EOL] public JsonFormat.Value findFormat(AnnotatedMember member) { [EOL]     return null; [EOL] }
public JsonFormat.Value findFormat(Annotated memberOrClass) { [EOL]     if (memberOrClass instanceof AnnotatedMember) { [EOL]         return findFormat((AnnotatedMember) memberOrClass); [EOL]     } [EOL]     return null; [EOL] }
public JsonFormat.Value findFormat(Annotated memberOrClass) { [EOL]     if (memberOrClass instanceof AnnotatedMember) { [EOL]         return findFormat((AnnotatedMember) memberOrClass); [EOL]     } [EOL]     return null; [EOL] }
public Object findContentSerializer(Annotated am) { [EOL]     return null; [EOL] }
public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { [EOL]     return null; [EOL] }
public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [EOL]     return null; [EOL] }
public Object findSerializationContentConverter(AnnotatedMember a) { [EOL]     return null; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapSerializer(MapSerializer src, BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored) { [EOL]     super(Map.class, false); [EOL]     _ignoredEntries = ignored; [EOL]     _keyType = src._keyType; [EOL]     _valueType = src._valueType; [EOL]     _valueTypeIsStatic = src._valueTypeIsStatic; [EOL]     _valueTypeSerializer = src._valueTypeSerializer; [EOL]     _keySerializer = (JsonSerializer<Object>) keySerializer; [EOL]     _valueSerializer = (JsonSerializer<Object>) valueSerializer; [EOL]     _dynamicValueSerializers = src._dynamicValueSerializers; [EOL]     _property = property; [EOL] }
protected MapSerializer(MapSerializer src, TypeSerializer vts) { [EOL]     super(Map.class, false); [EOL]     _ignoredEntries = src._ignoredEntries; [EOL]     _keyType = src._keyType; [EOL]     _valueType = src._valueType; [EOL]     _valueTypeIsStatic = src._valueTypeIsStatic; [EOL]     _valueTypeSerializer = vts; [EOL]     _keySerializer = src._keySerializer; [EOL]     _valueSerializer = src._valueSerializer; [EOL]     _dynamicValueSerializers = src._dynamicValueSerializers; [EOL]     _property = src._property; [EOL] }
@Override [EOL] public MapSerializer _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new MapSerializer(this, vts); [EOL] }
@Override [EOL] public MapSerializer _withValueTypeSerializer(TypeSerializer vts) { [EOL]     return new MapSerializer(this, vts); [EOL] }
public MapSerializer withResolved(BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored) { [EOL]     return new MapSerializer(this, property, keySerializer, valueSerializer, ignored); [EOL] }
public MapSerializer withResolved(BeanProperty property, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored) { [EOL]     return new MapSerializer(this, property, keySerializer, valueSerializer, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serializeWithType(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForObject(value, jgen); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     typeSer.writeTypeSuffixForObject(value, jgen); [EOL] }
@Override [EOL] public void serializeWithType(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForObject(value, jgen); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     typeSer.writeTypeSuffixForObject(value, jgen); [EOL] }
@Override [EOL] public void serializeWithType(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForObject(value, jgen); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     typeSer.writeTypeSuffixForObject(value, jgen); [EOL] }
@Override [EOL] public void serializeWithType(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForObject(value, jgen); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     typeSer.writeTypeSuffixForObject(value, jgen); [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             try { [EOL]                 if (typeSer == null) { [EOL]                     ser.serialize(valueElem, jgen, provider); [EOL]                 } else { [EOL]                     ser.serializeWithType(valueElem, jgen, provider, typeSer); [EOL]                 } [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             try { [EOL]                 if (typeSer == null) { [EOL]                     ser.serialize(valueElem, jgen, provider); [EOL]                 } else { [EOL]                     ser.serializeWithType(valueElem, jgen, provider, typeSer); [EOL]                 } [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             try { [EOL]                 if (typeSer == null) { [EOL]                     ser.serialize(valueElem, jgen, provider); [EOL]                 } else { [EOL]                     ser.serializeWithType(valueElem, jgen, provider, typeSer); [EOL]                 } [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             try { [EOL]                 if (typeSer == null) { [EOL]                     ser.serialize(valueElem, jgen, provider); [EOL]                 } else { [EOL]                     ser.serializeWithType(valueElem, jgen, provider, typeSer); [EOL]                 } [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             try { [EOL]                 if (typeSer == null) { [EOL]                     ser.serialize(valueElem, jgen, provider); [EOL]                 } else { [EOL]                     ser.serializeWithType(valueElem, jgen, provider, typeSer); [EOL]                 } [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void serializeFieldsUsing(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             try { [EOL]                 if (typeSer == null) { [EOL]                     ser.serialize(valueElem, jgen, provider); [EOL]                 } else { [EOL]                     ser.serializeWithType(valueElem, jgen, provider, typeSer); [EOL]                 } [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property); [EOL]     if (map != result.map) { [EOL]         _dynamicValueSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property); [EOL]     if (map != result.map) { [EOL]         _dynamicValueSerializers = result.map; [EOL]     } [EOL]     return result.serializer; [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
public boolean isCachable() { [EOL]     return false; [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String className = rawType.getName(); [EOL]     String factoryName; [EOL]     if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML) || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) { [EOL]         factoryName = DESERIALIZERS_FOR_JAVAX_XML; [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT); [EOL]     } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) { [EOL]         return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     Object ob = instantiate(factoryName); [EOL]     if (ob == null) { [EOL]         return null; [EOL]     } [EOL]     return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc); [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean doesImplement(Class<?> actualType, String classNameToImplement) { [EOL]     for (Class<?> type = actualType; type != null; type = type.getSuperclass()) { [EOL]         if (type.getName().equals(classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]         if (hasInterface(type, classNameToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterface(Class<?> type, String interfaceToImplement) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().equals(interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterface(iface, interfaceToImplement)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix) { [EOL]     for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) { [EOL]         if (supertype.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) { [EOL]         if (hasInterfaceStartingWith(cls, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix) { [EOL]     for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) { [EOL]         if (supertype.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) { [EOL]         if (hasInterfaceStartingWith(cls, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix) { [EOL]     for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) { [EOL]         if (supertype.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) { [EOL]         if (hasInterfaceStartingWith(cls, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix) { [EOL]     for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) { [EOL]         if (supertype.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) { [EOL]         if (hasInterfaceStartingWith(cls, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterfaceStartingWith(Class<?> type, String prefix) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterfaceStartingWith(iface, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean hasInterfaceStartingWith(Class<?> type, String prefix) { [EOL]     Class<?>[] interfaces = type.getInterfaces(); [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (iface.getName().startsWith(prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     for (Class<?> iface : interfaces) { [EOL]         if (hasInterfaceStartingWith(iface, prefix)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static Date parse(String date) { [EOL]     try { [EOL]         int offset = 0; [EOL]         int year = parseInt(date, offset, offset += 4); [EOL]         checkOffset(date, offset, '-'); [EOL]         int month = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, '-'); [EOL]         int day = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, 'T'); [EOL]         int hour = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int minutes = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int seconds = parseInt(date, offset += 1, offset += 2); [EOL]         int milliseconds = 0; [EOL]         if (date.charAt(offset) == '.') { [EOL]             checkOffset(date, offset, '.'); [EOL]             milliseconds = parseInt(date, offset += 1, offset += 3); [EOL]         } [EOL]         String timezoneId; [EOL]         char timezoneIndicator = date.charAt(offset); [EOL]         if (timezoneIndicator == '+' || timezoneIndicator == '-') { [EOL]             timezoneId = GMT_ID + date.substring(offset); [EOL]         } else if (timezoneIndicator == 'Z') { [EOL]             timezoneId = GMT_ID; [EOL]         } else { [EOL]             throw new IndexOutOfBoundsException("Invalid time zone indicator " + timezoneIndicator); [EOL]         } [EOL]         TimeZone timezone = TimeZone.getTimeZone(timezoneId); [EOL]         if (!timezone.getID().equals(timezoneId)) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]         Calendar calendar = new GregorianCalendar(timezone); [EOL]         calendar.setLenient(false); [EOL]         calendar.set(Calendar.YEAR, year); [EOL]         calendar.set(Calendar.MONTH, month - 1); [EOL]         calendar.set(Calendar.DAY_OF_MONTH, day); [EOL]         calendar.set(Calendar.HOUR_OF_DAY, hour); [EOL]         calendar.set(Calendar.MINUTE, minutes); [EOL]         calendar.set(Calendar.SECOND, seconds); [EOL]         calendar.set(Calendar.MILLISECOND, milliseconds); [EOL]         return calendar.getTime(); [EOL]     } catch (IndexOutOfBoundsException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (IllegalArgumentException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } [EOL] }
public static Date parse(String date) { [EOL]     try { [EOL]         int offset = 0; [EOL]         int year = parseInt(date, offset, offset += 4); [EOL]         checkOffset(date, offset, '-'); [EOL]         int month = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, '-'); [EOL]         int day = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, 'T'); [EOL]         int hour = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int minutes = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int seconds = parseInt(date, offset += 1, offset += 2); [EOL]         int milliseconds = 0; [EOL]         if (date.charAt(offset) == '.') { [EOL]             checkOffset(date, offset, '.'); [EOL]             milliseconds = parseInt(date, offset += 1, offset += 3); [EOL]         } [EOL]         String timezoneId; [EOL]         char timezoneIndicator = date.charAt(offset); [EOL]         if (timezoneIndicator == '+' || timezoneIndicator == '-') { [EOL]             timezoneId = GMT_ID + date.substring(offset); [EOL]         } else if (timezoneIndicator == 'Z') { [EOL]             timezoneId = GMT_ID; [EOL]         } else { [EOL]             throw new IndexOutOfBoundsException("Invalid time zone indicator " + timezoneIndicator); [EOL]         } [EOL]         TimeZone timezone = TimeZone.getTimeZone(timezoneId); [EOL]         if (!timezone.getID().equals(timezoneId)) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]         Calendar calendar = new GregorianCalendar(timezone); [EOL]         calendar.setLenient(false); [EOL]         calendar.set(Calendar.YEAR, year); [EOL]         calendar.set(Calendar.MONTH, month - 1); [EOL]         calendar.set(Calendar.DAY_OF_MONTH, day); [EOL]         calendar.set(Calendar.HOUR_OF_DAY, hour); [EOL]         calendar.set(Calendar.MINUTE, minutes); [EOL]         calendar.set(Calendar.SECOND, seconds); [EOL]         calendar.set(Calendar.MILLISECOND, milliseconds); [EOL]         return calendar.getTime(); [EOL]     } catch (IndexOutOfBoundsException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (IllegalArgumentException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } [EOL] }
public static Date parse(String date) { [EOL]     try { [EOL]         int offset = 0; [EOL]         int year = parseInt(date, offset, offset += 4); [EOL]         checkOffset(date, offset, '-'); [EOL]         int month = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, '-'); [EOL]         int day = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, 'T'); [EOL]         int hour = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int minutes = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int seconds = parseInt(date, offset += 1, offset += 2); [EOL]         int milliseconds = 0; [EOL]         if (date.charAt(offset) == '.') { [EOL]             checkOffset(date, offset, '.'); [EOL]             milliseconds = parseInt(date, offset += 1, offset += 3); [EOL]         } [EOL]         String timezoneId; [EOL]         char timezoneIndicator = date.charAt(offset); [EOL]         if (timezoneIndicator == '+' || timezoneIndicator == '-') { [EOL]             timezoneId = GMT_ID + date.substring(offset); [EOL]         } else if (timezoneIndicator == 'Z') { [EOL]             timezoneId = GMT_ID; [EOL]         } else { [EOL]             throw new IndexOutOfBoundsException("Invalid time zone indicator " + timezoneIndicator); [EOL]         } [EOL]         TimeZone timezone = TimeZone.getTimeZone(timezoneId); [EOL]         if (!timezone.getID().equals(timezoneId)) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]         Calendar calendar = new GregorianCalendar(timezone); [EOL]         calendar.setLenient(false); [EOL]         calendar.set(Calendar.YEAR, year); [EOL]         calendar.set(Calendar.MONTH, month - 1); [EOL]         calendar.set(Calendar.DAY_OF_MONTH, day); [EOL]         calendar.set(Calendar.HOUR_OF_DAY, hour); [EOL]         calendar.set(Calendar.MINUTE, minutes); [EOL]         calendar.set(Calendar.SECOND, seconds); [EOL]         calendar.set(Calendar.MILLISECOND, milliseconds); [EOL]         return calendar.getTime(); [EOL]     } catch (IndexOutOfBoundsException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (IllegalArgumentException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } [EOL] }
public static Date parse(String date) { [EOL]     try { [EOL]         int offset = 0; [EOL]         int year = parseInt(date, offset, offset += 4); [EOL]         checkOffset(date, offset, '-'); [EOL]         int month = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, '-'); [EOL]         int day = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, 'T'); [EOL]         int hour = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int minutes = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int seconds = parseInt(date, offset += 1, offset += 2); [EOL]         int milliseconds = 0; [EOL]         if (date.charAt(offset) == '.') { [EOL]             checkOffset(date, offset, '.'); [EOL]             milliseconds = parseInt(date, offset += 1, offset += 3); [EOL]         } [EOL]         String timezoneId; [EOL]         char timezoneIndicator = date.charAt(offset); [EOL]         if (timezoneIndicator == '+' || timezoneIndicator == '-') { [EOL]             timezoneId = GMT_ID + date.substring(offset); [EOL]         } else if (timezoneIndicator == 'Z') { [EOL]             timezoneId = GMT_ID; [EOL]         } else { [EOL]             throw new IndexOutOfBoundsException("Invalid time zone indicator " + timezoneIndicator); [EOL]         } [EOL]         TimeZone timezone = TimeZone.getTimeZone(timezoneId); [EOL]         if (!timezone.getID().equals(timezoneId)) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]         Calendar calendar = new GregorianCalendar(timezone); [EOL]         calendar.setLenient(false); [EOL]         calendar.set(Calendar.YEAR, year); [EOL]         calendar.set(Calendar.MONTH, month - 1); [EOL]         calendar.set(Calendar.DAY_OF_MONTH, day); [EOL]         calendar.set(Calendar.HOUR_OF_DAY, hour); [EOL]         calendar.set(Calendar.MINUTE, minutes); [EOL]         calendar.set(Calendar.SECOND, seconds); [EOL]         calendar.set(Calendar.MILLISECOND, milliseconds); [EOL]         return calendar.getTime(); [EOL]     } catch (IndexOutOfBoundsException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (IllegalArgumentException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } [EOL] }
public static Date parse(String date) { [EOL]     try { [EOL]         int offset = 0; [EOL]         int year = parseInt(date, offset, offset += 4); [EOL]         checkOffset(date, offset, '-'); [EOL]         int month = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, '-'); [EOL]         int day = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, 'T'); [EOL]         int hour = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int minutes = parseInt(date, offset += 1, offset += 2); [EOL]         checkOffset(date, offset, ':'); [EOL]         int seconds = parseInt(date, offset += 1, offset += 2); [EOL]         int milliseconds = 0; [EOL]         if (date.charAt(offset) == '.') { [EOL]             checkOffset(date, offset, '.'); [EOL]             milliseconds = parseInt(date, offset += 1, offset += 3); [EOL]         } [EOL]         String timezoneId; [EOL]         char timezoneIndicator = date.charAt(offset); [EOL]         if (timezoneIndicator == '+' || timezoneIndicator == '-') { [EOL]             timezoneId = GMT_ID + date.substring(offset); [EOL]         } else if (timezoneIndicator == 'Z') { [EOL]             timezoneId = GMT_ID; [EOL]         } else { [EOL]             throw new IndexOutOfBoundsException("Invalid time zone indicator " + timezoneIndicator); [EOL]         } [EOL]         TimeZone timezone = TimeZone.getTimeZone(timezoneId); [EOL]         if (!timezone.getID().equals(timezoneId)) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]         Calendar calendar = new GregorianCalendar(timezone); [EOL]         calendar.setLenient(false); [EOL]         calendar.set(Calendar.YEAR, year); [EOL]         calendar.set(Calendar.MONTH, month - 1); [EOL]         calendar.set(Calendar.DAY_OF_MONTH, day); [EOL]         calendar.set(Calendar.HOUR_OF_DAY, hour); [EOL]         calendar.set(Calendar.MINUTE, minutes); [EOL]         calendar.set(Calendar.SECOND, seconds); [EOL]         calendar.set(Calendar.MILLISECOND, milliseconds); [EOL]         return calendar.getTime(); [EOL]     } catch (IndexOutOfBoundsException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } catch (IllegalArgumentException e) { [EOL]         throw new IllegalArgumentException("Failed to parse date " + date, e); [EOL]     } [EOL] }
private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException { [EOL]     char found = value.charAt(offset); [EOL]     if (found != expected) { [EOL]         throw new IndexOutOfBoundsException("Expected '" + expected + "' character but found '" + found + "'"); [EOL]     } [EOL] }
private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException { [EOL]     char found = value.charAt(offset); [EOL]     if (found != expected) { [EOL]         throw new IndexOutOfBoundsException("Expected '" + expected + "' character but found '" + found + "'"); [EOL]     } [EOL] }
private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException { [EOL]     char found = value.charAt(offset); [EOL]     if (found != expected) { [EOL]         throw new IndexOutOfBoundsException("Expected '" + expected + "' character but found '" + found + "'"); [EOL]     } [EOL] }
private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { [EOL]     if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) { [EOL]         throw new NumberFormatException(value); [EOL]     } [EOL]     int i = beginIndex; [EOL]     int result = 0; [EOL]     int digit; [EOL]     if (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result = -digit; [EOL]     } [EOL]     while (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result *= 10; [EOL]         result -= digit; [EOL]     } [EOL]     return -result; [EOL] }
private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { [EOL]     if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) { [EOL]         throw new NumberFormatException(value); [EOL]     } [EOL]     int i = beginIndex; [EOL]     int result = 0; [EOL]     int digit; [EOL]     if (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result = -digit; [EOL]     } [EOL]     while (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result *= 10; [EOL]         result -= digit; [EOL]     } [EOL]     return -result; [EOL] }
private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { [EOL]     if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) { [EOL]         throw new NumberFormatException(value); [EOL]     } [EOL]     int i = beginIndex; [EOL]     int result = 0; [EOL]     int digit; [EOL]     if (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result = -digit; [EOL]     } [EOL]     while (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result *= 10; [EOL]         result -= digit; [EOL]     } [EOL]     return -result; [EOL] }
private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { [EOL]     if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) { [EOL]         throw new NumberFormatException(value); [EOL]     } [EOL]     int i = beginIndex; [EOL]     int result = 0; [EOL]     int digit; [EOL]     if (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result = -digit; [EOL]     } [EOL]     while (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result *= 10; [EOL]         result -= digit; [EOL]     } [EOL]     return -result; [EOL] }
private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { [EOL]     if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) { [EOL]         throw new NumberFormatException(value); [EOL]     } [EOL]     int i = beginIndex; [EOL]     int result = 0; [EOL]     int digit; [EOL]     if (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result = -digit; [EOL]     } [EOL]     while (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result *= 10; [EOL]         result -= digit; [EOL]     } [EOL]     return -result; [EOL] }
private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { [EOL]     if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) { [EOL]         throw new NumberFormatException(value); [EOL]     } [EOL]     int i = beginIndex; [EOL]     int result = 0; [EOL]     int digit; [EOL]     if (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result = -digit; [EOL]     } [EOL]     while (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result *= 10; [EOL]         result -= digit; [EOL]     } [EOL]     return -result; [EOL] }
private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { [EOL]     if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) { [EOL]         throw new NumberFormatException(value); [EOL]     } [EOL]     int i = beginIndex; [EOL]     int result = 0; [EOL]     int digit; [EOL]     if (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result = -digit; [EOL]     } [EOL]     while (i < endIndex) { [EOL]         digit = Character.digit(value.charAt(i++), 10); [EOL]         if (digit < 0) { [EOL]             throw new NumberFormatException("Invalid number: " + value); [EOL]         } [EOL]         result *= 10; [EOL]         result -= digit; [EOL]     } [EOL]     return -result; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public static ValueInstantiator findValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) { [EOL]     if (beanDesc.getBeanClass() == JsonLocation.class) { [EOL]         return JsonLocationInstantiator.instance; [EOL]     } [EOL]     return null; [EOL] }
public static ValueInstantiator findValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) { [EOL]     if (beanDesc.getBeanClass() == JsonLocation.class) { [EOL]         return JsonLocationInstantiator.instance; [EOL]     } [EOL]     return null; [EOL] }
public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause) { [EOL]     super(msg, loc, rootCause); [EOL] }
public static JsonMappingException from(JsonParser jp, String msg) { [EOL]     return new JsonMappingException(msg, ((jp == null) ? null : jp.getTokenLocation())); [EOL] }
@Override [EOL] public String getMessage() { [EOL]     return _buildMessage(); [EOL] }
protected String _buildMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (_path == null) { [EOL]         return msg; [EOL]     } [EOL]     StringBuilder sb = (msg == null) ? new StringBuilder() : new StringBuilder(msg); [EOL]     sb.append(" (through reference chain: "); [EOL]     sb = getPathReference(sb); [EOL]     sb.append(')'); [EOL]     return sb.toString(); [EOL] }
protected String _buildMessage() { [EOL]     String msg = super.getMessage(); [EOL]     if (_path == null) { [EOL]         return msg; [EOL]     } [EOL]     StringBuilder sb = (msg == null) ? new StringBuilder() : new StringBuilder(msg); [EOL]     sb.append(" (through reference chain: "); [EOL]     sb = getPathReference(sb); [EOL]     sb.append(')'); [EOL]     return sb.toString(); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType)); [EOL]             if (ser == null) { [EOL]                 ser = _createAndCacheUntypedSerializer(valueType); [EOL]                 if (ser == null) { [EOL]                     ser = getUnknownTypeSerializer(valueType); [EOL]                     if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                     } [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
