public void testGetFunctionNameLast() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_LAST); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("last", result); [EOL] }
public void testGetFunctionNamePosition() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_POSITION); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("position", result); [EOL] }
public void testGetFunctionNameCount() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_COUNT); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("count", result); [EOL] }
public void testGetFunctionNameId() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_ID); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("id", result); [EOL] }
public void testGetFunctionNameLocalName() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_LOCAL_NAME); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("local-name", result); [EOL] }
public void testGetFunctionNameNamespaceUri() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_NAMESPACE_URI); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("namespace-uri", result); [EOL] }
public void testGetFunctionNameName() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_NAME); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("name", result); [EOL] }
public void testGetFunctionNameString() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_STRING); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("string", result); [EOL] }
public void testGetFunctionNameConcat() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_CONCAT); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("concat", result); [EOL] }
public void testGetFunctionNameStartsWith() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_STARTS_WITH); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("starts-with", result); [EOL] }
public void testGetFunctionNameContains() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_CONTAINS); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("contains", result); [EOL] }
public void testGetFunctionNameSubstringBefore() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_SUBSTRING_BEFORE); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("substring-before", result); [EOL] }
public void testGetFunctionNameSubstringAfter() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_SUBSTRING_AFTER); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("substring-after", result); [EOL] }
public void testGetFunctionNameSubstring() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_SUBSTRING); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("substring", result); [EOL] }
public void testGetFunctionNameStringLength() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_STRING_LENGTH); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("string-length", result); [EOL] }
public void testGetFunctionNameNormalizeSpace() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_NORMALIZE_SPACE); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("normalize-space", result); [EOL] }
public void testGetFunctionNameTranslate() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_TRANSLATE); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("translate", result); [EOL] }
public void testGetFunctionNameBoolean() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_BOOLEAN); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("boolean", result); [EOL] }
public void testGetFunctionNameNot() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_NOT); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("not", result); [EOL] }
public void testGetFunctionNameTrue() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_TRUE); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("true", result); [EOL] }
public void testGetFunctionNameFalse() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_FALSE); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("false", result); [EOL] }
public void testGetFunctionNameLang() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_LANG); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("lang", result); [EOL] }
public void testGetFunctionNameNumber() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_NUMBER); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("number", result); [EOL] }
public void testGetFunctionNameSum() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_SUM); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("sum", result); [EOL] }
public void testGetFunctionNameFloor() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_FLOOR); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("floor", result); [EOL] }
public void testGetFunctionNameCeiling() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_CEILING); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("ceiling", result); [EOL] }
public void testGetFunctionNameRound() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_ROUND); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("round", result); [EOL] }
public void testGetFunctionNameKey() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_KEY); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("key", result); [EOL] }
public void testGetFunctionNameFormatNumber() { [EOL] YourClass instance = new YourClass(Compiler.FUNCTION_FORMAT_NUMBER); [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("format-number", result); [EOL] }
public void testGetFunctionNameUnknown() { [EOL] YourClass instance = new YourClass(-1); // Assuming -1 is not a valid function code [EOL] String result = instance.getFunctionName(); [EOL] assertEquals("unknownFunction-1()", result); [EOL] }
public void testToStringWithNoArguments() { [EOL] Function function = new Function("testFunction", null); [EOL] String result = function.toString(); [EOL] assertEquals("testFunction()", result); [EOL] }
public void testToStringWithOneArgument() { [EOL] Expression[] args = new Expression[]{new Expression("arg1")}; [EOL] Function function = new Function("testFunction", args); [EOL] String result = function.toString(); [EOL] assertEquals("testFunction(arg1)", result); [EOL] }
public void testToStringWithMultipleArguments() { [EOL] Expression[] args = new Expression[]{new Expression("arg1"), new Expression("arg2")}; [EOL] Function function = new Function("testFunction", args); [EOL] String result = function.toString(); [EOL] assertEquals("testFunction(arg1, arg2)", result); [EOL] }
public int getOrder() { [EOL] return DYNAMIC_POINTER_FACTORY_ORDER; [EOL] }
public void testRootContextWithNonNullPointer() { [EOL] JXPathContextReferenceImpl context = mock(JXPathContextReferenceImpl.class); [EOL] NodePointer mockPointer = mock(NodePointer.class); [EOL] new RootContext(context, mockPointer); [EOL] verify(mockPointer).setNamespaceResolver(context.getNamespaceResolver()); [EOL] } [EOL] public void testRootContextWithNullPointer() { [EOL] JXPathContextReferenceImpl context = mock(JXPathContextReferenceImpl.class); [EOL] new RootContext(context, null); [EOL] }
public void testGetJXPathContextNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.jxpathContext = new JXPathContext(); // Assuming JXPathContext is a valid object [EOL] JXPathContext result = instance.getJXPathContext(); [EOL] assertNotNull(result); [EOL] }
public void testGetRootContext() { [EOL] RootContext rootContext = new RootContext(); [EOL] RootContext result = rootContext.getRootContext(); [EOL] assertSame("getRootContext should return the current instance", rootContext, result); [EOL] }
public void testGetCurrentNodePointer() { [EOL] NodePointer expectedPointer = ...; // Initialize with an appropriate value [EOL] MyClass instance = new MyClass(expectedPointer); // Assuming MyClass is the class containing getCurrentNodePointer [EOL] NodePointer result = instance.getCurrentNodePointer(); [EOL] assertEquals(expectedPointer, result); [EOL] }
public void testGetConstantContextWithNodeSet() { [EOL] NodeSet nodeSet = new NodeSet(); // Assuming NodeSet is a valid type for the context [EOL] EvalContext context = getConstantContext(nodeSet); [EOL] assertTrue(context instanceof NodeSetContext); [EOL] }
public void testGetConstantContextWithNodePointer() { [EOL] NodePointer nodePointer = NodePointer.newNodePointer(new QName(null, ""), new Object(), null); // Assuming this is a valid way to create a NodePointer [EOL] EvalContext context = getConstantContext(nodePointer); [EOL] assertTrue(context instanceof InitialContext); [EOL] }
public void testGetConstantContextWithOtherObject() { [EOL] Object constant = new Object(); // Any object that is not an instance of NodeSet or NodePointer [EOL] EvalContext context = getConstantContext(constant); [EOL] assertTrue(context instanceof InitialContext); [EOL] }
public void testGetVariableContextWithValidName() { [EOL] JXPathContext jxpathContext = JXPathContext.newContext(new Object()); [EOL] QName variableName = new QName("validName"); [EOL] jxpathContext.getVariables().declareVariable("validName", "value"); [EOL] EvalContext result = jxpathContext.getVariableContext(variableName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof InitialContext); [EOL] Pointer pointer = result.getSingleNodePointer(); [EOL] assertNotNull(pointer); [EOL] assertEquals("value", pointer.getValue()); [EOL] }
public void testGetVariableContextWithInvalidName() { [EOL] JXPathContext jxpathContext = JXPathContext.newContext(new Object()); [EOL] QName variableName = new QName("invalidName"); [EOL] EvalContext result = jxpathContext.getVariableContext(variableName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof InitialContext); [EOL] Pointer pointer = result.getSingleNodePointer(); [EOL] assertNull(pointer.getValue()); [EOL] }
public void testGetFunctionWithValidFunctionNameAndParameters() { [EOL] QName functionName = new QName("validFunctionName"); [EOL] Object[] parameters = new Object[] { "param1", 2, 3.0 }; [EOL] JXPathContext jxpathContext = JXPathContext.newContext(new Object()); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(jxpathContext.getFunction(functionName, parameters)).thenReturn(expectedFunction); [EOL] Function actualFunction = jxpathContext.getFunction(functionName, parameters); [EOL] assertEquals("The returned function should be the one provided by the context", expectedFunction, actualFunction); [EOL] }
public void testGetFunctionWithNullFunctionName() { [EOL] Object[] parameters = new Object[] { "param1", 2, 3.0 }; [EOL] JXPathContext jxpathContext = JXPathContext.newContext(new Object()); [EOL] try { [EOL] jxpathContext.getFunction(null, parameters); [EOL] fail("Should have thrown IllegalArgumentException for null functionName"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFunctionWithNullParameters() { [EOL] QName functionName = new QName("validFunctionName"); [EOL] JXPathContext jxpathContext = JXPathContext.newContext(new Object()); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(jxpathContext.getFunction(functionName, null)).thenReturn(expectedFunction); [EOL] Function actualFunction = jxpathContext.getFunction(functionName, null); [EOL] assertEquals("The returned function should be the one provided by the context with null parameters", expectedFunction, actualFunction); [EOL] }
public void testAsPathWithIdNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setId("someId"); [EOL] String result = instance.asPath(); [EOL] assertEquals("id('someId')", result); [EOL] }
public void testAsPathWithParentNotNullElementNode() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Element node = mock(Element.class); [EOL] instance.setNode(node); [EOL] when(node instanceof Element).thenReturn(true); [EOL] when(parentInstance instanceof JDOMNodePointer).thenReturn(true); [EOL] when(instance.getNamespaceURI()).thenReturn("namespaceURI"); [EOL] when(JDOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] when(instance.equalStrings("namespaceURI", instance.getNamespaceResolver().getDefaultNamespaceURI())).thenReturn(true); [EOL] when(instance.getRelativePositionByName()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/localName[1]", result); [EOL] }
public void testAsPathWithParentNotNullElementNodeDifferentNamespace() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Element node = mock(Element.class); [EOL] instance.setNode(node); [EOL] when(node instanceof Element).thenReturn(true); [EOL] when(parentInstance instanceof JDOMNodePointer).thenReturn(true); [EOL] String nsURI = "differentNamespaceURI"; [EOL] when(instance.getNamespaceURI()).thenReturn(nsURI); [EOL] when(JDOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] when(instance.equalStrings(nsURI, instance.getNamespaceResolver().getDefaultNamespaceURI())).thenReturn(false); [EOL] when(instance.getNamespaceResolver().getPrefix(nsURI)).thenReturn("prefix"); [EOL] when(instance.getRelativePositionByName()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/prefix:localName[1]", result); [EOL] }
public void testAsPathWithParentNotNullElementNodeNoNamespace() { [EOL] YourClass instance = new YourClass(); [EOL] YourClass parentInstance = new YourClass(); [EOL] parentInstance.setId("parentId"); [EOL] instance.setParent(parentInstance); [EOL] Element node = mock(Element.class); [EOL] instance.setNode(node); [EOL] when(node instanceof Element).thenReturn(true); [EOL] when(parentInstance instanceof JDOMNodePointer).thenReturn(true); [EOL] when(instance.getNamespaceURI()).thenReturn("namespaceURI"); [EOL] when(JDOMNodePointer.getLocalName(node)).thenReturn("localName"); [EOL] when(instance.equalStrings("namespaceURI", instance.getNamespaceResolver().getDefaultNamespaceURI())).thenReturn(false); [EOL] when(instance.getNamespaceResolver().getPrefix("namespaceURI")).thenReturn(null); [EOL] when(instance.getRelativePositionOfElement()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/node()[1]", result); [EOL] }
public void testAsPathWithTextNode() { [EOL] YourClass instance = new YourClass(); [EOL] Text node = mock(Text.class); [EOL] instance.setNode(node); [EOL] when(node instanceof Text).thenReturn(true); [EOL] when(instance.getRelativePositionOfTextNode()).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/text()[1]", result); [EOL] }
public void testAsPathWithProcessingInstruction() { [EOL] YourClass instance = new YourClass(); [EOL] ProcessingInstruction node = mock(ProcessingInstruction.class); [EOL] instance.setNode(node); [EOL] when(node instanceof ProcessingInstruction).thenReturn(true); [EOL] when(((ProcessingInstruction) node).getTarget()).thenReturn("target"); [EOL] when(instance.getRelativePositionOfPI("target")).thenReturn(1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/processing-instruction('target')[1]", result); [EOL] }
public void testGetRelativePositionByName_NodeIsNotElement() { [EOL] Object node = new Object(); [EOL] int result = getRelativePositionByName(node); [EOL] assertEquals(1, result); [EOL] }
public void testGetRelativePositionByName_NodeIsElementButParentIsNot() { [EOL] Element node = mock(Element.class); [EOL] Object parent = new Object(); [EOL] when(node.getParent()).thenReturn(parent); [EOL] int result = getRelativePositionByName(node); [EOL] assertEquals(1, result); [EOL] }
public void testGetRelativePositionByName_NodeIsElementWithElementParentAndNoMatchingSiblings() { [EOL] Element node = mock(Element.class); [EOL] Element parent = mock(Element.class); [EOL] List children = new ArrayList(); [EOL] children.add(node); [EOL] when(node.getParent()).thenReturn(parent); [EOL] when(parent.getContent()).thenReturn(children); [EOL] when(node.getQualifiedName()).thenReturn("uniqueName"); [EOL] int result = getRelativePositionByName(node); [EOL] assertEquals(1, result); [EOL] }
public void testGetRelativePositionByName_NodeIsElementWithElementParentAndMatchingSiblings() { [EOL] Element node = mock(Element.class); [EOL] Element parent = mock(Element.class); [EOL] Element siblingWithDifferentName = mock(Element.class); [EOL] Element siblingWithSameName = mock(Element.class); [EOL] List children = new ArrayList(); [EOL] children.add(siblingWithDifferentName); [EOL] children.add(siblingWithSameName); [EOL] children.add(node); [EOL] when(node.getParent()).thenReturn(parent); [EOL] when(parent.getContent()).thenReturn(children); [EOL] when(node.getQualifiedName()).thenReturn("sameName"); [EOL] when(siblingWithSameName.getQualifiedName()).thenReturn("sameName"); [EOL] int result = getRelativePositionByName(node); [EOL] assertEquals(2, result); [EOL] }
public void testEquals_SameObject() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] assertTrue(pointer.equals(pointer)); [EOL] }
public void testEquals_DifferentClass() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] Object other = new Object(); [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_NullParent() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.parent = null; [EOL] other.parent = new Object(); [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_NullName() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.name = null; [EOL] other.name = "test"; [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_DifferentIndex() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.index = 1; [EOL] other.index = 2; [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_DifferentDynaBeanPointer_DifferentDynaBean() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.dynaBean = new Object(); [EOL] other.dynaBean = new Object(); [EOL] assertFalse(pointer.equals(other)); [EOL] }
public void testEquals_EqualDynaBeanPointer() { [EOL] DynaBeanPointer pointer = new DynaBeanPointer(); [EOL] DynaBeanPointer other = new DynaBeanPointer(); [EOL] pointer.parent = other.parent = new Object(); [EOL] pointer.name = other.name = "test"; [EOL] pointer.index = other.index = 1; [EOL] pointer.dynaBean = other.dynaBean = new Object(); [EOL] assertTrue(pointer.equals(other)); [EOL] }
public void testNCNameWithNCNameToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = NCName; [EOL] token.image = "expectedNCName"; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = token; [EOL] parser.jj_nt = token; [EOL] String result = parser.NCName(); [EOL] assertEquals("expectedNCName", result); [EOL] }
public void testNCNameWithNodeToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = NODE; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(NODE, parser.token.kind); [EOL] }
public void testNCNameWithTextToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = TEXT; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(TEXT, parser.token.kind); [EOL] }
public void testNCNameWithCommentToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = COMMENT; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(COMMENT, parser.token.kind); [EOL] }
public void testNCNameWithPIToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = PI; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(PI, parser.token.kind); [EOL] }
public void testNCNameWithFunctionLastToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_LAST; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_LAST, parser.token.kind); [EOL] }
public void testNCNameWithFunctionPositionToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_POSITION; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_POSITION, parser.token.kind); [EOL] }
public void testNCNameWithFunctionCountToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_COUNT; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_COUNT, parser.token.kind); [EOL] }
public void testNCNameWithFunctionIdToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_ID; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_ID, parser.token.kind); [EOL] }
public void testNCNameWithFunctionLocalNameToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_LOCAL_NAME; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_LOCAL_NAME, parser.token.kind); [EOL] }
public void testNCNameWithFunctionNamespaceURIToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_NAMESPACE_URI; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_NAMESPACE_URI, parser.token.kind); [EOL] }
public void testNCNameWithFunctionNameToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_NAME; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_NAME, parser.token.kind); [EOL] }
public void testNCNameWithFunctionStringToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_STRING; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_STRING, parser.token.kind); [EOL] }
public void testNCNameWithFunctionConcatToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_CONCAT; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_CONCAT, parser.token.kind); [EOL] }
public void testNCNameWithFunctionStartsWithToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_STARTS_WITH; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_STARTS_WITH, parser.token.kind); [EOL] }
public void testNCNameWithFunctionContainsToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_CONTAINS; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_CONTAINS, parser.token.kind); [EOL] }
public void testNCNameWithFunctionSubstringBeforeToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_SUBSTRING_BEFORE; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_SUBSTRING_BEFORE, parser.token.kind); [EOL] }
public void testNCNameWithFunctionSubstringAfterToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_SUBSTRING_AFTER; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_SUBSTRING_AFTER, parser.token.kind); [EOL] }
public void testNCNameWithFunctionSubstringToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_SUBSTRING; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_SUBSTRING, parser.token.kind); [EOL] }
public void testNCNameWithFunctionStringLengthToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_STRING_LENGTH; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_STRING_LENGTH, parser.token.kind); [EOL] }
public void testNCNameWithFunctionNormalizeSpaceToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_NORMALIZE_SPACE; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_NORMALIZE_SPACE, parser.token.kind); [EOL] }
public void testNCNameWithFunctionTranslateToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_TRANSLATE; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_TRANSLATE, parser.token.kind); [EOL] }
public void testNCNameWithFunctionBooleanToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_BOOLEAN; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_BOOLEAN, parser.token.kind); [EOL] }
public void testNCNameWithFunctionNotToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_NOT; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_NOT, parser.token.kind); [EOL] }
public void testNCNameWithFunctionTrueToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_TRUE; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_TRUE, parser.token.kind); [EOL] }
public void testNCNameWithFunctionFalseToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_FALSE; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_FALSE, parser.token.kind); [EOL] }
public void testNCNameWithFunctionNullToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_NULL; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_NULL, parser.token.kind); [EOL] }
public void testNCNameWithFunctionLangToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_LANG; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_LANG, parser.token.kind); [EOL] }
public void testNCNameWithFunctionNumberToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_NUMBER; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_NUMBER, parser.token.kind); [EOL] }
public void testNCNameWithFunctionSumToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_SUM; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_SUM, parser.token.kind); [EOL] }
public void testNCNameWithFunctionFloorToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_FLOOR; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_FLOOR, parser.token.kind); [EOL] }
public void testNCNameWithFunctionCeilingToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_CEILING; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_CEILING, parser.token.kind); [EOL] }
public void testNCNameWithFunctionRoundToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_ROUND; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = a new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_ROUND, parser.token.kind); [EOL] }
public void testNCNameWithFunctionKeyToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_KEY; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_KEY, parser.token.kind); [EOL] }
public void testNCNameWithFunctionFormatNumberToken() throws ParseException { [EOL] Token token = new Token(); [EOL] token.kind = FUNCTION_FORMAT_NUMBER; [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] parser.NCName(); [EOL] assertEquals(FUNCTION_FORMAT_NUMBER, parser.token.kind); [EOL] }
public void testNCNameWithInvalidToken() { [EOL] Token token = new Token(); [EOL] token.kind = -1; // Invalid token kind [EOL] Parser parser = new Parser(new StringReader("")); [EOL] parser.token = new Token(); [EOL] parser.jj_nt = token; [EOL] try { [EOL] parser.NCName(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testNCName_Without_CoreFunctions_NCName() throws ParseException { [EOL] jj_nt.kind = NCName; [EOL] token.image = "NCNameToken"; [EOL] String result = NCName_Without_CoreFunctions(); [EOL] assertEquals("NCNameToken", result); [EOL] }
public void testNCName_Without_CoreFunctions_OR() throws ParseException { [EOL] jj_nt.kind = OR; [EOL] token.image = "ORToken"; [EOL] String result = NCName_Without_CoreFunctions(); [EOL] assertEquals("ORToken", result); [EOL] }
public void testNCName_Without_CoreFunctions_AND() throws ParseException { [EOL] jj_nt.kind = AND; [EOL] token.image = "ANDToken"; [EOL] String result = NCName_Without_CoreFunctions(); [EOL] assertEquals("ANDToken", result); [EOL] }
public void testNCName_Without_CoreFunctions_MOD() throws ParseException { [EOL] jj_nt.kind = MOD; [EOL] token.image = "MODToken"; [EOL] String result = NCName_Without_CoreFunctions(); [EOL] assertEquals("MODToken", result); [EOL] }
public void testNCName_Without_CoreFunctions_DIV() throws ParseException { [EOL] jj_nt.kind = DIV; [EOL] token.image = "DIVToken"; [EOL] String result = NCName_Without_CoreFunctions(); [EOL] assertEquals("DIVToken", result); [EOL] }
public void testNCName_Without_CoreFunctions_Default() { [EOL] jj_nt.kind = INVALID_KIND; // INVALID_KIND is a made-up constant representing an invalid kind [EOL] token.image = "InvalidToken"; [EOL] assertThrows(ParseException.class, () -> { [EOL] NCName_Without_CoreFunctions(); [EOL] }); [EOL] }
public void testCoreFunctionNameWithFunctionLast() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LAST; [EOL] int expectedCode = Compiler.FUNCTION_LAST; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionPosition() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_POSITION; [EOL] int expectedCode = Compiler.FUNCTION_POSITION; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionCount() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_COUNT; [EOL] int expectedCode = Compiler.FUNCTION_COUNT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionId() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_ID; [EOL] int expectedCode = Compiler.FUNCTION_ID; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionLocalName() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LOCAL_NAME; [EOL] int expectedCode = Compiler.FUNCTION_LOCAL_NAME; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNamespaceUri() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NAMESPACE_URI; [EOL] int expectedCode = Compiler.FUNCTION_NAMESPACE_URI; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionName() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NAME; [EOL] int expectedCode = Compiler.FUNCTION_NAME; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionString() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STRING; [EOL] int expectedCode = Compiler.FUNCTION_STRING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionConcat() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CONCAT; [EOL] int expectedCode = Compiler.FUNCTION_CONCAT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionStartsWith() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STARTS_WITH; [EOL] int expectedCode = Compiler.FUNCTION_STARTS_WITH; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionContains() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CONTAINS; [EOL] int expectedCode = Compiler.FUNCTION_CONTAINS; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstringBefore() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING_BEFORE; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstringAfter() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING_AFTER; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSubstring() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUBSTRING; [EOL] int expectedCode = Compiler.FUNCTION_SUBSTRING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionStringLength() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_STRING_LENGTH; [EOL] int expectedCode = Compiler.FUNCTION_STRING_LENGTH; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNormalizeSpace() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NORMALIZE_SPACE; [EOL] int expectedCode = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionTranslate() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_TRANSLATE; [EOL] int expectedCode = Compiler.FUNCTION_TRANSLATE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionBoolean() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_BOOLEAN; [EOL] int expectedCode = Compiler.FUNCTION_BOOLEAN; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNot() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NOT; [EOL] int expectedCode = Compiler.FUNCTION_NOT; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionTrue() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_TRUE; [EOL] int expectedCode = Compiler.FUNCTION_TRUE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFalse() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FALSE; [EOL] int expectedCode = Compiler.FUNCTION_FALSE; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNull() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NULL; [EOL] int expectedCode = Compiler.FUNCTION_NULL; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionLang() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_LANG; [EOL] int expectedCode = Compiler.FUNCTION_LANG; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionNumber() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_NUMBER; [EOL] int expectedCode = Compiler.FUNCTION_NUMBER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionSum() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_SUM; [EOL] int expectedCode = Compiler.FUNCTION_SUM; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFloor() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FLOOR; [EOL] int expectedCode = Compiler.FUNCTION_FLOOR; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionCeiling() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_CEILING; [EOL] int expectedCode = Compiler.FUNCTION_CEILING; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionRound() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_ROUND; [EOL] int expectedCode = Compiler.FUNCTION_ROUND; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionKey() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_KEY; [EOL] int expectedCode = Compiler.FUNCTION_KEY; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithFunctionFormatNumber() throws ParseException { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = FUNCTION_FORMAT_NUMBER; [EOL] int expectedCode = Compiler.FUNCTION_FORMAT_NUMBER; [EOL] int resultCode = CoreFunctionName(); [EOL] assertEquals(expectedCode, resultCode); [EOL] }
public void testCoreFunctionNameWithInvalidKind() { [EOL] Token jj_nt = new Token(); [EOL] jj_nt.kind = INVALID_KIND; // Assuming INVALID_KIND is a constant for an invalid kind [EOL] try { [EOL] CoreFunctionName(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testQNameWithNoNc2() throws ParseException { [EOL] JxPathParser parser = new JxPathParser(new StringReader("")); [EOL] JxPathParserTokenManager tokenManager = new JxPathParserTokenManager(new SimpleCharStream(new StringReader(""))); [EOL] parser.token_source = tokenManager; [EOL] parser.jj_nt = new Token(); [EOL] parser.jj_nt.kind = 80; // A kind that is not 79 to avoid entering the case block [EOL] parser.compiler = mock(Compiler.class); [EOL] when(parser.NCName()).thenReturn("localPart"); [EOL] Object result = parser.QName(); [EOL] verify(parser.compiler).qname(null, "localPart"); [EOL] assertNull("nc2 should be null", result); [EOL] }
public void testQNameWithNc2() throws ParseException { [EOL] JxPathParser parser = new JxPathParser(new StringReader("")); [EOL] JxPathParserTokenManager tokenManager = new JxPathParserTokenManager(new SimpleCharStream(new StringReader(""))); [EOL] parser.token_source = tokenManager; [EOL] parser.jj_nt = new Token(); [EOL] parser.jj_nt.kind = 79; // The kind that matches the case statement [EOL] parser.compiler = mock(Compiler.class); [EOL] when(parser.NCName()).thenReturn("prefix").thenReturn("localPart"); [EOL] Object result = parser.QName(); [EOL] verify(parser.compiler).qname("prefix", "localPart"); [EOL] assertNotNull("nc2 should not be null", result); [EOL] }
public void testQName_Without_CoreFunctions_Path1() throws ParseException { [EOL] when(jj_2_1(2147483647)).thenReturn(true); [EOL] when(NCName()).thenReturn("localPart"); [EOL] when(compiler.qname(null, "localPart")).thenReturn(new Object()); [EOL] Object result = QName_Without_CoreFunctions(); [EOL] assertNotNull(result); [EOL] }
public void testQName_Without_CoreFunctions_Path2() throws ParseException { [EOL] when(jj_2_1(2147483647)).thenReturn(true); [EOL] when(NCName()).thenReturn("prefix").thenReturn("localPart"); [EOL] when(compiler.qname("prefix", "localPart")).thenReturn(new Object()); [EOL] Object result = QName_Without_CoreFunctions(); [EOL] assertNotNull(result); [EOL] }
public void testQName_Without_CoreFunctions_Path3() throws ParseException { [EOL] when(jj_2_1(2147483647)).thenReturn(false); [EOL] when(jj_nt.kind).thenReturn(NCName); [EOL] when(NCName_Without_CoreFunctions()).thenReturn("localPart"); [EOL] when(compiler.qname(null, "localPart")).thenReturn(new Object()); [EOL] Object result = QName_Without_CoreFunctions(); [EOL] assertNotNull(result); [EOL] }
public void testQName_Without_CoreFunctions_Path4() throws ParseException { [EOL] when(jj_2_1(2147483647)).thenReturn(false); [EOL] when(jj_nt.kind).thenReturn(INVALID_KIND); // INVALID_KIND is a placeholder for an invalid kind [EOL] doThrow(new ParseException()).when(jj_consume_token(-1)); [EOL] assertThrows(ParseException.class, () -> { [EOL] QName_Without_CoreFunctions(); [EOL] }); [EOL] }
public Object testLocationPathWithRelativeLocationPath() throws ParseException { [EOL] jj_nt.kind = OR; // OR is one of the kinds that lead to RelativeLocationPath [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); // Assuming RelativeLocationPath returns a non-null object [EOL] return result; [EOL] }
public Object testLocationPathWithAbsoluteLocationPath() throws ParseException { [EOL] jj_nt.kind = SLASH; // SLASH is one of the kinds that lead to AbsoluteLocationPath [EOL] Object result = LocationPath(); [EOL] assertNotNull(result); // Assuming AbsoluteLocationPath returns a non-null object [EOL] return result; [EOL] }
public void testLocationPathWithParseException() { [EOL] jj_nt.kind = 999; // An invalid kind that is not handled by the switch [EOL] assertThrows(ParseException.class, () -> { [EOL] LocationPath(); [EOL] }); [EOL] }
public void testLocationStepWithSlash() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Token(); [EOL] jjParser.jj_nt.kind = JJParserConstants.SLASH; [EOL] jjParser.LocationStep(steps); [EOL] assertTrue(steps.isEmpty()); [EOL] }
public void testLocationStepWithSlashSlash() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Token(); [EOL] jjParser.jj_nt.kind = JJParserConstants.SLASHSLASH; [EOL] jjParser.LocationStep(steps); [EOL] assertFalse(steps.isEmpty()); [EOL] assertEquals(Compiler.AXIS_DESCENDANT_OR_SELF, ((Step) steps.get(0)).axis); [EOL] assertEquals(Compiler.NODE_TYPE_NODE, ((Step) steps.get(0)).nodeTest); [EOL] }
public void testLocationStepWithInvalidToken() { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Token(); [EOL] jjParser.jj_nt.kind = JJParserConstants.INVALID; // Assuming INVALID is a valid constant for an invalid token [EOL] try { [EOL] jjParser.LocationStep(steps); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testNodeTestWithNodeType() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NODE; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithProcessingInstruction() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.PI; [EOL] jjParser.jj_2_4(2147483647); [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithWildcardName() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NCName; [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithSelfAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 82; // Assuming 82 corresponds to a valid kind for AXIS_SELF [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParentAxis() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = 83; // Assuming 83 corresponds to a valid kind for AXIS_PARENT [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithPredicate() throws ParseException { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = JJParser.NODE; // Assuming NODE is a valid kind that will not enter the predicate loop [EOL] jjParser.NodeTest(steps); [EOL] } [EOL] public void testNodeTestWithParseException() { [EOL] ArrayList steps = new ArrayList(); [EOL] JJParser jjParser = new JJParser(); [EOL] jjParser.jj_nt = new Node(); [EOL] jjParser.jj_nt.kind = -1; // Assuming -1 is an invalid kind that will cause ParseException [EOL] try { [EOL] jjParser.NodeTest(steps); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testAxisSpecifierWithAxisSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisPreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisPrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithAxisDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AxisName(), result); [EOL] } [EOL] public void testAxisSpecifierWithDefault() throws ParseException { [EOL] jj_nt.kind = SOME_OTHER_KIND; [EOL] int result = AxisSpecifier(); [EOL] assertEquals(AbbreviatedAxisSpecifier(), result); [EOL] }
public void testAxisNameSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_SELF, result); [EOL] }
public void testAxisNameChild() throws ParseException { [EOL] jj_nt.kind = AXIS_CHILD; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_CHILD, result); [EOL] }
public void testAxisNameParent() throws ParseException { [EOL] jj_nt.kind = AXIS_PARENT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PARENT, result); [EOL] }
public void testAxisNameAncestor() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR, result); [EOL] }
public void testAxisNameAttribute() throws ParseException { [EOL] jj_nt.kind = AXIS_ATTRIBUTE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ATTRIBUTE, result); [EOL] }
public void testAxisNameNamespace() throws ParseException { [EOL] jj_nt.kind = AXIS_NAMESPACE; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_NAMESPACE, result); [EOL] }
public void testAxisNamePreceding() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING, result); [EOL] }
public void testAxisNameFollowing() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING, result); [EOL] }
public void testAxisNameDescendant() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT, result); [EOL] }
public void testAxisNameAncestorOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_ANCESTOR_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_ANCESTOR_OR_SELF, result); [EOL] }
public void testAxisNameFollowingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_FOLLOWING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_FOLLOWING_SIBLING, result); [EOL] }
public void testAxisNamePrecedingSibling() throws ParseException { [EOL] jj_nt.kind = AXIS_PRECEDING_SIBLING; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_PRECEDING_SIBLING, result); [EOL] }
public void testAxisNameDescendantOrSelf() throws ParseException { [EOL] jj_nt.kind = AXIS_DESCENDANT_OR_SELF; [EOL] int result = AxisName(); [EOL] assertEquals(Compiler.AXIS_DESCENDANT_OR_SELF, result); [EOL] }
public void testAxisNameInvalid() { [EOL] jj_nt.kind = INVALID_AXIS; // Assuming INVALID_AXIS is a constant for an invalid axis [EOL] assertThrows(ParseException.class, () -> { [EOL] AxisName(); [EOL] }); [EOL] }
public void testPredicateWithValidInput() throws ParseException { [EOL] jj_consume_token(84); [EOL] Object result = Predicate(); [EOL] jj_consume_token(85); [EOL] assertNotNull(result); [EOL] }
public void testPredicateWithParseExceptionOnFirstToken() { [EOL] try { [EOL] jj_consume_token(84); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testPredicateWithParseExceptionOnSecondToken() throws ParseException { [EOL] jj_consume_token(84); [EOL] Expression(); [EOL] try { [EOL] jj_consume_token(85); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testAbbreviatedAxisSpecifierChildAxis() throws ParseException { [EOL] Compiler compiler = new Compiler(); [EOL] compiler.jj_nt = new NodeToken(); [EOL] compiler.jj_nt.kind = 85; // Assuming 85 is not the case 86 [EOL] int result = compiler.AbbreviatedAxisSpecifier(); [EOL] assertEquals(Compiler.AXIS_CHILD, result); [EOL] }
public void testAbbreviatedAxisSpecifierAttributeAxis() throws ParseException { [EOL] Compiler compiler = new Compiler(); [EOL] compiler.jj_nt = new NodeToken(); [EOL] compiler.jj_nt.kind = 86; // The kind that triggers AXIS_ATTRIBUTE [EOL] int result = compiler.AbbreviatedAxisSpecifier(); [EOL] assertEquals(Compiler.AXIS_ATTRIBUTE, result); [EOL] }
public void testPrimaryExprWithVariable() throws ParseException { [EOL] jj_nt.kind = VARIABLE; [EOL] Object result = PrimaryExpr(); [EOL] assertNotNull(result); [EOL] }
public void testPrimaryExprWithLiteral() throws ParseException { [EOL] jj_nt.kind = Literal; [EOL] token.image = "\"literal\""; [EOL] Object result = PrimaryExpr(); [EOL] assertNotNull(result); [EOL] }
public void testPrimaryExprWithNumber() throws ParseException { [EOL] jj_nt.kind = Number; [EOL] token.image = "123"; [EOL] Object result = PrimaryExpr(); [EOL] assertNotNull(result); [EOL] }
public void testPrimaryExprWithParentheses() throws ParseException { [EOL] jj_nt.kind = 80; [EOL] Object result = PrimaryExpr(); [EOL] assertNotNull(result); [EOL] }
public void testPrimaryExprWithFunctionCall() throws ParseException { [EOL] forceConditionForCoreFunctionCall(); // This method needs to be implemented [EOL] Object result = PrimaryExpr(); [EOL] assertNotNull(result); [EOL] }
public void testPrimaryExprWithParseException() { [EOL] setConditionForParseException(); // This method needs to be implemented [EOL] assertThrows(ParseException.class, () -> { [EOL] PrimaryExpr(); [EOL] }); [EOL] }
public void testFunctionCallWithNullArguments() throws ParseException { [EOL] Compiler mockCompiler = Mockito.mock(Compiler.class); [EOL] JXPathContext context = new JXPathContext(); [EOL] context.setCompiler(mockCompiler); [EOL] Mockito.when(mockCompiler.function(Mockito.any(), Mockito.isNull())).thenReturn(new Object()); [EOL] Object result = context.FunctionCall(); [EOL] assertNotNull(result); [EOL] Mockito.verify(mockCompiler).function(Mockito.any(), Mockito.isNull()); [EOL] }
public void testFunctionCallWithNonNullArguments() throws ParseException { [EOL] Compiler mockCompiler = Mockito.mock(Compiler.class); [EOL] JXPathContext context = new JXPathContext(); [EOL] context.setCompiler(mockCompiler); [EOL] ArrayList<Object> arguments = new ArrayList<>(); [EOL] arguments.add(new Object()); [EOL] Mockito.when(mockCompiler.function(Mockito.any(), Mockito.any())).thenReturn(new Object()); [EOL] Object result = context.FunctionCall(); [EOL] assertNotNull(result); [EOL] Mockito.verify(mockCompiler).function(Mockito.any(), Mockito.any()); [EOL] }
public ArrayList ArgumentList() throws ParseException { [EOL] ArrayList args = null; [EOL] Object arg; [EOL] jj_consume_token(80); [EOL] switch(jj_nt.kind) { [EOL] case SLASH: [EOL] case SLASHSLASH: [EOL] case MINUS: [EOL] case VARIABLE: [EOL] case Literal: [EOL] case Number: [EOL] case OR: [EOL] case AND: [EOL] case MOD: [EOL] case DIV: [EOL] case NODE: [EOL] case TEXT: [EOL] case COMMENT: [EOL] case PI: [EOL] case AXIS_SELF: [EOL] case AXIS_CHILD: [EOL] case AXIS_PARENT: [EOL] case AXIS_ANCESTOR: [EOL] case AXIS_ATTRIBUTE: [EOL] case AXIS_NAMESPACE: [EOL] case AXIS_PRECEDING: [EOL] case AXIS_FOLLOWING: [EOL] case AXIS_DESCENDANT: [EOL] case AXIS_ANCESTOR_OR_SELF: [EOL] case AXIS_FOLLOWING_SIBLING: [EOL] case AXIS_PRECEDING_SIBLING: [EOL] case AXIS_DESCENDANT_OR_SELF: [EOL] case FUNCTION_LAST: [EOL] case FUNCTION_POSITION: [EOL] case FUNCTION_COUNT: [EOL] case FUNCTION_ID: [EOL] case FUNCTION_KEY: [EOL] case FUNCTION_LOCAL_NAME: [EOL] case FUNCTION_NAMESPACE_URI: [EOL] case FUNCTION_NAME: [EOL] case FUNCTION_STRING: [EOL] case FUNCTION_CONCAT: [EOL] case FUNCTION_STARTS_WITH: [EOL] case FUNCTION_CONTAINS: [EOL] case FUNCTION_SUBSTRING_BEFORE: [EOL] case FUNCTION_SUBSTRING_AFTER: [EOL] case FUNCTION_SUBSTRING: [EOL] case FUNCTION_STRING_LENGTH: [EOL] case FUNCTION_NORMALIZE_SPACE: [EOL] case FUNCTION_TRANSLATE: [EOL] case FUNCTION_BOOLEAN: [EOL] case FUNCTION_NOT: [EOL] case FUNCTION_TRUE: [EOL] case FUNCTION_FALSE: [EOL] case FUNCTION_NULL: [EOL] case FUNCTION_LANG: [EOL] case FUNCTION_NUMBER: [EOL] case FUNCTION_SUM: [EOL] case FUNCTION_FLOOR: [EOL] case FUNCTION_CEILING: [EOL] case FUNCTION_ROUND: [EOL] case FUNCTION_FORMAT_NUMBER: [EOL] case NCName: [EOL] case 80: [EOL] case 82: [EOL] case 83: [EOL] case 86: [EOL] case 88: [EOL] arg = Argument(); [EOL] args = new ArrayList(); [EOL] args.add(arg); [EOL] label_4: while (true) { [EOL] switch(jj_nt.kind) { [EOL] case 87: [EOL] ; [EOL] break; [EOL] default: [EOL] jj_la1[18] = jj_gen; [EOL] break label_4; [EOL] } [EOL] jj_consume_token(87); [EOL] arg = Argument(); [EOL] args.add(arg); [EOL] } [EOL] break; [EOL] default: [EOL] jj_la1[19] = jj_gen; [EOL] ; [EOL] } [EOL] jj_consume_token(81); [EOL] { [EOL] if (true) [EOL] return args; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public Object testPathExprWithFilterExpr() throws ParseException { [EOL] setJj_2_6ToReturn(true); [EOL] Object result = PathExpr(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedFilterExprResult, result); [EOL] }
public Object testPathExprWithLocationPath() throws ParseException { [EOL] setJj_ntKindToLocationPathCase(); [EOL] Object result = PathExpr(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedLocationPathResult, result); [EOL] }
public Object testPathExprWithParseException() throws ParseException { [EOL] setJj_ntKindToDefaultCase(); [EOL] try { [EOL] PathExpr(); [EOL] fail("Expected ParseException to be thrown"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public Object testFilterExprWithNoPath() throws ParseException { [EOL] Object result = FilterExpr(); [EOL] assertNotNull(result); [EOL] Object expected = getPrimaryExprResult(); [EOL] assertEquals(expected, result); [EOL] assertTrue(ps.isEmpty()); [EOL] assertTrue(steps.isEmpty()); [EOL] }
public Object testFilterExprWithPathAndNoSteps() throws ParseException { [EOL] Object result = FilterExpr(); [EOL] assertNotNull(result); [EOL] assertNotEquals(getPrimaryExprResult(), result); [EOL] assertFalse(ps.isEmpty()); [EOL] assertTrue(steps.isEmpty()); [EOL] Object expected = getExpressionPathResult(ex, ps.toArray(), new Object[0]); [EOL] assertEquals(expected, result); [EOL] }
public Object testFilterExprWithPathAndSteps() throws ParseException { [EOL] Object result = FilterExpr(); [EOL] assertNotNull(result); [EOL] assertNotEquals(getPrimaryExprResult(), result); [EOL] assertFalse(ps.isEmpty()); [EOL] assertFalse(steps.isEmpty()); [EOL] Object expected = getExpressionPathResult(ex, ps.toArray(), steps.toArray()); [EOL] assertEquals(expected, result); [EOL] }
public Object testRelationalExprWithLT() throws ParseException { [EOL] jj_nt.kind = LT; [EOL] Object expected = new Object(); // Replace with actual expected value [EOL] Object ex = AdditiveExpr(); [EOL] Object r = AdditiveExpr(); [EOL] Object result = compiler.lessThan(ex, r); [EOL] Object actual = RelationalExpr(); [EOL] assertEquals(expected, actual); [EOL] return actual; [EOL] }
public Object testRelationalExprWithGT() throws ParseException { [EOL] jj_nt.kind = GT; [EOL] Object expected = new Object(); // Replace with actual expected value [EOL] Object ex = AdditiveExpr(); [EOL] Object r = AdditiveExpr(); [EOL] Object result = compiler.greaterThan(ex, r); [EOL] Object actual = RelationalExpr(); [EOL] assertEquals(expected, actual); [EOL] return actual; [EOL] }
public Object testRelationalExprWithLTE() throws ParseException { [EOL] jj_nt.kind = LTE; [EOL] Object expected = new Object(); // Replace with actual expected value [EOL] Object ex = AdditiveExpr(); [EOL] Object r = AdditiveExpr(); [EOL] Object result = compiler.lessThanOrEqual(ex, r); [EOL] Object actual = RelationalExpr(); [EOL] assertEquals(expected, actual); [EOL] return actual; [EOL] }
public Object testRelationalExprWithGTE() throws ParseException { [EOL] jj_nt.kind = GTE; [EOL] Object expected = new Object(); // Replace with actual expected value [EOL] Object ex = AdditiveExpr(); [EOL] Object r = AdditiveExpr(); [EOL] Object result = compiler.greaterThanOrEqual(ex, r); [EOL] Object actual = RelationalExpr(); [EOL] assertEquals(expected, actual); [EOL] return actual; [EOL] }
public void testRelationalExprWithParseException() { [EOL] jj_nt.kind = -1; // Invalid kind to trigger the default case and ParseException [EOL] assertThrows(ParseException.class, () -> { [EOL] RelationalExpr(); [EOL] }); [EOL] }
public Object MultiplicativeExpr() throws ParseException { [EOL] Object ex, r; [EOL] ex = UnaryExpr(); [EOL] label_14: while (true) { [EOL] switch(jj_nt.kind) { [EOL] case MOD: [EOL] case DIV: [EOL] case 88: [EOL] ; [EOL] break; [EOL] default: [EOL] jj_la1[32] = jj_gen; [EOL] break label_14; [EOL] } [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] r = UnaryExpr(); [EOL] ex = compiler.multiply(ex, r); [EOL] break; [EOL] case DIV: [EOL] jj_consume_token(DIV); [EOL] r = UnaryExpr(); [EOL] ex = compiler.divide(ex, r); [EOL] break; [EOL] case MOD: [EOL] jj_consume_token(MOD); [EOL] r = UnaryExpr(); [EOL] ex = compiler.mod(ex, r); [EOL] break; [EOL] default: [EOL] jj_la1[33] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] } [EOL] { [EOL] if (true) [EOL] return ex; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public Object testUnaryExprWithSlash() throws ParseException { [EOL] initParser("/"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnaryExprWithVariable() throws ParseException { [EOL] initParser("$variable"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public Object testUnaryExprWithMinus() throws ParseException { [EOL] initParser("-"); [EOL] Object result = parser.UnaryExpr(); [EOL] assertNotNull(result); [EOL] return result; [EOL] }
public void testUnaryExprWithInvalidToken() { [EOL] initParser("#"); [EOL] assertThrows(ParseException.class, () -> { [EOL] parser.UnaryExpr(); [EOL] }); [EOL] }
public Object testFunctionNameReturnsQName() throws ParseException { [EOL] Object expected = QName_Without_CoreFunctions(); [EOL] Object result = FunctionName(); [EOL] assertEquals(expected, result); [EOL] }
public Object testVariableReferenceWithValidVariable() throws ParseException { [EOL] Object expected = new Object(); // Replace with the expected object from compiler.variableReference [EOL] when(jj_consume_token(VARIABLE)).thenReturn(null); // Assuming jj_consume_token is a method that can be mocked [EOL] when(QName()).thenReturn(new Object()); // Assuming QName is a method that can be mocked [EOL] when(compiler.variableReference(any())).thenReturn(expected); // Assuming compiler is a mockable field [EOL] Object result = VariableReference(); [EOL] assertEquals(expected, result); [EOL] }
public Object WildcardName() throws ParseException { [EOL] Object qn; [EOL] String nc1, nc2 = null; [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] break; [EOL] case OR: [EOL] case AND: [EOL] case MOD: [EOL] case DIV: [EOL] case NODE: [EOL] case TEXT: [EOL] case COMMENT: [EOL] case PI: [EOL] case FUNCTION_LAST: [EOL] case FUNCTION_POSITION: [EOL] case FUNCTION_COUNT: [EOL] case FUNCTION_ID: [EOL] case FUNCTION_KEY: [EOL] case FUNCTION_LOCAL_NAME: [EOL] case FUNCTION_NAMESPACE_URI: [EOL] case FUNCTION_NAME: [EOL] case FUNCTION_STRING: [EOL] case FUNCTION_CONCAT: [EOL] case FUNCTION_STARTS_WITH: [EOL] case FUNCTION_CONTAINS: [EOL] case FUNCTION_SUBSTRING_BEFORE: [EOL] case FUNCTION_SUBSTRING_AFTER: [EOL] case FUNCTION_SUBSTRING: [EOL] case FUNCTION_STRING_LENGTH: [EOL] case FUNCTION_NORMALIZE_SPACE: [EOL] case FUNCTION_TRANSLATE: [EOL] case FUNCTION_BOOLEAN: [EOL] case FUNCTION_NOT: [EOL] case FUNCTION_TRUE: [EOL] case FUNCTION_FALSE: [EOL] case FUNCTION_NULL: [EOL] case FUNCTION_LANG: [EOL] case FUNCTION_NUMBER: [EOL] case FUNCTION_SUM: [EOL] case FUNCTION_FLOOR: [EOL] case FUNCTION_CEILING: [EOL] case FUNCTION_ROUND: [EOL] case FUNCTION_FORMAT_NUMBER: [EOL] case NCName: [EOL] NCName(); [EOL] break; [EOL] default: [EOL] jj_la1[35] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] nc1 = token.image; [EOL] switch(jj_nt.kind) { [EOL] case 79: [EOL] jj_consume_token(79); [EOL] switch(jj_nt.kind) { [EOL] case 88: [EOL] jj_consume_token(88); [EOL] break; [EOL] case OR: [EOL] case AND: [EOL] case MOD: [EOL] case DIV: [EOL] case NODE: [EOL] case TEXT: [EOL] case COMMENT: [EOL] case PI: [EOL] case FUNCTION_LAST: [EOL] case FUNCTION_POSITION: [EOL] case FUNCTION_COUNT: [EOL] case FUNCTION_ID: [EOL] case FUNCTION_KEY: [EOL] case FUNCTION_LOCAL_NAME: [EOL] case FUNCTION_NAMESPACE_URI: [EOL] case FUNCTION_NAME: [EOL] case FUNCTION_STRING: [EOL] case FUNCTION_CONCAT: [EOL] case FUNCTION_STARTS_WITH: [EOL] case FUNCTION_CONTAINS: [EOL] case FUNCTION_SUBSTRING_BEFORE: [EOL] case FUNCTION_SUBSTRING_AFTER: [EOL] case FUNCTION_SUBSTRING: [EOL] case FUNCTION_STRING_LENGTH: [EOL] case FUNCTION_NORMALIZE_SPACE: [EOL] case FUNCTION_TRANSLATE: [EOL] case FUNCTION_BOOLEAN: [EOL] case FUNCTION_NOT: [EOL] case FUNCTION_TRUE: [EOL] case FUNCTION_FALSE: [EOL] case FUNCTION_NULL: [EOL] case FUNCTION_LANG: [EOL] case FUNCTION_NUMBER: [EOL] case FUNCTION_SUM: [EOL] case FUNCTION_FLOOR: [EOL] case FUNCTION_CEILING: [EOL] case FUNCTION_ROUND: [EOL] case FUNCTION_FORMAT_NUMBER: [EOL] case NCName: [EOL] NCName(); [EOL] break; [EOL] default: [EOL] jj_la1[36] = jj_gen; [EOL] jj_consume_token(-1); [EOL] throw new ParseException(); [EOL] } [EOL] nc2 = token.image; [EOL] break; [EOL] default: [EOL] jj_la1[37] = jj_gen; [EOL] ; [EOL] } [EOL] if (nc2 != null) { [EOL] qn = compiler.qname(nc1, nc2); [EOL] } else { [EOL] qn = compiler.qname(null, nc1); [EOL] } [EOL] { [EOL] if (true) [EOL] return qn; [EOL] } [EOL] throw new Error("Missing return statement in function"); [EOL] }
public void testJj_2_1_WhenXlaIsPositive() { [EOL] int xla = 1; // Assuming xla should be positive for this test case [EOL] boolean result = jj_2_1(xla); [EOL] assertTrue("Expected jj_2_1 to return true for positive xla", result); [EOL] }
public void testJj_2_1_WhenXlaIsZero() { [EOL] int xla = 0; // Boundary condition where xla is zero [EOL] boolean result = jj_2_1(xla); [EOL] assertFalse("Expected jj_2_1 to return false when xla is zero", result); [EOL] }
public void testJj_2_1_WhenXlaIsNegative() { [EOL] int xla = -1; // Assuming xla should be negative for this test case [EOL] boolean result = jj_2_1(xla); [EOL] assertFalse("Expected jj_2_1 to return false for negative xla", result); [EOL] }
public void testJj_2_3WithXlaZero() { [EOL] int xla = 0; [EOL] boolean result = jj_2_3(xla); [EOL] assertFalse("Expected jj_2_3 to return false when jj_3_3 is true", result); [EOL] assertEquals("Expected jj_la to be set to xla", xla, jj_la); [EOL] assertSame("Expected jj_lastpos to be set to token", token, jj_lastpos); [EOL] assertSame("Expected jj_scanpos to be set to token", token, jj_scanpos); [EOL] }
public void testJj_2_3WithXlaPositive() { [EOL] int xla = 1; // or any positive number [EOL] boolean result = jj_2_3(xla); [EOL] assertFalse("Expected jj_2_3 to return false when jj_3_3 is true", result); [EOL] assertEquals("Expected jj_la to be set to xla", xla, jj_la); [EOL] assertSame("Expected jj_lastpos to be set to token", token, jj_lastpos); [EOL] assertSame("Expected jj_scanpos to be set to token", token, jj_scanpos); [EOL] }
public void testJj_2_3WhenJj_3_3ReturnsFalse() { [EOL] int xla = 1; // or any positive number [EOL] boolean result = jj_2_3(xla); [EOL] assertTrue("Expected jj_2_3 to return true when jj_3_3 is false", result); [EOL] assertEquals("Expected jj_la to be set to xla", xla, jj_la); [EOL] assertSame("Expected jj_lastpos to be set to token", token, jj_lastpos); [EOL] assertSame("Expected jj_scanpos to be set to token", token, jj_scanpos); [EOL] }
public void testJj_2_4WithXlaZero() { [EOL] int xla = 0; [EOL] boolean result = jj_2_4(xla); [EOL] assertTrue("Expected jj_2_4 to return true when jj_3_4 returns false", result); [EOL] assertEquals("Expected jj_la to be set to xla", xla, jj_la); [EOL] assertNotNull("Expected jj_lastpos to be set", jj_lastpos); [EOL] assertNotNull("Expected jj_scanpos to be set", jj_scanpos); [EOL] assertEquals("Expected jj_lastpos to be equal to token", token, jj_lastpos); [EOL] assertEquals("Expected jj_scanpos to be equal to token", token, jj_scanpos); [EOL] }
public void testJj_2_4WithXlaPositive() { [EOL] int xla = 1; [EOL] boolean result = jj_2_4(xla); [EOL] assertFalse("Expected jj_2_4 to return false when jj_3_4 returns true", result); [EOL] assertEquals("Expected jj_la to be set to xla", xla, jj_la); [EOL] assertNotNull("Expected jj_lastpos to be set", jj_lastpos); [EOL] assertNotNull("Expected jj_scanpos to be set", jj_scanpos); [EOL] assertEquals("Expected jj_lastpos to be equal to token", token, jj_lastpos); [EOL] assertEquals("Expected jj_scanpos to be equal to token", token, jj_scanpos); [EOL] }
public void testJj_3R_65_TokenIsFunctionId() { [EOL] boolean result = jj_3R_65(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_65_AtEndOfInput() { [EOL] boolean result = jj_3R_65(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_63_TokenIsFunctionPosition() { [EOL] initToken(FUNCTION_POSITION); [EOL] boolean result = jj_3R_63(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_63_AtEndOfInput() { [EOL] initToken(NOT_FUNCTION_POSITION); [EOL] setAtEndOfInput(); [EOL] boolean result = jj_3R_63(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_63_NotAtEndOfInput() { [EOL] initToken(NOT_FUNCTION_POSITION); [EOL] setNotAtEndOfInput(); [EOL] boolean result = jj_3R_63(); [EOL] assertFalse(result); [EOL] }
final private boolean jj_3R_18() { [EOL] Token xsp; [EOL] xsp = jj_scanpos; [EOL] if (jj_3R_62()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_63()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_64()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_65()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_66()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_67()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_68()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_69()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_70()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_71()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_72()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_73()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_74()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_75()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_76()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_77()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_78()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_79()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_80()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_81()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_82()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_83()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_84()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_85()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_86()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_87()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_88()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_89()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_90()) { [EOL] jj_scanpos = xsp; [EOL] if (jj_3R_91()) [EOL] return true; [EOL] if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL] return false; [EOL] return false; [EOL] }
public void testJj_3R_107_TokenIsNCName() { [EOL] boolean result = jj_3R_107(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_107_AtEndOfInput() { [EOL] boolean result = jj_3R_107(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_173_WithTrueMinusToken() { [EOL] when(jj_scan_token(MINUS)).thenReturn(true); [EOL] boolean result = jj_3R_173(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_173_WithFalseMinusTokenAndLaEqualsZero() { [EOL] when(jj_scan_token(MINUS)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_173(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_173_WithFalseMinusTokenAndTrueJj_3R_170() { [EOL] when(jj_scan_token(MINUS)).thenReturn(false); [EOL] when(jj_3R_170()).thenReturn(true); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are object references [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_173(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_173_WithAllConditionsFalse() { [EOL] when(jj_scan_token(MINUS)).thenReturn(false); [EOL] when(jj_3R_170()).thenReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are object references [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_173(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_98_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_98()); [EOL] }
public void testJj_3R_98_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] setJj_3R_107(true); [EOL] assertTrue(jj_3R_98()); [EOL] }
public void testJj_3R_98_SecondTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] setJj_3R_107(false); [EOL] setJj_3R_108(true); [EOL] assertTrue(jj_3R_98()); [EOL] }
public void testJj_3R_98_ThirdTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] setJj_3R_107(false); [EOL] setJj_3R_108(false); [EOL] setJj_3R_109(true); [EOL] assertTrue(jj_3R_98()); [EOL] }
public void testJj_3R_98_FourthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] setJj_3R_107(false); [EOL] setJj_3R_108(false); [EOL] setJj_3R_109(false); [EOL] setJj_3R_110(true); [EOL] assertTrue(jj_3R_98()); [EOL] }
public void testJj_3R_98_FifthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] setJj_3R_107(false); [EOL] setJj_3R_108(false); [EOL] setJj_3R_109(false); [EOL] setJj_3R_110(false); [EOL] setJj_3R_111(true); [EOL] assertTrue(jj_3R_98()); [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningTrue() { [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningFalseAndLaLastposCheck() { [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningFalseAndJj_3R_173ReturningTrue() { [EOL] }
public void testJj_3R_170_WithJj_3R_172ReturningFalseAndJj_3R_173ReturningFalse() { [EOL] }
public void testJj_3R_152_TokenIsAxisDescendantOrSelf() { [EOL] boolean result = jj_3R_152(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_152_AtEndOfInput() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_152(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_152_NotAtEndOfInput() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos and jj_lastpos are of type Token and different [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_152(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_151_TokenIsAxisPrecedingSibling() { [EOL] boolean result = jj_3R_151(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_151_ScanPositionAtEnd() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_151(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_151_ScanPositionNotAtEnd() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = someOtherPosition; // someOtherPosition should not be equal to jj_lastpos [EOL] boolean result = jj_3R_151(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_20_WhenJj_3R_98IsTrue() { [EOL] setJj_3R_98Condition(true); [EOL] boolean result = jj_3R_20(); [EOL] assert(result); [EOL] }
public void testJj_3R_20_WhenJj_3R_98IsFalseAndJj_laIsZeroAndJj_scanposEqualsJj_lastpos() { [EOL] setJj_3R_98Condition(false); [EOL] setJj_la(0); [EOL] setJj_scanposEqualsJj_lastpos(); [EOL] boolean result = jj_3R_20(); [EOL] assert(!result); [EOL] }
public void testJj_3R_20_WhenJj_3R_98IsFalseAndJj_laIsNotZero() { [EOL] setJj_3R_98Condition(false); [EOL] setJj_la(1); [EOL] boolean result = jj_3R_20(); [EOL] assert(!result); [EOL] }
public void testJj_3R_20_WhenJj_3R_98IsFalseAndJj_scanposNotEqualsJj_lastpos() { [EOL] setJj_3R_98Condition(false); [EOL] setJj_scanposNotEqualsJj_lastpos(); [EOL] boolean result = jj_3R_20(); [EOL] assert(!result); [EOL] }
public void testJj_3R_15_AllFalse() { [EOL] when(mockedObject.jj_3R_20()).thenReturn(false); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_FirstTrue() { [EOL] when(mockedObject.jj_3R_20()).thenReturn(true); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_15_LastTrue() { [EOL] when(mockedObject.jj_3R_20()).thenReturn(false); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] when(mockedObject.jj_3R_54()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_15_ScanposLastpos() { [EOL] when(mockedObject.jj_3R_20()).thenReturn(false); [EOL] when(mockedObject.jj_3R_21()).thenReturn(false); [EOL] mockedObject.jj_scanpos = mockedObject.jj_lastpos; [EOL] boolean result = mockedObject.jj_3R_15(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_140_ScanTokenAxisSelfReturnsTrue() { [EOL] initTokenState(AXIS_SELF); // Assuming initTokenState is a method that sets up the token state [EOL] boolean result = jj_3R_140(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_140_ScanTokenNotAxisSelfReturnsFalse() { [EOL] initTokenState(NOT_AXIS_SELF); // Assuming initTokenState is a method that sets up the token state [EOL] jj_la = 1; // Assuming jj_la is the lookahead variable [EOL] jj_scanpos = new Token(); // Assuming jj_scanpos is the current scan position [EOL] jj_lastpos = new Token(); // Assuming jj_lastpos is the last scan position [EOL] jj_scanpos.next = jj_lastpos; // Link the current scan position to the last scan position [EOL] boolean result = jj_3R_140(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_140_EndOfInputReturnsFalse() { [EOL] initTokenState(NOT_AXIS_SELF); // Assuming initTokenState is a method that sets up the token state [EOL] jj_la = 0; // Assuming jj_la is the lookahead variable [EOL] jj_scanpos = jj_lastpos; // Assuming jj_scanpos and jj_lastpos are the current and last scan positions [EOL] boolean result = jj_3R_140(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_129_AllFalse() { [EOL] when(jj_3R_140()).thenReturn(false); [EOL] when(jj_3R_141()).thenReturn(false); [EOL] when(jj_3R_142()).thenReturn(false); [EOL] when(jj_3R_143()).thenReturn(false); [EOL] when(jj_3R_144()).thenReturn(false); [EOL] when(jj_3R_145()).thenReturn(false); [EOL] when(jj_3R_146()).thenReturn(false); [EOL] when(jj_3R_147()).thenReturn(false); [EOL] when(jj_3R_148()).thenReturn(false); [EOL] when(jj_3R_149()).thenReturn(false); [EOL] when(jj_3R_150()).thenReturn(false); [EOL] when(jj_3R_151()).thenReturn(false); [EOL] when(jj_3R_152()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_129(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_129_FirstTrueRestFalse() { [EOL] when(jj_3R_140()).thenReturn(true); [EOL] when(jj_3R_141()).thenReturn(false); [EOL] when(jj_3R_142()).thenReturn(false); [EOL] when(jj_3R_143()).thenReturn(false); [EOL] when(jj_3R_144()).thenReturn(false); [EOL] when(jj_3R_145()).thenReturn(false); [EOL] when(jj_3R_146()).thenReturn(false); [EOL] when(jj_3R_147()).thenReturn(false); [EOL] when(jj_3R_148()).thenReturn(false); [EOL] when(jj_3R_149()).thenReturn(false); [EOL] when(jj_3R_150()).thenReturn(false); [EOL] when(jj_3R_151()).thenReturn(false); [EOL] when(jj_3R_152()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_129(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_129_LastTrue() { [EOL] when(jj_3R_140()).thenReturn(false); [EOL] when(jj_3R_141()).thenReturn(false); [EOL] when(jj_3R_142()).thenReturn(false); [EOL] when(jj_3R_143()).thenReturn(false); [EOL] when(jj_3R_144()).thenReturn(false); [EOL] when(jj_3R_145()).thenReturn(false); [EOL] when(jj_3R_146()).thenReturn(false); [EOL] when(jj_3R_147()).thenReturn(false); [EOL] when(jj_3R_148()).thenReturn(false); [EOL] when(jj_3R_149()).thenReturn(false); [EOL] when(jj_3R_150()).thenReturn(false); [EOL] when(jj_3R_151()).thenReturn(false); [EOL] when(jj_3R_152()).thenReturn(true); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_129(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_159_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_159()); [EOL] } [EOL] public void testJj_3R_159_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_159()); [EOL] }
public void testJj_3R_159_SecondTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_159()); [EOL] }
public void testJj_3R_159_ThirdTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_159()); [EOL] }
public void testJj_3R_159_FourthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_159()); [EOL] }
public void testJj_3R_167_WithGteToken() { [EOL] jj_scan_token(GTE); // Assuming this method sets up the condition for jj_scan_token(GTE) to return true [EOL] boolean result = jj_3R_167(); [EOL] assert(result); // Assert that the result is true when jj_scan_token(GTE) is true [EOL] }
public void testJj_3R_167_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Assuming this sets up the condition for jj_la == 0 && jj_scanpos == jj_lastpos to be true [EOL] boolean result = jj_3R_167(); [EOL] assert(!result); // Assert that the result is false when jj_la == 0 && jj_scanpos == jj_lastpos [EOL] }
public void testJj_3R_167_WithJj_3R_158ReturningTrue() { [EOL] boolean result = jj_3R_167(); [EOL] assert(result); // Assert that the result is true when jj_3R_158() is true [EOL] }
public void testJj_3R_167_WithAllConditionsFalse() { [EOL] boolean result = jj_3R_167(); [EOL] assert(!result); // Assert that the result is false when all conditions are false [EOL] }
public void testJj_3_4_WithPIToken() { [EOL] boolean result = jj_3_4(); [EOL] assertTrue(result); [EOL] }
public void testJj_3_4_WithLaAndScanposEqualLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3_4(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_4_WithLaNotZero() { [EOL] jj_la = 1; [EOL] boolean result = jj_3_4(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsTrue() { [EOL] assertTrue(jj_3_3()); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsFalseAndScanposEqualsLastpos() { [EOL] assertFalse(jj_3_3()); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsFalseAndScanToken80IsTrue() { [EOL] assertTrue(jj_3_3()); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsFalseAndScanToken80IsFalseAndScanposEqualsLastpos() { [EOL] assertFalse(jj_3_3()); [EOL] }
public void testJj_3_3_WhenJj_3R_17IsFalseAndScanToken80IsFalseAndScanToken81IsTrue() { [EOL] assertTrue(jj_3_3()); [EOL] }
public void testJj_3_3_WhenAllConditionsAreFalse() { [EOL] assertFalse(jj_3_3()); [EOL] }
public void testJj_3R_101_Token83() { [EOL] boolean result = jj_3R_101(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_101_EndOfLookahead() { [EOL] boolean result = jj_3R_101(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_101_Continuation() { [EOL] boolean result = jj_3R_101(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_100_Token82() { [EOL] setToken82(true); [EOL] boolean result = jj_3R_100(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_100_EndOfLookahead() { [EOL] setEndOfLookahead(true); [EOL] boolean result = jj_3R_100(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_100_NotToken82NorEndOfLookahead() { [EOL] setToken82(false); [EOL] setEndOfLookahead(false); [EOL] boolean result = jj_3R_100(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WithJj_3R_99ReturningTrue() { [EOL] when(jj_3R_99()).thenReturn(true); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] jj_la = 0; [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WithJj_3R_99ReturningFalse() { [EOL] when(jj_3R_99()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WithJj_3R_100ReturningTrue() { [EOL] when(jj_3R_99()).thenReturn(true); [EOL] when(jj_3R_100()).thenReturn(true); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WithJj_3R_101ReturningTrue() { [EOL] when(jj_3R_99()).thenReturn(true); [EOL] when(jj_3R_100()).thenReturn(true); [EOL] when(jj_3R_101()).thenReturn(true); [EOL] boolean result = jj_3R_57(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_57_WithJj_3R_102ReturningTrue() { [EOL] when(jj_3R_99()).thenReturn(true); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] when(jj_3R_102()).thenReturn(true); [EOL] jj_la = 0; [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_57_WithJj_3R_102ReturningFalse() { [EOL] when(jj_3R_99()).thenReturn(true); [EOL] when(jj_3R_100()).thenReturn(false); [EOL] when(jj_3R_101()).thenReturn(false); [EOL] when(jj_3R_102()).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = jj_scanpos; [EOL] boolean result = jj_3R_57(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_192_SlashToken() { [EOL] when(jj_scan_token(SLASH)).thenReturn(true); [EOL] boolean result = jj_3R_192(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_192_NotSlashTokenAndLaZeroAndScanposEqualsLastpos() { [EOL] when(jj_scan_token(SLASH)).thenReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Assuming jj_scanpos and jj_lastpos are accessible and can be set [EOL] boolean result = jj_3R_192(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_192_NotSlashTokenAndLaNotZeroOrScanposNotEqualsLastpos() { [EOL] when(jj_scan_token(SLASH)).thenReturn(false); [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // Assuming jj_scanpos is an object and can be set to a new instance [EOL] jj_lastpos = new Object(); // Assuming jj_lastpos is an object and can be set to a new instance [EOL] boolean result = jj_3R_192(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_191_WhenJj_3R_16IsTrue() { [EOL] when(jj_3R_16()).thenReturn(true); [EOL] boolean result = jj_3R_191(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_191_WhenAtEndOfInput() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_191(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_191_WhenJj_3R_193IsTrue() { [EOL] when(jj_3R_16()).thenReturn(false); [EOL] when(jj_3R_193()).thenReturn(true); [EOL] jj_la = 1; // Ensure we don't trigger the end of input condition [EOL] boolean result = jj_3R_191(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_191_WhenJj_3R_193IsAlwaysFalse() { [EOL] when(jj_3R_16()).thenReturn(false); [EOL] when(jj_3R_193()).thenReturn(false); [EOL] jj_la = 1; // Ensure we don't trigger the end of input condition [EOL] boolean result = jj_3R_191(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_189_WithJj_3R_191ReturningTrue() { [EOL] boolean result = jj_3R_189(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_189_WithJj_3R_191ReturningFalseAndJj_3R_192ReturningTrue() { [EOL] boolean result = jj_3R_189(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_189_WithJj_3R_191ReturningFalseAndJj_3R_192ReturningFalseAndJj_laEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_189(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_189_WithJj_3R_191ReturningFalseAndJj_laNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_189(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_187_WhenJj_3R_189ReturnsTrue() { [EOL] boolean result = jj_3R_187(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_187_WhenJj_3R_189ReturnsFalseAndJjLaIsZeroAndJjScanposEqualsJjLastpos() { [EOL] boolean result = jj_3R_187(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_187_WhenJj_3R_189ReturnsFalseAndJjLaIsNotZeroOrJjScanposNotEqualsJjLastpos() { [EOL] boolean result = jj_3R_187(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_183_WhenJj_3R_186IsTrueAndJj_3R_187IsTrue() { [EOL] }
public void testJj_3R_183_WhenJj_3R_186IsTrueAndJj_3R_187IsFalse() { [EOL] }
public void testJj_3R_183_WhenJj_3R_186IsFalse() { [EOL] }
public void testJj_3R_61_WithPIToken() { [EOL] setupToken(PI); [EOL] boolean result = jj_3R_61(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_61_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_61(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_61_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming Token is the type of jj_scanpos and jj_lastpos [EOL] jj_lastpos = new Token(); [EOL] assertNotSame(jj_scanpos, jj_lastpos); [EOL] boolean result = jj_3R_61(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_60_WithCommentToken() { [EOL] boolean result = jj_3R_60(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_60_WithLaAndScanposEqualLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_60(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_60_WithLaNotZeroOrScanposNotEqualLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = jj_lastpos + 1; // or any value not equal to jj_lastpos [EOL] boolean result = jj_3R_60(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_59_NodeToken() { [EOL] boolean result = jj_3R_59(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_59_NoNodeTokenEndOfLookahead() { [EOL] boolean result = jj_3R_59(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_59_NoNodeTokenNotEndOfLookahead() { [EOL] boolean result = jj_3R_59(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_58_WithTextToken() { [EOL] jj_scan_token = TEXT; // Assuming TEXT is a constant representing a token type [EOL] jj_la = 1; // Set lookahead to a non-zero value [EOL] jj_scanpos = new Token(); // Assuming Token is a class representing a token [EOL] jj_lastpos = new Token(); [EOL] boolean result = jj_3R_58(); [EOL] assert(result); // The method should return true if TEXT token is scanned [EOL] }
public void testJj_3R_58_WithLaZeroAndScanposEqualsLastpos() { [EOL] jj_scan_token = OTHER_TOKEN; // Assuming OTHER_TOKEN is a constant representing a different token type [EOL] jj_la = 0; // Set lookahead to zero [EOL] jj_scanpos = new Token(); // Assuming Token is a class representing a token [EOL] jj_lastpos = jj_scanpos; // Set lastpos to be the same as scanpos [EOL] boolean result = jj_3R_58(); [EOL] assert(!result); // The method should return false if lookahead is zero and scanpos equals lastpos [EOL] }
public void testJj_3R_58_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] jj_scan_token = OTHER_TOKEN; // Assuming OTHER_TOKEN is a constant representing a different token type [EOL] jj_la = 1; // Set lookahead to a non-zero value [EOL] jj_scanpos = new Token(); // Assuming Token is a class representing a token [EOL] jj_lastpos = new Token(); // Ensure lastpos is not the same as scanpos [EOL] boolean result = jj_3R_58(); [EOL] assert(!result); // The method should return false if lookahead is non-zero or scanpos does not equal lastpos [EOL] }
public void testJj_3_1_WhenJj3R15ReturnsTrue_ShouldReturnTrue() { [EOL] setJj3R15ToReturn(true); [EOL] boolean result = jj_3_1(); [EOL] assertTrue(result); [EOL] }
public void testJj_3_1_WhenJj3R15ReturnsFalseAndScanposEqualsLastpos_ShouldReturnFalse() { [EOL] setJj3R15ToReturn(false); [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3_1(); [EOL] assertFalse(result); [EOL] }
public void testJj_3_1_WhenJj3R15ReturnsFalseAndScanToken79ReturnsTrue_ShouldReturnTrue() { [EOL] setJj3R15ToReturn(false); [EOL] setJjScanTokenToReturn(79, true); [EOL] boolean result = jj_3_1(); [EOL] assertTrue(result); [EOL] }
public void testJj_3_1_WhenAllConditionsFail_ShouldReturnFalse() { [EOL] setJj3R15ToReturn(false); [EOL] setJjScanTokenToReturn(79, false); [EOL] jj_la = 1; [EOL] jj_scanpos = new Object(); // Assuming jj_scanpos and jj_lastpos are objects and not equal [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3_1(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_17_AllFalse() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertFalse(jj_3R_17()); [EOL] }
public void testJj_3R_17_FirstTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_17()); [EOL] }
public void testJj_3R_17_SecondTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_17()); [EOL] }
public void testJj_3R_17_ThirdTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_17()); [EOL] }
public void testJj_3R_17_FourthTrue() { [EOL] jj_scanpos = new Token(); [EOL] jj_lastpos = new Token(); [EOL] jj_la = 0; [EOL] assertTrue(jj_3R_17()); [EOL] }
public void testJj_3R_138_WhenJj_3R_15IsTrue() { [EOL] when(jj_3R_15()).thenReturn(true); [EOL] boolean result = jj_3R_138(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_138_WhenJjLaIsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Mock condition to make jj_scanpos equal to jj_lastpos [EOL] boolean result = jj_3R_138(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_138_WhenJjScanTokenIsTrue() { [EOL] when(jj_scan_token(79)).thenReturn(true); [EOL] boolean result = jj_3R_138(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_138_WhenAllConditionsAreFalse() { [EOL] when(jj_3R_15()).thenReturn(false); [EOL] when(jj_scan_token(79)).thenReturn(false); [EOL] jj_la = 1; // Set jj_la to a non-zero value to bypass the condition [EOL] jj_scanpos = new Object(); // Set jj_scanpos to a different object than jj_lastpos [EOL] boolean result = jj_3R_138(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_124_Token79() { [EOL] boolean result = jj_3R_124(); [EOL] assert(result); [EOL] }
public void testJj_3R_124_EndOfLookahead() { [EOL] boolean result = jj_3R_124(); [EOL] assert(!result); [EOL] }
public void testJj_3R_124_Jj_3R_15() { [EOL] boolean result = jj_3R_124(); [EOL] assert(result); [EOL] }
public void testJj_3R_124_AllFalse() { [EOL] boolean result = jj_3R_124(); [EOL] assert(!result); [EOL] }
public void testJj_3R_128_WithJj_3R_138ReturningTrueAndJj_3R_139ReturningTrue() { [EOL] boolean result = jj_3R_128(); [EOL] assertTrue(result); [EOL] } [EOL] public void testJj_3R_128_WithJj_3R_138ReturningTrueAndJj_3R_139ReturningFalse() { [EOL] boolean result = jj_3R_128(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_128_WithJj_3R_138ReturningFalseAndJjLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_128(); [EOL] assertFalse(result); [EOL] } [EOL] public void testJj_3R_128_WithJj_3R_138ReturningFalseAndJjLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_128(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_106_WhenJj_3R_120ReturnsTrue() { [EOL] boolean result = jj_3R_106(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_106_WhenAtEndOfInputAndJj_3R_120ReturnsFalse() { [EOL] boolean result = jj_3R_106(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_106_WhenNotAtEndOfInputAndJj_3R_120ReturnsFalse() { [EOL] boolean result = jj_3R_106(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_106_WhenJj_3R_119ReturnsFalse() { [EOL] boolean result = jj_3R_106(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_117_WhenJj_3R_15IsTrue() { [EOL] when(mockedObject.jj_3R_15()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_117(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_117_WhenJjLaIsZeroAndScanposEqualsLastpos() { [EOL] mockedObject.jj_la = 0; [EOL] mockedObject.jj_scanpos = mockedObject.jj_lastpos; [EOL] boolean result = mockedObject.jj_3R_117(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_117_WhenJj_3R_124IsTrue() { [EOL] when(mockedObject.jj_3R_15()).thenReturn(false); [EOL] when(mockedObject.jj_3R_124()).thenReturn(true); [EOL] boolean result = mockedObject.jj_3R_117(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_117_WhenJj_3R_124IsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] when(mockedObject.jj_3R_15()).thenReturn(false); [EOL] when(mockedObject.jj_3R_124()).thenReturn(false); [EOL] mockedObject.jj_la = 0; [EOL] mockedObject.jj_scanpos = mockedObject.jj_lastpos; [EOL] boolean result = mockedObject.jj_3R_117(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_103_WithTokenVariable() { [EOL] boolean result = jj_3R_103(); [EOL] assert(result); [EOL] }
public void testJj_3R_103_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_103(); [EOL] assert(!result); [EOL] }
public void testJj_3R_103_WithJj_3R_117ReturningTrue() { [EOL] boolean result = jj_3R_103(); [EOL] assert(result); [EOL] }
public void testJj_3R_103_WithJj_3R_117ReturningFalse() { [EOL] boolean result = jj_3R_103(); [EOL] assert(!result); [EOL] }
public void testJj_3R_91_TokenIsFunctionFormatNumber() { [EOL] initToken(FUNCTION_FORMAT_NUMBER); [EOL] boolean result = jj_3R_91(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_91_AtEndOfInput() { [EOL] initAtEndOfInput(); [EOL] boolean result = jj_3R_91(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_89_TokenIsFunctionRound() { [EOL] boolean result = jj_3R_89(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_89_AtEndOfInput() { [EOL] boolean result = jj_3R_89(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_89_NotAtEndOfInputNorFunctionRound() { [EOL] boolean result = jj_3R_89(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_88_WithFunctionCeilingToken() { [EOL] boolean result = jj_3R_88(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_88_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_88(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_88_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_88(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_97_WhenJj_3R_106ReturnsTrue() { [EOL] setupJj_3R_106ToReturnTrue(); [EOL] boolean result = jj_3R_97(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_97_WhenJj_3R_106ReturnsFalseAndJjLaIsZeroAndScanposEqualsLastpos() { [EOL] setupJj_3R_106ToReturnFalse(); [EOL] setJjLaToZero(); [EOL] makeJjScanposEqualJjLastpos(); [EOL] boolean result = jj_3R_97(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_97_WhenJj_3R_106ReturnsFalseAndJjLaIsNotZeroOrScanposNotEqualsLastpos() { [EOL] setupJj_3R_106ToReturnFalse(); [EOL] setJjLaToNonZeroOrMakeJjScanposNotEqualJjLastpos(); [EOL] boolean result = jj_3R_97(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_87_WithFunctionFloorToken() { [EOL] boolean result = jj_3R_87(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_87_WithNonFunctionFloorTokenAndLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_87(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_87_WithNonFunctionFloorTokenAndLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Token(); // assuming jj_scanpos is of type Token and is not equal to jj_lastpos [EOL] boolean result = jj_3R_87(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_86_TokenIsFunctionSum() { [EOL] boolean result = jj_3R_86(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_86_AtEndOfInput() { [EOL] boolean result = jj_3R_86(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_86_NotAtEndOfInputNorFunctionSum() { [EOL] boolean result = jj_3R_86(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_92_WhenJj_3R_103ReturnsTrue() { [EOL] assertTrue(jj_3R_92()); [EOL] }
public void testJj_3R_92_WhenJj_3R_103ReturnsFalseAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // Make sure jj_scanpos is equal to jj_lastpos [EOL] assertFalse(jj_3R_92()); [EOL] }
public void testJj_3R_92_WhenJj_3R_103ReturnsFalseAndScanposNotEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = new Object(); // Use a different object to ensure jj_scanpos is not equal to jj_lastpos [EOL] jj_lastpos = new Object(); [EOL] assertFalse(jj_3R_92()); [EOL] }
public void testJj_3R_82_WithFunctionFalseToken() { [EOL] boolean result = jj_3R_82(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_82_WithNonFunctionFalseTokenAndLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_82(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_82_WithNonFunctionFalseTokenAndLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_82(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_81_WithFunctionTrueToken() { [EOL] boolean result = jj_3R_81(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_81_WithLaZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_81(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_81_WithLaNonZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_81(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_80_WithFunctionNotToken() { [EOL] initToken(FUNCTION_NOT); [EOL] boolean result = jj_3R_80(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_80_WithNonFunctionNotTokenAndLaEqualsZero() { [EOL] initToken(NON_FUNCTION_NOT_TOKEN); [EOL] setLa(0); [EOL] setScanPos(jj_lastpos); [EOL] boolean result = jj_3R_80(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_80_WithNonFunctionNotTokenAndLaNotZero() { [EOL] initToken(NON_FUNCTION_NOT_TOKEN); [EOL] setLa(1); // any non-zero value [EOL] boolean result = jj_3R_80(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_78_WithFunctionTranslateToken() { [EOL] setToken(FUNCTION_TRANSLATE); [EOL] boolean result = jj_3R_78(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_78_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] setLaToZero(); [EOL] setScanposToLastpos(); [EOL] boolean result = jj_3R_78(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_78_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] setLaToNonZero(); [EOL] setScanposNotEqualLastpos(); [EOL] boolean result = jj_3R_78(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_77_TokenIsFunctionNormalizeSpace() { [EOL] boolean result = jj_3R_77(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_77_AtEndOfInput() { [EOL] boolean result = jj_3R_77(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_77_NotAtEndOfInputNorFunctionNormalizeSpace() { [EOL] boolean result = jj_3R_77(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_19_AllFalse() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] when(jj_3R_92()).thenReturn(false); [EOL] when(jj_3R_93()).thenReturn(false); [EOL] when(jj_3R_94()).thenReturn(false); [EOL] when(jj_3R_95()).thenReturn(false); [EOL] when(jj_3R_96()).thenReturn(false); [EOL] when(jj_3R_97()).thenReturn(false); [EOL] assertFalse(jj_3R_19()); [EOL] }
public void testJj_3R_19_FirstTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] when(jj_3R_92()).thenReturn(true); [EOL] when(jj_3R_93()).thenReturn(false); [EOL] when(jj_3R_94()).thenReturn(false); [EOL] when(jj_3R_95()).thenReturn(false); [EOL] when(jj_3R_96()).thenReturn(false); [EOL] when(jj_3R_97()).thenReturn(false); [EOL] assertFalse(jj_3R_19()); [EOL] }
public void testJj_3R_19_SecondTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] when(jj_3R_92()).thenReturn(false); [EOL] when(jj_3R_93()).thenReturn(true); [EOL] when(jj_3R_94()).thenReturn(false); [EOL] when(jj_3R_95()).thenReturn(false); [EOL] when(jj_3R_96()).thenReturn(false); [EOL] when(jj_3R_97()).thenReturn(false); [EOL] assertFalse(jj_3R_19()); [EOL] }
public void testJj_3R_19_ThirdTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] when(jj_3R_92()).thenReturn(false); [EOL] when(jj_3R_93()).thenReturn(false); [EOL] when(jj_3R_94()).thenReturn(true); [EOL] when(jj_3R_95()).thenReturn(false); [EOL] when(jj_3R_96()).thenReturn(false); [EOL] when(jj_3R_97()).thenReturn(false); [EOL] assertFalse(jj_3R_19()); [EOL] }
public void testJj_3R_19_FourthTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] when(jj_3R_92()).thenReturn(false); [EOL] when(jj_3R_93()).thenReturn(false); [EOL] when(jj_3R_94()).thenReturn(false); [EOL] when(jj_3R_95()).thenReturn(true); [EOL] when(jj_3R_96()).thenReturn(false); [EOL] when(jj_3R_97()).thenReturn(false); [EOL] assertFalse(jj_3R_19()); [EOL] }
public void testJj_3R_19_FifthTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] when(jj_3R_92()).thenReturn(false); [EOL] when(jj_3R_93()).thenReturn(false); [EOL] when(jj_3R_94()).thenReturn(false); [EOL] when(jj_3R_95()).thenReturn(false); [EOL] when(jj_3R_96()).thenReturn(true); [EOL] when(jj_3R_97()).thenReturn(false); [EOL] assertFalse(jj_3R_19()); [EOL] }
public void testJj_3R_19_SixthTrue() { [EOL] jj_scanpos = mock(Token.class); [EOL] jj_lastpos = mock(Token.class); [EOL] jj_la = 0; [EOL] when(jj_3R_92()).thenReturn(false); [EOL] when(jj_3R_93()).thenReturn(false); [EOL] when(jj_3R_94()).thenReturn(false); [EOL] when(jj_3R_95()).thenReturn(false); [EOL] when(jj_3R_96()).thenReturn(false); [EOL] when(jj_3R_97()).thenReturn(true); [EOL] assertTrue(jj_3R_19()); [EOL] }
public void testJj_3R_76_WithFunctionStringLengthToken() { [EOL] boolean result = jj_3R_76(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_76_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_76(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_76_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_76(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_75_WithFunctionSubstringToken() { [EOL] initToken(FUNCTION_SUBSTRING); [EOL] boolean result = jj_3R_75(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_75_WithDifferentToken() { [EOL] initToken(DIFFERENT_TOKEN); [EOL] boolean result = jj_3R_75(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_75_AtEndOfInput() { [EOL] initToken(END_OF_INPUT); [EOL] setAtEndOfInput(); [EOL] boolean result = jj_3R_75(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_74_WithFunctionSubstringAfterToken() { [EOL] boolean result = jj_3R_74(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_74_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; // assuming jj_scanpos and jj_lastpos are accessible and can be set [EOL] boolean result = jj_3R_74(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_74_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos can be set to a new value [EOL] jj_lastpos = new Object(); // and is not equal to jj_scanpos [EOL] boolean result = jj_3R_74(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_73_WithFunctionSubstringBeforeToken() { [EOL] boolean result = jj_3R_73(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_73_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_73(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_73_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos and jj_lastpos are object references [EOL] jj_lastpos = new Object(); [EOL] boolean result = jj_3R_73(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_71_WithFunctionStartsWithToken() { [EOL] boolean result = jj_3R_71(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_71_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] jj_la = 0; [EOL] jj_scanpos = jj_lastpos; [EOL] boolean result = jj_3R_71(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_71_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] jj_la = 1; // or any non-zero value [EOL] jj_scanpos = new Object(); // assuming jj_scanpos is an object and not equal to jj_lastpos [EOL] jj_lastpos = new Object(); // ensure jj_lastpos is a different object [EOL] boolean result = jj_3R_71(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_70_WithFunctionConcatToken() { [EOL] boolean result = jj_3R_70(); [EOL] assertTrue(result); [EOL] }
public void testJj_3R_70_WithLaEqualsZeroAndScanposEqualsLastpos() { [EOL] boolean result = jj_3R_70(); [EOL] assertFalse(result); [EOL] }
public void testJj_3R_70_WithLaNotZeroOrScanposNotEqualsLastpos() { [EOL] boolean result = jj_3R_70(); [EOL] assertFalse(result); [EOL] }
public void testConsumeTokenWithCorrectKind() throws ParseException { [EOL] int expectedKind = 1; [EOL] Token expectedToken = new Token(); [EOL] expectedToken.kind = expectedKind; [EOL] token_source.setNextToken(expectedToken); [EOL] token = new Token(); [EOL] token.next = null; [EOL] jj_nt = token; [EOL] Token result = jj_consume_token(expectedKind); [EOL] assertEquals(expectedToken, result); [EOL] assertEquals(expectedKind, result.kind); [EOL] }
public void testConsumeTokenWithIncorrectKind() { [EOL] int expectedKind = 1; [EOL] int incorrectKind = 2; [EOL] Token expectedToken = new Token(); [EOL] expectedToken.kind = incorrectKind; [EOL] token_source.setNextToken(expectedToken); [EOL] token = new Token(); [EOL] token.next = null; [EOL] jj_nt = token; [EOL] try { [EOL] jj_consume_token(expectedKind); [EOL] fail("ParseException expected"); [EOL] } catch (ParseException e) { [EOL] } [EOL] assertEquals(incorrectKind, jj_kind); [EOL] }
public void testConsumeTokenWithGarbageCollectionTrigger() throws ParseException { [EOL] int expectedKind = 1; [EOL] Token expectedToken = new Token(); [EOL] expectedToken.kind = expectedKind; [EOL] token_source.setNextToken(expectedToken); [EOL] token = new Token(); [EOL] token.next = null; [EOL] jj_nt = token; [EOL] jj_gc = 100; // Set to threshold to trigger garbage collection [EOL] Token result = jj_consume_token(expectedKind); [EOL] assertEquals(expectedToken, result); [EOL] assertEquals(0, jj_gc); // Garbage collection should have reset the counter [EOL] }
public void testJjScanTokenWithScanposEqualsLastposAndNextNull() { [EOL] Token token = new Token(); [EOL] token.kind = 1; [EOL] token.next = null; [EOL] TokenSource tokenSource = mock(TokenSource.class); [EOL] when(tokenSource.getNextToken()).thenReturn(token); [EOL] Parser parser = new Parser(tokenSource); [EOL] parser.jj_scanpos = parser.jj_lastpos = new Token(); [EOL] parser.jj_la = 1; [EOL] boolean result = parser.jj_scan_token(2); [EOL] assertTrue(result); [EOL] assertSame(token, parser.jj_scanpos); [EOL] assertSame(token, parser.jj_lastpos); [EOL] assertEquals(0, parser.jj_la); [EOL] }
public void testJjScanTokenWithScanposEqualsLastposAndNextNotNull() { [EOL] Token nextToken = new Token(); [EOL] nextToken.kind = 1; [EOL] Token initialToken = new Token(); [EOL] initialToken.next = nextToken; [EOL] Parser parser = new Parser(null); [EOL] parser.jj_scanpos = parser.jj_lastpos = initialToken; [EOL] parser.jj_la = 1; [EOL] boolean result = parser.jj_scan_token(2); [EOL] assertTrue(result); [EOL] assertSame(nextToken, parser.jj_scanpos); [EOL] assertSame(nextToken, parser.jj_lastpos); [EOL] assertEquals(1, parser.jj_la); [EOL] }
public void testJjScanTokenWithScanposNotEqualsLastpos() { [EOL] Token lastToken = new Token(); [EOL] lastToken.kind = 1; [EOL] Token middleToken = new Token(); [EOL] middleToken.kind = 1; [EOL] middleToken.next = lastToken; [EOL] Token firstToken = new Token(); [EOL] firstToken.kind = 1; [EOL] firstToken.next = middleToken; [EOL] Parser parser = new Parser(null); [EOL] parser.jj_scanpos = firstToken; [EOL] parser.jj_lastpos = lastToken; [EOL] boolean result = parser.jj_scan_token(2); [EOL] assertTrue(result); [EOL] assertSame(middleToken, parser.jj_scanpos); [EOL] }
public void testJjScanTokenWithRescanTrue() { [EOL] Token lastToken = new Token(); [EOL] lastToken.kind = 1; [EOL] Token firstToken = new Token(); [EOL] firstToken.kind = 1; [EOL] firstToken.next = lastToken; [EOL] Parser parser = new Parser(null); [EOL] parser.jj_scanpos = lastToken; [EOL] parser.jj_lastpos = lastToken; [EOL] parser.token = firstToken; [EOL] parser.jj_rescan = true; [EOL] boolean result = parser.jj_scan_token(1); [EOL] assertFalse(result); [EOL] verify(parser).jj_add_error_token(1, 1); [EOL] }
public void testQNameWithNonNullPrefixAndLocalName() { [EOL] String prefix = "testPrefix"; [EOL] String localName = "testLocalName"; [EOL] QName qName = new QName(prefix, localName); [EOL] assertEquals(prefix, qName.getPrefix()); [EOL] assertEquals(localName, qName.getLocalName()); [EOL] }
public void testQNameWithNullPrefix() { [EOL] String prefix = null; [EOL] String localName = "testLocalName"; [EOL] QName qName = new QName(prefix, localName); [EOL] assertNull(qName.getPrefix()); [EOL] assertEquals(localName, qName.getLocalName()); [EOL] }
public void testQNameWithNullLocalName() { [EOL] String prefix = "testPrefix"; [EOL] String localName = null; [EOL] QName qName = new QName(prefix, localName); [EOL] assertEquals(prefix, qName.getPrefix()); [EOL] assertNull(qName.getLocalName()); [EOL] }
public void testQNameWithNullPrefixAndLocalName() { [EOL] String prefix = null; [EOL] String localName = null; [EOL] QName qName = new QName(prefix, localName); [EOL] assertNull(qName.getPrefix()); [EOL] assertNull(qName.getLocalName()); [EOL] }
public void testGetPrefix() { [EOL] MyClass instance = new MyClass(); [EOL] String expected = "expectedPrefix"; [EOL] instance.prefix = expected; // Assuming direct access to the field for the purpose of the test [EOL] String result = instance.getPrefix(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetName() { [EOL] MyClass myClass = new MyClass("testName"); [EOL] String name = myClass.getName(); [EOL] assertEquals("testName", name); [EOL] }
public void testToStringWithPrefix() { [EOL] MyClass obj = new MyClass("prefix", "name"); [EOL] String result = obj.toString(); [EOL] assertEquals("prefix:name", result); [EOL] }
public void testToStringWithoutPrefix() { [EOL] MyClass obj = new MyClass(null, "name"); [EOL] String result = obj.toString(); [EOL] assertEquals("name", result); [EOL] }
private static NodePointer doStep(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL] if (parent == null) { [EOL] return null; [EOL] } [EOL] if (currentStep == steps.length) { [EOL] return parent; [EOL] } [EOL] parent = valuePointer(parent); [EOL] Step step = steps[currentStep]; [EOL] Expression[] predicates = step.getPredicates(); [EOL] if (parent instanceof PropertyOwnerPointer) { [EOL] if (predicates == null || predicates.length == 0) { [EOL] return doStepNoPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL] } else { [EOL] return doStepPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL] } [EOL] } else { [EOL] if (predicates == null || predicates.length == 0) { [EOL] return doStepNoPredicatesStandard(context, parent, steps, currentStep); [EOL] } else { [EOL] return doStepPredicatesStandard(context, parent, steps, currentStep); [EOL] } [EOL] } [EOL] }
private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) { [EOL] Step step = steps[currentStep]; [EOL] if (step.getAxis() == Compiler.AXIS_SELF) { [EOL] return doStep(context, parentPointer, steps, currentStep + 1); [EOL] } [EOL] int bestQuality = 0; [EOL] NodePointer bestMatch = null; [EOL] NodeIterator it = getNodeIterator(context, parentPointer, step); [EOL] if (it != null) { [EOL] for (int i = 1; it.setPosition(i); i++) { [EOL] NodePointer childPointer = it.getNodePointer(); [EOL] if (steps.length == currentStep + 1) { [EOL] return childPointer; [EOL] } [EOL] NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1); [EOL] int quality = computeQuality(pointer); [EOL] if (quality == PERFECT_MATCH) { [EOL] return pointer; [EOL] } else if (quality > bestQuality) { [EOL] bestQuality = quality; [EOL] bestMatch = (NodePointer) pointer.clone(); [EOL] } [EOL] } [EOL] } [EOL] if (bestMatch != null) { [EOL] return bestMatch; [EOL] } [EOL] return createNullPointer(context, parentPointer, steps, currentStep); [EOL] }
private static NodePointer doStepPredicatesStandard(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL] Step step = steps[currentStep]; [EOL] Expression[] predicates = step.getPredicates(); [EOL] int axis = step.getAxis(); [EOL] if (axis == Compiler.AXIS_SELF) { [EOL] return doPredicate(context, parent, steps, currentStep, predicates, 0); [EOL] } [EOL] Expression predicate = predicates[0]; [EOL] if (predicates.length == 1) { [EOL] NodeIterator it = getNodeIterator(context, parent, step); [EOL] NodePointer pointer = null; [EOL] if (it != null) { [EOL] if (predicate instanceof NameAttributeTest) { [EOL] String key = keyFromPredicate(context, predicate); [EOL] for (int i = 1; it.setPosition(i); i++) { [EOL] NodePointer ptr = it.getNodePointer(); [EOL] if (isNameAttributeEqual(ptr, key)) { [EOL] pointer = ptr; [EOL] break; [EOL] } [EOL] } [EOL] } else { [EOL] int index = indexFromPredicate(context, predicate); [EOL] if (it.setPosition(index + 1)) { [EOL] pointer = it.getNodePointer(); [EOL] } [EOL] } [EOL] } [EOL] if (pointer != null) { [EOL] return doStep(context, pointer, steps, currentStep + 1); [EOL] } [EOL] } else { [EOL] NodeIterator it = getNodeIterator(context, parent, step); [EOL] if (it != null) { [EOL] List list = new ArrayList(); [EOL] for (int i = 1; it.setPosition(i); i++) { [EOL] list.add(it.getNodePointer()); [EOL] } [EOL] NodePointer pointer = doPredicatesStandard(context, list, steps, currentStep, predicates, 0); [EOL] if (pointer != null) { [EOL] return pointer; [EOL] } [EOL] } [EOL] } [EOL] return createNullPointer(context, parent, steps, currentStep); [EOL] }
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL] if (parents.size() == 0) { [EOL] return null; [EOL] } [EOL] if (currentPredicate == predicates.length) { [EOL] NodePointer pointer = (NodePointer) parents.get(0); [EOL] return doStep(context, pointer, steps, currentStep + 1); [EOL] } [EOL] Expression predicate = predicates[currentPredicate]; [EOL] if (predicate instanceof NameAttributeTest) { [EOL] String key = keyFromPredicate(context, predicate); [EOL] List newList = new ArrayList(); [EOL] for (int i = 0; i < parents.size(); i++) { [EOL] NodePointer pointer = (NodePointer) parents.get(i); [EOL] if (isNameAttributeEqual(pointer, key)) { [EOL] newList.add(pointer); [EOL] } [EOL] } [EOL] if (newList.size() == 0) { [EOL] return null; [EOL] } [EOL] return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL] } else { [EOL] int index = indexFromPredicate(context, predicate); [EOL] if (index < 0 || index >= parents.size()) { [EOL] return null; [EOL] } [EOL] NodePointer ptr = (NodePointer) parents.get(index); [EOL] return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL] } [EOL] }
private static NodeIterator getNodeIterator(EvalContext context, NodePointer pointer, Step step) { [EOL] if (step.getAxis() == Compiler.AXIS_CHILD) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL] String prefix = qname.getPrefix(); [EOL] String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL] if (namespaceURI != null) { [EOL] nodeTest = new NodeNameTest(qname, namespaceURI); [EOL] } [EOL] return pointer.childIterator(nodeTest, false, null); [EOL] } else { [EOL] if (!(step.getNodeTest() instanceof NodeNameTest)) { [EOL] throw new UnsupportedOperationException("Not supported node test for attributes: " + step.getNodeTest()); [EOL] } [EOL] return pointer.attributeIterator(((NodeNameTest) step.getNodeTest()).getNodeName()); [EOL] } [EOL] }
public void testIteratePointersWithNullResult() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.compute()).thenReturn(null); [EOL] Iterator resultIterator = iteratePointers(context); [EOL] assertFalse(resultIterator.hasNext()); [EOL] }
public void testIteratePointersWithEvalContextResult() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext evalContextResult = mock(EvalContext.class); [EOL] when(context.compute()).thenReturn(evalContextResult); [EOL] Iterator resultIterator = iteratePointers(context); [EOL] assertTrue(resultIterator instanceof EvalContext); [EOL] assertEquals(evalContextResult, resultIterator); [EOL] }
public void testIteratePointersWithNonEvalContextResult() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] List<Object> listResult = Arrays.asList("value1", "value2"); [EOL] when(context.compute()).thenReturn(listResult); [EOL] RootContext rootContext = mock(RootContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(context.getRootContext()).thenReturn(rootContext); [EOL] when(rootContext.getCurrentNodePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.getLocale()).thenReturn(Locale.getDefault()); [EOL] Iterator resultIterator = iteratePointers(context); [EOL] assertTrue(resultIterator instanceof PointerIterator); [EOL] }
public void testAsPathWhenByNameAttributeIsFalse() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.byNameAttribute = false; [EOL] when(testInstance.super.asPath()).thenReturn("/some/path"); [EOL] String result = testInstance.asPath(); [EOL] assertEquals("/some/path", result); [EOL] }
public void testAsPathWhenByNameAttributeIsTrueAndIndexIsWholeCollection() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.byNameAttribute = true; [EOL] testInstance.index = WHOLE_COLLECTION; // Assuming WHOLE_COLLECTION is a static constant [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn("/parent/path"); [EOL] when(testInstance.getImmediateParentPointer()).thenReturn(parentPointer); [EOL] when(testInstance.getPropertyName()).thenReturn("propertyName"); [EOL] when(testInstance.escape("propertyName")).thenReturn("propertyName"); [EOL] String result = testInstance.asPath(); [EOL] assertEquals("/parent/path[@name='propertyName']", result); [EOL] }
public void testAsPathWhenByNameAttributeIsTrueAndIndexIsNotWholeCollection() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.byNameAttribute = true; [EOL] testInstance.index = 1; // Assuming index is not WHOLE_COLLECTION [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn("/parent/path"); [EOL] when(testInstance.getImmediateParentPointer()).thenReturn(parentPointer); [EOL] when(testInstance.getPropertyName()).thenReturn("propertyName"); [EOL] when(testInstance.escape("propertyName")).thenReturn("propertyName"); [EOL] String result = testInstance.asPath(); [EOL] assertEquals("/parent/path[@name='propertyName'][2]", result); [EOL] }
public void testAsPathWithNonNullId() { [EOL] YourClass instance = new YourClass(); [EOL] instance.id = "someId"; [EOL] String result = instance.asPath(); [EOL] assertEquals("id(someId)", result); [EOL] }
public void testAsPathWithNullIdAndNonNullParent() { [EOL] YourClass instance = new YourClass(); [EOL] instance.id = null; [EOL] YourClass parent = new YourClass(); [EOL] parent.id = "parentId"; [EOL] instance.parent = parent; [EOL] String result = instance.asPath(); [EOL] assertEquals("id(parentId)", result); [EOL] }
public void testAsPathWithNullIdAndNullParent() { [EOL] YourClass instance = new YourClass(); [EOL] instance.id = null; [EOL] instance.parent = null; [EOL] String result = instance.asPath(); [EOL] assertEquals("null()", result); [EOL] }
public void testBooleanValueWithNumberNonZero() { [EOL] double nonZeroNumber = 1.0; [EOL] assertTrue(jxPath.booleanValue(nonZeroNumber)); [EOL] } [EOL] public void testBooleanValueWithNumberZero() { [EOL] double zeroNumber = 0.0; [EOL] assertFalse(jxPath.booleanValue(zeroNumber)); [EOL] } [EOL] public void testBooleanValueWithNumberNaN() { [EOL] double nanValue = Double.NaN; [EOL] assertFalse(jxPath.booleanValue(nanValue)); [EOL] } [EOL] public void testBooleanValueWithBooleanTrue() { [EOL] Boolean trueValue = Boolean.TRUE; [EOL] assertTrue(jxPath.booleanValue(trueValue)); [EOL] } [EOL] public void testBooleanValueWithBooleanFalse() { [EOL] Boolean falseValue = Boolean.FALSE; [EOL] assertFalse(jxPath.booleanValue(falseValue)); [EOL] } [EOL] public void testBooleanValueWithEvalContextNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(null); [EOL] assertFalse(jxPath.booleanValue(ctx)); [EOL] } [EOL] public void testBooleanValueWithEvalContextNonNullPointer() { [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer ptr = mock(Pointer.class); [EOL] when(ctx.getSingleNodePointer()).thenReturn(ptr); [EOL] when(ptr.isActual()).thenReturn(true); // Assuming booleanValue(ptr) returns true [EOL] assertTrue(jxPath.booleanValue(ctx)); [EOL] } [EOL] public void testBooleanValueWithStringEmpty() { [EOL] String emptyString = ""; [EOL] assertFalse(jxPath.booleanValue(emptyString)); [EOL] } [EOL] public void testBooleanValueWithStringNonEmpty() { [EOL] String nonEmptyString = "jxPath"; [EOL] assertTrue(jxPath.booleanValue(nonEmptyString)); [EOL] } [EOL] public void testBooleanValueWithNodePointerActual() { [EOL] NodePointer pointer = mock(NodePointer.class); [EOL] when(pointer.isActual()).thenReturn(true); [EOL] assertTrue(jxPath.booleanValue(pointer)); [EOL] } [EOL] public void testBooleanValueWithNodePointerNotActual() { [EOL] NodePointer pointer = mock(NodePointer.class); [EOL] when(pointer.isActual()).thenReturn(false); [EOL] assertFalse(jxPath.booleanValue(pointer)); [EOL] } [EOL] public void testBooleanValueWithVariablePointer() { [EOL] VariablePointer variablePointer = mock(VariablePointer.class); [EOL] Node node = mock(Node.class); [EOL] when(variablePointer.getNode()).thenReturn(node); [EOL] when(node.isActual()).thenReturn(true); // Assuming booleanValue(node) returns true [EOL] assertTrue(jxPath.booleanValue(variablePointer)); [EOL] } [EOL] public void testBooleanValueWithNull() { [EOL] assertFalse(jxPath.booleanValue(null)); [EOL] } [EOL] public void testBooleanValueWithOtherObject() { [EOL] Object otherObject = new Object(); [EOL] assertTrue(jxPath.booleanValue(otherObject)); [EOL] }
public void testNullElementPointerWithValidParentAndIndex() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] int index = 1; [EOL] NullElementPointer nullElementPointer = new NullElementPointer(parent, index); [EOL] assertNotNull(nullElementPointer); [EOL] assertEquals(parent, nullElementPointer.getParent()); [EOL] assertEquals(index, nullElementPointer.getIndex()); [EOL] }
public void testNullElementPointerWithNullParent() { [EOL] int index = 1; [EOL] try { [EOL] NullElementPointer nullElementPointer = new NullElementPointer(null, index); [EOL] fail("Should have thrown IllegalArgumentException for null parent"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetNameReturnsNull() { [EOL] ClassName instance = new ClassName(); [EOL] QName result = instance.getName(); [EOL] assertNull(result); [EOL] }
public void testGetValuePointer() { [EOL] YourClass instance = createInstanceWithMockedGetName(); [EOL] NodePointer result = instance.getValuePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullPointer); [EOL] assertEquals(instance.getName(), result.getName()); [EOL] }
public void testCreatePathWithValidIndex() { [EOL] NodePointer mockParent = Mockito.mock(NodePointer.class); [EOL] NodePointer expectedChild = Mockito.mock(NodePointer.class); [EOL] JXPathContext context = Mockito.mock(JXPathContext.class); [EOL] int index = 1; // Assuming a valid index [EOL] NodePointerExtension nodePointerExtension = new NodePointerExtension(mockParent, index); [EOL] Mockito.when(mockParent.createChild(context, null, index)).thenReturn(expectedChild); [EOL] NodePointer result = nodePointerExtension.createPath(context); [EOL] Assert.assertSame("The created NodePointer is not the expected one.", expectedChild, result); [EOL] }
public void testSetValueWithWholeCollection() { [EOL] int index = WHOLE_COLLECTION; [EOL] Object value = new Object(); [EOL] PropertyHandler handler = mock(PropertyHandler.class); [EOL] Object bean = new Object(); [EOL] String propertyName = "testProperty"; [EOL] setValue(value); [EOL] verify(handler).setProperty(bean, propertyName, value); [EOL] }
public void testSetValueWithSpecificIndex() { [EOL] int index = 1; // Assuming 1 is not WHOLE_COLLECTION [EOL] Object value = new Object(); [EOL] PropertyHandler handler = mock(PropertyHandler.class); [EOL] Object bean = new Object(); [EOL] String propertyName = "testProperty"; [EOL] Object propertyValue = new Object(); [EOL] when(handler.getProperty(bean, propertyName)).thenReturn(propertyValue); [EOL] setValue(value); [EOL] verifyStatic(ValueUtils.class); [EOL] ValueUtils.setValue(propertyValue, index, value); [EOL] }
public void testCreatePathWithWholeCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object value = new Object(); [EOL] NodePointer nodePointer = new ConcreteNodePointer(WHOLE_COLLECTION); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(nodePointer, result); [EOL] }
public void testCreatePathWithSpecificIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Object value = new Object(); [EOL] int specificIndex = 1; // Assuming 1 is not WHOLE_COLLECTION [EOL] NodePointer nodePointer = new ConcreteNodePointer(specificIndex); [EOL] NodePointer result = nodePointer.createPath(context, value); [EOL] assertNotNull(result); [EOL] assertEquals(nodePointer, result); [EOL] }
public void testAsPath_ImmediateParentPathNotEmpty() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn("/parent/path"); [EOL] MyClass instance = new MyClass(parentPointer, "propertyName", false, -1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parent/path[@name='propertyName']", result); [EOL] }
public void testAsPath_ImmediateParentPathEmpty() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn(""); [EOL] MyClass instance = new MyClass(parentPointer, "propertyName", false, -1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/.[@name='propertyName']", result); [EOL] }
public void testAsPath_ImmediateParentPathEndsWithSlash() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn("/parent/path/"); [EOL] MyClass instance = new MyClass(parentPointer, "propertyName", false, -1); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parent/path/.[@name='propertyName']", result); [EOL] }
public void testAsPath_IsCollectionWithIndex() { [EOL] Pointer parentPointer = mock(Pointer.class); [EOL] when(parentPointer.asPath()).thenReturn("/parent/path"); [EOL] MyClass instance = new MyClass(parentPointer, "propertyName", true, 2); [EOL] String result = instance.asPath(); [EOL] assertEquals("/parent/path[@name='propertyName'][3]", result); [EOL] }
It appears that the provided input text is for a constructor method that does not contain any executable code. Since the constructor `JXPathContextFactoryReferenceImpl()` is empty, there are no lines of code to cover with unit tests. Therefore, no unit test cases are needed for this specific method, as it does not contribute to line coverage. [EOL] If you have another method or piece of code that you would like to generate test cases for, please provide the relevant code snippet, and I will assist you with generating the test cases.
public void testNewContextWithValidArguments() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] Object contextBean = new Object(); [EOL] JXPathContext result = JXPathContext.newContext(parentContext, contextBean); [EOL] assertNotNull("Resulting JXPathContext should not be null", result); [EOL] assertSame("Parent context should be the one that was passed in", parentContext, result.getParentContext()); [EOL] assertSame("Context bean should be the one that was passed in", contextBean, result.getContextBean()); [EOL] }
public void testNewContextWithNullParentContext() { [EOL] Object contextBean = new Object(); [EOL] JXPathContext result = JXPathContext.newContext(null, contextBean); [EOL] assertNotNull("Resulting JXPathContext should not be null", result); [EOL] assertNull("Parent context should be null", result.getParentContext()); [EOL] assertSame("Context bean should be the one that was passed in", contextBean, result.getContextBean()); [EOL] }
public void testNewContextWithNullContextBean() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContext result = JXPathContext.newContext(parentContext, null); [EOL] assertNotNull("Resulting JXPathContext should not be null", result); [EOL] assertSame("Parent context should be the one that was passed in", parentContext, result.getParentContext()); [EOL] assertNull("Context bean should be null", result.getContextBean()); [EOL] }
public void testEvalContextConstructorWithNullParent() { [EOL] EvalContext context = new EvalContext(null); [EOL] assertNull("Parent context should be null", context.parentContext); [EOL] }
public void testEvalContextConstructorWithNonNullParent() { [EOL] EvalContext parent = new EvalContext(null); [EOL] EvalContext context = new EvalContext(parent); [EOL] assertNotNull("Parent context should not be null", context.parentContext); [EOL] assertSame("Parent context should be the same as the one passed to constructor", parent, context.parentContext); [EOL] }
public JXPathContext getJXPathContext() { [EOL] return getRootContext().getJXPathContext(); [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=Optional[0]; [EOL] boolean startedSetIteration=Optional[false]; [EOL] boolean done=Optional[false]; [EOL] boolean hasPerformedIteratorStep=Optional[false]; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; [EOL] public int compare(Object o1, Object o2) {; [EOL] return ((Comparable) o2).compareTo(o1);; [EOL] }; [EOL] }]
public void testGetDocumentOrder_WithParentContextRequiringChildOrdering() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] when(parentContext.isChildOrderingRequired()).thenReturn(true); [EOL] EvalContext context = new EvalContext(parentContext); [EOL] int order = context.getDocumentOrder(); [EOL] assertEquals(1, order); [EOL] }
public void testGetDocumentOrder_WithParentContextNotRequiringChildOrdering() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] when(parentContext.isChildOrderingRequired()).thenReturn(false); [EOL] EvalContext context = new EvalContext(parentContext); [EOL] int order = context.getDocumentOrder(); [EOL] assertEquals(0, order); [EOL] }
public void testGetDocumentOrder_WithNullParentContext() { [EOL] EvalContext context = new EvalContext(null); [EOL] int order = context.getDocumentOrder(); [EOL] assertEquals(0, order); [EOL] }
public void testIsChildOrderingRequired_DocumentOrderNonZero() { [EOL] EvalContext context = new EvalContext() { [EOL] public int getDocumentOrder() { [EOL] return 1; // Any non-zero value [EOL] } [EOL] }; [EOL] assertTrue(context.isChildOrderingRequired()); [EOL] } [EOL] public void testIsChildOrderingRequired_DocumentOrderZero() { [EOL] EvalContext context = new EvalContext() { [EOL] public int getDocumentOrder() { [EOL] return 0; [EOL] } [EOL] }; [EOL] assertFalse(context.isChildOrderingRequired()); [EOL] }
public boolean hasNext() { [EOL] if (pointerIterator != null) { [EOL] return pointerIterator.hasNext(); [EOL] } [EOL] if (getDocumentOrder() != 0) { [EOL] return constructIterator(); [EOL] } else { [EOL] if (!done && !hasPerformedIteratorStep) { [EOL] performIteratorStep(); [EOL] } [EOL] return !done; [EOL] } [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=Optional[0]; [EOL] boolean startedSetIteration=Optional[false]; [EOL] boolean done=Optional[false]; [EOL] boolean hasPerformedIteratorStep=Optional[false]; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ; [EOL] public int compare(Object o1, Object o2) {; [EOL] return ((Comparable) o2).compareTo(o1);; [EOL] }; }]
public Object next() { [EOL] if (pointerIterator != null) { [EOL] return pointerIterator.next(); [EOL] } [EOL] if (getDocumentOrder() != 0) { [EOL] if (!constructIterator()) { [EOL] throw new NoSuchElementException(); [EOL] } [EOL] return pointerIterator.next(); [EOL] } else { [EOL] if (!done && !hasPerformedIteratorStep) { [EOL] performIteratorStep(); [EOL] } [EOL] if (done) { [EOL] throw new NoSuchElementException(); [EOL] } [EOL] hasPerformedIteratorStep = false; [EOL] return getCurrentNodePointer(); [EOL] } [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=Optional[0]; [EOL] boolean startedSetIteration=Optional[false]; [EOL] boolean done=Optional[false]; [EOL] boolean hasPerformedIteratorStep=Optional[false]; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ; [EOL] public int compare(Object o1, Object o2) {; [EOL] return ((Comparable) o2).compareTo(o1);; [EOL] }; }]
private boolean constructIterator() { [EOL] HashSet set = new HashSet(); [EOL] ArrayList list = new ArrayList(); [EOL] while (nextSet()) { [EOL] while (nextNode()) { [EOL] NodePointer pointer = getCurrentNodePointer(); [EOL] if (!set.contains(pointer)) { [EOL] set.add(pointer); [EOL] list.add(pointer); [EOL] } [EOL] } [EOL] } [EOL] if (list.isEmpty()) { [EOL] return false; [EOL] } [EOL] if (getDocumentOrder() == 1) { [EOL] Collections.sort(list); [EOL] } else { [EOL] Collections.sort(list, REVERSE_COMPARATOR); [EOL] } [EOL] pointerIterator = list.iterator(); [EOL] return true; [EOL] }
public void testGetRootContext_WhenRootContextIsNull() { [EOL] EvalContext evalContext = new EvalContext(null); [EOL] RootContext result = evalContext.getRootContext(); [EOL] assertNull("Root context should be null when parent context is null", result); [EOL] } [EOL] public void testGetRootContext_WhenRootContextIsNotNull() { [EOL] RootContext expectedRootContext = new RootContext(); [EOL] EvalContext parentContext = new EvalContext(null) { [EOL] public RootContext getRootContext() { [EOL] return expectedRootContext; [EOL] } [EOL] }; [EOL] EvalContext evalContext = new EvalContext(parentContext); [EOL] RootContext result = evalContext.getRootContext(); [EOL] assertSame("Root context should be the same as expected", expectedRootContext, result); [EOL] }

public void testReset() { [EOL] EvalContext context = new EvalContext(null); [EOL] context.position = 1; // Assuming there is a way to set position [EOL] context.reset(); [EOL] assertEquals(0, context.getPosition()); [EOL] }
public void testGetPosition_Initial() { [EOL] EvalContext context = new EvalContext(null); [EOL] assertEquals(0, context.getPosition()); [EOL] }
public void testGetPosition_AfterReset() { [EOL] EvalContext context = new EvalContext(null); [EOL] context.position = 2; // Assuming there is a way to set position [EOL] context.reset(); [EOL] assertEquals(0, context.getPosition()); [EOL] }
public int getCurrentPosition() { [EOL] return position; [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=0; [EOL] boolean startedSetIteration=false; [EOL] boolean done=false; [EOL] boolean hasPerformedIteratorStep=false; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=new Comparator() { [EOL] public int compare(Object o1, Object o2) { [EOL] return ((Comparable) o2).compareTo(o1); [EOL] } [EOL] }
public boolean nextSet() { [EOL] reset(); [EOL] if (!startedSetIteration) { [EOL] startedSetIteration = true; [EOL] while (parentContext.nextSet()) { [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] } [EOL] return false; [EOL] } [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] while (parentContext.nextSet()) { [EOL] if (parentContext.nextNode()) { [EOL] return true; [EOL] } [EOL] } [EOL] return false; [EOL] } [EOL] public EvalContext(EvalContext parentContext); [EOL] public int compare(Object o1, Object o2); [EOL] public Pointer getContextNodePointer(); [EOL] public JXPathContext getJXPathContext(); [EOL] public int getPosition(); [EOL] public int getDocumentOrder(); [EOL] public boolean isChildOrderingRequired(); [EOL] public boolean hasNext(); [EOL] public Object next(); [EOL] private void performIteratorStep(); [EOL] public void remove(); [EOL] private boolean constructIterator(); [EOL] public List getContextNodeList(); [EOL] public NodeSet getNodeSet(); [EOL] public Object getValue(); [EOL] public String toString(); [EOL] public RootContext getRootContext(); [EOL] public void reset(); [EOL] public int getCurrentPosition(); [EOL] public Pointer getSingleNodePointer(); [EOL] public abstract NodePointer getCurrentNodePointer(); [EOL] public boolean nextSet(); [EOL] public abstract boolean nextNode(); [EOL] public boolean setPosition(int position); [EOL] EvalContext parentContext; [EOL] RootContext rootContext; [EOL] int position=Optional[0]; [EOL] boolean startedSetIteration=Optional[false]; [EOL] boolean done=Optional[false]; [EOL] boolean hasPerformedIteratorStep=Optional[false]; [EOL] Iterator pointerIterator; [EOL] Comparator REVERSE_COMPARATOR=Optional[new Comparator() { [EOL] public int compare(Object o1, Object o2) { [EOL] return ((Comparable) o2).compareTo(o1); [EOL] }; [EOL] }]
public void testSetPosition_PositiveNumber() { [EOL] EvalContext context = new EvalContext(null); [EOL] boolean result = context.setPosition(1); [EOL] assertTrue(result); [EOL] assertEquals(1, context.getPosition()); [EOL] }
public void testSetPosition_Zero() { [EOL] EvalContext context = new EvalContext(null); [EOL] boolean result = context.setPosition(0); [EOL] assertTrue(result); [EOL] assertEquals(0, context.getPosition()); [EOL] }
public void testSetPosition_NegativeNumber() { [EOL] EvalContext context = new EvalContext(null); [EOL] boolean result = context.setPosition(-1); [EOL] assertTrue(result); [EOL] assertEquals(-1, context.getPosition()); [EOL] }
public void testConstantWithNullNumber() { [EOL] try { [EOL] new Constant(null); [EOL] fail("Should have thrown NullPointerException for null number"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testConstantWithNonNullNumber() { [EOL] Number number = 10; [EOL] Constant constant = new Constant(number); [EOL] assertEquals("The value should be equal to the number provided", number, constant.getValue()); [EOL] }
public void testConstantWithString() { [EOL] String testString = "testValue"; [EOL] Constant constant = new Constant(testString); [EOL] assertEquals(testString, constant.value); [EOL] }
public void testComputeValueWithNonNullContext() { [EOL] EvalContext context = new MockEvalContext(); // Replace MockEvalContext with actual implementation [EOL] Object expectedValue = new Object(); // Replace with the actual expected value [EOL] this.value = expectedValue; // Assuming 'value' is a field in the class [EOL] Object result = computeValue(context); [EOL] assertEquals(expectedValue, result); [EOL] }

public boolean isContextDependent() { [EOL] return false; [EOL] }
public void testToStringWithIntegerValue() { [EOL] MyClass instance = new MyClass(5); [EOL] String result = instance.toString(); [EOL] assertEquals("5", result); [EOL] }
public void testToStringWithDoubleValue() { [EOL] MyClass instance = new MyClass(5.5); [EOL] String result = instance.toString(); [EOL] assertEquals("5.5", result); [EOL] }
public void testToStringWithNonNumberValue() { [EOL] MyClass instance = new MyClass("test"); [EOL] String result = instance.toString(); [EOL] assertEquals("'test'", result); [EOL] }
public int getOrder() { [EOL] return BEAN_POINTER_FACTORY_ORDER; [EOL] }
protected boolean equal(EvalContext context, Expression left, Expression right) { [EOL] Object l = left.compute(context); [EOL] Object r = right.compute(context); [EOL] if (l instanceof InitialContext || l instanceof SelfContext) { [EOL] l = ((EvalContext) l).getSingleNodePointer(); [EOL] } [EOL] if (r instanceof InitialContext || r instanceof SelfContext) { [EOL] r = ((EvalContext) r).getSingleNodePointer(); [EOL] } [EOL] if (l instanceof Collection) { [EOL] l = ((Collection) l).iterator(); [EOL] } [EOL] if (r instanceof Collection) { [EOL] r = ((Collection) r).iterator(); [EOL] } [EOL] if ((l instanceof Iterator) && !(r instanceof Iterator)) { [EOL] return contains((Iterator) l, r); [EOL] } else if (!(l instanceof Iterator) && (r instanceof Iterator)) { [EOL] return contains((Iterator) r, l); [EOL] } else if (l instanceof Iterator && r instanceof Iterator) { [EOL] return findMatch((Iterator) l, (Iterator) r); [EOL] } [EOL] return equal(l, r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL] if (l instanceof Pointer && r instanceof Pointer) { [EOL] if (l.equals(r)) { [EOL] return true; [EOL] } [EOL] } [EOL] if (l instanceof Pointer) { [EOL] l = ((Pointer) l).getValue(); [EOL] } [EOL] if (r instanceof Pointer) { [EOL] r = ((Pointer) r).getValue(); [EOL] } [EOL] if (l == r) { [EOL] return true; [EOL] } [EOL] if (l instanceof Boolean || r instanceof Boolean) { [EOL] return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL] } else if (l instanceof Number || r instanceof Number) { [EOL] return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL] } else if (l instanceof String || r instanceof String) { [EOL] return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL] } else if (l == null) { [EOL] return r == null; [EOL] } [EOL] return l.equals(r); [EOL] }
public boolean canConvert(Object object, Class toType) { [EOL] if (object == null) { [EOL] return true; [EOL] } [EOL] if (toType == Object.class) { [EOL] return true; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType)) { [EOL] return true; [EOL] } [EOL] if (toType.isAssignableFrom(fromType)) { [EOL] return true; [EOL] } [EOL] if (toType == String.class) { [EOL] return true; [EOL] } [EOL] if (object instanceof Boolean) { [EOL] if (toType == boolean.class || Number.class.isAssignableFrom(toType)) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof Number) { [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return true; [EOL] } [EOL] } else if (object instanceof String) { [EOL] if (toType.isPrimitive()) { [EOL] return true; [EOL] } [EOL] if (toType == Boolean.class || toType == Character.class || toType == Byte.class || toType == Short.class || toType == Integer.class || toType == Long.class || toType == Float.class || toType == Double.class) { [EOL] return true; [EOL] } [EOL] } else if (fromType.isArray()) { [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] int length = Array.getLength(object); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] if (!canConvert(value, cType)) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] return canCreateCollection(toType); [EOL] } else { [EOL] if (Array.getLength(object) > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return canConvert(value, toType); [EOL] } else { [EOL] return canConvert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] while (it.hasNext()) { [EOL] Object value = it.next(); [EOL] if (!canConvert(value, cType)) { [EOL] return false; [EOL] } [EOL] } [EOL] return true; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] return canCreateCollection(toType); [EOL] } else { [EOL] if (((Collection) object).size() > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return canConvert(value, toType); [EOL] } else { [EOL] return canConvert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return canConvert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return canConvert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return ConvertUtils.lookup(toType) != null; [EOL] }
public Object convert(Object object, Class toType) { [EOL] if (object == null) { [EOL] if (toType.isPrimitive()) { [EOL] return convertNullToPrimitive(toType); [EOL] } [EOL] return null; [EOL] } [EOL] if (toType == Object.class) { [EOL] if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } [EOL] return object; [EOL] } [EOL] Class fromType = object.getClass(); [EOL] if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL] return object; [EOL] } [EOL] if (fromType.isArray()) { [EOL] int length = Array.getLength(object); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = Array.get(object, i); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] for (int i = 0; i < length; i++) { [EOL] collection.add(Array.get(object, i)); [EOL] } [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value = Array.get(object, 0); [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof Collection) { [EOL] int length = ((Collection) object).size(); [EOL] if (toType.isArray()) { [EOL] Class cType = toType.getComponentType(); [EOL] Object array = Array.newInstance(cType, length); [EOL] Iterator it = ((Collection) object).iterator(); [EOL] for (int i = 0; i < length; i++) { [EOL] Object value = it.next(); [EOL] Array.set(array, i, convert(value, cType)); [EOL] } [EOL] return array; [EOL] } else if (Collection.class.isAssignableFrom(toType)) { [EOL] Collection collection = allocateCollection(toType); [EOL] collection.addAll((Collection) object); [EOL] return unmodifiableCollection(collection); [EOL] } else { [EOL] if (length > 0) { [EOL] Object value; [EOL] if (object instanceof List) { [EOL] value = ((List) object).get(0); [EOL] } else { [EOL] Iterator it = ((Collection) object).iterator(); [EOL] value = it.next(); [EOL] } [EOL] return convert(value, toType); [EOL] } else { [EOL] return convert("", toType); [EOL] } [EOL] } [EOL] } else if (object instanceof NodeSet) { [EOL] return convert(((NodeSet) object).getValues(), toType); [EOL] } else if (object instanceof Pointer) { [EOL] return convert(((Pointer) object).getValue(), toType); [EOL] } else if (toType == String.class) { [EOL] return object.toString(); [EOL] } else if (object instanceof Boolean) { [EOL] if (toType == boolean.class) { [EOL] return object; [EOL] } [EOL] boolean value = ((Boolean) object).booleanValue(); [EOL] return allocateNumber(toType, value ? 1 : 0); [EOL] } else if (object instanceof Number) { [EOL] double value = ((Number) object).doubleValue(); [EOL] if (toType == boolean.class || toType == Boolean.class) { [EOL] return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL] } [EOL] if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL] return allocateNumber(toType, value); [EOL] } [EOL] } else if (object instanceof Character) { [EOL] if (toType == char.class) { [EOL] return object; [EOL] } [EOL] } else if (object instanceof String) { [EOL] Object value = convertStringToPrimitive(object, toType); [EOL] if (value != null) { [EOL] return value; [EOL] } [EOL] } [EOL] Converter converter = ConvertUtils.lookup(toType); [EOL] if (converter != null) { [EOL] return converter.convert(toType, object); [EOL] } [EOL] throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
public void testCanCreateCollectionWithNonInterfaceNonAbstractClass() { [EOL] boolean result = canCreateCollection(SomeConcreteClass.class); [EOL] assertTrue(result); [EOL] }
public void testCanCreateCollectionWithInterface() { [EOL] boolean result = canCreateCollection(List.class); [EOL] assertTrue(result); [EOL] }
public void testCanCreateCollectionWithAbstractClass() { [EOL] boolean result = canCreateCollection(AbstractList.class); [EOL] assertFalse(result); [EOL] }
public void testCanCreateCollectionWithSetInterface() { [EOL] boolean result = canCreateCollection(Set.class); [EOL] assertTrue(result); [EOL] }
public void testAllocateCollectionWithConcreteClass() throws Exception { [EOL] Class type = ArrayList.class; [EOL] Collection result = allocateCollection(type); [EOL] assertTrue(result instanceof ArrayList); [EOL] }
public void testAllocateCollectionWithListInterface() throws Exception { [EOL] Class type = List.class; [EOL] Collection result = allocateCollection(type); [EOL] assertTrue(result instanceof ArrayList); [EOL] }
public void testAllocateCollectionWithSetInterface() throws Exception { [EOL] Class type = Set.class; [EOL] Collection result = allocateCollection(type); [EOL] assertTrue(result instanceof HashSet); [EOL] }
public void testAllocateCollectionWithAbstractClass() { [EOL] Class type = AbstractCollection.class; [EOL] try { [EOL] allocateCollection(type); [EOL] fail("JXPathInvalidAccessException expected"); [EOL] } catch (JXPathInvalidAccessException ex) { [EOL] } [EOL] }
public void testAllocateCollectionWithInterfaceHavingNoDefaultImplementation() { [EOL] Class type = Queue.class; [EOL] try { [EOL] allocateCollection(type); [EOL] fail("JXPathInvalidAccessException expected"); [EOL] } catch (JXPathInvalidAccessException ex) { [EOL] } [EOL] }
public void testUnmodifiableCollectionWithList() { [EOL] List<String> list = new ArrayList<>(); [EOL] list.add("test"); [EOL] Collection result = unmodifiableCollection(list); [EOL] assertTrue(result instanceof List); [EOL] assertEquals(Collections.unmodifiableList(list), result); [EOL] }
public void testUnmodifiableCollectionWithSet() { [EOL] Set<String> set = new HashSet<>(); [EOL] set.add("test"); [EOL] Collection result = unmodifiableCollection(set); [EOL] assertTrue(result instanceof Set); [EOL] assertEquals(Collections.unmodifiableSet(set), result); [EOL] }
public void testUnmodifiableCollectionWithOtherCollection() { [EOL] Collection<String> collection = new LinkedList<>(); [EOL] collection.add("test"); [EOL] Collection result = unmodifiableCollection(collection); [EOL] assertSame(collection, result); [EOL] }
public void testCoreOperationEqual() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationEqual operation = new CoreOperationEqual(arg1, arg2); [EOL] assertNotNull(operation); [EOL] }
protected int getPrecedence() { [EOL] return 2; [EOL] }
public void testGetSymbol() { [EOL] MyClass instance = new MyClass(); [EOL] String expected = "="; [EOL] String actual = instance.getSymbol(); [EOL] assertEquals(expected, actual); [EOL] }
public void testAsPath_WithParent() { [EOL] Node parentNode = new Node(); // Replace Node with the actual class name [EOL] node.setParent(parentNode); [EOL] when(parentNode.asPath()).thenReturn("/parent/path"); [EOL] String result = node.asPath(); [EOL] assertEquals("/parent/path", result); [EOL] }
public void testAsPath_WithoutParent() { [EOL] node.setParent(null); [EOL] String result = node.asPath(); [EOL] assertEquals("/", result); [EOL] }
public void testInitialContextWithNonNullParentContextAndNodePointer() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.clone()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION); [EOL] InitialContext context = new InitialContext(parentContext); [EOL] assertNotNull(context); [EOL] assertEquals(mockNodePointer, context.nodePointer); [EOL] assertTrue(context.collection); [EOL] }
public void testInitialContextWithNonNullParentContextAndNonWholeCollectionNodePointer() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.clone()).thenReturn(mockNodePointer); [EOL] when(mockNodePointer.getIndex()).thenReturn(0); [EOL] InitialContext context = new InitialContext(parentContext); [EOL] assertNotNull(context); [EOL] assertEquals(mockNodePointer, context.nodePointer); [EOL] assertFalse(context.collection); [EOL] }
public void testInitialContextWithNullParentContextNodePointer() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(null); [EOL] InitialContext context = new InitialContext(parentContext); [EOL] assertNotNull(context); [EOL] assertNull(context.nodePointer); [EOL] }
public void testGetCurrentNodePointer() { [EOL] NodePointer expected = new NodePointer(); // Assuming NodePointer is a class that can be instantiated. [EOL] instance.nodePointer = expected; // Directly setting the nodePointer for the purpose of the test. [EOL] NodePointer result = instance.getCurrentNodePointer(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetValueWhenNodePointerIsNull() { [EOL] MyClass instance = new MyClass(null); // Assuming MyClass is the class name and it has such a constructor [EOL] Object result = instance.getValue(); [EOL] assertNull("Expected null when nodePointer is null", result); [EOL] } [EOL] public void testGetValueWhenNodePointerIsNotNull() { [EOL] NodePointer mockNodePointer = mock(NodePointer.class); // Assuming use of a mocking framework like Mockito [EOL] when(mockNodePointer.getValue()).thenReturn("MockValue"); [EOL] MyClass instance = new MyClass(mockNodePointer); // Assuming MyClass is the class name and it has such a constructor [EOL] Object result = instance.getValue(); [EOL] assertNotNull("Expected non-null when nodePointer is not null", result); [EOL] assertEquals("Expected value from nodePointer", "MockValue", result); [EOL] }
public boolean nextNode() { [EOL] return setPosition(position + 1); [EOL] }
public void testSetPositionWithinCollectionBounds() { [EOL] YourClass instance = new YourClass(); [EOL] instance.collection = true; [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.getLength()).thenReturn(5); [EOL] instance.nodePointer = mockNodePointer; [EOL] boolean result = instance.setPosition(3); [EOL] Mockito.verify(mockNodePointer).setIndex(2); [EOL] assertTrue(result); [EOL] }
public void testSetPositionOutsideCollectionBounds() { [EOL] YourClass instance = new YourClass(); [EOL] instance.collection = true; [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] Mockito.when(mockNodePointer.getLength()).thenReturn(5); [EOL] instance.nodePointer = mockNodePointer; [EOL] boolean result = instance.setPosition(6); [EOL] assertFalse(result); [EOL] }
public void testSetPositionNotInCollection() { [EOL] YourClass instance = new YourClass(); [EOL] instance.collection = false; [EOL] boolean result = instance.setPosition(1); [EOL] assertTrue(result); [EOL] result = instance.setPosition(2); [EOL] assertFalse(result); [EOL] }
public void testNextSet_StartedTrue() { [EOL] yourObject.setStarted(true); // You need to replace 'yourObject' with the actual object name [EOL] boolean result = yourObject.nextSet(); [EOL] assertFalse(result); [EOL] } [EOL] public void testNextSet_StartedFalse() { [EOL] yourObject.setStarted(false); // You need to replace 'yourObject' with the actual object name [EOL] boolean result = yourObject.nextSet(); [EOL] assertTrue(result); [EOL] }
public void testPropertyIteratorWithForwardAndStartWithNull() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] String name = "testProperty"; [EOL] boolean reverse = false; [EOL] NodePointer startWith = null; [EOL] PropertyIterator iterator = new PropertyIterator(pointer, name, reverse, startWith); [EOL] assertEquals("Property name should be set", name, iterator.name); [EOL] assertFalse("Reverse should be false", iterator.reverse); [EOL] assertTrue("Include start should be true", iterator.includeStart); [EOL] assertEquals("Start property index should be default", PropertyPointer.UNSPECIFIED_PROPERTY, iterator.startPropertyIndex); [EOL] assertEquals("Start index should be default", 0, iterator.startIndex); [EOL] }
public void testPropertyIteratorWithReverseAndStartWithNull() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] String name = "testProperty"; [EOL] boolean reverse = true; [EOL] NodePointer startWith = null; [EOL] PropertyIterator iterator = new PropertyIterator(pointer, name, reverse, startWith); [EOL] assertEquals("Property name should be set", name, iterator.name); [EOL] assertTrue("Reverse should be true", iterator.reverse); [EOL] assertTrue("Include start should be true", iterator.includeStart); [EOL] assertEquals("Start property index should be default", PropertyPointer.UNSPECIFIED_PROPERTY, iterator.startPropertyIndex); [EOL] assertEquals("Start index should be -1", -1, iterator.startIndex); [EOL] }
public void testPropertyIteratorWithStartWithNotNull() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] NodePointer startWith = mock(NodePointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] when(startWith.getImmediateParentPointer()).thenReturn(pointer); [EOL] when(startWith.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION); [EOL] when(((PropertyPointer) startWith).getPropertyIndex()).thenReturn(1); [EOL] String name = "testProperty"; [EOL] boolean reverse = false; [EOL] PropertyIterator iterator = new PropertyIterator(pointer, name, reverse, startWith); [EOL] assertEquals("Property name should be set", name, iterator.name); [EOL] assertFalse("Reverse should be false", iterator.reverse); [EOL] assertFalse("Include start should be false", iterator.includeStart); [EOL] assertEquals("Start property index should be set", 1, iterator.startPropertyIndex); [EOL] assertEquals("Start index should be 0", 0, iterator.startIndex); [EOL] }
public void testPropertyIteratorWithReverseAndStartWithNotNull() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] NodePointer startWith = mock(NodePointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] when(startWith.getImmediateParentPointer()).thenReturn(pointer); [EOL] when(startWith.getIndex()).thenReturn(-1); [EOL] when(((PropertyPointer) startWith).getPropertyIndex()).thenReturn(1); [EOL] String name = "testProperty"; [EOL] boolean reverse = true; [EOL] PropertyIterator iterator = new PropertyIterator(pointer, name, reverse, startWith); [EOL] assertEquals("Property name should be set", name, iterator.name); [EOL] assertTrue("Reverse should be true", iterator.reverse); [EOL] assertTrue("Include start should be true", iterator.includeStart); [EOL] assertEquals("Start property index should be set", 1, iterator.startPropertyIndex); [EOL] assertEquals("Start index should be -1", -1, iterator.startIndex); [EOL] }
public void testPropertyIteratorWithStartWithNotChildOfParent() { [EOL] PropertyOwnerPointer pointer = mock(PropertyOwnerPointer.class); [EOL] PropertyPointer propertyPointer = mock(PropertyPointer.class); [EOL] NodePointer startWith = mock(NodePointer.class); [EOL] when(pointer.getPropertyPointer()).thenReturn(propertyPointer); [EOL] when(propertyPointer.clone()).thenReturn(propertyPointer); [EOL] when(startWith.getImmediateParentPointer()).thenReturn(null); [EOL] String name = "testProperty"; [EOL] boolean reverse = false; [EOL] try { [EOL] new PropertyIterator(pointer, name, reverse, startWith); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("PropertyIerator startWith parameter is not a child of the supplied parent", e.getMessage()); [EOL] } [EOL] }
public void testSetPositionAllProperties_PositionLessThanOne() { [EOL] boolean result = setPositionAllProperties(0); [EOL] assertFalse(result); [EOL] }
public void testSetPositionAllProperties_ForwardTraversal_WithinBounds() { [EOL] boolean result = setPositionAllProperties(2); // Assuming 2 is within bounds [EOL] assertTrue(result); [EOL] }
public void testSetPositionAllProperties_ForwardTraversal_OutOfBounds() { [EOL] boolean result = setPositionAllProperties(10); // Assuming 10 is out of bounds [EOL] assertFalse(result); [EOL] }
public void testSetPositionAllProperties_ReverseTraversal_WithinBounds() { [EOL] boolean result = setPositionAllProperties(2); // Assuming 2 is within bounds and reverse is true [EOL] assertTrue(result); [EOL] }
public void testSetPositionAllProperties_ReverseTraversal_OutOfBounds() { [EOL] boolean result = setPositionAllProperties(10); // Assuming 10 is out of bounds and reverse is true [EOL] assertFalse(result); [EOL] }
public Object compute(EvalContext context) { [EOL] return computeValue(context); [EOL] }
public void testQnameWithNonNullPrefixAndName() { [EOL] String prefix = "testPrefix"; [EOL] String name = "testName"; [EOL] Object result = qname(prefix, name); [EOL] assertTrue(result instanceof QName); [EOL] QName qNameResult = (QName) result; [EOL] assertEquals(prefix, qNameResult.getPrefix()); [EOL] assertEquals(name, qNameResult.getLocalPart()); [EOL] }
public void testQnameWithNullPrefix() { [EOL] String prefix = null; [EOL] String name = "testName"; [EOL] Object result = qname(prefix, name); [EOL] assertTrue(result instanceof QName); [EOL] QName qNameResult = (QName) result; [EOL] assertNull(qNameResult.getPrefix()); [EOL] assertEquals(name, qNameResult.getLocalPart()); [EOL] }
public void testQnameWithNullName() { [EOL] String prefix = "testPrefix"; [EOL] String name = null; [EOL] Object result = qname(prefix, name); [EOL] assertTrue(result instanceof QName); [EOL] QName qNameResult = (QName) result; [EOL] assertEquals(prefix, qNameResult.getPrefix()); [EOL] assertNull(qNameResult.getLocalPart()); [EOL] }
public void testQnameWithNullPrefixAndName() { [EOL] String prefix = null; [EOL] String name = null; [EOL] Object result = qname(prefix, name); [EOL] assertTrue(result instanceof QName); [EOL] QName qNameResult = (QName) result; [EOL] assertNull(qNameResult.getPrefix()); [EOL] assertNull(qNameResult.getLocalPart()); [EOL] }
public void testDivideWithValidExpressions() { [EOL] Expression left = new ExpressionImpl(); [EOL] Expression right = new ExpressionImpl(); [EOL] Object result = divide(left, right); [EOL] assertTrue(result instanceof CoreOperationDivide); [EOL] assertEquals(left, ((CoreOperationDivide) result).getLeft()); [EOL] assertEquals(right, ((CoreOperationDivide) result).getRight()); [EOL] }
public void testGreaterThanOrEqualWithValidExpressions() { [EOL] Expression left = mock(Expression.class); [EOL] Expression right = mock(Expression.class); [EOL] Object result = greaterThanOrEqual(left, right); [EOL] assertTrue(result instanceof CoreOperationGreaterThanOrEqual); [EOL] }
public void testGreaterThanOrEqualWithLeftNull() { [EOL] Expression right = mock(Expression.class); [EOL] try { [EOL] greaterThanOrEqual(null, right); [EOL] fail("Expected an exception for null left expression"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testGreaterThanOrEqualWithRightNull() { [EOL] Expression left = mock(Expression.class); [EOL] try { [EOL] greaterThanOrEqual(left, null); [EOL] fail("Expected an exception for null right expression"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testVariableReferenceWithValidQName() { [EOL] QName qName = new QName("namespace", "localPart"); [EOL] Object result = variableReference(qName); [EOL] assertTrue(result instanceof VariableReference); [EOL] VariableReference varRef = (VariableReference) result; [EOL] assertEquals(qName, varRef.getQName()); [EOL] }
public void testFunctionWithValidNameAndArgs() { [EOL] Object name = new QName("http://example.com", "testFunction"); [EOL] Object[] args = new Object[] { "arg1", 2, 3.0 }; [EOL] Object result = function(name, args); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ExtensionFunction); [EOL] ExtensionFunction extFunc = (ExtensionFunction) result; [EOL] assertEquals(name, extFunc.getName()); [EOL] Expression[] expressions = extFunc.getArguments(); [EOL] assertEquals(args.length, expressions.length); [EOL] }
public void testFunctionWithNullName() { [EOL] Object name = null; [EOL] Object[] args = new Object[] { "arg1", 2, 3.0 }; [EOL] try { [EOL] function(name, args); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertTrue(e instanceof IllegalArgumentException); [EOL] } [EOL] }
public void testFunctionWithNullArgs() { [EOL] Object name = new QName("http://example.com", "testFunction"); [EOL] Object[] args = null; [EOL] Object result = function(name, args); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ExtensionFunction); [EOL] ExtensionFunction extFunc = (ExtensionFunction) result; [EOL] assertEquals(name, extFunc.getName()); [EOL] Expression[] expressions = extFunc.getArguments(); [EOL] assertNull(expressions); [EOL] }
public void testExpressionPathWithValidArguments() { [EOL] Object expression = mock(Expression.class); [EOL] Object[] predicates = new Object[] { mock(Expression.class), mock(Expression.class) }; [EOL] Object[] steps = new Object[] { mock(Step.class), mock(Step.class) }; [EOL] Object result = expressionPath(expression, predicates, steps); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ExpressionPath); [EOL] ExpressionPath expressionPathResult = (ExpressionPath) result; [EOL] assertEquals(expression, expressionPathResult.getExpression()); [EOL] assertArrayEquals(predicates, expressionPathResult.getPredicates()); [EOL] assertArrayEquals(steps, expressionPathResult.getSteps()); [EOL] }
public void testNodeNameTestWithValidQName() { [EOL] QName qname = new QName("namespace", "localPart"); [EOL] Object result = nodeNameTest(qname); [EOL] assertTrue(result instanceof NodeNameTest); [EOL] assertEquals("localPart", ((NodeNameTest) result).getNodeName().getLocalName()); [EOL] assertEquals("namespace", ((NodeNameTest) result).getNodeName().getNamespaceURI()); [EOL] }
public void testNodeNameTestWithNull() { [EOL] Object result = nodeNameTest(null); [EOL] try { [EOL] NodeNameTest testName = (NodeNameTest) result; [EOL] fail("Expected a ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testNodeTypeTestWithValidType() { [EOL] int nodeType = NodeType.ELEMENT_NODE; // Assuming NodeType is a valid class with ELEMENT_NODE constant [EOL] Object result = nodeTypeTest(nodeType); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodeTypeTest); [EOL] assertEquals(nodeType, ((NodeTypeTest) result).getNodeType()); [EOL] }
public void testNodeTypeTestWithInvalidType() { [EOL] int nodeType = -1; // Assuming -1 is an invalid node type [EOL] Object result = nodeTypeTest(nodeType); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodeTypeTest); [EOL] assertEquals(nodeType, ((NodeTypeTest) result).getNodeType()); [EOL] }
public void testStepWithValidArguments() { [EOL] int axis = Axis.CHILD; [EOL] NodeTest nodeTest = new NameTest(NameTest.NAME); [EOL] Object[] predicates = new Object[] { new Predicate(new LiteralExpr("predicate1")), new Predicate(new LiteralExpr("predicate2")) }; [EOL] Object result = step(axis, nodeTest, predicates); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Step); [EOL] Step stepResult = (Step) result; [EOL] assertEquals(axis, stepResult.getAxis()); [EOL] assertEquals(nodeTest, stepResult.getNodeTest()); [EOL] Expression[] expressions = stepResult.getPredicates(); [EOL] assertNotNull(expressions); [EOL] assertEquals(predicates.length, expressions.length); [EOL] for (int i = 0; i < expressions.length; i++) { [EOL] assertEquals(predicates[i], expressions[i]); [EOL] } [EOL] }
public void testToStepArrayWithNonNullArray() { [EOL] Object[] array = new Object[]{new Step(), new Step()}; [EOL] Step[] result = toStepArray(array); [EOL] assertNotNull(result); [EOL] assertEquals(array.length, result.length); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertSame(array[i], result[i]); [EOL] } [EOL] }
public void testToStepArrayWithNullArray() { [EOL] Object[] array = null; [EOL] Step[] result = toStepArray(array); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithWildcardName() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("*"); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithWholeCollection() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("validPropertyName"); [EOL] jxPath.setIndex(JxPath.WHOLE_COLLECTION); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndValidIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(validIndex); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedIndexedValue, result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndInvalidIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(invalidIndex); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithIndexedPropertyAndIllegalArgumentException() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("indexedPropertyName"); [EOL] jxPath.setIndex(indexThatCausesIllegalArgumentException); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedValueAfterException, result); [EOL] }
public void testGetImmediateNodeWithNonIndexedPropertyAndNonZeroIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("nonIndexedPropertyName"); [EOL] jxPath.setIndex(nonZeroIndex); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNull(result); [EOL] }
public void testGetImmediateNodeWithNonIndexedPropertyAndZeroIndex() { [EOL] JXPathContext context = JXPathContext.newContext(new TestBean()); [EOL] JxPath jxPath = new JxPath(context); [EOL] jxPath.setPropertyName("nonIndexedPropertyName"); [EOL] jxPath.setIndex(0); [EOL] Object result = jxPath.getImmediateNode(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedNonIndexedValue, result); [EOL] }
public void testCoreOperationLessThanWithNonNullArguments() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationLessThan operation = new CoreOperationLessThan(arg1, arg2); [EOL] assertNotNull(operation); [EOL] }
public void testGetPrecedence() { [EOL] SomeClass instance = new SomeClass(); [EOL] int expected = 3; [EOL] int actual = instance.getPrecedence(); [EOL] assertEquals(expected, actual); [EOL] }
protected boolean isSymmetric() { [EOL] return false; [EOL] }
public String getSymbolTest() { [EOL] YourClass instance = new YourClass(); [EOL] String result = instance.getSymbol(); [EOL] assertEquals("<", result); [EOL] }
public void testToStringWithAxisChild() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_CHILD); [EOL] instance.setNodeTest("testNode"); [EOL] String result = instance.toString(); [EOL] assertEquals("testNode", result); [EOL] }
public void testToStringWithAxisAttribute() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_ATTRIBUTE); [EOL] instance.setNodeTest("testNode"); [EOL] String result = instance.toString(); [EOL] assertEquals("@testNode", result); [EOL] }
public void testToStringWithAxisSelfNodeTypeNode() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_SELF); [EOL] NodeTypeTest nodeTest = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] instance.setNodeTest(nodeTest); [EOL] String result = instance.toString(); [EOL] assertEquals(".", result); [EOL] }
public void testToStringWithAxisParentNodeTypeNode() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_PARENT); [EOL] NodeTypeTest nodeTest = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] instance.setNodeTest(nodeTest); [EOL] String result = instance.toString(); [EOL] assertEquals("..", result); [EOL] }
public void testToStringWithAxisDescendantOrSelfNodeTypeNodeNoPredicates() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_DESCENDANT_OR_SELF); [EOL] NodeTypeTest nodeTest = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] instance.setNodeTest(nodeTest); [EOL] instance.setPredicates(null); [EOL] String result = instance.toString(); [EOL] assertEquals("", result); [EOL] }
public void testToStringWithOtherAxis() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_OTHER); [EOL] instance.setNodeTest("testNode"); [EOL] String result = instance.toString(); [EOL] assertTrue(result.startsWith("otherAxisString::testNode")); [EOL] }
public void testToStringWithPredicates() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setAxis(Compiler.AXIS_OTHER); [EOL] instance.setNodeTest("testNode"); [EOL] Expression[] predicates = new Expression[] {new Expression("predicate1"), new Expression("predicate2")}; [EOL] instance.setPredicates(predicates); [EOL] String result = instance.toString(); [EOL] assertEquals("otherAxisString::testNode[predicate1][predicate2]", result); [EOL] }
public void testAxisToStringSelf() { [EOL] String result = axisToString(Compiler.AXIS_SELF); [EOL] assertEquals("self", result); [EOL] } [EOL] public void testAxisToStringChild() { [EOL] String result = axisToString(Compiler.AXIS_CHILD); [EOL] assertEquals("child", result); [EOL] } [EOL] public void testAxisToStringParent() { [EOL] String result = axisToString(Compiler.AXIS_PARENT); [EOL] assertEquals("parent", result); [EOL] } [EOL] public void testAxisToStringAncestor() { [EOL] String result = axisToString(Compiler.AXIS_ANCESTOR); [EOL] assertEquals("ancestor", result); [EOL] } [EOL] public void testAxisToStringAttribute() { [EOL] String result = axisToString(Compiler.AXIS_ATTRIBUTE); [EOL] assertEquals("attribute", result); [EOL] } [EOL] public void testAxisToStringNamespace() { [EOL] String result = axisToString(Compiler.AXIS_NAMESPACE); [EOL] assertEquals("namespace", result); [EOL] } [EOL] public void testAxisToStringPreceding() { [EOL] String result = axisToString(Compiler.AXIS_PRECEDING); [EOL] assertEquals("preceding", result); [EOL] } [EOL] public void testAxisToStringFollowing() { [EOL] String result = axisToString(Compiler.AXIS_FOLLOWING); [EOL] assertEquals("following", result); [EOL] } [EOL] public void testAxisToStringDescendant() { [EOL] String result = axisToString(Compiler.AXIS_DESCENDANT); [EOL] assertEquals("descendant", result); [EOL] } [EOL] public void testAxisToStringAncestorOrSelf() { [EOL] String result = axisToString(Compiler.AXIS_ANCESTOR_OR_SELF); [EOL] assertEquals("ancestor-or-self", result); [EOL] } [EOL] public void testAxisToStringFollowingSibling() { [EOL] String result = axisToString(Compiler.AXIS_FOLLOWING_SIBLING); [EOL] assertEquals("following-sibling", result); [EOL] } [EOL] public void testAxisToStringPrecedingSibling() { [EOL] String result = axisToString(Compiler.AXIS_PRECEDING_SIBLING); [EOL] assertEquals("preceding-sibling", result); [EOL] } [EOL] public void testAxisToStringDescendantOrSelf() { [EOL] String result = axisToString(Compiler.AXIS_DESCENDANT_OR_SELF); [EOL] assertEquals("descendant-or-self", result); [EOL] } [EOL] public void testAxisToStringUnknown() { [EOL] String result = axisToString(-1); [EOL] assertEquals("UNKNOWN", result); [EOL] }
public void testGetDefaultNamespaceURI_Null() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] assertNull("Default namespace URI should be null", context.getDefaultNamespaceURI()); [EOL] }
public void testGetDefaultNamespaceURI_NonNull() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setDefaultNamespaceURI("http://example.com/"); [EOL] assertEquals("Default namespace URI should be 'http://example.com/'", "http://example.com/", context.getDefaultNamespaceURI()); [EOL] }
public void testRegisterDefaultNamespaceURI() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] String expectedUri = "http://example.com"; [EOL] context.registerDefaultNamespaceURI(expectedUri); [EOL] assertEquals("Default namespace URI should be set", expectedUri, context.getDefaultNamespaceURI()); [EOL] }
public void testSeal_WithNoParent() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.seal(); [EOL] assertTrue("Context should be sealed", context.isSealed()); [EOL] }
public void testSeal_WithParent() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] JXPathContext childContext = parentContext.newContext(new Object()); [EOL] childContext.seal(); [EOL] assertTrue("Child context should be sealed", childContext.isSealed()); [EOL] assertTrue("Parent context should be sealed", parentContext.isSealed()); [EOL] }
public void testGetContextFactoryWhenNull() { [EOL] JXPathContextFactory result = ClassName.getContextFactory(); [EOL] assertNotNull(result); [EOL] }
public void testGetContextFactoryWhenNotNull() { [EOL] ClassName.setContextFactory(new JXPathContextFactoryImplementation()); [EOL] JXPathContextFactory result = ClassName.getContextFactory(); [EOL] assertNotNull(result); [EOL] }
public Object testGetContextBeanWithNonNullContextBean() { [EOL] Object expectedBean = new Object(); [EOL] JXPathContext context = JXPathContext.newContext(expectedBean); [EOL] Object result = context.getContextBean(); [EOL] assertSame("The returned context bean should be the one that was set.", expectedBean, result); [EOL] }
public void testGetVariables_WhenVarsIsNull() { [EOL] MyClassUnderTest myObjectUnderTest = new MyClassUnderTest(); [EOL] Variables result = myObjectUnderTest.getVariables(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof BasicVariables); [EOL] }
public void testGetVariables_WhenVarsIsNotNull() { [EOL] MyClassUnderTest myObjectUnderTest = new MyClassUnderTest(); [EOL] Variables preInitializedVars = new BasicVariables(); [EOL] myObjectUnderTest.vars = preInitializedVars; // Assuming vars is accessible, otherwise use reflection or a setter [EOL] Variables result = myObjectUnderTest.getVariables(); [EOL] assertSame(preInitializedVars, result); [EOL] }
public void testGetFunctionsWhenFunctionsIsNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Functions expectedFunctions = new Functions(); [EOL] context.setFunctions(expectedFunctions); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertEquals("Expected the non-null functions object to be returned", expectedFunctions, actualFunctions); [EOL] }
public void testGetFunctionsWhenFunctionsIsNullAndParentContextIsNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setFunctions(null); [EOL] context.setParentContext(null); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertEquals("Expected the GENERIC_FUNCTIONS to be returned when functions is null and parent context is null", Functions.GENERIC_FUNCTIONS, actualFunctions); [EOL] }
public void testGetFunctionsWhenFunctionsIsNullAndParentContextIsNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setFunctions(null); [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] context.setParentContext(parentContext); [EOL] Functions actualFunctions = context.getFunctions(); [EOL] assertNull("Expected null to be returned when functions is null and parent context is not null", actualFunctions); [EOL] }
public void testSetLenientTrue() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLenient(true); [EOL] assertTrue(context.isLenient()); [EOL] assertTrue(context.isLenientSet()); [EOL] }
public void testSetLenientFalse() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setLenient(false); [EOL] assertFalse(context.isLenient()); [EOL] assertTrue(context.isLenientSet()); [EOL] }
public void testIsLenient_WhenLenientSet() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] boolean result = context.isLenient(); [EOL] assertTrue(result); [EOL] }
public void testIsLenient_WhenLenientNotSetButParentContextIsLenient() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] parentContext.setLenient(true); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext, new Object()); [EOL] boolean result = childContext.isLenient(); [EOL] assertTrue(result); [EOL] }
public void testIsLenient_WhenLenientNotSetAndParentContextIsNotLenient() { [EOL] JXPathContext parentContext = JXPathContext.newContext(new Object()); [EOL] parentContext.setLenient(false); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext, new Object()); [EOL] boolean result = childContext.isLenient(); [EOL] assertFalse(result); [EOL] }
public void testCompileWithNullContextAndNonNullXPath() { [EOL] String xpath = "/some/path"; [EOL] CompiledExpression result = YourClass.compile(xpath); [EOL] assertNotNull(result); [EOL] }
public void testCompileWithNonNullContextAndNonNullXPath() { [EOL] YourClass.setCompilationContext(JXPathContext.newContext(new Object())); [EOL] String xpath = "/some/path"; [EOL] CompiledExpression result = YourClass.compile(xpath); [EOL] assertNotNull(result); [EOL] }
public Object invoke(ExpressionContext context, Object[] parameters) { [EOL] try { [EOL] Object target; [EOL] Object[] args; [EOL] if (Modifier.isStatic(method.getModifiers())) { [EOL] target = null; [EOL] if (parameters == null) { [EOL] parameters = EMPTY_ARRAY; [EOL] } [EOL] int pi = 0; [EOL] Class[] types = method.getParameterTypes(); [EOL] if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL] pi = 1; [EOL] } [EOL] args = new Object[parameters.length + pi]; [EOL] if (pi == 1) { [EOL] args[0] = context; [EOL] } [EOL] for (int i = 0; i < parameters.length; i++) { [EOL] args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); [EOL] } [EOL] } else { [EOL] int pi = 0; [EOL] Class[] types = method.getParameterTypes(); [EOL] if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL] pi = 1; [EOL] } [EOL] target = TypeUtils.convert(parameters[0], method.getDeclaringClass()); [EOL] args = new Object[parameters.length - 1 + pi]; [EOL] if (pi == 1) { [EOL] args[0] = context; [EOL] } [EOL] for (int i = 1; i < parameters.length; i++) { [EOL] args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i + pi - 1]); [EOL] } [EOL] } [EOL] return method.invoke(target, args); [EOL] } catch (Throwable ex) { [EOL] if (ex instanceof InvocationTargetException) { [EOL] ex = ((InvocationTargetException) ex).getTargetException(); [EOL] } [EOL] throw new JXPathInvalidAccessException("Cannot invoke " + method, ex); [EOL] } [EOL] }
public void testChildIteratorWithNullTest() { [EOL] NodeIterator result = childIterator(null, true, null); [EOL] assertNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestAndDefaultNamespace() { [EOL] NodeTest test = new NodeNameTest(new QName("", "testNode")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestAndNonDefaultNamespace() { [EOL] NodeTest test = new NodeNameTest(new QName("nonDefault", "testNode")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNull(result); [EOL] }
public void testChildIteratorWithNodeNameTestWildcard() { [EOL] NodeTest test = new NodeNameTest(new QName("", "*")); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithNodeTypeTest() { [EOL] NodeTest test = new NodeTypeTest(Compiler.NODE_TYPE_NODE); [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNotNull(result); [EOL] }
public void testChildIteratorWithOtherNodeTypeTest() { [EOL] NodeTest test = new NodeTypeTest(Compiler.NODE_TYPE_COMMENT); // Assuming NODE_TYPE_COMMENT is a valid node type and different from NODE_TYPE_NODE [EOL] NodeIterator result = childIterator(test, true, null); [EOL] assertNull(result); [EOL] }
public void testAttributeIteratorWithValidName() { [EOL] QName validName = new QName("validName"); [EOL] BeanAttributeIterator iterator = (BeanAttributeIterator) bean.attributeIterator(validName); [EOL] assertNotNull(iterator); [EOL] }
public void testAttributeIteratorWithNullName() { [EOL] QName nullName = null; [EOL] try { [EOL] bean.attributeIterator(nullName); [EOL] fail("Should throw IllegalArgumentException for null QName"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
protected boolean isSimpleStep(Step step) { [EOL] if (step.getAxis() == Compiler.AXIS_SELF) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] if (!(nodeTest instanceof NodeTypeTest)) { [EOL] return false; [EOL] } [EOL] int nodeType = ((NodeTypeTest) nodeTest).getNodeType(); [EOL] if (nodeType != Compiler.NODE_TYPE_NODE) { [EOL] return false; [EOL] } [EOL] return areBasicPredicates(step.getPredicates()); [EOL] } else if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) { [EOL] NodeTest nodeTest = step.getNodeTest(); [EOL] if (!(nodeTest instanceof NodeNameTest)) { [EOL] return false; [EOL] } [EOL] if (((NodeNameTest) nodeTest).isWildcard()) { [EOL] return false; [EOL] } [EOL] return areBasicPredicates(step.getPredicates()); [EOL] } [EOL] return false; [EOL] }
public void testSearchForPathWithNonNullPointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer expectedPointer = mock(Pointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(expectedPointer); [EOL] Pointer result = searchForPath(context); [EOL] assertEquals(expectedPointer, result); [EOL] }
public void testSearchForPathWithNullPointerAndSimpleSteps() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(false); [EOL] steps = new Step[] { /* steps setup to be simple */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithComplexStep() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(context.hasNext()).thenReturn(false); [EOL] steps = new Step[] { /* steps setup with at least one complex step */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithPartialPointerAndHasNext() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(ctx.hasNext()).thenReturn(true).thenReturn(true); [EOL] steps = new Step[] { /* steps setup to be simple */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNull(result); [EOL] }
public void testSearchForPathWithPartialNodePointer() { [EOL] EvalContext context = mock(EvalContext.class); [EOL] EvalContext ctx = mock(EvalContext.class); [EOL] Pointer partialPointer = mock(NodePointer.class); [EOL] when(context.getSingleNodePointer()).thenReturn(null); [EOL] when(ctx.hasNext()).thenReturn(true).thenReturn(false); [EOL] when(ctx.next()).thenReturn(partialPointer); [EOL] steps = new Step[] { /* steps setup to be simple */ }; [EOL] Pointer result = searchForPath(context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullPointer); [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL] if (nodeTest instanceof NodeNameTest) { [EOL] QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL] String prefix = qname.getPrefix(); [EOL] String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL] if (namespaceURI != null) { [EOL] nodeTest = new NodeNameTest(qname, namespaceURI); [EOL] } [EOL] } [EOL] switch(axis) { [EOL] case Compiler.AXIS_ANCESTOR: [EOL] return new AncestorContext(context, false, nodeTest); [EOL] case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL] return new AncestorContext(context, true, nodeTest); [EOL] case Compiler.AXIS_ATTRIBUTE: [EOL] return new AttributeContext(context, nodeTest); [EOL] case Compiler.AXIS_CHILD: [EOL] return new ChildContext(context, nodeTest, false, false); [EOL] case Compiler.AXIS_DESCENDANT: [EOL] return new DescendantContext(context, false, nodeTest); [EOL] case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL] return new DescendantContext(context, true, nodeTest); [EOL] case Compiler.AXIS_FOLLOWING: [EOL] return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL] case Compiler.AXIS_FOLLOWING_SIBLING: [EOL] return new ChildContext(context, nodeTest, true, false); [EOL] case Compiler.AXIS_NAMESPACE: [EOL] return new NamespaceContext(context, nodeTest); [EOL] case Compiler.AXIS_PARENT: [EOL] return new ParentContext(context, nodeTest); [EOL] case Compiler.AXIS_PRECEDING: [EOL] return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL] case Compiler.AXIS_PRECEDING_SIBLING: [EOL] return new ChildContext(context, nodeTest, true, true); [EOL] case Compiler.AXIS_SELF: [EOL] return new SelfContext(context, nodeTest); [EOL] } [EOL] return null; [EOL] }
public void testIsCollection_BaseValueNull() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] JXPathCompiledExpression expression = (JXPathCompiledExpression) context.compile("dummyPath"); [EOL] expression = Mockito.spy(expression); [EOL] Mockito.doReturn(null).when(expression).getBaseValue(); [EOL] boolean result = expression.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testIsCollection_BaseValueIsCollection() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] JXPathCompiledExpression expression = (JXPathCompiledExpression) context.compile("dummyPath"); [EOL] expression = Mockito.spy(expression); [EOL] Collection<?> collection = new ArrayList<>(); [EOL] Mockito.doReturn(collection).when(expression).getBaseValue(); [EOL] boolean result = expression.isCollection(); [EOL] assertTrue(result); [EOL] }
public void testIsCollection_BaseValueIsNotCollection() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] JXPathCompiledExpression expression = (JXPathCompiledExpression) context.compile("dummyPath"); [EOL] expression = Mockito.spy(expression); [EOL] Object nonCollectionObject = new Object(); [EOL] Mockito.doReturn(nonCollectionObject).when(expression).getBaseValue(); [EOL] boolean result = expression.isCollection(); [EOL] assertFalse(result); [EOL] }
public void testGetImmediateNodeWithIndexNotWholeCollection() { [EOL] int testIndex = 1; // Assuming WHOLE_COLLECTION is a constant not equal to 1 [EOL] YourClassUnderTest instance = new YourClassUnderTest(testIndex); [EOL] Object expectedValue = new Object(); // Replace with actual expected value [EOL] Object result = instance.getImmediateNode(); [EOL] assertEquals("Value should be retrieved for the given index", expectedValue, result); [EOL] }
public void testGetImmediateNodeWithWholeCollection() { [EOL] int testIndex = WHOLE_COLLECTION; // Use the actual WHOLE_COLLECTION constant [EOL] YourClassUnderTest instance = new YourClassUnderTest(testIndex); [EOL] Object expectedValue = new Object(); // Replace with actual expected value [EOL] Object result = instance.getImmediateNode(); [EOL] assertEquals("Value should be retrieved for the whole collection", expectedValue, result); [EOL] }
public void testSetIndex() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setIndex(5); [EOL] assertNull(instance.valuePointer); [EOL] }
public void testGetImmediateValuePointerWhenValuePointerIsNullAndActualIsTrue() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.valuePointer = null; [EOL] instance.actual = true; [EOL] NodePointer result = instance.getImmediateValuePointer(); [EOL] assertNotNull("Expected non-null result when actual is true", result); [EOL] } [EOL] public void testGetImmediateValuePointerWhenValuePointerIsNullAndActualIsFalse() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.valuePointer = null; [EOL] instance.actual = false; [EOL] NodePointer result = instance.getImmediateValuePointer(); [EOL] assertTrue("Expected result to be an instance of NullPointer", result instanceof NullPointer); [EOL] } [EOL] public void testGetImmediateValuePointerWhenValuePointerIsNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] NodePointer expectedValuePointer = new NodePointer() { [EOL] }; [EOL] instance.valuePointer = expectedValuePointer; [EOL] NodePointer result = instance.getImmediateValuePointer(); [EOL] assertSame("Expected the pre-set valuePointer to be returned", expectedValuePointer, result); [EOL] }
public void testGetLengthWhenActualIsTrueAndValueIsNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.actual = true; [EOL] instance.setBaseValue(null); // Assuming there is a method to set the base value [EOL] int result = instance.getLength(); [EOL] assertEquals(1, result); [EOL] }
public void testGetLengthWhenActualIsTrueAndValueIsNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.actual = true; [EOL] Object nonNullValue = new Object(); // Replace with an appropriate value [EOL] instance.setBaseValue(nonNullValue); // Assuming there is a method to set the base value [EOL] when(ValueUtils.getLength(nonNullValue)).thenReturn(10); // Mocking ValueUtils.getLength [EOL] int result = instance.getLength(); [EOL] assertEquals(10, result); [EOL] }
public void testGetLengthWhenActualIsFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.actual = false; [EOL] int result = instance.getLength(); [EOL] assertEquals(0, result); [EOL] }
public void testChildIteratorWithNullTest() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] NodeIterator result = mockNodePointer.childIterator(null, false, null); [EOL] assertNull(result); [EOL] }
public void testChildIteratorWithNonNullTest() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] NodeTest mockTest = Mockito.mock(NodeTest.class); [EOL] NodeIterator expectedIterator = Mockito.mock(NodeIterator.class); [EOL] Mockito.when(mockNodePointer.childIterator(mockTest, false, null)).thenReturn(expectedIterator); [EOL] NodeIterator result = mockNodePointer.childIterator(mockTest, false, null); [EOL] assertEquals(expectedIterator, result); [EOL] }
public void testChildIteratorWithReverseTrue() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] NodeTest mockTest = Mockito.mock(NodeTest.class); [EOL] NodeIterator expectedIterator = Mockito.mock(NodeIterator.class); [EOL] Mockito.when(mockNodePointer.childIterator(mockTest, true, null)).thenReturn(expectedIterator); [EOL] NodeIterator result = mockNodePointer.childIterator(mockTest, true, null); [EOL] assertEquals(expectedIterator, result); [EOL] }
public void testChildIteratorWithStartWith() { [EOL] NodePointer mockNodePointer = Mockito.mock(NodePointer.class); [EOL] NodeTest mockTest = Mockito.mock(NodeTest.class); [EOL] NodePointer mockStartWith = Mockito.mock(NodePointer.class); [EOL] NodeIterator expectedIterator = Mockito.mock(NodeIterator.class); [EOL] Mockito.when(mockNodePointer.childIterator(mockTest, false, mockStartWith)).thenReturn(expectedIterator); [EOL] NodeIterator result = mockNodePointer.childIterator(mockTest, false, mockStartWith); [EOL] assertEquals(expectedIterator, result); [EOL] }
public void testNewNodePointerWithNullBean() { [EOL] QName name = new QName("test"); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = ClassName.newNodePointer(name, null, locale); [EOL] assertTrue(result instanceof NullPointer); [EOL] }
public void testNewNodePointerWithNonNullBeanAndFactoryReturnsPointer() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointerFactory factory = new NodePointerFactory() { [EOL] public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL] return new ConcreteNodePointer(name, bean, locale); [EOL] } [EOL] }; [EOL] JXPathContextReferenceImpl.addNodePointerFactory(factory); [EOL] NodePointer result = ClassName.newNodePointer(name, bean, locale); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ConcreteNodePointer); [EOL] JXPathContextReferenceImpl.removeNodePointerFactory(factory); [EOL] }
public void testNewNodePointerWithNonNullBeanAndFactoryReturnsNull() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointerFactory factory = new NodePointerFactory() { [EOL] public NodePointer createNodePointer(QName name, Object bean, Locale locale) { [EOL] return null; [EOL] } [EOL] }; [EOL] JXPathContextReferenceImpl.addNodePointerFactory(factory); [EOL] try { [EOL] ClassName.newNodePointer(name, bean, locale); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] JXPathContextReferenceImpl.removeNodePointerFactory(factory); [EOL] }
public void testNewChildNodePointerWithNonNullPointer() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] NodePointerFactory factory = mock(NodePointerFactory.class); [EOL] NodePointer expectedPointer = mock(NodePointer.class); [EOL] when(factory.createNodePointer(parent, name, bean)).thenReturn(expectedPointer); [EOL] NodePointerFactory[] factories = new NodePointerFactory[]{factory}; [EOL] JXPathContextReferenceImpl.setNodePointerFactories(factories); [EOL] NodePointer result = JXPathContext.newChildNodePointer(parent, name, bean); [EOL] assertNotNull(result); [EOL] assertSame(expectedPointer, result); [EOL] }
public void testNewChildNodePointerWithAllNullPointers() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] NodePointerFactory factory = mock(NodePointerFactory.class); [EOL] when(factory.createNodePointer(parent, name, bean)).thenReturn(null); [EOL] NodePointerFactory[] factories = new NodePointerFactory[]{factory}; [EOL] JXPathContextReferenceImpl.setNodePointerFactories(factories); [EOL] try { [EOL] JXPathContext.newChildNodePointer(parent, name, bean); [EOL] fail("JXPathException expected"); [EOL] } catch (JXPathException e) { [EOL] assertEquals("Could not allocate a NodePointer for object of " + bean.getClass(), e.getMessage()); [EOL] } [EOL] }
protected NodePointer(NodePointer parent) { [EOL] this.parent = parent; [EOL] }
public void testGetNamespaceResolver_WithNonNullParentAndNullResolver() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] NamespaceResolver mockResolver = new NamespaceResolver(); [EOL] parentContext.setNamespaceResolver(mockResolver); [EOL] JXPathContext context = JXPathContext.newContext(parentContext); [EOL] NamespaceResolver result = context.getNamespaceResolver(); [EOL] assertNotNull(result); [EOL] assertSame(mockResolver, result); [EOL] }
public void testGetNamespaceResolver_WithNullParent() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NamespaceResolver result = context.getNamespaceResolver(); [EOL] assertNull(result); [EOL] }
public void testGetNamespaceResolver_WithNonNullResolver() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NamespaceResolver mockResolver = new NamespaceResolver(); [EOL] context.setNamespaceResolver(mockResolver); [EOL] NamespaceResolver result = context.getNamespaceResolver(); [EOL] assertNotNull(result); [EOL] assertSame(mockResolver, result); [EOL] }
public void testSetNamespaceResolver() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NamespaceResolver resolver = new NamespaceResolver(); [EOL] context.setNamespaceResolver(resolver); [EOL] assertEquals("NamespaceResolver should be set", resolver, context.getNamespaceResolver()); [EOL] }
public void testGetIndex() { [EOL] MyClass instance = new MyClass(5); // Assuming there's a constructor that sets the index [EOL] int expected = 5; [EOL] int actual = instance.getIndex(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetIndex() { [EOL] YourClass instance = new YourClass(); [EOL] int index = 5; [EOL] instance.setIndex(index); [EOL] assertEquals(index, instance.getIndex()); [EOL] }
public void testGetValuePointerWhenImmediateValuePointerIsNotThis() { [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(mockNodePointer.getValuePointer()).thenReturn(mockNodePointer); [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] public NodePointer getImmediateValuePointer() { [EOL] return mockNodePointer; [EOL] } [EOL] }; [EOL] NodePointer result = instance.getValuePointer(); [EOL] assertSame("Expected the result to be the same as the immediate value pointer", mockNodePointer, result); [EOL] }
public void testGetValuePointerWhenImmediateValuePointerIsThis() { [EOL] YourClassUnderTest instance = new YourClassUnderTest() { [EOL] public NodePointer getImmediateValuePointer() { [EOL] return this; [EOL] } [EOL] }; [EOL] NodePointer result = instance.getValuePointer(); [EOL] assertSame("Expected the result to be 'this'", instance, result); [EOL] }
public void testGetImmediateValuePointer() { [EOL] NodePointer nodePointer = new ConcreteNodePointer(); // Assuming ConcreteNodePointer is a concrete implementation of NodePointer [EOL] NodePointer result = nodePointer.getImmediateValuePointer(); [EOL] assertEquals("getImmediateValuePointer should return the same instance", nodePointer, result); [EOL] }
public void testIsActualWithWholeCollection() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.index = YourClassUnderTest.WHOLE_COLLECTION; [EOL] boolean result = instance.isActual(); [EOL] assertTrue(result); [EOL] }
public void testIsActualWithValidIndex() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.index = 5; // Assuming getLength() returns a value greater than 5 [EOL] when(instance.getLength()).thenReturn(10); [EOL] boolean result = instance.isActual(); [EOL] assertTrue(result); [EOL] }
public void testIsActualWithInvalidIndexNegative() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.index = -1; [EOL] boolean result = instance.isActual(); [EOL] assertFalse(result); [EOL] }
public void testIsActualWithInvalidIndexGreaterThanLength() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.index = 10; // Assuming getLength() returns a value less than 10 [EOL] when(instance.getLength()).thenReturn(5); [EOL] boolean result = instance.isActual(); [EOL] assertFalse(result); [EOL] }
public Object getNode() { [EOL] return getValuePointer().getImmediateNode(); [EOL] }
public void testCloneWithNonNullParent() throws Exception { [EOL] NodePointer original = new NodePointer(); [EOL] NodePointer parent = new NodePointer(); [EOL] original.setParent(parent); [EOL] NodePointer cloned = (NodePointer) original.clone(); [EOL] assertNotNull(cloned); [EOL] assertNotNull(cloned.getParent()); [EOL] assertNotSame(parent, cloned.getParent()); [EOL] }
public void testCloneWithNullParent() throws Exception { [EOL] NodePointer original = new NodePointer(); [EOL] original.setParent(null); [EOL] NodePointer cloned = (NodePointer) original.clone(); [EOL] assertNotNull(cloned); [EOL] assertNull(cloned.getParent()); [EOL] }
public void testToString() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String result = context.toString(); [EOL] assertNotNull("Result should not be null", result); [EOL] assertFalse("Result should not be empty", result.isEmpty()); [EOL] }
public void testCompareNodePointersBothNull() { [EOL] NodePointer p1 = null; [EOL] NodePointer p2 = null; [EOL] int depth1 = 0; [EOL] int depth2 = 0; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareNodePointersFirstDeeper() { [EOL] NodePointer p1 = createMockNodePointerWithParent(); [EOL] NodePointer p2 = createMockNodePointer(); [EOL] int depth1 = 2; [EOL] int depth2 = 1; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertTrue(result == 1 || result == -1); [EOL] }
public void testCompareNodePointersSecondDeeper() { [EOL] NodePointer p1 = createMockNodePointer(); [EOL] NodePointer p2 = createMockNodePointerWithParent(); [EOL] int depth1 = 1; [EOL] int depth2 = 2; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertTrue(result == 1 || result == -1); [EOL] }
public void testCompareNodePointersEqualDepthDifferentNodes() { [EOL] NodePointer p1 = createMockNodePointer(); [EOL] NodePointer p2 = createMockNodePointer(); [EOL] when(p1.equals(p2)).thenReturn(false); [EOL] when(p1.parent).thenReturn(createMockNodePointer()); [EOL] when(p2.parent).thenReturn(createMockNodePointer()); [EOL] when(p1.parent.compareChildNodePointers(p1, p2)).thenReturn(1); [EOL] int depth1 = 1; [EOL] int depth2 = 1; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertEquals(1, result); [EOL] }
public void testCompareNodePointersEqualDepthSameNodes() { [EOL] NodePointer p1 = createMockNodePointer(); [EOL] NodePointer p2 = p1; [EOL] int depth1 = 1; [EOL] int depth2 = 1; [EOL] int result = compareNodePointers(p1, depth1, p2, depth2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareNodePointersEqualDepthThrowsException() { [EOL] NodePointer p1 = createMockNodePointer(); [EOL] NodePointer p2 = createMockNodePointer(); [EOL] when(p1.equals(p2)).thenReturn(false); [EOL] int depth1 = 1; [EOL] int depth2 = 1; [EOL] try { [EOL] compareNodePointers(p1, depth1, p2, depth2); [EOL] fail("Expected JXPathException"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testHashCode() { [EOL] Object attr = new Object(); [EOL] MyClass instance = new MyClass(attr); [EOL] int expected = System.identityHashCode(attr); [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testIsCollectionWithNull() { [EOL] boolean result = isCollection(null); [EOL] assertFalse(result); [EOL] }
public void testIsCollectionWithArray() { [EOL] boolean result = isCollection(new int[]{1, 2, 3}); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithCollection() { [EOL] boolean result = isCollection(Arrays.asList(1, 2, 3)); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionWithNonCollection() { [EOL] boolean result = isCollection(new Object()); [EOL] assertFalse(result); [EOL] }
public void testGetLengthWithNull() { [EOL] int result = getLength(null); [EOL] assertEquals(0, result); [EOL] }
public void testGetLengthWithArray() { [EOL] Object array = new int[]{1, 2, 3}; [EOL] int result = getLength(array); [EOL] assertEquals(3, result); [EOL] }
public void testGetLengthWithCollection() { [EOL] Collection collection = new ArrayList(); [EOL] collection.add("item1"); [EOL] collection.add("item2"); [EOL] int result = getLength(collection); [EOL] assertEquals(2, result); [EOL] }
public void testGetLengthWithNonCollectionObject() { [EOL] Object obj = new Object(); [EOL] int result = getLength(obj); [EOL] assertEquals(1, result); [EOL] }
public void testGetValueWithNullCollection() { [EOL] Object result = getValue(null, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithEmptyArray() { [EOL] Object[] array = new Object[0]; [EOL] Object result = getValue(array, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidArrayIndex() { [EOL] Object[] array = new Object[] { "a", "b", "c" }; [EOL] Object result = getValue(array, 1); [EOL] assertEquals("b", result); [EOL] } [EOL] public void testGetValueWithInvalidArrayIndex() { [EOL] Object[] array = new Object[] { "a", "b", "c" }; [EOL] Object result = getValue(array, 3); [EOL] assertNull(result); [EOL] }
public void testGetValueWithEmptyList() { [EOL] List<Object> list = new ArrayList<>(); [EOL] Object result = getValue(list, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidListIndex() { [EOL] List<Object> list = new ArrayList<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(list, 1); [EOL] assertEquals("b", result); [EOL] } [EOL] public void testGetValueWithInvalidListIndex() { [EOL] List<Object> list = new ArrayList<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(list, 3); [EOL] assertNull(result); [EOL] }
public void testGetValueWithEmptyCollection() { [EOL] Collection<Object> collection = new HashSet<>(); [EOL] Object result = getValue(collection, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWithValidCollectionIndex() { [EOL] Collection<Object> collection = new LinkedHashSet<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(collection, 1); [EOL] assertEquals("b", result); [EOL] } [EOL] public void testGetValueWithInvalidCollectionIndex() { [EOL] Collection<Object> collection = new LinkedHashSet<>(Arrays.asList("a", "b", "c")); [EOL] Object result = getValue(collection, 3); [EOL] assertNull(result); [EOL] }
public void testGetValueWithNonContainer() { [EOL] Object expected = new Object(); [EOL] Object actual = ClassName.getValue(expected); [EOL] assertSame(expected, actual); [EOL] }
public void testGetValueWithContainer() { [EOL] Container container = mock(Container.class); [EOL] Object innerValue = new Object(); [EOL] when(container.getValue()).thenReturn(innerValue); [EOL] Object actual = ClassName.getValue(container); [EOL] assertSame(innerValue, actual); [EOL] }
public void testGetValueWithNestedContainers() { [EOL] Container innerContainer = mock(Container.class); [EOL] Container outerContainer = mock(Container.class); [EOL] Object innerMostValue = new Object(); [EOL] when(innerContainer.getValue()).thenReturn(innerMostValue); [EOL] when(outerContainer.getValue()).thenReturn(innerContainer); [EOL] Object actual = ClassName.getValue(outerContainer); [EOL] assertSame(innerMostValue, actual); [EOL] }
public int testGetOrder() { [EOL] JxPathContext context = new JxPathContext(); [EOL] int order = context.getOrder(); [EOL] assertEquals(JDOM_POINTER_FACTORY_ORDER, order); [EOL] }
public void testCreateNodePointerWithDocument() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate with a string [EOL] Object bean = org.w3c.dom.Document; // Assuming this is a valid Document instance [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] assertEquals(parent, result.getParent()); [EOL] }
public void testCreateNodePointerWithElement() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate with a string [EOL] Object bean = org.w3c.dom.Element; // Assuming this is a valid Element instance [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertTrue(result instanceof JDOMNodePointer); [EOL] assertEquals(parent, result.getParent()); [EOL] }
public void testCreateNodePointerWithNonDocumentOrElement() { [EOL] NodePointer parent = null; // Assuming NodePointer is an interface or class we can instantiate or mock [EOL] QName name = new QName("test"); // Assuming QName is a class we can instantiate with a string [EOL] Object bean = new Object(); // A generic Object that is neither Document nor Element [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNull(result); [EOL] }
public int getDocumentOrder() { [EOL] return -1; [EOL] }
public void testNextNode_SetStartedTrue() { [EOL] objectUnderTest.setStarted(true); [EOL] boolean result = objectUnderTest.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNode_SetStartedFalse_NodePointerIsContainer() { [EOL] objectUnderTest.setStarted(false); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(mockNodePointer.isContainer()).thenReturn(true); [EOL] when(mockNodePointer.getImmediateParentPointer()).thenReturn(null); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] boolean result = objectUnderTest.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testNextNode_SetStartedFalse_NodePointerIsNotContainer_NodeTestPasses() { [EOL] objectUnderTest.setStarted(false); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(mockNodePointer.isContainer()).thenReturn(false); [EOL] when(mockNodePointer.testNode(any(NodeTest.class))).thenReturn(true); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] boolean result = objectUnderTest.nextNode(); [EOL] assertTrue(result); [EOL] assertEquals(1, objectUnderTest.getPosition()); [EOL] }
public void testNextNode_SetStartedFalse_NodePointerIsNotContainer_NodeTestFails() { [EOL] objectUnderTest.setStarted(false); [EOL] NodePointer mockNodePointer = mock(NodePointer.class); [EOL] when(mockNodePointer.isContainer()).thenReturn(false); [EOL] when(mockNodePointer.testNode(any(NodeTest.class))).thenReturn(false); [EOL] when(parentContext.getCurrentNodePointer()).thenReturn(mockNodePointer); [EOL] boolean result = objectUnderTest.nextNode(); [EOL] assertFalse(result); [EOL] }
public void testIsLeafTrue() { [EOL] ValuePointer mockValuePointer = Mockito.mock(ValuePointer.class); [EOL] Mockito.when(mockValuePointer.isLeaf()).thenReturn(true); [EOL] Mockito.when(instance.getValuePointer()).thenReturn(mockValuePointer); [EOL] boolean result = instance.isLeaf(); [EOL] assertTrue(result); [EOL] }
public void testIsLeafFalse() { [EOL] ValuePointer mockValuePointer = Mockito.mock(ValuePointer.class); [EOL] Mockito.when(mockValuePointer.isLeaf()).thenReturn(false); [EOL] Mockito.when(instance.getValuePointer()).thenReturn(mockValuePointer); [EOL] boolean result = instance.isLeaf(); [EOL] assertFalse(result); [EOL] }
public void testNode_NullNodeTest() { [EOL] try { [EOL] ValuePointer valuePointer = Mockito.mock(ValuePointer.class); [EOL] JxPathContext context = new JxPathContext(valuePointer); [EOL] boolean result = context.testNode(null); [EOL] fail("Expected an exception to be thrown when NodeTest is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNode_ValidNodeTest() { [EOL] NodeTest nodeTest = Mockito.mock(NodeTest.class); [EOL] ValuePointer valuePointer = Mockito.mock(ValuePointer.class); [EOL] when(valuePointer.testNode(nodeTest)).thenReturn(true); [EOL] JxPathContext context = new JxPathContext(valuePointer); [EOL] boolean result = context.testNode(nodeTest); [EOL] assertTrue(result); [EOL] }
public void testNode_InvalidNodeTest() { [EOL] NodeTest nodeTest = Mockito.mock(NodeTest.class); [EOL] ValuePointer valuePointer = Mockito.mock(ValuePointer.class); [EOL] when(valuePointer.testNode(nodeTest)).thenReturn(false); [EOL] JxPathContext context = new JxPathContext(valuePointer); [EOL] boolean result = context.testNode(nodeTest); [EOL] assertFalse(result); [EOL] }
```java [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL] switch(pos) { [EOL] case 0: [EOL] if ((active1 & 0xc0000L) != 0L) [EOL] return 10; [EOL] if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL] jjmatchedKind = 78; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 1: [EOL] if ((active0 & 0x8000008000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 1; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 2: [EOL] if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 2; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 3: [EOL] if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL] if (jjmatchedPos != 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 4: [EOL] if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x800000000L) != 0L) { [EOL] if (jjmatchedPos < 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 5: [EOL] if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL] if (jjmatchedPos != 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x1000000000L) != 0L) { [EOL] if (jjmatchedPos < 4) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x800000000L) != 0L) { [EOL] if (jjmatchedPos < 3) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 3; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 6: [EOL] if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x2000000000L) != 0L) { [EOL] if (jjmatchedPos < 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x1000000000L) != 0L) { [EOL] if (jjmatchedPos < 4) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 4; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 6; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 7: [EOL] if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x802000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x2000000000L) != 0L) { [EOL] if (jjmatchedPos < 5) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 8: [EOL] if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x4000000000L) != 0L) { [EOL] if (jjmatchedPos < 7) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] if (jjmatchedPos != 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 9: [EOL] if ((active0 & 0x20000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x78000000000L) != 0L) { [EOL] if (jjmatchedPos < 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x4000000000L) != 0L) { [EOL] if (jjmatchedPos < 7) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 7; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 10: [EOL] if ((active0 & 0x400000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x80000000000L) != 0L) { [EOL] if (jjmatchedPos < 9) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x78000000000L) != 0L) { [EOL] if (jjmatchedPos < 8) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 10; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 11: [EOL] if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 11; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x80000000000L) != 0L) { [EOL] if (jjmatchedPos < 9) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 9; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 12: [EOL] if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 12; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 13: [EOL] if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 13; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 14: [EOL] if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0x1000f00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 14; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 15: [EOL] if ((active0 & 0x1000000000000000L) != 0L) [EOL] return 12; [EOL] if ((active0 & 0xf00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 16: [EOL] if ((active0 & 0xe00400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x100000000000L) != 0L) { [EOL] if (jjmatchedPos < 15) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 17: [EOL] if ((active0 & 0x600000000000L) != 0L) { [EOL] if (jjmatchedPos < 16) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x100000000000L) != 0L) { [EOL] if (jjmatchedPos < 15) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 15; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x800400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] return 12; [EOL] } [EOL] return -1; [EOL] case 18: [EOL] if ((active0 & 0x400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 18; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x800000000000L) != 0L) { [EOL] if (jjmatchedPos < 17) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] } [EOL] return -1; [EOL] } [EOL] if ((active0 & 0x600000000000L) != 0L) { [EOL] if (jjmatchedPos < 16) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 16; [EOL] } [EOL] return -1; [EOL] } [EOL] return -1; [EOL] case 19: [EOL] if ((active0 & 0x400000000L) != 0L) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 19; [EOL] return 12; [EOL] } [EOL] if ((active0 & 0x800000000000L) != 0L) { [EOL] if (jjmatchedPos < 17) { [EOL] jjmatchedKind = 78; [EOL] jjmatchedPos = 17; [EOL] } [EOL] return -1; [EOL] } [
private final int jjStartNfa_0(int pos, long active0, long active1) { [EOL] return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }];
public void testJjMoveStringLiteralDfa0_0_Case33() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '!'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x1000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case36() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '$'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 17)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case40() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '('; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 80)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case41() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = ')'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 81)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case42() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '*'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 88)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case43() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '+'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 9)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case44() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = ','; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 87)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case45() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '-'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 10)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case46() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '.'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x0L, 0x80000L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case47() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '/'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x80L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case58() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = ':'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 79)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case60() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '<'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x4000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case61() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '='; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 11)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case62() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '>'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x10000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case64() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '@'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 86)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case91() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '['; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 84)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case93() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = ']'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 85)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case97() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'a'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case98() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'b'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x0L, 0x4L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case99() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'c'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case100() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'd'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case102() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'f'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case105() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'i'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case107() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'k'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case108() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'l'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case109() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'm'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case110() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'n'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case111() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'o'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case112() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'p'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case114() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'r'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x0L, 0x1000L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case115() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 's'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case116() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 't'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_Case124() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = '|'; [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjStopAtPos(0, 8)); [EOL] }
public void testJjMoveStringLiteralDfa0_0_DefaultCase() { [EOL] XPathParserTokenManager tokenManager = new XPathParserTokenManager(null); [EOL] tokenManager.curChar = 'Z'; // Assuming 'Z' is not handled by any case [EOL] int result = tokenManager.jjMoveStringLiteralDfa0_0(); [EOL] assertEquals(result, tokenManager.jjMoveNfa_0(0, 0)); [EOL] }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(0, active0, active1); [EOL] return 1; [EOL] } [EOL] switch(curChar) { [EOL] case 46: [EOL] if ((active1 & 0x80000L) != 0L) [EOL] return jjStopAtPos(1, 83); [EOL] break; [EOL] case 47: [EOL] if ((active0 & 0x80L) != 0L) [EOL] return jjStopAtPos(1, 7); [EOL] break; [EOL] case 61: [EOL] if ((active0 & 0x1000L) != 0L) [EOL] return jjStopAtPos(1, 12); [EOL] else if ((active0 & 0x4000L) != 0L) [EOL] return jjStopAtPos(1, 14); [EOL] else if ((active0 & 0x10000L) != 0L) [EOL] return jjStopAtPos(1, 16); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL] case 100: [EOL] if ((active0 & 0x8000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 51, 12); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL] case 104: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL] case 114: [EOL] if ((active0 & 0x8000000L) != 0L) [EOL] return jjStartNfaWithStates_0(1, 27, 12); [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(0, active0, active1); [EOL] }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(0, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(1, active0, active1); [EOL] return 2; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL] case 100: [EOL] if ((active0 & 0x10000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 28, 12); [EOL] else if ((active0 & 0x20000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 29, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL] case 101: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL] case 109: [EOL] if ((active1 & 0x200L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 73, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL] case 116: [EOL] if ((active1 & 0x8L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 67, 12); [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL] case 118: [EOL] if ((active0 & 0x40000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 30, 12); [EOL] break; [EOL] case 120: [EOL] return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL] case 121: [EOL] if ((active0 & 0x10000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(2, 52, 12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(1, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); long[] jjbitVec0; long[] jjbitVec2; long[] jjbitVec3; long[] jjbitVec4; long[] jjbitVec5; long[] jjbitVec6; long[] jjbitVec7; long[] jjbitVec8; long[] jjbitVec9; long[] jjbitVec10; long[] jjbitVec11; long[] jjbitVec12; long[] jjbitVec13; long[] jjbitVec14; long[] jjbitVec15; long[] jjbitVec16; long[] jjbitVec17; long[] jjbitVec18; long[] jjbitVec19; long[] jjbitVec20; long[] jjbitVec21; long[] jjbitVec22; long[] jjbitVec23; long[] jjbitVec24; long[] jjbitVec25; long[] jjbitVec26; long[] jjbitVec27; long[] jjbitVec28; long[] jjbitVec29; long[] jjbitVec30; long[] jjbitVec31; long[] jjbitVec32; long[] jjbitVec33; long[] jjbitVec34; long[] jjbitVec35; long[] jjbitVec36; long[] jjbitVec37; long[] jjbitVec38; long[] jjbitVec39; long[] jjbitVec40; long[] jjbitVec41; int[] jjnextStates; String[] jjstrLiteralImages; String[] lexStateNames; long[] jjtoToken; long[] jjtoSkip;
```java [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(1, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(2, active0, active1); [EOL] return 3; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL] case 101: [EOL] if ((active0 & 0x80000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 31, 12); [EOL] else if ((active0 & 0x80000000000000L) != 0L) { [EOL] jjmatchedKind = 55; [EOL] jjmatchedPos = 3; [EOL] } else if ((active1 & 0x10L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 68, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x80L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 71, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL] case 108: [EOL] if ((active1 & 0x40L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 70, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL] case 116: [EOL] if ((active0 & 0x100000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 32, 12); [EOL] else if ((active0 & 0x1000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(3, 48, 12); [EOL] return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(2, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144
```java [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(2, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(3, active0, active1); [EOL] return 4; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0xa00000000000000L, active1, 0x2001L); [EOL] case 100: [EOL] if ((active1 & 0x1000L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 76, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x1000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active1 & 0x20L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 69, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0xca0600000000L, active1, 0x104L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0x800L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x8100002000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x240000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x400L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 74, 12); [EOL] break; [EOL] case 115: [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x40114000000000L, active1, 0x2L); [EOL] case 116: [EOL] if ((active0 & 0x4000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(4, 50, 12); [EOL] return jjMoveStringLiteralDfa5_0(active0, 0x7402000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(3, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=System.out; [EOL] long[] jjbitVec0={ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec2={ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }; [EOL] long[] jjbitVec3={ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }; [EOL] long[] jjbitVec4={ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec5={ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }; [EOL] long[] jjbitVec6={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }; [EOL] long[] jjbitVec7={ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec8={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec9={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }; [EOL] long[] jjbitVec10={ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }; [EOL] long[] jjbitVec11={ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }; [EOL] long[] jjbitVec12={ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }; [EOL] long[] jjbitVec13={ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }; [EOL] long[] jjbitVec14={ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }; [EOL] long[] jjbitVec15={ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }; [EOL] long[] jjbitVec16={ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }; [EOL] long[] jjbitVec17={ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }; [EOL] long[] jjbitVec18={ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }; [EOL] long[] jjbitVec19={ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }; [EOL] long[] jjbitVec20={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }; [EOL] long[] jjbitVec21={ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }; [EOL] long[] jjbitVec22={ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }; [EOL] long[] jjbitVec23={ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }; [EOL] long[] jjbitVec24={ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }; [EOL] long[] jjbitVec25={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }; [EOL] long[] jjbitVec26={ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }; [EOL] long[] jjbitVec27={ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }; [EOL] long[] jjbitVec28={ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }; [EOL] long[] jjbitVec29={ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }; [EOL] long[] jjbitVec30={ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }; [EOL] long[] jjbitVec31={ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }; [EOL] long[] jjbitVec32={ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }; [EOL] long[] jjbitVec33={ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }; [EOL] long[] jjbitVec34={ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }; [EOL] long[] jjbitVec35={ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }; [EOL] long[] jjbitVec36={ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }; [EOL] long[] jjbitVec37={ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }; [EOL] long[] jjbitVec38={ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }; [EOL] long[] jjbitVec39={ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }; [EOL] long[] jjbitVec40={ 0x0L, 0x0L, 0x0L, 0x21fff0000L }; [EOL] long[] jjbitVec41={ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }; [EOL] int[] jjnextStates={ 1, 2, 4, 5 }; [EOL] String[] jjstrLiteralImages={ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72
```java [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(3, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(4, active0, active1); [EOL] return 5; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x800000000L) != 0L) [EOL] return jjStopAtPos(5, 35); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active0 & 0x100000000000000L) != 0L) { [EOL] jjmatchedKind = 56; [EOL] jjmatchedPos = 5; [EOL] } [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x100L) != 0L) [EOL] return jjStartNfaWithStates_0(5, 72, 12); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(5, 57, 12); [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(4, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(4, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(5, active0, active1); [EOL] return 6; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL] case 58: [EOL] if ((active0 & 0x1000000000L) != 0L) [EOL] return jjStopAtPos(6, 36); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL] case 100: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL] case 103: [EOL] if ((active1 & 0x800L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 75, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL] case 110: [EOL] if ((active1 & 0x4L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 66, 12); [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL] case 116: [EOL] if ((active0 & 0x200000000L) != 0L) [EOL] return jjStartNfaWithStates_0(6, 33, 12); [EOL] break; [EOL] case 117: [EOL] return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(5, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); long[] jjbitVec0; long[] jjbitVec2; long[] jjbitVec3; long[] jjbitVec4; long[] jjbitVec5; long[] jjbitVec6; long[] jjbitVec7; long[] jjbitVec8; long[] jjbitVec9; long[] jjbitVec10; long[] jjbitVec11; long[] jjbitVec12; long[] jjbitVec13; long[] jjbitVec14; long[] jjbitVec15; long[] jjbitVec16; long[] jjbitVec17; long[] jjbitVec18; long[] jjbitVec19; long[] jjbitVec20; long[] jjbitVec21; long[] jjbitVec22; long[] jjbitVec23; long[] jjbitVec24; long[] jjbitVec25; long[] jjbitVec26; long[] jjbitVec27; long[] jjbitVec28; long[] jjbitVec29; long[] jjbitVec30; long[] jjbitVec31; long[] jjbitVec32; long[] jjbitVec33; long[] jjbitVec34; long[] jjbitVec35; long[] jjbitVec36; long[] jjbitVec37; long[] jjbitVec38; long[] jjbitVec39; long[] jjbitVec40; long[] jjbitVec41; int[] jjnextStates; String[] jjstrLiteralImages; String[] lexStateNames; long[] jjtoToken; long[] jjtoSkip;
```java [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(5, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(6, active0, active1); [EOL] return 7; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x2000000000L) != 0L) [EOL] return jjStopAtPos(7, 37); [EOL] break; [EOL] case 97: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 110: [EOL] if ((active0 & 0x2000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 49, 12); [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL] case 115: [EOL] if ((active0 & 0x800000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(7, 59, 12); [EOL] break; [EOL] case 116: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL] case 119: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 122: [EOL] return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(6, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xffc8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156
```java [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(6, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(7, active0, active1); [EOL] return 8; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL] case 58: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active1 & 0x2L) != 0L) [EOL] return jjStartNfaWithStates_0(8, 65, 12); [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL] case 103: [EOL] if ((active0 & 0x4000000000000000L) != 0L) { [EOL] jjmatchedKind = 62; [EOL] jjmatchedPos = 8; [EOL] } [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(7, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(7, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(8, active0, active1); [EOL] return 9; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL] case 58: [EOL] if ((active0 & 0x4000000000L) != 0L) [EOL] return jjStopAtPos(9, 38); [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL] case 101: [EOL] if ((active0 & 0x20000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(9, 53, 12); [EOL] break; [EOL] case 103: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL] case 109: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(8, active0, active1); [EOL] }
```java [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(8, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(9, active0, active1); [EOL] return 10; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x8000000000L) != 0L) [EOL] return jjStopAtPos(10, 39); [EOL] else if ((active0 & 0x10000000000L) != 0L) [EOL] return jjStopAtPos(10, 40); [EOL] else if ((active0 & 0x20000000000L) != 0L) [EOL] return jjStopAtPos(10, 41); [EOL] else if ((active0 & 0x40000000000L) != 0L) [EOL] return jjStopAtPos(10, 42); [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL] case 97: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL] case 103: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL] case 104: [EOL] if ((active0 & 0x400000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(10, 58, 12); [EOL] break; [EOL] case 114: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(9, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163
```java [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(9, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(10, active0, active1); [EOL] return 11; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL] case 58: [EOL] if ((active0 & 0x80000000000L) != 0L) [EOL] return jjStopAtPos(11, 43); [EOL] break; [EOL] case 101: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL] case 105: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL] case 112: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(10, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\
```java [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(10, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(11, active0, active1); [EOL] return 12; [EOL] } [EOL] switch(curChar) { [EOL] case 97: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL] case 98: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 104: [EOL] if ((active0 & 0x8000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 63, 12); [EOL] break; [EOL] case 105: [EOL] if ((active0 & 0x40000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 54, 12); [EOL] break; [EOL] case 110: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL] case 114: [EOL] if ((active1 & 0x2000L) != 0L) [EOL] return jjStartNfaWithStates_0(12, 77, 12); [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(11, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157
```java [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(11, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(12, active0, active1); [EOL] return 13; [EOL] } [EOL] switch(curChar) { [EOL] case 45: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x800000000000L, active1, 0L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x1L); [EOL] case 101: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x2000100000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x600000000000L, active1, 0L); [EOL] case 111: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa14_0(active0, 0x400000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(12, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154
```java [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(12, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(13, active0, active1); [EOL] return 14; [EOL] } [EOL] switch(curChar) { [EOL] case 101: [EOL] if ((active1 & 0x1L) != 0L) [EOL] return jjStartNfaWithStates_0(14, 64, 12); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x600000000000L, active1, 0L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x100000000000L, active1, 0L); [EOL] case 114: [EOL] if ((active0 & 0x2000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(14, 61, 12); [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x1000000000000000L, active1, 0L); [EOL] case 115: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x800000000000L, active1, 0L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa15_0(active0, 0x400000000L, active1, 0L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(13, active0, active1); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\
```java [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1) { [EOL] if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL] return jjStartNfa_0(13, old0, old1); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(14, active0, 0L); [EOL] return 15; [EOL] } [EOL] switch(curChar) { [EOL] case 101: [EOL] if ((active0 & 0x1000000000000000L) != 0L) [EOL] return jjStartNfaWithStates_0(15, 60, 12); [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x800000000000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x100000000000L); [EOL] case 110: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x600000000000L); [EOL] case 114: [EOL] return jjMoveStringLiteralDfa16_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(14, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\
```java [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(14, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(15, active0, 0L); [EOL] return 16; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x100000000000L); [EOL] case 103: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x600000000000L); [EOL] case 108: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x800000000000L); [EOL] case 117: [EOL] return jjMoveStringLiteralDfa17_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(15, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154
```java [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(15, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(16, active0, 0L); [EOL] return 17; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x100000000000L) != 0L) [EOL] return jjStopAtPos(17, 44); [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x600000000000L); [EOL] case 99: [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x400000000L); [EOL] case 102: [EOL] return jjMoveStringLiteralDfa18_0(active0, 0x800000000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(16, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\122\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156
```java [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(16, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(17, active0, 0L); [EOL] return 18; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x200000000000L) != 0L) [EOL] return jjStopAtPos(18, 45); [EOL] else if ((active0 & 0x400000000000L) != 0L) [EOL] return jjStopAtPos(18, 46); [EOL] return jjMoveStringLiteralDfa19_0(active0, 0x800000000000L); [EOL] case 116: [EOL] return jjMoveStringLiteralDfa19_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(17, active0, 0L); [EOL] } [EOL] public XPathParserTokenManager(SimpleCharStream stream); [EOL] public XPathParserTokenManager(SimpleCharStream stream, int lexState); [EOL] public void setDebugStream(java.io.PrintStream ds); [EOL] private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); [EOL] private final int jjStartNfa_0(int pos, long active0, long active1); [EOL] private final int jjStopAtPos(int pos, int kind); [EOL] private final int jjStartNfaWithStates_0(int pos, int kind, int state); [EOL] private final int jjMoveStringLiteralDfa0_0(); [EOL] private final int jjMoveStringLiteralDfa1_0(long active0, long active1); [EOL] private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); [EOL] private final int jjMoveStringLiteralDfa16_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa17_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa18_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa20_0(long old0, long active0); [EOL] private final int jjMoveStringLiteralDfa21_0(long old0, long active0); [EOL] private final void jjCheckNAdd(int state); [EOL] private final void jjAddStates(int start, int end); [EOL] private final void jjCheckNAddTwoStates(int state1, int state2); [EOL] private final void jjCheckNAddStates(int start, int end); [EOL] private final void jjCheckNAddStates(int start); [EOL] private final int jjMoveNfa_0(int startState, int curPos); [EOL] private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); [EOL] private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); [EOL] public void ReInit(SimpleCharStream stream); [EOL] private final void ReInitRounds(); [EOL] public void ReInit(SimpleCharStream stream, int lexState); [EOL] public void SwitchTo(int lexState); [EOL] protected Token jjFillToken(); [EOL] public Token getNextToken(); [EOL] java.io.PrintStream debugStream=Optional[System.out]; [EOL] long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; [EOL] long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; [EOL] long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; [EOL] long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; [EOL] long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; [EOL] long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; [EOL] long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; [EOL] long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; [EOL] long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; [EOL] long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; [EOL] long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; [EOL] long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; [EOL] long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; [EOL] long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; [EOL] long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; [EOL] long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; [EOL] long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; [EOL] long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; [EOL] long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; [EOL] long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; [EOL] long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; [EOL] long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; [EOL] long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; [EOL] long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; [EOL] long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; [EOL] long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; [EOL] long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; [EOL] long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; [EOL] long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; [EOL] long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; [EOL] long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; [EOL] long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; [EOL] long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; [EOL] long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; [EOL] long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; [EOL] int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; [EOL] String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\
```java [EOL] private final int jjMoveStringLiteralDfa19_0(long old0, long active0) { [EOL] if (((active0 &= old0)) == 0L) [EOL] return jjStartNfa_0(17, old0, 0L); [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] jjStopStringLiteralDfa_0(18, active0, 0L); [EOL] return 19; [EOL] } [EOL] switch(curChar) { [EOL] case 58: [EOL] if ((active0 & 0x800000000000L) != 0L) [EOL] return jjStopAtPos(19, 47); [EOL] break; [EOL] case 105: [EOL] return jjMoveStringLiteralDfa20_0(active0, 0x400000000L); [EOL] default: [EOL] break; [EOL] } [EOL] return jjStartNfa_0(18, active0, 0L); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{
private final int jjMoveNfa_0(int startState, int curPos) { [EOL] int[] nextStates; [EOL] int startsAt = 0; [EOL] jjnewStateCnt = 13; [EOL] int i = 1; [EOL] jjstateSet[0] = startState; [EOL] int j, kind = 0x7fffffff; [EOL] for (; ; ) { [EOL] if (++jjround == 0x7fffffff) [EOL] ReInitRounds(); [EOL] if (curChar < 64) { [EOL] long l = 1L << curChar; [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] if ((0x3ff000000000000L & l) != 0L) { [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAddTwoStates(6, 7); [EOL] } else if (curChar == 46) [EOL] jjCheckNAdd(10); [EOL] else if (curChar == 39) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] else if (curChar == 34) [EOL] jjCheckNAddTwoStates(1, 2); [EOL] break; [EOL] case 1: [EOL] if ((0xfffffffbffffffffL & l) != 0L) [EOL] jjCheckNAddTwoStates(1, 2); [EOL] break; [EOL] case 2: [EOL] if (curChar == 34 && kind > 18) [EOL] kind = 18; [EOL] break; [EOL] case 3: [EOL] if (curChar == 39) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] break; [EOL] case 4: [EOL] if ((0xffffff7fffffffffL & l) != 0L) [EOL] jjCheckNAddTwoStates(4, 5); [EOL] break; [EOL] case 5: [EOL] if (curChar == 39 && kind > 18) [EOL] kind = 18; [EOL] break; [EOL] case 6: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAddTwoStates(6, 7); [EOL] break; [EOL] case 7: [EOL] if (curChar != 46) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(8); [EOL] break; [EOL] case 8: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(8); [EOL] break; [EOL] case 9: [EOL] if (curChar == 46) [EOL] jjCheckNAdd(10); [EOL] break; [EOL] case 10: [EOL] if ((0x3ff000000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 20) [EOL] kind = 20; [EOL] jjCheckNAdd(10); [EOL] break; [EOL] case 12: [EOL] if ((0x3ff600000000000L & l) == 0L) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjstateSet[jjnewStateCnt++] = 12; [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } else if (curChar < 128) { [EOL] long l = 1L << (curChar & 077); [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] case 12: [EOL] if ((0x7fffffe87fffffeL & l) == 0L) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] case 1: [EOL] jjAddStates(0, 1); [EOL] break; [EOL] case 4: [EOL] jjAddStates(2, 3); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } else { [EOL] int hiByte = (int) (curChar >> 8); [EOL] int i1 = hiByte >> 6; [EOL] long l1 = 1L << (hiByte & 077); [EOL] int i2 = (curChar & 0xff) >> 6; [EOL] long l2 = 1L << (curChar & 077); [EOL] MatchLoop: do { [EOL] switch(jjstateSet[--i]) { [EOL] case 0: [EOL] if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] case 1: [EOL] if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL] jjAddStates(0, 1); [EOL] break; [EOL] case 4: [EOL] if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL] jjAddStates(2, 3); [EOL] break; [EOL] case 12: [EOL] if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL] break; [EOL] if (kind > 78) [EOL] kind = 78; [EOL] jjCheckNAdd(12); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] } while (i != startsAt); [EOL] } [EOL] if (kind != 0x7fffffff) { [EOL] jjmatchedKind = kind; [EOL] jjmatchedPos = curPos; [EOL] kind = 0x7fffffff; [EOL] } [EOL] ++curPos; [EOL] if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL] return curPos; [EOL] try { [EOL] curChar = input_stream.readChar(); [EOL] } catch (java.io.IOException e) { [EOL] return curPos; [EOL] } [EOL] } [EOL] }
public void testAsPathWithIdNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setId("someId"); [EOL] String result = instance.asPath(); [EOL] assertEquals("id('someEscapedId')", result); [EOL] }
public void testAsPathWithParentNotNullElementNodeDefaultNamespace() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setParent(new YourParentClass()); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] instance.setNode(node); [EOL] instance.setNamespaceResolver(new YourNamespaceResolver()); [EOL] when(instance.getNamespaceURI()).thenReturn("defaultNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getDefaultNamespaceURI()).thenReturn("defaultNamespaceURI"); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/elementName[1]")); [EOL] }
public void testAsPathWithParentNotNullElementNodeNonDefaultNamespace() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setParent(new YourParentClass()); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] instance.setNode(node); [EOL] instance.setNamespaceResolver(new YourNamespaceResolver()); [EOL] when(instance.getNamespaceURI()).thenReturn("nonDefaultNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getDefaultNamespaceURI()).thenReturn("defaultNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getPrefix("nonDefaultNamespaceURI")).thenReturn("prefix"); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/prefix:elementName[1]")); [EOL] }
public void testAsPathWithParentNotNullElementNodeNoPrefix() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.setParent(new YourParentClass()); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] instance.setNode(node); [EOL] instance.setNamespaceResolver(new YourNamespaceResolver()); [EOL] when(instance.getNamespaceURI()).thenReturn("nonDefaultNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getDefaultNamespaceURI()).thenReturn("defaultNamespaceURI"); [EOL] when(instance.getNamespaceResolver().getPrefix("nonDefaultNamespaceURI")).thenReturn(null); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/node()[1]")); [EOL] }
public void testAsPathWithTextNode() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/text()[1]")); [EOL] }
public void testAsPathWithCDATASectionNode() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.CDATA_SECTION_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/text()[1]")); [EOL] }
public void testAsPathWithProcessingInstructionNode() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] ProcessingInstruction pi = mock(ProcessingInstruction.class); [EOL] when(pi.getNodeType()).thenReturn(Node.PROCESSING_INSTRUCTION_NODE); [EOL] when(pi.getTarget()).thenReturn("target"); [EOL] instance.setNode(pi); [EOL] String result = instance.asPath(); [EOL] assertTrue(result.contains("/processing-instruction('target')[1]")); [EOL] }
public void testAsPathWithDocumentNode() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] Node node = mock(Node.class); [EOL] when(node.getNodeType()).thenReturn(Node.DOCUMENT_NODE); [EOL] instance.setNode(node); [EOL] String result = instance.asPath(); [EOL] assertEquals("", result); [EOL] }
public void testGetRelativePositionByNameSingleNode() { [EOL] Node node = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(null); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getNodeName()).thenReturn("testNode"); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionByName(); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionByNameMultipleSiblingsDifferentNames() { [EOL] Node node = mock(Node.class); [EOL] Node prevSibling1 = mock(Node.class); [EOL] Node prevSibling2 = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(prevSibling1); [EOL] when(prevSibling1.getPreviousSibling()).thenReturn(prevSibling2); [EOL] when(prevSibling2.getPreviousSibling()).thenReturn(null); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(prevSibling1.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(prevSibling2.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getNodeName()).thenReturn("testNode"); [EOL] when(prevSibling1.getNodeName()).thenReturn("differentNode"); [EOL] when(prevSibling2.getNodeName()).thenReturn("anotherNode"); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionByName(); [EOL] assertEquals(1, position); [EOL] }
public void testGetRelativePositionByNameMultipleSiblingsSameNames() { [EOL] Node node = mock(Node.class); [EOL] Node prevSibling1 = mock(Node.class); [EOL] Node prevSibling2 = mock(Node.class); [EOL] when(node.getPreviousSibling()).thenReturn(prevSibling1); [EOL] when(prevSibling1.getPreviousSibling()).thenReturn(prevSibling2); [EOL] when(prevSibling2.getPreviousSibling()).thenReturn(null); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(prevSibling1.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(prevSibling2.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getNodeName()).thenReturn("testNode"); [EOL] when(prevSibling1.getNodeName()).thenReturn("testNode"); [EOL] when(prevSibling2.getNodeName()).thenReturn("testNode"); [EOL] JXPathContext context = JXPathContext.newContext(node); [EOL] int position = context.getRelativePositionByName(); [EOL] assertEquals(3, position); [EOL] }
public void testGetFunctionWithDifferentNamespace() { [EOL] String namespace = "http://example.com"; [EOL] String name = "testFunction"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction("http://different.com", name, parameters); [EOL] assertNull(result); [EOL] }
public void testGetFunctionWithNullParameters() { [EOL] String namespace = "http://example.com"; [EOL] String name = "testFunction"; [EOL] Function result = getFunction(namespace, name, null); [EOL] assertNotNull(result); [EOL] }
public void testGetFunctionWithConstructor() { [EOL] String namespace = "http://example.com"; [EOL] String name = "new"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ConstructorFunction); [EOL] }
public void testGetFunctionWithStaticMethod() { [EOL] String namespace = "http://example.com"; [EOL] String name = "staticMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MethodFunction); [EOL] }
public void testGetFunctionWithInstanceMethod() { [EOL] String namespace = "http://example.com"; [EOL] String name = "instanceMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MethodFunction); [EOL] }
public void testGetFunctionNotFound() { [EOL] String namespace = "http://example.com"; [EOL] String name = "nonExistentMethod"; [EOL] Object[] parameters = new Object[]{}; [EOL] Function result = getFunction(namespace, name, parameters); [EOL] assertNull(result); [EOL] }
public void testToStringWithNoArguments() { [EOL] Function function = new Function("testFunction", null); [EOL] String result = function.toString(); [EOL] assertEquals("testFunction()", result); [EOL] }
public void testToStringWithOneArgument() { [EOL] Expression[] args = new Expression[]{new Expression("arg1")}; [EOL] Function function = new Function("testFunction", args); [EOL] String result = function.toString(); [EOL] assertEquals("testFunction(arg1)", result); [EOL] }
public void testToStringWithMultipleArguments() { [EOL] Expression[] args = new Expression[]{new Expression("arg1"), new Expression("arg2")}; [EOL] Function function = new Function("testFunction", args); [EOL] String result = function.toString(); [EOL] assertEquals("testFunction(arg1, arg2)", result); [EOL] }
public void testLookupStaticMethodExactMatch() { [EOL] Class targetClass = MyClass.class; [EOL] String name = "staticMethod"; [EOL] Object[] parameters = new Object[] { "param1", 1 }; [EOL] Method result = jxPath.lookupStaticMethod(targetClass, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(Modifier.isStatic(result.getModifiers())); [EOL] assertEquals(name, result.getName()); [EOL] }
public void testLookupStaticMethodWithNullParameters() { [EOL] Class targetClass = MyClass.class; [EOL] String name = "staticMethod"; [EOL] Object[] parameters = null; [EOL] Method result = jxPath.lookupStaticMethod(targetClass, name, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(Modifier.isStatic(result.getModifiers())); [EOL] assertEquals(name, result.getName()); [EOL] }
public void testLookupStaticMethodWithNullParameterInArray() { [EOL] Class targetClass = MyClass.class; [EOL] String name = "staticMethod"; [EOL] Object[] parameters = new Object[] { null, 1 }; [EOL] Method result = jxPath.lookupStaticMethod(targetClass, name, parameters); [EOL] assertNull(result); [EOL] }
public void testLookupStaticMethodAmbiguousCall() { [EOL] Class targetClass = MyClass.class; [EOL] String name = "ambiguousStaticMethod"; [EOL] Object[] parameters = new Object[] { "param1", 1 }; [EOL] try { [EOL] jxPath.lookupStaticMethod(targetClass, name, parameters); [EOL] fail("Expected JXPathException for ambiguous method call"); [EOL] } catch (JXPathException ex) { [EOL] assertEquals("Ambigous method call: " + name, ex.getMessage()); [EOL] } [EOL] }
public void testLookupMethodWithNullParameters() { [EOL] Method result = YourClass.lookupMethod(SomeClass.class, "methodName", null); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithEmptyParameters() { [EOL] Method result = YourClass.lookupMethod(SomeClass.class, "methodName", new Object[]{}); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithNullFirstParameter() { [EOL] Object[] parameters = {null, "param1", "param2"}; [EOL] Method result = YourClass.lookupMethod(SomeClass.class, "methodName", parameters); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithNoMatch() { [EOL] Object[] parameters = {new NonMatchingType(), "param1", "param2"}; [EOL] Method result = YourClass.lookupMethod(SomeClass.class, "methodName", parameters); [EOL] assertNull(result); [EOL] }
public void testLookupMethodWithExactMatch() throws NoSuchMethodException { [EOL] Object[] parameters = {new MatchingType(), "param1", "param2"}; [EOL] Method expectedMethod = SomeClass.class.getMethod("methodName", String.class, String.class); [EOL] Method result = YourClass.lookupMethod(SomeClass.class, "methodName", parameters); [EOL] assertEquals(expectedMethod, result); [EOL] }
public void testLookupMethodWithNullInParameters() { [EOL] Object[] parameters = {new MatchingType(), null, "param2"}; [EOL] Method result = YourClass.lookupMethod(SomeClass.class, "methodName", parameters); [EOL] assertNotNull(result); [EOL] }
public void testLookupMethodWithAmbiguousMatch() { [EOL] Object[] parameters = {new MatchingType(), new AmbiguousType(), "param2"}; [EOL] try { [EOL] YourClass.lookupMethod(SomeClass.class, "methodName", parameters); [EOL] fail("Expected JXPathException for ambiguous method call"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testMatchTypeWithNullObject() { [EOL] int result = matchType(String.class, null); [EOL] assertEquals(APPROXIMATE_MATCH, result); [EOL] }
public void testMatchTypeWithExactMatch() { [EOL] int result = matchType(String.class, "test"); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchTypeWithAssignableMatch() { [EOL] int result = matchType(Object.class, "test"); [EOL] assertEquals(EXACT_MATCH, result); [EOL] }
public void testMatchTypeWithApproximateMatch() { [EOL] int result = matchType(Integer.class, "10"); [EOL] when(TypeUtils.canConvert("10", Integer.class)).thenReturn(true); [EOL] assertEquals(APPROXIMATE_MATCH, result); [EOL] }
public void testMatchTypeWithNoMatch() { [EOL] int result = matchType(Integer.class, "test"); [EOL] when(TypeUtils.canConvert("test", Integer.class)).thenReturn(false); [EOL] assertEquals(NO_MATCH, result); [EOL] }
public void testDOMAttributePointerWithNonNullParentNonNullAttr() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] Attr attr = mock(Attr.class); [EOL] DOMAttributePointer pointer = new DOMAttributePointer(parent, attr); [EOL] assertNotNull(pointer); [EOL] assertSame(parent, pointer.getParent()); [EOL] assertSame(attr, pointer.getAttribute()); [EOL] }
public void testDOMAttributePointerWithNullParentNonNullAttr() { [EOL] Attr attr = mock(Attr.class); [EOL] DOMAttributePointer pointer = new DOMAttributePointer(null, attr); [EOL] assertNotNull(pointer); [EOL] assertNull(pointer.getParent()); [EOL] assertSame(attr, pointer.getAttribute()); [EOL] }
public void testDOMAttributePointerWithNonNullParentNullAttr() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] DOMAttributePointer pointer = new DOMAttributePointer(parent, null); [EOL] assertNotNull(pointer); [EOL] assertSame(parent, pointer.getParent()); [EOL] assertNull(pointer.getAttribute()); [EOL] }
public void testDOMAttributePointerWithNullParentNullAttr() { [EOL] DOMAttributePointer pointer = new DOMAttributePointer(null, null); [EOL] assertNotNull(pointer); [EOL] assertNull(pointer.getParent()); [EOL] assertNull(pointer.getAttribute()); [EOL] }
public void testGetValueWhenValueIsNull() { [EOL] Attribute attr = mock(Attribute.class); [EOL] when(attr.getValue()).thenReturn(null); [EOL] Object result = attr.getValue(); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWhenValueIsEmptyAndNotSpecified() { [EOL] Attribute attr = mock(Attribute.class); [EOL] when(attr.getValue()).thenReturn(""); [EOL] when(attr.getSpecified()).thenReturn(false); [EOL] Object result = attr.getValue(); [EOL] assertNull(result); [EOL] } [EOL] public void testGetValueWhenValueIsNotEmpty() { [EOL] Attribute attr = mock(Attribute.class); [EOL] when(attr.getValue()).thenReturn("someValue"); [EOL] Object result = attr.getValue(); [EOL] assertEquals("someValue", result); [EOL] } [EOL] public void testGetValueWhenValueIsEmptyAndSpecified() { [EOL] Attribute attr = mock(Attribute.class); [EOL] when(attr.getValue()).thenReturn(""); [EOL] when(attr.getSpecified()).thenReturn(true); [EOL] Object result = attr.getValue(); [EOL] assertEquals("", result); [EOL] }
public Object testGetImmediateNode() { [EOL] YourClass instance = new YourClass(); [EOL] Object expected = instance.attr; [EOL] Object result = instance.getImmediateNode(); [EOL] assertEquals(expected, result); [EOL] }
public boolean isActual() { [EOL] return true; [EOL] }
public void testChildContextConstructorWithNonNullNodeTest() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] boolean startFromParentLocation = true; [EOL] boolean reverse = true; [EOL] ChildContext childContext = new ChildContext(parentContext, nodeTest, startFromParentLocation, reverse); [EOL] assertNotNull(childContext); [EOL] assertEquals(nodeTest, childContext.nodeTest); [EOL] assertEquals(startFromParentLocation, childContext.startFromParentLocation); [EOL] assertEquals(reverse, childContext.reverse); [EOL] }
public void testChildContextConstructorWithNullNodeTest() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = null; [EOL] boolean startFromParentLocation = false; [EOL] boolean reverse = false; [EOL] ChildContext childContext = new ChildContext(parentContext, nodeTest, startFromParentLocation, reverse); [EOL] assertNotNull(childContext); [EOL] assertNull(childContext.nodeTest); [EOL] assertEquals(startFromParentLocation, childContext.startFromParentLocation); [EOL] assertEquals(reverse, childContext.reverse); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionFails() { [EOL] setPosition(0); [EOL] mockSetPosition(1, false); // Mocking setPosition to return false [EOL] NodePointer result = getCurrentNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionSucceeds_IteratorNotNull() { [EOL] setPosition(0); [EOL] mockSetPosition(1, true); // Mocking setPosition to return true [EOL] mockIteratorNotNull(); // Mocking iterator to be not null and ready to return a NodePointer [EOL] NodePointer result = getCurrentNodePointer(); [EOL] assertNotNull(result); [EOL] NodePointer expected = getExpectedNodePointerFromIterator(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetCurrentNodePointer_PositionNotZero_IteratorNotNull() { [EOL] setPosition(2); // Set position to a value other than 0 [EOL] mockIteratorNotNull(); // Mocking iterator to be not null and ready to return a NodePointer [EOL] NodePointer result = getCurrentNodePointer(); [EOL] assertNotNull(result); [EOL] NodePointer expected = getExpectedNodePointerFromIterator(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetCurrentNodePointer_IteratorIsNull() { [EOL] mockIteratorNull(); // Mocking iterator to be null [EOL] NodePointer result = getCurrentNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetSingleNodePointer_PositionIsZero_IteratorIsNull() { [EOL] setPosition(0); [EOL] setIterator(null); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetSingleNodePointer_PositionIsZero_IteratorHasNonNullPointer() { [EOL] setPosition(0); [EOL] setIteratorWithNonNullPointer(); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNotNull(result); [EOL] assertSame(expectedPointer, result); [EOL] }
public void testGetSingleNodePointer_PositionIsZero_IteratorHasOnlyNullPointers() { [EOL] setPosition(0); [EOL] setIteratorWithOnlyNullPointers(); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetSingleNodePointer_PositionIsNotZero() { [EOL] setPosition(1); [EOL] Pointer result = getSingleNodePointer(); [EOL] assertNotNull(result); [EOL] assertSame(expectedCurrentNodePointer, result); [EOL] }
public boolean nextNode() { [EOL] return setPosition(getCurrentPosition() + 1); [EOL] }
public void testReset() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] JXPathIterator testIterator = context.iterate("someXPath"); [EOL] assertNotNull("Iterator should not be null before reset", testIterator); [EOL] ((JXPathContext.ReferenceImpl) testIterator).reset(); [EOL] assertNull("Iterator should be null after reset", ((JXPathContext.ReferenceImpl) testIterator).iterator); [EOL] }
public void testSetPosition_NewPosition() { [EOL] YourObject obj = new YourObject(); [EOL] obj.iterator = new IteratorImplementation(); // Replace with actual iterator implementation [EOL] boolean result = obj.setPosition(1); [EOL] assertTrue(result); [EOL] assertEquals(1, obj.getCurrentPosition()); [EOL] }
public void testSetPosition_SamePosition() { [EOL] YourObject obj = new YourObject(); [EOL] obj.iterator = new IteratorImplementation(); // Replace with actual iterator implementation [EOL] obj.setPosition(0); // Set initial position to 0 [EOL] boolean result = obj.setPosition(0); [EOL] assertTrue(result); [EOL] assertEquals(0, obj.getCurrentPosition()); [EOL] }
public void testSetPosition_WithNullIterator() { [EOL] YourObject obj = new YourObject(); [EOL] obj.iterator = null; [EOL] boolean result = obj.setPosition(1); [EOL] assertFalse(result); [EOL] }
public void testPrepareWithNullParent() { [EOL] parentContext.setCurrentNodePointer(null); [EOL] prepare(); [EOL] assertNull(iterator); [EOL] }
public void testPrepareWithNonNullParentAndStartFromParentLocationTrue() { [EOL] NodePointer mockParent = mock(NodePointer.class); [EOL] NodePointer mockParentParent = mock(NodePointer.class); [EOL] when(mockParent.getParent()).thenReturn(mockParentParent); [EOL] when(mockParentParent.childIterator(nodeTest, reverse, mockParent)).thenReturn(mockIterator); [EOL] parentContext.setCurrentNodePointer(mockParent); [EOL] startFromParentLocation = true; [EOL] prepare(); [EOL] assertEquals(mockIterator, iterator); [EOL] }
public void testPrepareWithNonNullParentAndStartFromParentLocationFalse() { [EOL] NodePointer mockParent = mock(NodePointer.class); [EOL] when(mockParent.childIterator(nodeTest, reverse, null)).thenReturn(mockIterator); [EOL] parentContext.setCurrentNodePointer(mockParent); [EOL] startFromParentLocation = false; [EOL] prepare(); [EOL] assertEquals(mockIterator, iterator); [EOL] }
public int getOrder() { [EOL] return DOM_POINTER_FACTORY_ORDER; [EOL] }
public void testCreateNodePointerWithNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Node bean = mock(Node.class); [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMNodePointer); [EOL] }
public void testCreateNodePointerWithNonNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object bean = new Object(); [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNull(result); [EOL] }
public void testCanConvertWithNullObject() { [EOL] boolean result = ClassName.canConvert(null, SomeClass.class); [EOL] assert result == false || result == true; // Replace with actual expected value [EOL] } [EOL] public void testCanConvertWithNonNullObjectToSameType() { [EOL] SomeClass object = new SomeClass(); [EOL] boolean result = ClassName.canConvert(object, SomeClass.class); [EOL] assert result == true; // Assuming typeConverter can convert to the same type [EOL] } [EOL] public void testCanConvertWithNonNullObjectToDifferentType() { [EOL] SomeClass object = new SomeClass(); [EOL] boolean result = ClassName.canConvert(object, OtherClass.class); [EOL] assert result == false || result == true; // Replace with actual expected value based on typeConverter's capabilities [EOL] }

public void testAttributeIteratorWithWholeCollection() { [EOL] context.setIndex(WHOLE_COLLECTION); [EOL] QName name = new QName("test"); [EOL] NodeIterator result = context.attributeIterator(name); [EOL] assertTrue(result instanceof CollectionAttributeNodeIterator); [EOL] }
public void testAttributeIteratorWithValuePointer() { [EOL] context.setIndex(SPECIFIC_INDEX); [EOL] QName name = new QName("test"); [EOL] NodeIterator result = context.attributeIterator(name); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ExpectedNodeIteratorType); [EOL] }
public void testAsPathWithParentAndIndexNotWholeCollection() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] when(parent.asPath()).thenReturn("/parentPath"); [EOL] when(parent.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION); [EOL] NodePointer child = new ConcreteNodePointer(parent, 1); [EOL] String result = child.asPath(); [EOL] assertEquals("/parentPath/.[2]", result); [EOL] }
public void testAsPathWithParentAndIndexWholeCollection() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] when(parent.asPath()).thenReturn("/parentPath"); [EOL] when(parent.getIndex()).thenReturn(NodePointer.WHOLE_COLLECTION); [EOL] NodePointer child = new ConcreteNodePointer(parent, NodePointer.WHOLE_COLLECTION); [EOL] String result = child.asPath(); [EOL] assertEquals("/parentPath", result); [EOL] }
public void testAsPathWithoutParentAndIndexNotWholeCollection() { [EOL] NodePointer child = new ConcreteNodePointer(null, 1); [EOL] String result = child.asPath(); [EOL] assertEquals("/.[2]", result); [EOL] }
public void testAsPathWithoutParentAndIndexWholeCollection() { [EOL] NodePointer child = new ConcreteNodePointer(null, NodePointer.WHOLE_COLLECTION); [EOL] String result = child.asPath(); [EOL] assertEquals("/", result); [EOL] }
public void testInvokeWithNullParameters() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] ConstructorFunction constructorFunction = new ConstructorFunction(SomeClass.class.getConstructor()); [EOL] Object result = constructorFunction.invoke(context, null); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SomeClass); [EOL] } [EOL] public void testInvokeWithContextParameter() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] ConstructorFunction constructorFunction = new ConstructorFunction(SomeOtherClass.class.getConstructor(ExpressionContext.class)); [EOL] Object[] parameters = new Object[]{context}; [EOL] Object result = constructorFunction.invoke(context, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SomeOtherClass); [EOL] } [EOL] public void testInvokeWithParameters() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] ConstructorFunction constructorFunction = new ConstructorFunction(ParameterizedClass.class.getConstructor(String.class, int.class)); [EOL] Object[] parameters = new Object[]{"test", 1}; [EOL] Object result = constructorFunction.invoke(context, parameters); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ParameterizedClass); [EOL] } [EOL] public void testInvokeWithInvalidParameters() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] ConstructorFunction constructorFunction = new ConstructorFunction(ParameterizedClass.class.getConstructor(String.class, int.class)); [EOL] Object[] parameters = new Object[]{"test", "invalid"}; [EOL] try { [EOL] constructorFunction.invoke(context, parameters); [EOL] fail("Expected JXPathInvalidAccessException to be thrown"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] } [EOL] } [EOL] public void testInvokeWithInvocationTargetException() { [EOL] ExpressionContext context = mock(ExpressionContext.class); [EOL] ConstructorFunction constructorFunction = new ConstructorFunction(FailingClass.class.getConstructor()); [EOL] try { [EOL] constructorFunction.invoke(context, new Object[]{}); [EOL] fail("Expected JXPathInvalidAccessException to be thrown"); [EOL] } catch (JXPathInvalidAccessException e) { [EOL] } [EOL] }
public void testDOMAttributeIteratorWithElementNodeAndSpecificName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("specificName"); [EOL] Node node = mock(Node.class); [EOL] Attr attr = mock(Attr.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getAttributes()).thenReturn(null); // Assuming getAttribute is a method to be mocked [EOL] when(getAttribute((Element) node, name)).thenReturn(attr); [EOL] DOMAttributeIterator iterator = new DOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertEquals(1, iterator.attributes.size()); [EOL] assertTrue(iterator.attributes.contains(attr)); [EOL] }
public void testDOMAttributeIteratorWithElementNodeAndWildcardName() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("*"); [EOL] Node node = mock(Node.class); [EOL] NamedNodeMap map = mock(NamedNodeMap.class); [EOL] Attr attr1 = mock(Attr.class); [EOL] Attr attr2 = mock(Attr.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] when(node.getNodeType()).thenReturn(Node.ELEMENT_NODE); [EOL] when(node.getAttributes()).thenReturn(map); [EOL] when(map.getLength()).thenReturn(2); [EOL] when(map.item(0)).thenReturn(attr1); [EOL] when(map.item(1)).thenReturn(attr2); [EOL] when(testAttr(attr1, name)).thenReturn(true); [EOL] when(testAttr(attr2, name)).thenReturn(false); [EOL] DOMAttributeIterator iterator = new DOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertEquals(1, iterator.attributes.size()); [EOL] assertTrue(iterator.attributes.contains(attr1)); [EOL] assertFalse(iterator.attributes.contains(attr2)); [EOL] }
public void testDOMAttributeIteratorWithNonElementNode() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = new QName("name"); [EOL] Node node = mock(Node.class); [EOL] when(parent.getNode()).thenReturn(node); [EOL] when(node.getNodeType()).thenReturn(Node.TEXT_NODE); [EOL] DOMAttributeIterator iterator = new DOMAttributeIterator(parent, name); [EOL] assertNotNull(iterator.attributes); [EOL] assertTrue(iterator.attributes.isEmpty()); [EOL] }
public void testGetAttributeWithNonNullPrefixAndNamespace() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn("namespaceURI"); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockElement.getAttributeNodeNS("namespaceURI", "name")).thenReturn(mockAttr); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testGetAttributeWithNonNullPrefixButNullNamespace() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn(null); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] when(mockElement.getAttributes()).thenReturn(mockNamedNodeMap); [EOL] when(mockNamedNodeMap.getLength()).thenReturn(0); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNull(result); [EOL] }
public void testGetAttributeWithNonNullPrefixAndMatchingAttribute() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn("prefix"); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] when(parent.getNamespaceURI("prefix")).thenReturn(null); [EOL] NamedNodeMap mockNamedNodeMap = mock(NamedNodeMap.class); [EOL] when(mockElement.getAttributes()).thenReturn(mockNamedNodeMap); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockNamedNodeMap.getLength()).thenReturn(1); [EOL] when(mockNamedNodeMap.item(0)).thenReturn(mockAttr); [EOL] when(testAttr(mockAttr, mockQName)).thenReturn(true); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testGetAttributeWithNullPrefix() { [EOL] Element mockElement = mock(Element.class); [EOL] QName mockQName = mock(QName.class); [EOL] when(mockQName.getPrefix()).thenReturn(null); [EOL] when(mockQName.getName()).thenReturn("name"); [EOL] Attr mockAttr = mock(Attr.class); [EOL] when(mockElement.getAttributeNode("name")).thenReturn(mockAttr); [EOL] Attr result = getAttribute(mockElement, mockQName); [EOL] assertNotNull(result); [EOL] assertEquals(mockAttr, result); [EOL] }
public void testGetNodePointer_PositionZero_SetPositionFails() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 0; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNull(result); [EOL] }
public void testGetNodePointer_PositionZero_SetPositionSucceeds() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 0; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMAttributePointer); [EOL] }
public void testGetNodePointer_NegativePosition() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = -1; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMAttributePointer); [EOL] }
public void testGetNodePointer_ValidPosition() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance.position = 2; [EOL] NodePointer result = instance.getNodePointer(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DOMAttributePointer); [EOL] }
public void testSetPositionWithinRange() { [EOL] JxPathContext context = new JxPathContext(); // Assuming JxPathContext is the class where setPosition is defined [EOL] context.addAttribute("attribute1", "value1"); // Assuming addAttribute method exists to add attributes [EOL] context.addAttribute("attribute2", "value2"); [EOL] boolean result = context.setPosition(1); [EOL] assertTrue(result); [EOL] assertEquals(1, context.getPosition()); // Assuming getPosition method exists to get the current position [EOL] }
public void testSetPositionBelowRange() { [EOL] JxPathContext context = new JxPathContext(); [EOL] boolean result = context.setPosition(0); [EOL] assertFalse(result); [EOL] assertEquals(0, context.getPosition()); [EOL] }
public void testSetPositionAboveRange() { [EOL] JxPathContext context = new JxPathContext(); [EOL] context.addAttribute("attribute1", "value1"); [EOL] context.addAttribute("attribute2", "value2"); [EOL] boolean result = context.setPosition(3); [EOL] assertFalse(result); [EOL] assertEquals(3, context.getPosition()); [EOL] }
Since the provided method `protected JXPathContextFactory() { [EOL] }` is a constructor with an empty body, there is no executable code within it to cover with unit tests. Therefore, no unit test cases are necessary or possible to achieve line coverage for this specific method. If the constructor were to contain logic or perform actions, then test cases could be generated to ensure that logic is executed correctly. However, as it stands, there is nothing to test in this constructor.
public void testNewInstanceWithNullFactoryImplName() { [EOL] JXPathContextFactory.factoryImplName = null; [EOL] JXPathContextFactory factory = JXPathContextFactory.newInstance(); [EOL] assertNotNull("Factory should not be null", factory); [EOL] }
public void testNewInstanceWithValidFactoryImplName() { [EOL] JXPathContextFactory factory = JXPathContextFactory.newInstance(); [EOL] assertNotNull("Factory should not be null", factory); [EOL] }
public void testNewInstanceClassNotFoundException() { [EOL] JXPathContextFactory.factoryImplName = "invalid.ClassName"; [EOL] try { [EOL] JXPathContextFactory.newInstance(); [EOL] fail("Should have thrown JXPathContextFactoryConfigurationError due to ClassNotFoundException"); [EOL] } catch (JXPathContextFactoryConfigurationError expected) { [EOL] } [EOL] }
public void testNewInstanceIllegalAccessException() { [EOL] JXPathContextFactory.factoryImplName = "com.private.ClassName"; [EOL] try { [EOL] JXPathContextFactory.newInstance(); [EOL] fail("Should have thrown JXPathContextFactoryConfigurationError due to IllegalAccessException"); [EOL] } catch (JXPathContextFactoryConfigurationError expected) { [EOL] } [EOL] }
public void testNewInstanceInstantiationException() { [EOL] JXPathContextFactory.factoryImplName = "com.abstract.ClassName"; [EOL] try { [EOL] JXPathContextFactory.newInstance(); [EOL] fail("Should have thrown JXPathContextFactoryConfigurationError due to InstantiationException"); [EOL] } catch (JXPathContextFactoryConfigurationError expected) { [EOL] } [EOL] }
private static String findFactory(String property, String defaultFactory) { [EOL] try { [EOL] String systemProp = System.getProperty(property); [EOL] if (systemProp != null) { [EOL] if (debug) { [EOL] System.err.println("JXPath: found system property" + systemProp); [EOL] } [EOL] return systemProp; [EOL] } [EOL] } catch (SecurityException se) { [EOL] } [EOL] try { [EOL] String javah = System.getProperty("java.home"); [EOL] String configFile = javah + File.separator + "lib" + File.separator + "jxpath.properties"; [EOL] File f = new File(configFile); [EOL] if (f.exists()) { [EOL] Properties props = new Properties(); [EOL] props.load(new FileInputStream(f)); [EOL] String factory = props.getProperty(property); [EOL] if (factory != null) { [EOL] if (debug) { [EOL] System.err.println("JXPath: found java.home property " + factory); [EOL] } [EOL] return factory; [EOL] } [EOL] } [EOL] } catch (Exception ex) { [EOL] if (debug) { [EOL] ex.printStackTrace(); [EOL] } [EOL] } [EOL] String serviceId = "META-INF/services/" + property; [EOL] try { [EOL] ClassLoader cl = JXPathContextFactory.class.getClassLoader(); [EOL] InputStream is = null; [EOL] if (cl == null) { [EOL] is = ClassLoader.getSystemResourceAsStream(serviceId); [EOL] } else { [EOL] is = cl.getResourceAsStream(serviceId); [EOL] } [EOL] if (is != null) { [EOL] if (debug) { [EOL] System.err.println("JXPath: found  " + serviceId); [EOL] } [EOL] BufferedReader rd = new BufferedReader(new InputStreamReader(is)); [EOL] String factory = rd.readLine(); [EOL] rd.close(); [EOL] if (factory != null && !"".equals(factory)) { [EOL] if (debug) { [EOL] System.err.println("JXPath: loaded from services: " + factory); [EOL] } [EOL] return factory; [EOL] } [EOL] } [EOL] } catch (Exception ex) { [EOL] if (debug) { [EOL] ex.printStackTrace(); [EOL] } [EOL] } [EOL] return defaultFactory; [EOL] }
public int getOrder() { [EOL] return CONTAINER_POINTER_FACTORY_ORDER; [EOL] }
public int getOrder() { [EOL] return DYNA_BEAN_POINTER_FACTORY_ORDER; [EOL] }
public int getOrder() { [EOL] return COLLECTION_POINTER_FACTORY_ORDER; [EOL] }
public void testCreateNodePointerWithCollection() { [EOL] QName name = new QName("test"); [EOL] Object bean = new ArrayList(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertTrue(result instanceof CollectionPointer); [EOL] }
public void testCreateNodePointerWithNonCollection() { [EOL] QName name = new QName("test"); [EOL] Object bean = new Object(); [EOL] Locale locale = Locale.getDefault(); [EOL] NodePointer result = createNodePointer(name, bean, locale); [EOL] assertNull(result); [EOL] }
public void testCreateNodePointerWithCollectionBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object bean = mock(Collection.class); [EOL] when(ValueUtils.isCollection(bean)).thenReturn(true); [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CollectionPointer); [EOL] assertEquals(parent, result.getParent()); [EOL] assertEquals(bean, ((CollectionPointer) result).getCollection()); [EOL] }
public void testCreateNodePointerWithNonCollectionBean() { [EOL] NodePointer parent = mock(NodePointer.class); [EOL] QName name = mock(QName.class); [EOL] Object bean = new Object(); [EOL] when(ValueUtils.isCollection(bean)).thenReturn(false); [EOL] NodePointer result = createNodePointer(parent, name, bean); [EOL] assertNull(result); [EOL] }
public void testCoreOperationDivideWithNonNullArguments() { [EOL] Expression arg1 = mock(Expression.class); [EOL] Expression arg2 = mock(Expression.class); [EOL] CoreOperationDivide operation = new CoreOperationDivide(arg1, arg2); [EOL] assertNotNull(operation); [EOL] }
public void testCoreOperationDivideWithNullArguments() { [EOL] try { [EOL] new CoreOperationDivide(null, null); [EOL] fail("Should have thrown IllegalArgumentException for null arguments"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetPrecedence() { [EOL] SomeClass instance = new SomeClass(); [EOL] int expected = 5; [EOL] int actual = instance.getPrecedence(); [EOL] assertEquals(expected, actual); [EOL] }
public String getSymbol() { [EOL] return "div"; [EOL] }
public void testCreateNodeFactoryArrayWhenNull() { [EOL] ReflectionTestUtils.setField(MyClass.class, "nodeFactoryArray", null); [EOL] nodeFactories.clear(); [EOL] nodeFactories.add(new NodePointerFactory(2)); // Assuming a constructor that sets the order [EOL] nodeFactories.add(new NodePointerFactory(1)); [EOL] MyClass.createNodeFactoryArray(); [EOL] assertNotNull(MyClass.getNodeFactoryArray()); [EOL] assertEquals(1, MyClass.getNodeFactoryArray()[0].getOrder()); [EOL] assertEquals(2, MyClass.getNodeFactoryArray()[1].getOrder()); [EOL] }
public void testCreateNodeFactoryArrayWhenNotNull() { [EOL] NodePointerFactory[] prePopulatedArray = {new NodePointerFactory(1)}; [EOL] ReflectionTestUtils.setField(MyClass.class, "nodeFactoryArray", prePopulatedArray); [EOL] MyClass.createNodeFactoryArray(); [EOL] assertSame(prePopulatedArray, MyClass.getNodeFactoryArray()); [EOL] }
public void testGetNodePointerFactories() { [EOL] NodePointerFactory[] factories = ClassName.getNodePointerFactories(); [EOL] assertNotNull("Factories should not be null", factories); [EOL] }
public void testCompileExpressionWithSoftCacheHit() { [EOL] String xpath = "/some/xpath"; [EOL] Expression expectedExpression = new Expression(); [EOL] SoftReference<Expression> softRef = new SoftReference<>(expectedExpression); [EOL] compiled.put(xpath, softRef); [EOL] USE_SOFT_CACHE = true; [EOL] Expression result = compileExpression(xpath); [EOL] assertSame("Should return the cached Expression object", expectedExpression, result); [EOL] }
public void testCompileExpressionWithSoftCacheMissAndCleanup() { [EOL] String xpath = "/some/xpath"; [EOL] Expression expectedExpression = new Expression(); [EOL] compiled.put(xpath, new SoftReference<Expression>(null)); // Simulate garbage-collected reference [EOL] USE_SOFT_CACHE = true; [EOL] CLEANUP_THRESHOLD = 0; // Force cleanup [EOL] cleanupCount = CLEANUP_THRESHOLD; [EOL] Expression result = compileExpression(xpath); [EOL] assertNotNull("Should compile a new Expression object", result); [EOL] assertNotSame("Should not return the previously cached (and collected) Expression object", expectedExpression, result); [EOL] assertEquals("Cleanup count should be reset", 0, cleanupCount); [EOL] }
public void testCompileExpressionWithoutSoftCache() { [EOL] String xpath = "/some/xpath"; [EOL] Expression expectedExpression = new Expression(); [EOL] compiled.put(xpath, expectedExpression); [EOL] USE_SOFT_CACHE = false; [EOL] Expression result = compileExpression(xpath); [EOL] assertSame("Should return the cached Expression object", expectedExpression, result); [EOL] }
public void testCompileExpressionWithSoftCacheMissAndNoCleanup() { [EOL] String xpath = "/some/xpath"; [EOL] USE_SOFT_CACHE = true; [EOL] CLEANUP_THRESHOLD = 10; // Set a threshold that won't trigger cleanup [EOL] cleanupCount = 0; [EOL] Expression result = compileExpression(xpath); [EOL] assertNotNull("Should compile a new Expression object", result); [EOL] assertEquals("Cleanup count should be incremented", 1, cleanupCount); [EOL] }
public void testCompileExpressionWithSoftCacheAndNewExpression() { [EOL] String xpath = "/some/new/xpath"; [EOL] USE_SOFT_CACHE = true; [EOL] CLEANUP_THRESHOLD = 10; // Set a threshold that won't trigger cleanup [EOL] cleanupCount = 0; [EOL] Expression result = compileExpression(xpath); [EOL] assertNotNull("Should compile a new Expression object", result); [EOL] SoftReference ref = (SoftReference) compiled.get(xpath); [EOL] assertNotNull("Compiled expression should be cached", ref); [EOL] assertSame("Cached expression should be the same as the result", result, ref.get()); [EOL] }
public void testGetValueWithValidXpath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String validXpath = "/valid/xpath"; [EOL] Object result = context.getValue(validXpath); [EOL] assertNotNull(result); [EOL] }
public void testGetValueWithInvalidXpath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String invalidXpath = "/invalid/xpath"; [EOL] try { [EOL] context.getValue(invalidXpath); [EOL] fail("Should have thrown an exception for invalid XPath"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetValueWithNullXpath() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] String nullXpath = null; [EOL] try { [EOL] context.getValue(nullXpath); [EOL] fail("Should have thrown an exception for null XPath"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetValueWithNullResultAndNonLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(null); [EOL] when(expr instanceof Path).thenReturn(true); [EOL] try { [EOL] context.getValue("nonexistent/path", expr); [EOL] fail("JXPathNotFoundException expected"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetValueWithNullResultAndLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(true); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(null); [EOL] Object result = context.getValue("nonexistent/path", expr); [EOL] assertNull(result); [EOL] }
public void testGetValueWithEvalContextResultAndSingleNodePointerNullNonLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(null); [EOL] try { [EOL] context.getValue("valid/path", expr); [EOL] fail("JXPathNotFoundException expected"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetValueWithNodePointerResultAndNonActualNonLenient() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.getValuePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(false); [EOL] when(nodePointer.getImmediateParentPointer()).thenReturn(null); [EOL] try { [EOL] context.getValue("valid/path", expr); [EOL] fail("JXPathNotFoundException expected"); [EOL] } catch (JXPathNotFoundException e) { [EOL] } [EOL] }
public void testGetValueWithValidResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] Expression expr = mock(Expression.class); [EOL] Object expectedResult = new Object(); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.getValuePointer()).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(true); [EOL] when(nodePointer.getValue()).thenReturn(expectedResult); [EOL] Object result = context.getValue("valid/path", expr); [EOL] assertSame(expectedResult, result); [EOL] }
public Iterator iterate(String xpath) { [EOL] return iterate(xpath, compileExpression(xpath)); [EOL] }
public Iterator iterate(String xpath, Expression expr) { [EOL] return expr.iterate(getEvalContext()); [EOL] }
public Pointer getPointer(String xpath) { [EOL] return getPointer(xpath, compileExpression(xpath)); [EOL] }
public void testGetPointerWithEvalContextResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] EvalContext evalContext = mock(EvalContext.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(evalContext); [EOL] when(evalContext.getSingleNodePointer()).thenReturn(nodePointer); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertSame(nodePointer, result); [EOL] }
public void testGetPointerWithNodePointerResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(true); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertSame(nodePointer, result); [EOL] }
public void testGetPointerWithNonPointerResult() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] Expression expr = mock(Expression.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(new Object()); [EOL] Pointer result = context.getPointer("some/xpath", expr); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NodePointer); [EOL] }
public void testGetPointerThrowsJXPathNotFoundException() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] context.setLenient(false); [EOL] Expression expr = mock(Expression.class); [EOL] NodePointer nodePointer = mock(NodePointer.class); [EOL] when(expr.computeValue(any(EvalContext.class))).thenReturn(nodePointer); [EOL] when(nodePointer.isActual()).thenReturn(false); [EOL] try { [EOL] context.getPointer("some/xpath", expr); [EOL] fail("JXPathNotFoundException expected"); [EOL] } catch (JXPathNotFoundException e) { [EOL] assertEquals("No pointer for xpath: some/xpath", e.getMessage()); [EOL] } [EOL] }
public Iterator iteratePointers(String xpath) { [EOL] return iteratePointers(xpath, compileExpression(xpath)); [EOL] }
public Iterator iteratePointers(String xpath, Expression expr) { [EOL] return expr.iteratePointers(getEvalContext()); [EOL] }
public void testGetContextPointerWhenContextPointerIsNull() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] assertNull(context.getContextPointer()); [EOL] }
public void testGetContextPointerWhenContextPointerIsNotNull() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] assertNotNull(context.getContextPointer()); [EOL] }
public void testGetEvalContext() { [EOL] JXPathContext context = JXPathContext.newContext(new Object()); [EOL] EvalContext evalContext = context.getEvalContext(); [EOL] assertNotNull("EvalContext should not be null", evalContext); [EOL] assertTrue("EvalContext should be instance of InitialContext", evalContext instanceof InitialContext); [EOL] }
public void testGetVariablePointerWithDeclaredVariable() { [EOL] QName varName = new QName("testVar"); [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.getVariables().declareVariable("testVar", "testValue"); [EOL] NodePointer result = context.getVariablePointer(varName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof VariablePointer); [EOL] assertEquals("testValue", result.getValue()); [EOL] }
public void testGetVariablePointerWithUndeclaredVariable() { [EOL] QName varName = new QName("testVar"); [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NodePointer result = context.getVariablePointer(varName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof VariablePointer); [EOL] assertNull(result.getValue()); [EOL] }
public void testGetVariablePointerWithNestedContexts() { [EOL] QName varName = new QName("testVar"); [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] parentContext.getVariables().declareVariable("testVar", "parentValue"); [EOL] childContext.getVariables().declareVariable("testVar", "childValue"); [EOL] NodePointer result = childContext.getVariablePointer(varName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof VariablePointer); [EOL] assertEquals("childValue", result.getValue()); [EOL] }
public void testGetVariablePointerWithNestedContextsUndeclared() { [EOL] QName varName = new QName("testVar"); [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] NodePointer result = childContext.getVariablePointer(varName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof VariablePointer); [EOL] assertNull(result.getValue()); [EOL] }
public void testGetFunctionWithValidFunction() { [EOL] QName functionName = new QName("http://example.com", "testFunction"); [EOL] Object[] parameters = new Object[]{}; [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] Functions functions = mock(Functions.class); [EOL] Function expectedFunction = mock(Function.class); [EOL] when(context.getFunctions()).thenReturn(functions); [EOL] when(functions.getFunction("http://example.com", "testFunction", parameters)).thenReturn(expectedFunction); [EOL] Function result = context.getFunction(functionName, parameters); [EOL] assertNotNull(result); [EOL] assertSame(expectedFunction, result); [EOL] }
public void testGetFunctionWithFunctionNotFound() { [EOL] QName functionName = new QName("http://example.com", "nonExistentFunction"); [EOL] Object[] parameters = new Object[]{}; [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] JXPathContext parentContext = mock(JXPathContext.class); [EOL] Functions functions = mock(Functions.class); [EOL] when(context.getFunctions()).thenReturn(null); [EOL] when(context.getParentContext()).thenReturn(parentContext); [EOL] when(parentContext.getFunctions()).thenReturn(functions); [EOL] when(functions.getFunction("http://example.com", "nonExistentFunction", parameters)).thenReturn(null); [EOL] try { [EOL] context.getFunction(functionName, parameters); [EOL] fail("JXPathFunctionNotFoundException expected"); [EOL] } catch (JXPathFunctionNotFoundException e) { [EOL] assertEquals("Undefined function: {http://example.com}nonExistentFunction", e.getMessage()); [EOL] } [EOL] }
public void testGetFunctionWithFunctionNotFoundInParentContext() { [EOL] QName functionName = new QName("http://example.com", "nonExistentFunction"); [EOL] Object[] parameters = new Object[]{}; [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] JXPathContext parentContext = mock(JXPathContext.class); [EOL] when(context.getFunctions()).thenReturn(null); [EOL] when(context.getParentContext()).thenReturn(parentContext); [EOL] when(parentContext.getFunctions()).thenReturn(null); [EOL] when(parentContext.getParentContext()).thenReturn(null); [EOL] try { [EOL] context.getFunction(functionName, parameters); [EOL] fail("JXPathFunctionNotFoundException expected"); [EOL] } catch (JXPathFunctionNotFoundException e) { [EOL] assertEquals("Undefined function: {http://example.com}nonExistentFunction", e.getMessage()); [EOL] } [EOL] }
public void testGetNamespaceResolver_SealsResolver() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] NamespaceResolver originalResolver = context.getNamespaceResolver(); [EOL] NamespaceResolver result = context.getNamespaceResolver(); [EOL] assertNotNull("NamespaceResolver should not be null", result); [EOL] assertTrue("NamespaceResolver should be sealed after getting", result.isSealed()); [EOL] }
public void testGetNamespaceResolver_RegistersDefaultNamespaceURI() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] String defaultNamespaceURI = "http://www.example.com"; [EOL] context.registerDefaultNamespaceURI(defaultNamespaceURI); [EOL] NamespaceResolver result = context.getNamespaceResolver(); [EOL] assertEquals("Default namespace URI should be registered", [EOL] defaultNamespaceURI, result.getDefaultNamespaceURI()); [EOL] }
public void testGetDefaultNamespaceURI_WithNonNullDefaultNamespaceURI() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.setDefaultNamespaceURI("http://example.com/namespace"); [EOL] String result = context.getDefaultNamespaceURI(); [EOL] assertEquals("http://example.com/namespace", result); [EOL] }
public void testGetDefaultNamespaceURI_WithNullDefaultNamespaceURIAndNonNullParentContext() { [EOL] JXPathContext parentContext = JXPathContext.newContext(null); [EOL] parentContext.setDefaultNamespaceURI("http://parent.com/namespace"); [EOL] JXPathContext childContext = JXPathContext.newContext(parentContext); [EOL] String result = childContext.getDefaultNamespaceURI(); [EOL] assertEquals("http://parent.com/namespace", result); [EOL] }
public void testGetDefaultNamespaceURI_WithNullDefaultNamespaceURIAndNullParentContext() { [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] String result = context.getDefaultNamespaceURI(); [EOL] assertNull(result); [EOL] }
public void testAllocateConditionallyWithExistingClasses() { [EOL] String existingClass = "java.lang.String"; [EOL] String existenceCheckClass = "java.lang.Object"; [EOL] Object result = JXPath.allocateConditionally(existingClass, existenceCheckClass); [EOL] assertNotNull(result); [EOL] }
public void testAllocateConditionallyWithNonExistingCheckClass() { [EOL] String existingClass = "java.lang.String"; [EOL] String nonExistingCheckClass = "non.existing.Class"; [EOL] Object result = JXPath.allocateConditionally(existingClass, nonExistingCheckClass); [EOL] assertNull(result); [EOL] }
public void testAllocateConditionallyWithInvalidClassToAllocate() { [EOL] String invalidClassToAllocate = "invalid.ClassToAllocate"; [EOL] String existenceCheckClass = "java.lang.Object"; [EOL] try { [EOL] JXPath.allocateConditionally(invalidClassToAllocate, existenceCheckClass); [EOL] fail("Should have thrown JXPathException"); [EOL] } catch (JXPathException e) { [EOL] } [EOL] }
public void testGetArguments_NullArgs() { [EOL] Expression[] args = null; [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.getVariables().declareVariable("args", args); [EOL] Expression[] result = context.getVariables().getVariable("args").getArguments(); [EOL] assertNull("Arguments should be null", result); [EOL] }
public void testGetArguments_EmptyArgs() { [EOL] Expression[] args = new Expression[0]; [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.getVariables().declareVariable("args", args); [EOL] Expression[] result = context.getVariables().getVariable("args").getArguments(); [EOL] assertNotNull("Arguments should not be null", result); [EOL] assertEquals("Arguments length should be 0", 0, result.length); [EOL] }
public void testGetArguments_NonEmptyArgs() { [EOL] Expression[] args = new Expression[]{new ExpressionImpl(), new ExpressionImpl()}; [EOL] JXPathContext context = JXPathContext.newContext(null); [EOL] context.getVariables().declareVariable("args", args); [EOL] Expression[] result = context.getVariables().getVariable("args").getArguments(); [EOL] assertNotNull("Arguments should not be null", result); [EOL] assertEquals("Arguments length should be 2", 2, result.length); [EOL] }
public void testSelfContextWithNonNullParentContextAndNodeTest() { [EOL] EvalContext parentContext = mock(EvalContext.class); [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] SelfContext selfContext = new SelfContext(parentContext, nodeTest); [EOL] assertNotNull(selfContext); [EOL] assertSame(parentContext, selfContext.getParentContext()); [EOL] assertSame(nodeTest, selfContext.getNodeTest()); [EOL] }
public void testSelfContextWithNullParentContextAndNodeTest() { [EOL] NodeTest nodeTest = mock(NodeTest.class); [EOL] SelfContext selfContext = new SelfContext(null, nodeTest); [EOL] assertNotNull(selfContext); [EOL] assertNull(selfContext.getParentContext()); [EOL] assertSame(nodeTest, selfContext.getNodeTest()); [EOL] }
public Pointer getSingleNodePointer() { [EOL] return parentContext.getSingleNodePointer(); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionFails() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.position = 0; [EOL] NodePointer expectedNodePointer = null; [EOL] NodePointer result = testInstance.getCurrentNodePointer(); [EOL] assertEquals(expectedNodePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionIsZero_SetPositionSucceeds() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.position = 0; [EOL] NodePointer expectedNodePointer = new NodePointer(); // Assuming NodePointer is a valid object [EOL] testInstance.nodePointer = expectedNodePointer; [EOL] NodePointer result = testInstance.getCurrentNodePointer(); [EOL] assertEquals(expectedNodePointer, result); [EOL] }
public void testGetCurrentNodePointer_PositionIsNotZero() { [EOL] YourClass testInstance = new YourClass(); [EOL] testInstance.position = 1; [EOL] NodePointer expectedNodePointer = new NodePointer(); // Assuming NodePointer is a valid object [EOL] testInstance.nodePointer = expectedNodePointer; [EOL] NodePointer result = testInstance.getCurrentNodePointer(); [EOL] assertEquals(expectedNodePointer, result); [EOL] }
public void testReset() { [EOL] YourClass instance = new YourClass(); [EOL] instance.reset(); [EOL] assertFalse(instance.startedSet); [EOL] }
public void testSetPosition_NotEqualToOne() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.setPosition(2); [EOL] assertFalse(result); [EOL] }
public void testSetPosition_EqualToOne_StartedSetFalse_NodePointerNull() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.setPosition(1); [EOL] assertFalse(result); [EOL] }
public void testSetPosition_EqualToOne_StartedSetFalse_NodePointerNotNull_NodeTestNull() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.setPosition(1); [EOL] assertTrue(result); [EOL] }
public void testSetPosition_EqualToOne_StartedSetFalse_NodePointerNotNull_NodeTestNotNull_PassesTest() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.setPosition(1); [EOL] assertTrue(result); [EOL] }
public void testSetPosition_EqualToOne_StartedSetFalse_NodePointerNotNull_NodeTestNotNull_FailsTest() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.setPosition(1); [EOL] assertFalse(result); [EOL] }
public void testSetPosition_EqualToOne_StartedSetTrue() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.setPosition(1); [EOL] }
public void testCollectionAttributeNodeIteratorWithNonNullName() { [EOL] CollectionPointer mockPointer = mock(CollectionPointer.class); [EOL] QName mockName = mock(QName.class); [EOL] CollectionAttributeNodeIterator iterator = new CollectionAttributeNodeIterator(mockPointer, mockName); [EOL] assertNotNull(iterator); [EOL] }
public void testCollectionAttributeNodeIteratorWithNullName() { [EOL] CollectionPointer mockPointer = mock(CollectionPointer.class); [EOL] CollectionAttributeNodeIterator iterator = new CollectionAttributeNodeIterator(mockPointer, null); [EOL] assertNotNull(iterator); [EOL] assertNull(iterator.getName()); [EOL] }
protected NodeIterator getElementNodeIterator(NodePointer elementPointer) { [EOL] return elementPointer.attributeIterator(name); [EOL] }
