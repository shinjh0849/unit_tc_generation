public Attributes attributes() { [EOL]     return attributes; [EOL] }
public Attributes attributes() { [EOL]     return attributes; [EOL] }
public String baseUri() { [EOL]     return baseUri; [EOL] }
public String baseUri() { [EOL]     return baseUri; [EOL] }
public void setBaseUri(String baseUri) { [EOL]     Validate.notNull(baseUri); [EOL]     this.baseUri = baseUri; [EOL] }
public void setBaseUri(String baseUri) { [EOL]     Validate.notNull(baseUri); [EOL]     this.baseUri = baseUri; [EOL] }
public List<Node> childNodes() { [EOL]     return Collections.unmodifiableList(childNodes); [EOL] }
public List<Node> childNodes() { [EOL]     return Collections.unmodifiableList(childNodes); [EOL] }
public void replaceWith(Node in) { [EOL]     Validate.notNull(in); [EOL]     Validate.notNull(parentNode); [EOL]     parentNode.replaceChild(this, in); [EOL] }
public void replaceWith(Node in) { [EOL]     Validate.notNull(in); [EOL]     Validate.notNull(parentNode); [EOL]     parentNode.replaceChild(this, in); [EOL] }
protected void replaceChild(Node out, Node in) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     Integer index = indexInList(out, childNodes); [EOL]     childNodes.set(index, in); [EOL]     in.parentNode = this; [EOL]     out.parentNode = null; [EOL] }
protected void replaceChild(Node out, Node in) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     Integer index = indexInList(out, childNodes); [EOL]     childNodes.set(index, in); [EOL]     in.parentNode = this; [EOL]     out.parentNode = null; [EOL] }
protected void replaceChild(Node out, Node in) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     Integer index = indexInList(out, childNodes); [EOL]     childNodes.set(index, in); [EOL]     in.parentNode = this; [EOL]     out.parentNode = null; [EOL] }
protected void replaceChild(Node out, Node in) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     Integer index = indexInList(out, childNodes); [EOL]     childNodes.set(index, in); [EOL]     in.parentNode = this; [EOL]     out.parentNode = null; [EOL] }
protected int nodeDepth() { [EOL]     if (parentNode == null) [EOL]         return 0; [EOL]     else [EOL]         return parentNode.nodeDepth() + 1; [EOL] }
protected int nodeDepth() { [EOL]     if (parentNode == null) [EOL]         return 0; [EOL]     else [EOL]         return parentNode.nodeDepth() + 1; [EOL] }
protected int nodeDepth() { [EOL]     if (parentNode == null) [EOL]         return 0; [EOL]     else [EOL]         return parentNode.nodeDepth() + 1; [EOL] }
protected static <N extends Node> Integer indexInList(N search, List<N> nodes) { [EOL]     Validate.notNull(search); [EOL]     Validate.notNull(nodes); [EOL]     for (int i = 0; i < nodes.size(); i++) { [EOL]         N node = nodes.get(i); [EOL]         if (node.equals(search)) [EOL]             return i; [EOL]     } [EOL]     return null; [EOL] }
protected static <N extends Node> Integer indexInList(N search, List<N> nodes) { [EOL]     Validate.notNull(search); [EOL]     Validate.notNull(nodes); [EOL]     for (int i = 0; i < nodes.size(); i++) { [EOL]         N node = nodes.get(i); [EOL]         if (node.equals(search)) [EOL]             return i; [EOL]     } [EOL]     return null; [EOL] }
protected static <N extends Node> Integer indexInList(N search, List<N> nodes) { [EOL]     Validate.notNull(search); [EOL]     Validate.notNull(nodes); [EOL]     for (int i = 0; i < nodes.size(); i++) { [EOL]         N node = nodes.get(i); [EOL]         if (node.equals(search)) [EOL]             return i; [EOL]     } [EOL]     return null; [EOL] }
protected static <N extends Node> Integer indexInList(N search, List<N> nodes) { [EOL]     Validate.notNull(search); [EOL]     Validate.notNull(nodes); [EOL]     for (int i = 0; i < nodes.size(); i++) { [EOL]         N node = nodes.get(i); [EOL]         if (node.equals(search)) [EOL]             return i; [EOL]     } [EOL]     return null; [EOL] }
protected void indent(StringBuilder accum) { [EOL]     accum.append("\n").append(StringUtils.leftPad("", nodeDepth() - 1 * 2)); [EOL] }
protected void indent(StringBuilder accum) { [EOL]     accum.append("\n").append(StringUtils.leftPad("", nodeDepth() - 1 * 2)); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     return false; [EOL] }
public Elements() { [EOL]     contents = new ArrayList<Element>(); [EOL] }
public Elements(Collection<Element> elements) { [EOL]     contents = new ArrayList<Element>(elements); [EOL] }
public Elements(Collection<Element> elements) { [EOL]     contents = new ArrayList<Element>(elements); [EOL] }
public Elements(List<Element> elements) { [EOL]     contents = elements; [EOL] }
public Elements(List<Element> elements) { [EOL]     contents = elements; [EOL] }
public Elements(Element... elements) { [EOL]     this(Arrays.asList(elements)); [EOL] }
public Elements(Element... elements) { [EOL]     this(Arrays.asList(elements)); [EOL] }
public Elements(Element... elements) { [EOL]     this(Arrays.asList(elements)); [EOL] }
public String text() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Element element : contents) { [EOL]         if (sb.length() != 0) [EOL]             sb.append(" "); [EOL]         sb.append(element.text()); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String html() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Element element : contents) { [EOL]         if (sb.length() != 0) [EOL]             sb.append("\n"); [EOL]         sb.append(element.html()); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String html() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Element element : contents) { [EOL]         if (sb.length() != 0) [EOL]             sb.append("\n"); [EOL]         sb.append(element.html()); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public String html() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Element element : contents) { [EOL]         if (sb.length() != 0) [EOL]             sb.append("\n"); [EOL]         sb.append(element.html()); [EOL]     } [EOL]     return sb.toString(); [EOL] }
public Elements html(String html) { [EOL]     for (Element element : contents) { [EOL]         element.html(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements html(String html) { [EOL]     for (Element element : contents) { [EOL]         element.html(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements html(String html) { [EOL]     for (Element element : contents) { [EOL]         element.html(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements prepend(String html) { [EOL]     for (Element element : contents) { [EOL]         element.prepend(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements prepend(String html) { [EOL]     for (Element element : contents) { [EOL]         element.prepend(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements prepend(String html) { [EOL]     for (Element element : contents) { [EOL]         element.prepend(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements append(String html) { [EOL]     for (Element element : contents) { [EOL]         element.append(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements append(String html) { [EOL]     for (Element element : contents) { [EOL]         element.append(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements append(String html) { [EOL]     for (Element element : contents) { [EOL]         element.append(html); [EOL]     } [EOL]     return this; [EOL] }
public Elements eq(int index) { [EOL]     if (contents.size() > index) [EOL]         return new Elements(get(index)); [EOL]     else [EOL]         return new Elements(); [EOL] }
public Elements eq(int index) { [EOL]     if (contents.size() > index) [EOL]         return new Elements(get(index)); [EOL]     else [EOL]         return new Elements(); [EOL] }
public Elements eq(int index) { [EOL]     if (contents.size() > index) [EOL]         return new Elements(get(index)); [EOL]     else [EOL]         return new Elements(); [EOL] }
public Element first() { [EOL]     return !contents.isEmpty() ? contents.get(0) : null; [EOL] }
public Element first() { [EOL]     return !contents.isEmpty() ? contents.get(0) : null; [EOL] }
public boolean isEmpty() { [EOL]     return contents.isEmpty(); [EOL] }
public boolean isEmpty() { [EOL]     return contents.isEmpty(); [EOL] }
public Iterator<Element> iterator() { [EOL]     return contents.iterator(); [EOL] }
public Iterator<Element> iterator() { [EOL]     return contents.iterator(); [EOL] }
public boolean add(Element element) { [EOL]     return contents.add(element); [EOL] }
public boolean add(Element element) { [EOL]     return contents.add(element); [EOL] }
public Element get(int index) { [EOL]     return contents.get(index); [EOL] }
public Element get(int index) { [EOL]     return contents.get(index); [EOL] }
public Element get(int index) { [EOL]     return contents.get(index); [EOL] }
Id(String id) { [EOL]     this.id = id; [EOL] }
public boolean matches(Element element) { [EOL]     return (id.equals(element.id())); [EOL] }
public boolean matches(Element element) { [EOL]     return (id.equals(element.id())); [EOL] }
public boolean isValid(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return numDiscarded == 0; [EOL] }
public boolean isValid(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return numDiscarded == 0; [EOL] }
public boolean isValid(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return numDiscarded == 0; [EOL] }
public Document(String baseUri) { [EOL]     super(Tag.valueOf("#root"), baseUri); [EOL] }
public Document(String baseUri) { [EOL]     super(Tag.valueOf("#root"), baseUri); [EOL] }
public Document(String baseUri) { [EOL]     super(Tag.valueOf("#root"), baseUri); [EOL] }
static public Document createShell(String baseUri) { [EOL]     Validate.notNull(baseUri); [EOL]     Document doc = new Document(baseUri); [EOL]     Element html = doc.appendElement("html"); [EOL]     html.appendElement("head"); [EOL]     html.appendElement("body"); [EOL]     return doc; [EOL] }
public Element head() { [EOL]     return getElementsByTag("head").first(); [EOL] }
public Element head() { [EOL]     return getElementsByTag("head").first(); [EOL] }
public Element body() { [EOL]     return getElementsByTag("body").first(); [EOL] }
public Element body() { [EOL]     return getElementsByTag("body").first(); [EOL] }
public Element createElement(String tagName) { [EOL]     return new Element(Tag.valueOf(tagName), this.baseUri()); [EOL] }
public Element createElement(String tagName) { [EOL]     return new Element(Tag.valueOf(tagName), this.baseUri()); [EOL] }
public Element createElement(String tagName) { [EOL]     return new Element(Tag.valueOf(tagName), this.baseUri()); [EOL] }
public Document normalise() { [EOL]     if (select("html").isEmpty()) [EOL]         appendElement("html"); [EOL]     if (head() == null) [EOL]         select("html").first().prependElement("head"); [EOL]     if (body() == null) [EOL]         select("html").first().appendElement("body"); [EOL]     normalise(head()); [EOL]     normalise(select("html").first()); [EOL]     normalise(this); [EOL]     return this; [EOL] }
public Document normalise() { [EOL]     if (select("html").isEmpty()) [EOL]         appendElement("html"); [EOL]     if (head() == null) [EOL]         select("html").first().prependElement("head"); [EOL]     if (body() == null) [EOL]         select("html").first().appendElement("body"); [EOL]     normalise(head()); [EOL]     normalise(select("html").first()); [EOL]     normalise(this); [EOL]     return this; [EOL] }
public Document normalise() { [EOL]     if (select("html").isEmpty()) [EOL]         appendElement("html"); [EOL]     if (head() == null) [EOL]         select("html").first().prependElement("head"); [EOL]     if (body() == null) [EOL]         select("html").first().appendElement("body"); [EOL]     normalise(head()); [EOL]     normalise(select("html").first()); [EOL]     normalise(this); [EOL]     return this; [EOL] }
public Document normalise() { [EOL]     if (select("html").isEmpty()) [EOL]         appendElement("html"); [EOL]     if (head() == null) [EOL]         select("html").first().prependElement("head"); [EOL]     if (body() == null) [EOL]         select("html").first().appendElement("body"); [EOL]     normalise(head()); [EOL]     normalise(select("html").first()); [EOL]     normalise(this); [EOL]     return this; [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
private void normalise(Element element) { [EOL]     List<Node> toMove = new ArrayList<Node>(); [EOL]     for (Node node : element.childNodes) { [EOL]         if (node instanceof TextNode) { [EOL]             TextNode tn = (TextNode) node; [EOL]             if (!tn.isBlank()) [EOL]                 toMove.add(tn); [EOL]         } [EOL]     } [EOL]     for (Node node : toMove) { [EOL]         element.removeChild(node); [EOL]         body().prependChild(node); [EOL]         body().prependChild(new TextNode(" ", "")); [EOL]     } [EOL] }
private Elements select() { [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchesAny(combinators)) { [EOL]         elements.add(root); [EOL]         combinator(tq.consume().toString()); [EOL]     } else { [EOL]         addElements(findElements()); [EOL]     } [EOL]     while (!tq.isEmpty()) { [EOL]         boolean seenWhite = tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(",")) { [EOL]             while (!tq.isEmpty()) { [EOL]                 String subQuery = tq.chompTo(","); [EOL]                 elements.addAll(select(subQuery, root)); [EOL]             } [EOL]         } else if (tq.matchesAny(combinators)) { [EOL]             combinator(tq.consume().toString()); [EOL]         } else if (seenWhite) { [EOL]             combinator(" "); [EOL]         } else { [EOL]             Elements candidates = findElements(); [EOL]             intersectElements(filterForSelf(elements, candidates)); [EOL]         } [EOL]     } [EOL]     return new Elements(elements); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void intersectElements(Collection<Element> intersect) { [EOL]     elements.retainAll(intersect); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void intersectElements(Collection<Element> intersect) { [EOL]     elements.retainAll(intersect); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private void intersectElements(Collection<Element> intersect) { [EOL]     elements.retainAll(intersect); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byId() { [EOL]     String id = tq.consumeCssIdentifier(); [EOL]     Validate.notEmpty(id); [EOL]     Element found = root.getElementById(id); [EOL]     Elements byId = new Elements(); [EOL]     if (found != null) [EOL]         byId.add(found); [EOL]     return byId; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byId() { [EOL]     String id = tq.consumeCssIdentifier(); [EOL]     Validate.notEmpty(id); [EOL]     Element found = root.getElementById(id); [EOL]     Elements byId = new Elements(); [EOL]     if (found != null) [EOL]         byId.add(found); [EOL]     return byId; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byId() { [EOL]     String id = tq.consumeCssIdentifier(); [EOL]     Validate.notEmpty(id); [EOL]     Element found = root.getElementById(id); [EOL]     Elements byId = new Elements(); [EOL]     if (found != null) [EOL]         byId.add(found); [EOL]     return byId; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byClass() { [EOL]     String className = tq.consumeCssIdentifier(); [EOL]     Validate.notEmpty(className); [EOL]     return root.getElementsByClass(className); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         boolean found = false; [EOL]         for (Element p : parents) { [EOL]             if (c.equals(p)) { [EOL]                 found = true; [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]         if (!found) [EOL]             children.add(c); [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         boolean found = false; [EOL]         for (Element p : parents) { [EOL]             if (c.equals(p)) { [EOL]                 found = true; [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]         if (!found) [EOL]             children.add(c); [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         boolean found = false; [EOL]         for (Element p : parents) { [EOL]             if (c.equals(p)) { [EOL]                 found = true; [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]         if (!found) [EOL]             children.add(c); [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         boolean found = false; [EOL]         for (Element p : parents) { [EOL]             if (c.equals(p)) { [EOL]                 found = true; [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]         if (!found) [EOL]             children.add(c); [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) { [EOL]     Elements children = new Elements(); [EOL]     CHILD: for (Element c : candidates) { [EOL]         for (Element p : parents) { [EOL]             if (c.equals(p)) { [EOL]                 children.add(c); [EOL]                 continue CHILD; [EOL]             } [EOL]         } [EOL]     } [EOL]     return children; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }
public Element(Tag tag, String baseUri, Attributes attributes) { [EOL]     super(baseUri, attributes); [EOL]     Validate.notNull(tag); [EOL]     this.tag = tag; [EOL] }
public Element(Tag tag, String baseUri, Attributes attributes) { [EOL]     super(baseUri, attributes); [EOL]     Validate.notNull(tag); [EOL]     this.tag = tag; [EOL] }
public Element(Tag tag, String baseUri) { [EOL]     this(tag, baseUri, new Attributes()); [EOL] }
public Element(Tag tag, String baseUri) { [EOL]     this(tag, baseUri, new Attributes()); [EOL] }
public Element(Tag tag, String baseUri) { [EOL]     this(tag, baseUri, new Attributes()); [EOL] }
public String tagName() { [EOL]     return tag.getName(); [EOL] }
public String tagName() { [EOL]     return tag.getName(); [EOL] }
public Tag tag() { [EOL]     return tag; [EOL] }
public boolean isBlock() { [EOL]     return tag.isBlock(); [EOL] }
public boolean isBlock() { [EOL]     return tag.isBlock(); [EOL] }
@Override [EOL] public Element parent() { [EOL]     return (Element) super.parent(); [EOL] }
@Override [EOL] public Element parent() { [EOL]     return (Element) super.parent(); [EOL] }
public Elements children() { [EOL]     List<Element> elements = new ArrayList<Element>(); [EOL]     for (Node node : childNodes) { [EOL]         if (node instanceof Element) [EOL]             elements.add((Element) node); [EOL]     } [EOL]     return new Elements(elements); [EOL] }
public Elements children() { [EOL]     List<Element> elements = new ArrayList<Element>(); [EOL]     for (Node node : childNodes) { [EOL]         if (node instanceof Element) [EOL]             elements.add((Element) node); [EOL]     } [EOL]     return new Elements(elements); [EOL] }
public Elements select(String query) { [EOL]     return Selector.select(query, this); [EOL] }
public Elements select(String query) { [EOL]     return Selector.select(query, this); [EOL] }
public Elements select(String query) { [EOL]     return Selector.select(query, this); [EOL] }
public Element appendChild(Node child) { [EOL]     Validate.notNull(child); [EOL]     child.setParentNode(this); [EOL]     childNodes.add(child); [EOL]     return this; [EOL] }
public Element appendChild(Node child) { [EOL]     Validate.notNull(child); [EOL]     child.setParentNode(this); [EOL]     childNodes.add(child); [EOL]     return this; [EOL] }
public Element prependChild(Node child) { [EOL]     Validate.notNull(child); [EOL]     child.setParentNode(this); [EOL]     childNodes.add(0, child); [EOL]     return this; [EOL] }
public Element prependChild(Node child) { [EOL]     Validate.notNull(child); [EOL]     child.setParentNode(this); [EOL]     childNodes.add(0, child); [EOL]     return this; [EOL] }
public Element appendElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     appendChild(child); [EOL]     return child; [EOL] }
public Element appendElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     appendChild(child); [EOL]     return child; [EOL] }
public Element appendElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     appendChild(child); [EOL]     return child; [EOL] }
public Element appendText(String text) { [EOL]     TextNode node = new TextNode(text, baseUri()); [EOL]     appendChild(node); [EOL]     return this; [EOL] }
public Element appendText(String text) { [EOL]     TextNode node = new TextNode(text, baseUri()); [EOL]     appendChild(node); [EOL]     return this; [EOL] }
public Element appendText(String text) { [EOL]     TextNode node = new TextNode(text, baseUri()); [EOL]     appendChild(node); [EOL]     return this; [EOL] }
public Element append(String html) { [EOL]     Validate.notNull(html); [EOL]     Element fragment = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     for (Node node : fragment.childNodes()) { [EOL]         node.parentNode = null; [EOL]         appendChild(node); [EOL]     } [EOL]     return this; [EOL] }
public Element append(String html) { [EOL]     Validate.notNull(html); [EOL]     Element fragment = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     for (Node node : fragment.childNodes()) { [EOL]         node.parentNode = null; [EOL]         appendChild(node); [EOL]     } [EOL]     return this; [EOL] }
public Element append(String html) { [EOL]     Validate.notNull(html); [EOL]     Element fragment = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     for (Node node : fragment.childNodes()) { [EOL]         node.parentNode = null; [EOL]         appendChild(node); [EOL]     } [EOL]     return this; [EOL] }
public Element prepend(String html) { [EOL]     Validate.notNull(html); [EOL]     Element fragment = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     List<Node> nodes = fragment.childNodes(); [EOL]     for (int i = nodes.size() - 1; i >= 0; i--) { [EOL]         Node node = nodes.get(i); [EOL]         node.parentNode = null; [EOL]         prependChild(node); [EOL]     } [EOL]     return this; [EOL] }
public Element prepend(String html) { [EOL]     Validate.notNull(html); [EOL]     Element fragment = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     List<Node> nodes = fragment.childNodes(); [EOL]     for (int i = nodes.size() - 1; i >= 0; i--) { [EOL]         Node node = nodes.get(i); [EOL]         node.parentNode = null; [EOL]         prependChild(node); [EOL]     } [EOL]     return this; [EOL] }
public Element prepend(String html) { [EOL]     Validate.notNull(html); [EOL]     Element fragment = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     List<Node> nodes = fragment.childNodes(); [EOL]     for (int i = nodes.size() - 1; i >= 0; i--) { [EOL]         Node node = nodes.get(i); [EOL]         node.parentNode = null; [EOL]         prependChild(node); [EOL]     } [EOL]     return this; [EOL] }
public Element empty() { [EOL]     childNodes.clear(); [EOL]     return this; [EOL] }
public Element nextElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (siblings.size() > index + 1) [EOL]         return siblings.get(index + 1); [EOL]     else [EOL]         return null; [EOL] }
public Element nextElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (siblings.size() > index + 1) [EOL]         return siblings.get(index + 1); [EOL]     else [EOL]         return null; [EOL] }
public Element nextElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (siblings.size() > index + 1) [EOL]         return siblings.get(index + 1); [EOL]     else [EOL]         return null; [EOL] }
public Element firstElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     return siblings.size() > 1 ? siblings.get(0) : null; [EOL] }
public Element firstElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     return siblings.size() > 1 ? siblings.get(0) : null; [EOL] }
public Element firstElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     return siblings.size() > 1 ? siblings.get(0) : null; [EOL] }
public Element lastElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; [EOL] }
public Element lastElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; [EOL] }
public Element lastElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; [EOL] }
public Elements getElementsByTag(String tagName) { [EOL]     Validate.notEmpty(tagName); [EOL]     tagName = tagName.toLowerCase().trim(); [EOL]     return Collector.collect(new Evaluator.Tag(tagName), this); [EOL] }
public Elements getElementsByTag(String tagName) { [EOL]     Validate.notEmpty(tagName); [EOL]     tagName = tagName.toLowerCase().trim(); [EOL]     return Collector.collect(new Evaluator.Tag(tagName), this); [EOL] }
public Elements getElementsByTag(String tagName) { [EOL]     Validate.notEmpty(tagName); [EOL]     tagName = tagName.toLowerCase().trim(); [EOL]     return Collector.collect(new Evaluator.Tag(tagName), this); [EOL] }
public Elements getElementsByTag(String tagName) { [EOL]     Validate.notEmpty(tagName); [EOL]     tagName = tagName.toLowerCase().trim(); [EOL]     return Collector.collect(new Evaluator.Tag(tagName), this); [EOL] }
public Elements getElementsByClass(String className) { [EOL]     Validate.notEmpty(className); [EOL]     return Collector.collect(new Evaluator.Class(className), this); [EOL] }
public Elements getElementsByClass(String className) { [EOL]     Validate.notEmpty(className); [EOL]     return Collector.collect(new Evaluator.Class(className), this); [EOL] }
public Elements getElementsByClass(String className) { [EOL]     Validate.notEmpty(className); [EOL]     return Collector.collect(new Evaluator.Class(className), this); [EOL] }
boolean preserveWhitespace() { [EOL]     return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace(); [EOL] }
boolean preserveWhitespace() { [EOL]     return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace(); [EOL] }
boolean preserveWhitespace() { [EOL]     return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace(); [EOL] }
boolean preserveWhitespace() { [EOL]     return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace(); [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) [EOL]         indent(accum); [EOL]     accum.append("<").append(tagName()).append(attributes.html()); [EOL]     if (childNodes.isEmpty() && tag.isEmpty()) { [EOL]         accum.append(" />"); [EOL]     } else { [EOL]         accum.append(">"); [EOL]         html(accum); [EOL]         if (tag.canContainBlock()) [EOL]             indent(accum); [EOL]         accum.append("</").append(tagName()).append(">"); [EOL]     } [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) [EOL]         indent(accum); [EOL]     accum.append("<").append(tagName()).append(attributes.html()); [EOL]     if (childNodes.isEmpty() && tag.isEmpty()) { [EOL]         accum.append(" />"); [EOL]     } else { [EOL]         accum.append(">"); [EOL]         html(accum); [EOL]         if (tag.canContainBlock()) [EOL]             indent(accum); [EOL]         accum.append("</").append(tagName()).append(">"); [EOL]     } [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) [EOL]         indent(accum); [EOL]     accum.append("<").append(tagName()).append(attributes.html()); [EOL]     if (childNodes.isEmpty() && tag.isEmpty()) { [EOL]         accum.append(" />"); [EOL]     } else { [EOL]         accum.append(">"); [EOL]         html(accum); [EOL]         if (tag.canContainBlock()) [EOL]             indent(accum); [EOL]         accum.append("</").append(tagName()).append(">"); [EOL]     } [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) [EOL]         indent(accum); [EOL]     accum.append("<").append(tagName()).append(attributes.html()); [EOL]     if (childNodes.isEmpty() && tag.isEmpty()) { [EOL]         accum.append(" />"); [EOL]     } else { [EOL]         accum.append(">"); [EOL]         html(accum); [EOL]         if (tag.canContainBlock()) [EOL]             indent(accum); [EOL]         accum.append("</").append(tagName()).append(">"); [EOL]     } [EOL] }
void outerHtml(StringBuilder accum) { [EOL]     if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0)) [EOL]         indent(accum); [EOL]     accum.append("<").append(tagName()).append(attributes.html()); [EOL]     if (childNodes.isEmpty() && tag.isEmpty()) { [EOL]         accum.append(" />"); [EOL]     } else { [EOL]         accum.append(">"); [EOL]         html(accum); [EOL]         if (tag.canContainBlock()) [EOL]             indent(accum); [EOL]         accum.append("</").append(tagName()).append(">"); [EOL]     } [EOL] }
private void html(StringBuilder accum) { [EOL]     for (Node node : childNodes) node.outerHtml(accum); [EOL] }
private void html(StringBuilder accum) { [EOL]     for (Node node : childNodes) node.outerHtml(accum); [EOL] }
private void html(StringBuilder accum) { [EOL]     for (Node node : childNodes) node.outerHtml(accum); [EOL] }
public Element html(String html) { [EOL]     empty(); [EOL]     append(html); [EOL]     return this; [EOL] }
public Element html(String html) { [EOL]     empty(); [EOL]     append(html); [EOL]     return this; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (!(o instanceof Element)) [EOL]         return false; [EOL]     if (!super.equals(o)) [EOL]         return false; [EOL]     Element element = (Element) o; [EOL]     if (tag != null ? !tag.equals(element.tag) : element.tag != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (!(o instanceof Element)) [EOL]         return false; [EOL]     if (!super.equals(o)) [EOL]         return false; [EOL]     Element element = (Element) o; [EOL]     if (tag != null ? !tag.equals(element.tag) : element.tag != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (!(o instanceof Element)) [EOL]         return false; [EOL]     if (!super.equals(o)) [EOL]         return false; [EOL]     Element element = (Element) o; [EOL]     if (tag != null ? !tag.equals(element.tag) : element.tag != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (!(o instanceof Element)) [EOL]         return false; [EOL]     if (!super.equals(o)) [EOL]         return false; [EOL]     Element element = (Element) o; [EOL]     if (tag != null ? !tag.equals(element.tag) : element.tag != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (!(o instanceof Element)) [EOL]         return false; [EOL]     if (!super.equals(o)) [EOL]         return false; [EOL]     Element element = (Element) o; [EOL]     if (tag != null ? !tag.equals(element.tag) : element.tag != null) [EOL]         return false; [EOL]     return true; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = super.hashCode(); [EOL]     result = 31 * result + (tag != null ? tag.hashCode() : 0); [EOL]     return result; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = super.hashCode(); [EOL]     result = 31 * result + (tag != null ? tag.hashCode() : 0); [EOL]     return result; [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] }
public Attribute(String key, String value) { [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(value); [EOL]     this.key = key.trim().toLowerCase(); [EOL]     this.value = value; [EOL] }
public String getKey() { [EOL]     return key; [EOL] }
public String getValue() { [EOL]     return value; [EOL] }
public static Attribute createFromEncoded(String unencodedKey, String encodedValue) { [EOL]     String value = StringEscapeUtils.unescapeHtml(encodedValue); [EOL]     return new Attribute(unencodedKey, value); [EOL] }
public static Attribute createFromEncoded(String unencodedKey, String encodedValue) { [EOL]     String value = StringEscapeUtils.unescapeHtml(encodedValue); [EOL]     return new Attribute(unencodedKey, value); [EOL] }
boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] }
public static Document parse(String html) { [EOL]     return Parser.parse(html, ""); [EOL] }
public static Document parse(String html) { [EOL]     return Parser.parse(html, ""); [EOL] }
public static Document parse(String html) { [EOL]     return Parser.parse(html, ""); [EOL] }
public static Document parseBodyFragment(String bodyHtml, String baseUri) { [EOL]     return Parser.parseBodyFragment(bodyHtml, baseUri); [EOL] }
public static Document parseBodyFragment(String bodyHtml, String baseUri) { [EOL]     return Parser.parseBodyFragment(bodyHtml, baseUri); [EOL] }
public static Document parseBodyFragment(String bodyHtml, String baseUri) { [EOL]     return Parser.parseBodyFragment(bodyHtml, baseUri); [EOL] }
public static Document parseBodyFragment(String bodyHtml, String baseUri) { [EOL]     return Parser.parseBodyFragment(bodyHtml, baseUri); [EOL] }
public static boolean isValid(String bodyHtml, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, ""); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     return cleaner.isValid(dirty); [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] }
