public void testSiblingIndexWithNoParent() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] assertNull(element.siblingIndex()); [EOL] }
public void testSiblingIndexAsFirstChild() { [EOL] Element parent = new Element(Tag.valueOf("div"), ""); [EOL] Element child = new Element(Tag.valueOf("p"), ""); [EOL] parent.appendChild(child); [EOL] assertEquals(Integer.valueOf(0), child.siblingIndex()); [EOL] }
public void testSiblingIndexAsMiddleChild() { [EOL] Element parent = new Element(Tag.valueOf("div"), ""); [EOL] Element firstChild = new Element(Tag.valueOf("p"), ""); [EOL] Element secondChild = new Element(Tag.valueOf("span"), ""); [EOL] Element thirdChild = new Element(Tag.valueOf("a"), ""); [EOL] parent.appendChild(firstChild); [EOL] parent.appendChild(secondChild); [EOL] parent.appendChild(thirdChild); [EOL] assertEquals(Integer.valueOf(1), secondChild.siblingIndex()); [EOL] }
public void testSiblingIndexAsLastChild() { [EOL] Element parent = new Element(Tag.valueOf("div"), ""); [EOL] Element firstChild = new Element(Tag.valueOf("p"), ""); [EOL] Element secondChild = new Element(Tag.valueOf("span"), ""); [EOL] Element thirdChild = new Element(Tag.valueOf("a"), ""); [EOL] parent.appendChild(firstChild); [EOL] parent.appendChild(secondChild); [EOL] parent.appendChild(thirdChild); [EOL] assertEquals(Integer.valueOf(2), thirdChild.siblingIndex()); [EOL] }
public void testHasAttr_WithExistingAttribute() { [EOL] Element element1 = new Element(Tag.valueOf("div"), ""); [EOL] element1.attr("existingAttr", "value1"); [EOL] Element element2 = new Element(Tag.valueOf("span"), ""); [EOL] element2.attr("existingAttr", "value2"); [EOL] Elements contents = new Elements(); [EOL] contents.add(element1); [EOL] contents.add(element2); [EOL] assertTrue(contents.hasAttr("existingAttr")); [EOL] }
public void testHasAttr_WithNonExistingAttribute() { [EOL] Element element1 = new Element(Tag.valueOf("div"), ""); [EOL] element1.attr("existingAttr", "value1"); [EOL] Element element2 = new Element(Tag.valueOf("span"), ""); [EOL] element2.attr("existingAttr", "value2"); [EOL] Elements contents = new Elements(); [EOL] contents.add(element1); [EOL] contents.add(element2); [EOL] assertFalse(contents.hasAttr("nonExistingAttr")); [EOL] }
public void testHasAttr_EmptyElements() { [EOL] Elements contents = new Elements(); [EOL] assertFalse(contents.hasAttr("anyAttr")); [EOL] }
public void testPrivateConstructor() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL] Constructor<Evaluator> constructor = Evaluator.class.getDeclaredConstructor(); [EOL] assertTrue(Modifier.isPrivate(constructor.getModifiers())); [EOL] constructor.setAccessible(true); [EOL] try { [EOL] constructor.newInstance(); [EOL] fail("Expected an IllegalAccessException to be thrown"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testTagConstructorWithValidName() { [EOL] String validTagName = "p"; [EOL] Tag tag = new Tag(validTagName); [EOL] assertEquals(validTagName, tag.tagName); [EOL] }
public void testTagConstructorWithEmptyName() { [EOL] String emptyTagName = "" ; [EOL] Tag tag = new Tag(emptyTagName); [EOL] assertEquals(emptyTagName, tag.tagName); [EOL] }
public void testTagConstructorWithNullName() { [EOL] String nullTagName = null; [EOL] try { [EOL] Tag tag = new Tag(nullTagName); [EOL] fail("Should have thrown an exception for null tagName"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testMatchesWithMatchingTagName() { [EOL] Element element = new Element(Tag.valueOf("p"), ""); [EOL] TagNameByElementMatcher matcher = new TagNameByElementMatcher("p"); [EOL] boolean result = matcher.matches(element); [EOL] assertTrue(result); [EOL] }
public void testMatchesWithNonMatchingTagName() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] TagNameByElementMatcher matcher = new TagNameByElementMatcher("p"); [EOL] boolean result = matcher.matches(element); [EOL] assertFalse(result); [EOL] }
public void testConstructorWithValidClassName() { [EOL] String validClassName = "testClass"; [EOL] ClassName cn = new ClassName(validClassName); [EOL] assertEquals(validClassName, cn.className); [EOL] }
public void testMatchesWithClass() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] String className = "test-class"; [EOL] element.addClass(className); [EOL] ClassNameMatcher matcher = new ClassNameMatcher(className); [EOL] boolean result = matcher.matches(element); [EOL] assertTrue(result); [EOL] }
public void testMatchesWithoutClass() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] String className = "test-class"; [EOL] ClassNameMatcher matcher = new ClassNameMatcher(className); [EOL] boolean result = matcher.matches(element); [EOL] assertFalse(result); [EOL] }
public void testAttributeConstructorWithNullKey() { [EOL] try { [EOL] new Attribute(null); [EOL] fail("Attribute constructor should throw IllegalArgumentException for null key"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAttributeConstructorWithEmptyKey() { [EOL] Attribute attr = new Attribute(""); [EOL] assertEquals("", attr.getKey()); [EOL] }
public void testAttributeConstructorWithValidKey() { [EOL] String key = "href"; [EOL] Attribute attr = new Attribute(key); [EOL] assertEquals(key, attr.getKey()); [EOL] }
public void testMatchesWithAttribute() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.attr("key", "value"); [EOL] AttributeKeyMatcher matcher = new AttributeKeyMatcher("key"); [EOL] assertTrue(matcher.matches(element)); [EOL] }
public void testMatchesWithoutAttribute() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] AttributeKeyMatcher matcher = new AttributeKeyMatcher("key"); [EOL] assertFalse(matcher.matches(element)); [EOL] }
public void testAttributeWithValue() { [EOL] String key = "someKey"; [EOL] String value = "someValue"; [EOL] AttributeWithValue attribute = new AttributeWithValue(key, value); [EOL] assertEquals(key, attribute.getKey()); [EOL] assertEquals(value, attribute.getValue()); [EOL] }
public void testMatches_True() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.attr("key", "Value"); [EOL] AttributesMatcher matcher = new AttributesMatcher("key", "Value"); [EOL] assertTrue(matcher.matches(element)); [EOL] }
public void testMatches_False() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.attr("key", "DifferentValue"); [EOL] AttributesMatcher matcher = new AttributesMatcher("key", "Value"); [EOL] assertFalse(matcher.matches(element)); [EOL] }
public void testMatches_CaseInsensitive() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.attr("key", "value"); [EOL] AttributesMatcher matcher = new AttributesMatcher("key", "VaLuE"); [EOL] assertTrue(matcher.matches(element)); [EOL] }
public void testAttributeWithValueContaining_KeyValueNotNull() { [EOL] AttributeWithValueContaining attr = new AttributeWithValueContaining("key", "value"); [EOL] assertNotNull(attr); [EOL] assertEquals("key", attr.getKey()); [EOL] assertEquals("value", attr.getValue()); [EOL] }
public void testAttributeWithValueContaining_KeyNullValueNotNull() { [EOL] AttributeWithValueContaining attr = new AttributeWithValueContaining(null, "value"); [EOL] assertNotNull(attr); [EOL] assertNull(attr.getKey()); [EOL] assertEquals("value", attr.getValue()); [EOL] }
public void testAttributeWithValueContaining_KeyNotNullValueNull() { [EOL] AttributeWithValueContaining attr = new AttributeWithValueContaining("key", null); [EOL] assertNotNull(attr); [EOL] assertEquals("key", attr.getKey()); [EOL] assertNull(attr.getValue()); [EOL] }
public void testAttributeWithValueContaining_KeyValueNull() { [EOL] AttributeWithValueContaining attr = new AttributeWithValueContaining(null, null); [EOL] assertNotNull(attr); [EOL] assertNull(attr.getKey()); [EOL] assertNull(attr.getValue()); [EOL] }
public void testMatchesWithMatchingElement() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.attr("key", "SomeValue"); [EOL] AttributeWithValueMatcher matcher = new AttributeWithValueMatcher("key", "some"); [EOL] boolean result = matcher.matches(element); [EOL] assertTrue(result); [EOL] }
public void testMatchesWithNonMatchingElement() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.attr("key", "OtherValue"); [EOL] AttributeWithValueMatcher matcher = new AttributeWithValueMatcher("key", "some"); [EOL] boolean result = matcher.matches(element); [EOL] assertFalse(result); [EOL] }
public void testMatchesWithCaseInsensitive() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.attr("key", "SOMEVALUE"); [EOL] AttributeWithValueMatcher matcher = new AttributeWithValueMatcher("key", "some"); [EOL] boolean result = matcher.matches(element); [EOL] assertTrue(result); [EOL] }
public void testMatchesWithEmptyValue() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] AttributeWithValueMatcher matcher = new AttributeWithValueMatcher("key", ""); [EOL] boolean result = matcher.matches(element); [EOL] assertTrue(result); [EOL] }
public void testMatchesWithNullElement() { [EOL] AttributeWithValueMatcher matcher = new AttributeWithValueMatcher("key", "some"); [EOL] try { [EOL] matcher.matches(null); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAttributeKeyPairWithValidArguments() { [EOL] String key = "SomeKey"; [EOL] String value = "SomeValue"; [EOL] AttributeKeyPair pair = new AttributeKeyPair(key, value); [EOL] assertEquals("somekey", pair.getKey()); [EOL] assertEquals("somevalue", pair.getValue()); [EOL] }
public void testAttributeKeyPairWithEmptyKey() { [EOL] try { [EOL] String key = ""; [EOL] String value = "SomeValue"; [EOL] new AttributeKeyPair(key, value); [EOL] fail("Should have thrown IllegalArgumentException for empty key"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAttributeKeyPairWithEmptyValue() { [EOL] try { [EOL] String key = "SomeKey"; [EOL] String value = ""; [EOL] new AttributeKeyPair(key, value); [EOL] fail("Should have thrown IllegalArgumentException for empty value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAttributeKeyPairWithWhitespaceKey() { [EOL] String key = "  "; [EOL] String value = "SomeValue"; [EOL] try { [EOL] new AttributeKeyPair(key, value); [EOL] fail("Should have thrown IllegalArgumentException for whitespace key"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAttributeKeyPairWithWhitespaceValue() { [EOL] String key = "SomeKey"; [EOL] String value = "  "; [EOL] try { [EOL] new AttributeKeyPair(key, value); [EOL] fail("Should have thrown IllegalArgumentException for whitespace value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIndexEquals() { [EOL] int index = 0; // Example index, should be replaced with meaningful value [EOL] IndexEquals instance = new IndexEquals(index); [EOL] }
public void testMatchesWithMatchingIndex() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] SiblingIndexFilter filter = new SiblingIndexFilter(0); [EOL] element.setSiblingIndex(0); [EOL] assertTrue(filter.matches(element)); [EOL] }
public void testMatchesWithNonMatchingIndex() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] SiblingIndexFilter filter = new SiblingIndexFilter(1); [EOL] element.setSiblingIndex(0); [EOL] assertFalse(filter.matches(element)); [EOL] }
public void testTokenQueueWithNonNullData() { [EOL] String data = "some data"; [EOL] TokenQueue tokenQueue = new TokenQueue(data); [EOL] assertFalse(tokenQueue.isEmpty()); [EOL] assertEquals(data.length(), tokenQueue.size()); [EOL] } [EOL] public void testTokenQueueWithEmptyString() { [EOL] String data = ""; [EOL] TokenQueue tokenQueue = new TokenQueue(data); [EOL] assertTrue(tokenQueue.isEmpty()); [EOL] } [EOL] public void testTokenQueueWithNullData() { [EOL] try { [EOL] new TokenQueue(null); [EOL] fail("Should throw NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testIsEmptyWhenQueueIsEmpty() { [EOL] PriorityQueue<String> queue = new PriorityQueue<>(); [EOL] assertTrue(queue.isEmpty()); [EOL] }
public void testIsEmptyWhenQueueIsNotEmpty() { [EOL] PriorityQueue<String> queue = new PriorityQueue<>(); [EOL] queue.add("item"); [EOL] assertFalse(queue.isEmpty()); [EOL] }
public void testMatches_SeqLongerThanQueue_ReturnsFalse() { [EOL] TokenQueue tq = new TokenQueue("short"); [EOL] boolean result = tq.matches("toolongstring"); [EOL] assertFalse(result); [EOL] }
public void testMatches_SeqMatchesExactly_ReturnsTrue() { [EOL] TokenQueue tq = new TokenQueue("match"); [EOL] boolean result = tq.matches("match"); [EOL] assertTrue(result); [EOL] }
public void testMatches_SeqWithDifferentCase_ReturnsTrue() { [EOL] TokenQueue tq = new TokenQueue("CaseInsensitive"); [EOL] boolean result = tq.matches("caseinsensitive"); [EOL] assertTrue(result); [EOL] }
public void testMatches_SeqDoesNotMatch_ReturnsFalse() { [EOL] TokenQueue tq = new TokenQueue("nomatch"); [EOL] boolean result = tq.matches("other"); [EOL] assertFalse(result); [EOL] }
public void testMatchesAny_EmptyInput() { [EOL] Element el = new Element(Tag.valueOf("div"), ""); [EOL] assertFalse(el.matchesAny()); [EOL] }
public void testMatchesAny_SingleMatch() { [EOL] Element el = new Element(Tag.valueOf("div"), ""); [EOL] el.addClass("test-class"); [EOL] assertTrue(el.matchesAny(".test-class")); [EOL] }
public void testMatchesAny_MultipleMatches() { [EOL] Element el = new Element(Tag.valueOf("div"), ""); [EOL] el.addClass("test-class"); [EOL] assertTrue(el.matchesAny(".no-class", ".test-class")); [EOL] }
public void testMatchesAny_NoMatch() { [EOL] Element el = new Element(Tag.valueOf("div"), ""); [EOL] assertFalse(el.matchesAny(".no-class")); [EOL] }
public void testMatchChomp_MatchAndConsume() { [EOL] TokenQueue tq = new TokenQueue("SomeString"); [EOL] boolean result = tq.matchChomp("Some"); [EOL] assertTrue(result); [EOL] assertEquals("String", tq.remainder()); [EOL] }
public void testMatchChomp_NoMatch() { [EOL] TokenQueue tq = new TokenQueue("SomeString"); [EOL] boolean result = tq.matchChomp("Other"); [EOL] assertFalse(result); [EOL] assertEquals("SomeString", tq.remainder()); [EOL] }
public void testMatchesWhitespace_EmptyQueue() { [EOL] TokenQueue queue = new TokenQueue(""); [EOL] assertFalse(queue.matchesWhitespace()); [EOL] }
public void testMatchesWhitespace_WithNonWhitespace() { [EOL] TokenQueue queue = new TokenQueue("abc"); [EOL] assertFalse(queue.matchesWhitespace()); [EOL] }
public void testMatchesWhitespace_WithWhitespace() { [EOL] TokenQueue queue = new TokenQueue(" "); [EOL] assertTrue(queue.matchesWhitespace()); [EOL] }
public void testMatchesWord_EmptyQueue() { [EOL] TokenQueue queue = new TokenQueue(""); [EOL] assertFalse(queue.matchesWord()); [EOL] }
public void testMatchesWord_NonEmptyQueueWithLetter() { [EOL] TokenQueue queue = new TokenQueue("a"); [EOL] assertTrue(queue.matchesWord()); [EOL] }
public void testMatchesWord_NonEmptyQueueWithDigit() { [EOL] TokenQueue queue = new TokenQueue("1"); [EOL] assertTrue(queue.matchesWord()); [EOL] }
public void testMatchesWord_NonEmptyQueueWithNonLetterOrDigit() { [EOL] TokenQueue queue = new TokenQueue("!"); [EOL] assertFalse(queue.matchesWord()); [EOL] }
public void testConsume_EmptyQueue() { [EOL] TokenQueue queue = new TokenQueue(""); [EOL] try { [EOL] queue.consume(); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testConsume_NonEmptyQueue() { [EOL] TokenQueue queue = new TokenQueue("abc"); [EOL] char result = queue.consume(); [EOL] assertEquals('a', result); [EOL] }
public void testConsumeMatchingSequence() { [EOL] TokenQueue tq = new TokenQueue("HelloWorld"); [EOL] tq.consume("Hello"); [EOL] assertEquals("World", tq.remainder()); [EOL] }
public void testConsumeWithExceptionOnMismatch() { [EOL] TokenQueue tq = new TokenQueue("HelloWorld"); [EOL] try { [EOL] tq.consume("Goodbye"); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Queue did not match expected sequence", e.getMessage()); [EOL] } [EOL] }
public void testConsumeWithExceptionOnShortQueue() { [EOL] TokenQueue tq = new TokenQueue("Hi"); [EOL] try { [EOL] tq.consume("Hello"); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Queue not long enough to consume sequence", e.getMessage()); [EOL] } [EOL] }
public void testConsumeTo() { [EOL] Parser parser = new Parser(new Lexer("Some sample text")); [EOL] String consumed = parser.consumeTo("sample"); [EOL] assertEquals("Some ", consumed); [EOL] }
public void testConsumeToEmpty() { [EOL] Parser parser = new Parser(new Lexer("")); [EOL] String consumed = parser.consumeTo("sample"); [EOL] assertEquals("", consumed); [EOL] }
public void testConsumeToEnd() { [EOL] Parser parser = new Parser(new Lexer("Some sample text")); [EOL] String consumed = parser.consumeTo("notfound"); [EOL] assertEquals("Some sample text", consumed); [EOL] }
public void testConsumeToAnyWithEmptyQueue() { [EOL] TokenQueue tq = new TokenQueue(""); [EOL] String result = tq.consumeToAny("a", "b"); [EOL] assertEquals("", result); [EOL] }
public void testConsumeToAnyWithNonMatchingSequence() { [EOL] TokenQueue tq = new TokenQueue("Hello World!"); [EOL] String result = tq.consumeToAny("x", "y", "z"); [EOL] assertEquals("Hello World!", result); [EOL] }
public void testConsumeToAnyWithMatchingSequence() { [EOL] TokenQueue tq = new TokenQueue("Hello World!"); [EOL] String result = tq.consumeToAny("W", "H"); [EOL] assertEquals("Hello ", result); [EOL] }
public void testConsumeToAnyWithMultipleMatches() { [EOL] TokenQueue tq = new TokenQueue("Hello World!"); [EOL] String result = tq.consumeToAny("o", "d"); [EOL] assertEquals("Hell", result); [EOL] }
public void testConsumeToAnyWithEmptySequences() { [EOL] TokenQueue tq = new TokenQueue("Hello World!"); [EOL] String result = tq.consumeToAny(); [EOL] assertEquals("Hello World!", result); [EOL] }
public void testChompTo_EmptyString() { [EOL] TokenQueue tq = new TokenQueue(""); [EOL] String result = tq.chompTo("foo"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testChompTo_SeqNotFound() { [EOL] TokenQueue tq = new TokenQueue("bar"); [EOL] String result = tq.chompTo("foo"); [EOL] assertEquals("bar", result); [EOL] } [EOL] public void testChompTo_SeqFound() { [EOL] TokenQueue tq = new TokenQueue("foobar"); [EOL] String result = tq.chompTo("foo"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testChompTo_SeqAtEnd() { [EOL] TokenQueue tq = new TokenQueue("barfoo"); [EOL] String result = tq.chompTo("foo"); [EOL] assertEquals("bar", result); [EOL] } [EOL] public void testChompTo_SeqAtBeginning() { [EOL] TokenQueue tq = new TokenQueue("foobarbaz"); [EOL] String result = tq.chompTo("foo"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testChompTo_SeqInMiddle() { [EOL] TokenQueue tq = new TokenQueue("barfoobaz"); [EOL] String result = tq.chompTo("foo"); [EOL] assertEquals("bar", result); [EOL] }
public void testConsumeWhitespace_EmptyQueue() { [EOL] TokenQueue tq = new TokenQueue(""); [EOL] boolean result = tq.consumeWhitespace(); [EOL] assertFalse(result); [EOL] } [EOL] public void testConsumeWhitespace_OnlyWhitespace() { [EOL] TokenQueue tq = new TokenQueue("   "); [EOL] boolean result = tq.consumeWhitespace(); [EOL] assertTrue(result); [EOL] } [EOL] public void testConsumeWhitespace_WhitespaceAndCharacters() { [EOL] TokenQueue tq = new TokenQueue("   abc"); [EOL] boolean result = tq.consumeWhitespace(); [EOL] assertTrue(result); [EOL] assertEquals("abc", tq.remainder()); [EOL] } [EOL] public void testConsumeWhitespace_NoWhitespace() { [EOL] TokenQueue tq = new TokenQueue("abc"); [EOL] boolean result = tq.consumeWhitespace(); [EOL] assertFalse(result); [EOL] assertEquals("abc", tq.remainder()); [EOL] }
public void testConsumeWord_EmptyQueue() { [EOL] TokenQueue tq = new TokenQueue(""); [EOL] String result = tq.consumeWord(); [EOL] assertEquals("", result); [EOL] }
public void testConsumeWord_OnlyLetters() { [EOL] TokenQueue tq = new TokenQueue("Hello"); [EOL] String result = tq.consumeWord(); [EOL] assertEquals("Hello", result); [EOL] }
public void testConsumeWord_OnlyDigits() { [EOL] TokenQueue tq = new TokenQueue("12345"); [EOL] String result = tq.consumeWord(); [EOL] assertEquals("12345", result); [EOL] }
public void testConsumeWord_LettersAndDigits() { [EOL] TokenQueue tq = new TokenQueue("Hello123"); [EOL] String result = tq.consumeWord(); [EOL] assertEquals("Hello123", result); [EOL] }
public void testConsumeWord_WithNonWordCharacters() { [EOL] TokenQueue tq = new TokenQueue("Hello!123"); [EOL] String result = tq.consumeWord(); [EOL] assertEquals("Hello", result); [EOL] }
public void testConsumeCssIdentifierWithLetters() { [EOL] TokenQueue queue = new TokenQueue("abcDEF"); [EOL] String result = queue.consumeCssIdentifier(); [EOL] assertEquals("abcDEF", result); [EOL] }
public void testConsumeCssIdentifierWithDigits() { [EOL] TokenQueue queue = new TokenQueue("123456"); [EOL] String result = queue.consumeCssIdentifier(); [EOL] assertEquals("123456", result); [EOL] }
public void testConsumeCssIdentifierWithHyphenAndUnderscore() { [EOL] TokenQueue queue = new TokenQueue("-_abc-123_DEF"); [EOL] String result = queue.consumeCssIdentifier(); [EOL] assertEquals("-_abc-123_DEF", result); [EOL] }
public void testConsumeCssIdentifierWithNonIdentifierChars() { [EOL] TokenQueue queue = new TokenQueue("abc123!@#"); [EOL] String result = queue.consumeCssIdentifier(); [EOL] assertEquals("abc123", result); [EOL] }
public void testConsumeCssIdentifierWithEmptyQueue() { [EOL] TokenQueue queue = new TokenQueue(""); [EOL] String result = queue.consumeCssIdentifier(); [EOL] assertEquals("", result); [EOL] }
public void testConsumeAttributeKey_EmptyQueue() { [EOL] TokenQueue queue = new TokenQueue(""); [EOL] String result = queue.consumeAttributeKey(); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testConsumeAttributeKey_LettersDigits() { [EOL] TokenQueue queue = new TokenQueue("abc123"); [EOL] String result = queue.consumeAttributeKey(); [EOL] assertEquals("abc123", result); [EOL] } [EOL] public void testConsumeAttributeKey_SpecialCharacters() { [EOL] TokenQueue queue = new TokenQueue("abc-123_def:"); [EOL] String result = queue.consumeAttributeKey(); [EOL] assertEquals("abc-123_def:", result); [EOL] } [EOL] public void testConsumeAttributeKey_StopAtNonKeyChar() { [EOL] TokenQueue queue = new TokenQueue("abc123!@#"); [EOL] String result = queue.consumeAttributeKey(); [EOL] assertEquals("abc123", result); [EOL] } [EOL] public void testConsumeAttributeKey_QueueWithSpaces() { [EOL] TokenQueue queue = new TokenQueue("abc 123"); [EOL] String result = queue.consumeAttributeKey(); [EOL] assertEquals("abc", result); [EOL] }
public void testCollectWithValidEvaluatorAndRoot() { [EOL] Evaluator eval = new Evaluator.Tag("div"); [EOL] Element root = Jsoup.parse("<div><p></p></div>").selectFirst("div"); [EOL] Elements result = Collector.collect(eval, root); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("div", result.first().tagName()); [EOL] }
public void testCollectWithNullEvaluator() { [EOL] Element root = Jsoup.parse("<div><p></p></div>").selectFirst("div"); [EOL] try { [EOL] Collector.collect(null, root); [EOL] fail("Should throw IllegalArgumentException for null Evaluator"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCollectWithNullRoot() { [EOL] Evaluator eval = new Evaluator.Tag("div"); [EOL] try { [EOL] Collector.collect(eval, null); [EOL] fail("Should throw IllegalArgumentException for null root Element"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAccumulateMatchesWithMatchingElement() { [EOL] Evaluator eval = new Evaluator() { [EOL] public boolean matches(Element element) { [EOL] return true; [EOL] } [EOL] }; [EOL] List<Element> elements = new ArrayList<>(); [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] accumulateMatches(eval, elements, element); [EOL] assertTrue(elements.contains(element)); [EOL] }
public void testAccumulateMatchesWithNonMatchingElement() { [EOL] Evaluator eval = new Evaluator() { [EOL] public boolean matches(Element element) { [EOL] return false; [EOL] } [EOL] }; [EOL] List<Element> elements = new ArrayList<>(); [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] accumulateMatches(eval, elements, element); [EOL] assertFalse(elements.contains(element)); [EOL] }
public void testAccumulateMatchesWithChildElements() { [EOL] Evaluator eval = new Evaluator() { [EOL] public boolean matches(Element element) { [EOL] return "child".equals(element.tagName()); [EOL] } [EOL] }; [EOL] List<Element> elements = new ArrayList<>(); [EOL] Element parent = new Element(Tag.valueOf("div"), ""); [EOL] Element child1 = new Element(Tag.valueOf("child"), ""); [EOL] Element child2 = new Element(Tag.valueOf("child"), ""); [EOL] parent.appendChild(child1); [EOL] parent.appendChild(child2); [EOL] accumulateMatches(eval, elements, parent); [EOL] assertTrue(elements.contains(child1)); [EOL] assertTrue(elements.contains(child2)); [EOL] assertFalse(elements.contains(parent)); [EOL] }
public void testNormaliseWithNonBlankTextNode() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] TextNode nonBlankTextNode = new TextNode("non-blank", ""); [EOL] element.appendChild(nonBlankTextNode); [EOL] normalise(element); [EOL] assertFalse(element.childNodes().contains(nonBlankTextNode)); [EOL] assertTrue(body().childNodes().contains(nonBlankTextNode)); [EOL] }
public void testNormaliseWithBlankTextNode() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] TextNode blankTextNode = new TextNode(" ", ""); [EOL] element.appendChild(blankTextNode); [EOL] normalise(element); [EOL] assertTrue(element.childNodes().contains(blankTextNode)); [EOL] assertFalse(body().childNodes().contains(blankTextNode)); [EOL] }
public void testNormaliseWithNoTextNodes() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] normalise(element); [EOL] assertTrue(element.childNodes().isEmpty()); [EOL] assertTrue(body().childNodes().isEmpty()); [EOL] }
public void testSetTextOnElement() { [EOL] Document doc = Jsoup.parse("<div></div>"); [EOL] Element div = doc.select("div").first(); [EOL] div.text("some text"); [EOL] assertEquals("some text", div.text()); [EOL] }
public void testSetTextOnElementWithExistingText() { [EOL] Document doc = Jsoup.parse("<div>Initial text</div>"); [EOL] Element div = doc.select("div").first(); [EOL] div.text("new text"); [EOL] assertEquals("new text", div.text()); [EOL] }
public void testSetTextOnEmptyElement() { [EOL] Document doc = Jsoup.parse("<div></div>"); [EOL] Element div = doc.select("div").first(); [EOL] div.text(""); [EOL] assertEquals("", div.text()); [EOL] }
private Elements select() { [EOL] tq.consumeWhitespace(); [EOL] if (tq.matchesAny(combinators)) { [EOL] elements.add(root); [EOL] combinator(tq.consume().toString()); [EOL] } else { [EOL] addElements(findElements()); [EOL] } [EOL] while (!tq.isEmpty()) { [EOL] boolean seenWhite = tq.consumeWhitespace(); [EOL] if (tq.matchChomp(",")) { [EOL] while (!tq.isEmpty()) { [EOL] String subQuery = tq.chompTo(","); [EOL] elements.addAll(select(subQuery, root)); [EOL] } [EOL] } else if (tq.matchesAny(combinators)) { [EOL] combinator(tq.consume().toString()); [EOL] } else if (seenWhite) { [EOL] combinator(" "); [EOL] } else { [EOL] Elements candidates = findElements(); [EOL] intersectElements(filterForSelf(elements, candidates)); [EOL] } [EOL] } [EOL] return new Elements(elements); [EOL] } [EOL] private Selector(String query, Element root); [EOL] public SelectorParseException(String s); [EOL] public static Elements select(String query, Element root); [EOL] public static Elements select(String query, Iterable<Element> roots); [EOL] private Elements select(); [EOL] private void combinator(String combinator); [EOL] private Elements findElements(); [EOL] private void addElements(Collection<Element> add); [EOL] private void intersectElements(Collection<Element> intersect); [EOL] private Elements byId(); [EOL] private Elements byClass(); [EOL] private Elements byTag(); [EOL] private Elements byAttribute(); [EOL] private Elements allElements(); [EOL] private Elements indexLessThan(); [EOL] private Elements indexGreaterThan(); [EOL] private Elements indexEquals(); [EOL] private int consumeIndex(); [EOL] private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); [EOL] private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); [EOL] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); [EOL] private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); [EOL] private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); [EOL] String[] combinators=Optional[{ ",", ">", "+", "~", " " }];
public void testCombinatorChild() { [EOL] Element root = new Element(Tag.valueOf("div"), ""); [EOL] Element child = new Element(Tag.valueOf("span"), ""); [EOL] root.appendChild(child); [EOL] Selector selector = new Selector("div > span", root); [EOL] Elements result = selector.select(); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains(child)); [EOL] }
public void testCombinatorDescendant() { [EOL] Element root = new Element(Tag.valueOf("div"), ""); [EOL] Element descendant = new Element(Tag.valueOf("span"), ""); [EOL] root.appendChild(new Element(Tag.valueOf("section"), "")).appendChild(descendant); [EOL] Selector selector = new Selector("div span", root); [EOL] Elements result = selector.select(); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains(descendant)); [EOL] }
public void testCombinatorAdjacentSibling() { [EOL] Element root = new Element(Tag.valueOf("div"), ""); [EOL] Element firstChild = new Element(Tag.valueOf("p"), ""); [EOL] Element adjacentSibling = new Element(Tag.valueOf("span"), ""); [EOL] root.appendChild(firstChild); [EOL] root.appendChild(adjacentSibling); [EOL] Selector selector = new Selector("p + span", root); [EOL] Elements result = selector.select(); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains(adjacentSibling)); [EOL] }
public void testCombinatorGeneralSibling() { [EOL] Element root = new Element(Tag.valueOf("div"), ""); [EOL] Element firstChild = new Element(Tag.valueOf("p"), ""); [EOL] Element generalSibling = new Element(Tag.valueOf("span"), ""); [EOL] root.appendChild(firstChild); [EOL] root.appendChild(new Element(Tag.valueOf("section"), "")); [EOL] root.appendChild(generalSibling); [EOL] Selector selector = new Selector("p ~ span", root); [EOL] Elements result = selector.select(); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains(generalSibling)); [EOL] }
public void testCombinatorInvalid() { [EOL] Element root = new Element(Tag.valueOf("div"), ""); [EOL] try { [EOL] Selector selector = new Selector("div , span", root); [EOL] selector.select(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Unknown combinator: ,", e.getMessage()); [EOL] } [EOL] }
public void testFindElementsById() { [EOL] Selector selector = new Selector("#someId", null); [EOL] Elements result = selector.findElements(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals("Expected ID", "someId", result.first().id()); [EOL] }
public void testFindElementsByClass() { [EOL] Selector selector = new Selector(".someClass", null); [EOL] Elements result = selector.findElements(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertTrue("Expected class", result.hasClass("someClass")); [EOL] }
public void testFindElementsByTagName() { [EOL] Selector selector = new Selector("div", null); [EOL] Elements result = selector.findElements(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals("Expected tag", "div", result.first().tagName()); [EOL] }
public void testFindElementsByAttribute() { [EOL] Selector selector = new Selector("[href]", null); [EOL] Elements result = selector.findElements(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertTrue("Expected attribute", result.hasAttr("href")); [EOL] }
public void testFindAllElements() { [EOL] Selector selector = new Selector("*", null); [EOL] Elements result = selector.findElements(); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindElementsByIndexLessThan() { [EOL] Selector selector = new Selector(":lt(3)", null); [EOL] Elements result = selector.findElements(); [EOL] assertNotNull(result); [EOL] assertTrue("Expected size less than 3", result.size() < 3); [EOL] }
public void testFindElementsByIndexGreaterThan() { [EOL] Selector selector = new Selector(":gt(1)", null); [EOL] Elements result = selector.findElements(); [EOL] assertNotNull(result); [EOL] assertTrue("Expected size greater than 1", result.size() > 1); [EOL] }
public void testFindElementsByIndexEquals() { [EOL] Selector selector = new Selector(":eq(0)", null); [EOL] Elements result = selector.findElements(); [EOL] assertNotNull(result); [EOL] assertEquals("Expected size 1", 1, result.size()); [EOL] }
public void testFindElementsParseException() { [EOL] Selector selector = new Selector("invalid", null); [EOL] try { [EOL] selector.findElements(); [EOL] fail("SelectorParseException expected"); [EOL] } catch (SelectorParseException e) { [EOL] assertEquals("Could not parse query invalid", e.getMessage()); [EOL] } [EOL] }
private Elements indexEquals() { [EOL] return root.getElementsByIndexEquals(consumeIndex()); [EOL] }
public void testFilterForGeneralSiblings_BothEmpty() { [EOL] Collection<Element> elements = new ArrayList<>(); [EOL] Collection<Element> candidates = new ArrayList<>(); [EOL] Elements result = Jsoup.filterForGeneralSiblings(elements, candidates); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFilterForGeneralSiblings_NoGeneralSiblings() { [EOL] Document doc = Jsoup.parse("<div><p></p><span></span></div>"); [EOL] Collection<Element> elements = new ArrayList<>(); [EOL] elements.add(doc.select("p").first()); [EOL] Collection<Element> candidates = new ArrayList<>(); [EOL] candidates.add(doc.select("span").first()); [EOL] Elements result = Jsoup.filterForGeneralSiblings(elements, candidates); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFilterForGeneralSiblings_WithGeneralSiblings() { [EOL] Document doc = Jsoup.parse("<div><p></p><span></span><em></em></div>"); [EOL] Collection<Element> elements = new ArrayList<>(); [EOL] elements.add(doc.select("p").first()); [EOL] Collection<Element> candidates = new ArrayList<>(); [EOL] candidates.add(doc.select("span").first()); [EOL] candidates.add(doc.select("em").first()); [EOL] Elements result = Jsoup.filterForGeneralSiblings(elements, candidates); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains(doc.select("span").first())); [EOL] assertTrue(result.contains(doc.select("em").first())); [EOL] }
public void testFilterForGeneralSiblings_WithNonGeneralSiblings() { [EOL] Document doc = Jsoup.parse("<div><p></p></div><div><span></span></div>"); [EOL] Collection<Element> elements = new ArrayList<>(); [EOL] elements.add(doc.select("p").first()); [EOL] Collection<Element> candidates = new ArrayList<>(); [EOL] candidates.add(doc.select("span").first()); [EOL] Elements result = Jsoup.filterForGeneralSiblings(elements, candidates); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFilterForGeneralSiblings_SameElement() { [EOL] Document doc = Jsoup.parse("<div><p></p><p></p></div>"); [EOL] Collection<Element> elements = new ArrayList<>(); [EOL] Element p = doc.select("p").first(); [EOL] elements.add(p); [EOL] Collection<Element> candidates = new ArrayList<>(); [EOL] candidates.add(p); [EOL] Elements result = Jsoup.filterForGeneralSiblings(elements, candidates); [EOL] assertFalse(result.contains(p)); [EOL] }
public void testOuterHtmlWithElementParent() { [EOL] Element parent = new Element(Tag.valueOf("div"), ""); [EOL] TextNode textNode = new TextNode("Some text", ""); [EOL] parent.appendChild(textNode); [EOL] StringBuilder accum = new StringBuilder(); [EOL] textNode.outerHtml(accum); [EOL] String expected = "Some text"; [EOL] assertEquals(expected, accum.toString()); [EOL] }
public void testOuterHtmlWithNonElementParent() { [EOL] Document doc = new Document(""); [EOL] TextNode textNode = new TextNode("Some text", ""); [EOL] doc.appendChild(textNode); [EOL] StringBuilder accum = new StringBuilder(); [EOL] textNode.outerHtml(accum); [EOL] String expected = "Some text"; [EOL] assertEquals(expected, accum.toString()); [EOL] }
public void testOuterHtmlWithPreserveWhitespace() { [EOL] Element parent = new Element(Tag.valueOf("pre"), ""); [EOL] TextNode textNode = new TextNode(" Some   text ", ""); [EOL] parent.appendChild(textNode); [EOL] StringBuilder accum = new StringBuilder(); [EOL] textNode.outerHtml(accum); [EOL] String expected = " Some   text "; [EOL] assertEquals(expected, accum.toString()); [EOL] }
public void testOuterHtmlWithSiblingAndBlockParent() { [EOL] Element parent = new Element(Tag.valueOf("div"), ""); [EOL] parent.tag().setCanContainBlock(true); [EOL] TextNode textNode = new TextNode("Some text", ""); [EOL] parent.appendChild(textNode); [EOL] StringBuilder accum = new StringBuilder(); [EOL] textNode.outerHtml(accum); [EOL] String expected = "    Some text"; // Assuming default indent is 4 spaces [EOL] assertEquals(expected, accum.toString()); [EOL] }
public void testStripLeadingWhitespace_NullInput() { [EOL] try { [EOL] String result = stripLeadingWhitespace(null); [EOL] assertNull("Result should be null for null input", result); [EOL] } catch (Exception e) { [EOL] fail("Method should handle null input without throwing exception"); [EOL] } [EOL] }
public void testStripLeadingWhitespace_EmptyString() { [EOL] String input = ""; [EOL] String result = stripLeadingWhitespace(input); [EOL] assertEquals("Result should be an empty string for empty input", "", result); [EOL] }
public void testStripLeadingWhitespace_NoLeadingWhitespace() { [EOL] String input = "textWithNoLeadingWhitespace"; [EOL] String result = stripLeadingWhitespace(input); [EOL] assertEquals("Result should be unchanged when there is no leading whitespace", input, result); [EOL] }
public void testStripLeadingWhitespace_LeadingSpaces() { [EOL] String input = "    textWithLeadingSpaces"; [EOL] String expected = "textWithLeadingSpaces"; [EOL] String result = stripLeadingWhitespace(input); [EOL] assertEquals("Result should have leading spaces removed", expected, result); [EOL] }
public void testStripLeadingWhitespace_LeadingTabs() { [EOL] String input = "\t\ttextWithLeadingTabs"; [EOL] String expected = "textWithLeadingTabs"; [EOL] String result = stripLeadingWhitespace(input); [EOL] assertEquals("Result should have leading tabs removed", expected, result); [EOL] }
public void testStripLeadingWhitespace_LeadingNewLines() { [EOL] String input = "\n\ntextWithLeadingNewLines"; [EOL] String expected = "textWithLeadingNewLines"; [EOL] String result = stripLeadingWhitespace(input); [EOL] assertEquals("Result should have leading new lines removed", expected, result); [EOL] }
public void testStripLeadingWhitespace_LeadingMixedWhitespace() { [EOL] String input = " \t\n  textWithMixedLeadingWhitespace"; [EOL] String expected = "textWithMixedLeadingWhitespace"; [EOL] String result = stripLeadingWhitespace(input); [EOL] assertEquals("Result should have all types of leading whitespace removed", expected, result); [EOL] }
public void testLastCharIsWhitespace_EmptyStringBuilder() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] boolean result = lastCharIsWhitespace(sb); [EOL] assertFalse(result); [EOL] } [EOL] public void testLastCharIsWhitespace_WithNonWhitespaceChar() { [EOL] StringBuilder sb = new StringBuilder("Test"); [EOL] boolean result = lastCharIsWhitespace(sb); [EOL] assertFalse(result); [EOL] } [EOL] public void testLastCharIsWhitespace_WithWhitespaceChar() { [EOL] StringBuilder sb = new StringBuilder("Test "); [EOL] boolean result = lastCharIsWhitespace(sb); [EOL] assertTrue(result); [EOL] } [EOL] public void testLastCharIsWhitespace_WithMultipleWhitespaceChars() { [EOL] StringBuilder sb = new StringBuilder("Test   "); [EOL] boolean result = lastCharIsWhitespace(sb); [EOL] assertTrue(result); [EOL] } [EOL] public void testLastCharIsWhitespace_WithNewLineChar() { [EOL] StringBuilder sb = new StringBuilder("Test\n"); [EOL] boolean result = lastCharIsWhitespace(sb); [EOL] assertFalse(result); [EOL] }
public void testIdWithExistingId() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.attr("id", "testId"); [EOL] String result = element.id(); [EOL] assertNotEquals("", result); [EOL] assertEquals("testId", result); [EOL] } [EOL] public void testIdWithNoId() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] String result = element.id(); [EOL] assertNotNull(result); [EOL] assertEquals("", result); [EOL] }
public void testGetElementById_WithExistingId() { [EOL] Element root = Jsoup.parse("<div><p id='test'>Hello</p></div>"); [EOL] Element result = root.getElementById("test"); [EOL] assertNotNull(result); [EOL] assertEquals("p", result.tagName()); [EOL] assertEquals("Hello", result.text()); [EOL] }
public void testGetElementById_WithNonExistingId() { [EOL] Element root = Jsoup.parse("<div><p id='test'>Hello</p></div>"); [EOL] Element result = root.getElementById("not_exist"); [EOL] assertNull(result); [EOL] }
public void testGetElementById_WithEmptyId() { [EOL] Element root = Jsoup.parse("<div><p id=''>Hello</p></div>"); [EOL] try { [EOL] root.getElementById(""); [EOL] fail("Should throw IllegalArgumentException for empty id"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetElementsByAttribute_withNonEmptyKey() { [EOL] Document doc = Jsoup.parse("<div id='1' custom='value'></div>"); [EOL] Elements elements = doc.getElementsByAttribute("custom"); [EOL] assertEquals(1, elements.size()); [EOL] assertEquals("value", elements.get(0).attr("custom")); [EOL] }
public void testGetElementsByAttribute_withEmptyKey() { [EOL] Document doc = Jsoup.parse("<div id='1' custom='value'></div>"); [EOL] try { [EOL] doc.getElementsByAttribute(""); [EOL] fail("Should throw IllegalArgumentException for empty key"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetElementsByAttribute_withWhitespaceKey() { [EOL] Document doc = Jsoup.parse("<div id='1' custom='value'></div>"); [EOL] Elements elements = doc.getElementsByAttribute(" custom "); [EOL] assertEquals(1, elements.size()); [EOL] assertEquals("value", elements.get(0).attr("custom")); [EOL] }
public void testGetElementsByAttributeValueContaining_EmptyDocument() { [EOL] Document doc = Jsoup.parse(""); [EOL] Elements elements = doc.getElementsByAttributeValueContaining("key", "match"); [EOL] assertTrue(elements.isEmpty()); [EOL] }
public void testGetElementsByAttributeValueContaining_NoMatching() { [EOL] Document doc = Jsoup.parse("<div id='1' class='no-match'></div>"); [EOL] Elements elements = doc.getElementsByAttributeValueContaining("key", "match"); [EOL] assertTrue(elements.isEmpty()); [EOL] }
public void testGetElementsByAttributeValueContaining_SingleMatch() { [EOL] Document doc = Jsoup.parse("<div id='1' key='prefixmatchsuffix'></div>"); [EOL] Elements elements = doc.getElementsByAttributeValueContaining("key", "match"); [EOL] assertEquals(1, elements.size()); [EOL] assertEquals("div", elements.first().tagName()); [EOL] }
public void testGetElementsByAttributeValueContaining_MultipleMatches() { [EOL] Document doc = Jsoup.parse("<div key='match'></div><p key='nomatch'></p><span key='anothermatch'></span>"); [EOL] Elements elements = doc.getElementsByAttributeValueContaining("key", "match"); [EOL] assertEquals(2, elements.size()); [EOL] }
public void testGetElementsByAttributeValueContaining_CaseInsensitive() { [EOL] Document doc = Jsoup.parse("<div key='Match'></div><div key='MATCH'></div><div key='match'></div>"); [EOL] Elements elements = doc.getElementsByAttributeValueContaining("key", "match"); [EOL] assertEquals(3, elements.size()); [EOL] }
public void testGetElementsByIndexEquals_ValidIndex() { [EOL] Document doc = Jsoup.parse("<div><p>First</p><p>Second</p><div>Third</div></div>"); [EOL] Elements elements = doc.getElementsByIndexEquals(1); [EOL] assertEquals(2, elements.size()); [EOL] assertEquals("First", elements.get(0).text()); [EOL] assertEquals("Second", elements.get(1).text()); [EOL] }
public void testGetElementsByIndexEquals_InvalidIndex() { [EOL] Document doc = Jsoup.parse("<div><p>First</p><p>Second</p><div>Third</div></div>"); [EOL] Elements elements = doc.getElementsByIndexEquals(3); [EOL] assertTrue(elements.isEmpty()); [EOL] }
public void testGetElementsByIndexEquals_NegativeIndex() { [EOL] Document doc = Jsoup.parse("<div><p>First</p><p>Second</p><div>Third</div></div>"); [EOL] Elements elements = doc.getElementsByIndexEquals(-1); [EOL] assertTrue(elements.isEmpty()); [EOL] }
public void testTextNodeInsideElement() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] TextNode textNode = new TextNode("Sample text", ""); [EOL] element.appendChild(textNode); [EOL] StringBuilder accum = new StringBuilder(); [EOL] element.text(accum); [EOL] assertEquals("Sample text", accum.toString()); [EOL] }
public void testElementWithWhitespaceNormalization() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] TextNode textNode = new TextNode("  Sample   text  ", ""); [EOL] element.appendChild(textNode); [EOL] StringBuilder accum = new StringBuilder(); [EOL] element.text(accum); [EOL] assertEquals("Sample text", accum.toString()); [EOL] }
public void testElementWithBlockChild() { [EOL] Element parent = new Element(Tag.valueOf("div"), ""); [EOL] Element child = new Element(Tag.valueOf("p"), ""); [EOL] TextNode textNode = new TextNode("Child text", ""); [EOL] child.appendChild(textNode); [EOL] parent.appendChild(child); [EOL] StringBuilder accum = new StringBuilder(); [EOL] parent.text(accum); [EOL] assertEquals(" Child text", accum.toString()); [EOL] }
public void testElementWithInlineChild() { [EOL] Element parent = new Element(Tag.valueOf("span"), ""); [EOL] Element child = new Element(Tag.valueOf("em"), ""); [EOL] TextNode textNode = new TextNode("Child text", ""); [EOL] child.appendChild(textNode); [EOL] parent.appendChild(child); [EOL] StringBuilder accum = new StringBuilder(); [EOL] parent.text(accum); [EOL] assertEquals("Child text", accum.toString()); [EOL] }
public void testElementWithMultipleChildren() { [EOL] Element parent = new Element(Tag.valueOf("div"), ""); [EOL] TextNode textNode1 = new TextNode("First ", ""); [EOL] Element child = new Element(Tag.valueOf("p"), ""); [EOL] TextNode textNode2 = new TextNode("Second", ""); [EOL] child.appendChild(textNode2); [EOL] parent.appendChild(textNode1); [EOL] parent.appendChild(child); [EOL] StringBuilder accum = new StringBuilder(); [EOL] parent.text(accum); [EOL] assertEquals("First Second", accum.toString()); [EOL] }
public void testHasText_withTextNodeHavingText() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.appendChild(new TextNode("Some text", "")); [EOL] boolean hasText = element.hasText(); [EOL] assertTrue(hasText); [EOL] }
public void testHasText_withTextNodeBeingBlank() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] element.appendChild(new TextNode(" ", "")); [EOL] boolean hasText = element.hasText(); [EOL] assertFalse(hasText); [EOL] }
public void testHasText_withNestedElementHavingText() { [EOL] Element parentElement = new Element(Tag.valueOf("div"), ""); [EOL] Element childElement = new Element(Tag.valueOf("p"), ""); [EOL] childElement.appendChild(new TextNode("Some text", "")); [EOL] parentElement.appendChild(childElement); [EOL] boolean hasText = parentElement.hasText(); [EOL] assertTrue(hasText); [EOL] }
public void testHasText_withNestedElementBeingBlank() { [EOL] Element parentElement = new Element(Tag.valueOf("div"), ""); [EOL] Element childElement = new Element(Tag.valueOf("p"), ""); [EOL] childElement.appendChild(new TextNode(" ", "")); [EOL] parentElement.appendChild(childElement); [EOL] boolean hasText = parentElement.hasText(); [EOL] assertFalse(hasText); [EOL] }
public void testHasText_withNoChildren() { [EOL] Element element = new Element(Tag.valueOf("div"), ""); [EOL] boolean hasText = element.hasText(); [EOL] assertFalse(hasText); [EOL] }
public void testParserWithNonNullHtmlAndBaseUriAsBodyFragment() { [EOL] String html = "<div>Hello</div>"; [EOL] String baseUri = "http://example.com"; [EOL] boolean isBodyFragment = true; [EOL] Parser parser = new Parser(html, baseUri, isBodyFragment); [EOL] assertNotNull(parser.getDocument()); [EOL] assertTrue(parser.getDocument().body() != null); [EOL] assertEquals(baseUri, parser.getDocument().baseUri()); [EOL] }
public void testParserWithNonNullHtmlAndBaseUriNotAsBodyFragment() { [EOL] String html = "<html><head></head><body>Hello</body></html>"; [EOL] String baseUri = "http://example.com"; [EOL] boolean isBodyFragment = false; [EOL] Parser parser = new Parser(html, baseUri, isBodyFragment); [EOL] assertNotNull(parser.getDocument()); [EOL] assertTrue(parser.getDocument().body() == null); [EOL] assertEquals(baseUri, parser.getDocument().baseUri()); [EOL] }
public void testParseBodyFragmentWithEmptyString() { [EOL] Document doc = Jsoup.parseBodyFragment("", "http://example.com"); [EOL] assertNotNull(doc); [EOL] assertEquals("http://example.com", doc.baseUri()); [EOL] assertEquals(0, doc.body().childNodeSize()); [EOL] }
public void testParseBodyFragmentWithValidHtml() { [EOL] String html = "<div><p>Hello</p></div>"; [EOL] Document doc = Jsoup.parseBodyFragment(html, "http://example.com"); [EOL] assertNotNull(doc); [EOL] assertEquals("http://example.com", doc.baseUri()); [EOL] assertEquals("Hello", doc.select("p").first().text()); [EOL] }
public void testParseBodyFragmentWithNullBaseUri() { [EOL] String html = "<div><p>Hello</p></div>"; [EOL] Document doc = Jsoup.parseBodyFragment(html, null); [EOL] assertNotNull(doc); [EOL] assertEquals("", doc.baseUri()); // Assuming Jsoup handles null baseUri by setting it to empty string [EOL] assertEquals("Hello", doc.select("p").first().text()); [EOL] }
public void testParseWithComment() { [EOL] TokenQueue tq = new TokenQueue("<!-- Comment -->"); [EOL] Parser parser = new Parser(tq); [EOL] Document doc = parser.parse(); [EOL] }
public void testParseWithCdata() { [EOL] TokenQueue tq = new TokenQueue("<![CDATA[data]]>"); [EOL] Parser parser = new Parser(tq); [EOL] Document doc = parser.parse(); [EOL] }
public void testParseWithXmlDecl() { [EOL] TokenQueue tq = new TokenQueue("<?xml version=\"1.0\"?>"); [EOL] Parser parser = new Parser(tq); [EOL] Document doc = parser.parse(); [EOL] }
public void testParseWithDocType() { [EOL] TokenQueue tq = new TokenQueue("<!DOCTYPE html>"); [EOL] Parser parser = new Parser(tq); [EOL] Document doc = parser.parse(); [EOL] }
public void testParseWithEndTag() { [EOL] TokenQueue tq = new TokenQueue("</tag>"); [EOL] Parser parser = new Parser(tq); [EOL] Document doc = parser.parse(); [EOL] }
public void testParseWithStartTag() { [EOL] TokenQueue tq = new TokenQueue("<tag>"); [EOL] Parser parser = new Parser(tq); [EOL] Document doc = parser.parse(); [EOL] }
public void testParseWithTextNode() { [EOL] TokenQueue tq = new TokenQueue("Some text node"); [EOL] Parser parser = new Parser(tq); [EOL] Document doc = parser.parse(); [EOL] }
public void testParseXmlDeclWithProcessingInstruction() { [EOL] TokenQueue tq = new TokenQueue("<!xml version=\"1.0\">"); [EOL] Node node = new Node("baseUri"); [EOL] YourClass yourClassInstance = new YourClass(tq, node); [EOL] yourClassInstance.parseXmlDecl(); [EOL] assertTrue(node.childNode(0) instanceof XmlDeclaration); [EOL] XmlDeclaration decl = (XmlDeclaration) node.childNode(0); [EOL] assertTrue(decl.isProcessingInstruction()); [EOL] assertEquals("xml version=\"1.0\"", decl.getData()); [EOL] }
public void testParseXmlDeclWithoutProcessingInstruction() { [EOL] TokenQueue tq = new TokenQueue("<xml version=\"1.0\">"); [EOL] Node node = new Node("baseUri"); [EOL] YourClass yourClassInstance = new YourClass(tq, node); [EOL] yourClassInstance.parseXmlDecl(); [EOL] assertTrue(node.childNode(0) instanceof XmlDeclaration); [EOL] XmlDeclaration decl = (XmlDeclaration) node.childNode(0); [EOL] assertFalse(decl.isProcessingInstruction()); [EOL] assertEquals("xml version=\"1.0\"", decl.getData()); [EOL] }
public void put_NewAttribute_ShouldAddAttribute() { [EOL] Attributes attributes = new Attributes(); [EOL] attributes.put("key", "value"); [EOL] Attribute attr = attributes.get("key"); [EOL] assertNotNull(attr); [EOL] assertEquals("key", attr.getKey()); [EOL] assertEquals("value", attr.getValue()); [EOL] }
public void put_ExistingAttribute_ShouldUpdateValue() { [EOL] Attributes attributes = new Attributes(); [EOL] attributes.put("key", "value1"); [EOL] attributes.put("key", "value2"); [EOL] Attribute attr = attributes.get("key"); [EOL] assertNotNull(attr); [EOL] assertEquals("key", attr.getKey()); [EOL] assertEquals("value2", attr.getValue()); [EOL] }
public void put_NullKey_ShouldNotAddAttribute() { [EOL] Attributes attributes = new Attributes(); [EOL] attributes.put(null, "value"); [EOL] Attribute attr = attributes.get(null); [EOL] assertNull(attr); [EOL] }
public void testParseWithValidHtmlAndBaseUri() { [EOL] String html = "<html><head><title>First parse</title></head>" + [EOL] "<body><p>Parsed HTML into a doc.</p></body></html>"; [EOL] String baseUri = "http://example.com"; [EOL] Document doc = Jsoup.parse(html, baseUri); [EOL] assertNotNull(doc); [EOL] assertEquals("First parse", doc.title()); [EOL] assertEquals(baseUri, doc.baseUri()); [EOL] }
public void testParseWithEmptyString() { [EOL] String html = ""; [EOL] String baseUri = "http://example.com"; [EOL] Document doc = Jsoup.parse(html, baseUri); [EOL] assertNotNull(doc); [EOL] assertEquals("", doc.title()); [EOL] assertEquals(baseUri, doc.baseUri()); [EOL] }
public void testParseWithNullBaseUri() { [EOL] String html = "<html><head><title>Test</title></head><body></body></html>"; [EOL] Document doc = Jsoup.parse(html, null); [EOL] assertNotNull(doc); [EOL] assertEquals("Test", doc.title()); [EOL] assertEquals("", doc.baseUri()); [EOL] }
public void testParseFileWithValidInput() throws IOException { [EOL] File input = new File("path/to/validHtmlFile.html"); [EOL] String charsetName = "UTF-8"; [EOL] String baseUri = "http://example.com"; [EOL] Document doc = Jsoup.parse(input, charsetName, baseUri); [EOL] assertNotNull(doc); [EOL] assertEquals(baseUri, doc.baseUri()); [EOL] }
public void testParseFileWithIOException() { [EOL] File input = new File("path/to/nonExistentFile.html"); [EOL] String charsetName = "UTF-8"; [EOL] String baseUri = "http://example.com"; [EOL] try { [EOL] Jsoup.parse(input, charsetName, baseUri); [EOL] fail("Expected IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testParseFileWithUnsupportedCharset() { [EOL] File input = new File("path/to/validHtmlFile.html"); [EOL] String charsetName = "UNSUPPORTED_CHARSET"; [EOL] String baseUri = "http://example.com"; [EOL] try { [EOL] Jsoup.parse(input, charsetName, baseUri); [EOL] fail("Expected IOException to be thrown due to unsupported charset"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testParseFileWithValidCharset() throws IOException { [EOL] File input = createTestFile("utf-8", "<html><head><title>Test</title></head><body></body></html>"); [EOL] Document doc = Jsoup.parse(input, "utf-8"); [EOL] assertEquals("Test", doc.title()); [EOL] }
public void testParseFileWithInvalidCharset() { [EOL] File input = createTestFile("utf-8", "<html><head><title>Test</title></head><body></body></html>"); [EOL] try { [EOL] Document doc = Jsoup.parse(input, "invalid-charset"); [EOL] fail("Should have thrown IOException due to invalid charset"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testParseFileWithNullCharset() throws IOException { [EOL] File input = createTestFile("utf-8", "<html><head><title>Test</title></head><body></body></html>"); [EOL] Document doc = Jsoup.parse(input, null); [EOL] assertEquals("Test", doc.title()); [EOL] }
public void testParseBodyFragmentWithEmptyString() { [EOL] Document doc = Jsoup.parseBodyFragment(""); [EOL] assertNotNull(doc); [EOL] assertEquals("", doc.body().html()); [EOL] }
public void testParseBodyFragmentWithValidHtml() { [EOL] String html = "<div><p>Hello World</p></div>"; [EOL] Document doc = Jsoup.parseBodyFragment(html); [EOL] assertNotNull(doc); [EOL] assertEquals("<div><p>Hello World</p></div>", doc.body().html()); [EOL] }
public void testParseBodyFragmentWithNull() { [EOL] try { [EOL] Document doc = Jsoup.parseBodyFragment(null); [EOL] fail("Should throw IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCanContain_BlockElementCannotContainBlock() { [EOL] Tag parent = new Tag("div"); [EOL] parent.canContainBlock = false; [EOL] Tag child = new Tag("p"); [EOL] child.isBlock = true; [EOL] assertFalse(parent.canContain(child)); [EOL] }
public void testCanContain_InlineElementCannotContainInline() { [EOL] Tag parent = new Tag("span"); [EOL] parent.canContainInline = false; [EOL] Tag child = new Tag("a"); [EOL] child.isBlock = false; [EOL] assertFalse(parent.canContain(child)); [EOL] }
public void testCanContain_OptionalClosingTagCannotContainItself() { [EOL] Tag parent = new Tag("li"); [EOL] parent.optionalClosing = true; [EOL] Tag child = new Tag("li"); [EOL] assertTrue(parent.equals(child)); [EOL] assertFalse(parent.canContain(child)); [EOL] }
public void testCanContain_EmptyTagCannotContainAnyChild() { [EOL] Tag parent = new Tag("input"); [EOL] parent.empty = true; [EOL] Tag child = new Tag("label"); [EOL] assertFalse(parent.canContain(child)); [EOL] }
public void testCanContain_DataTagCannotContainAnyChild() { [EOL] Tag parent = new Tag("script"); [EOL] parent.setIsData(true); [EOL] Tag child = new Tag("div"); [EOL] assertFalse(parent.canContain(child)); [EOL] }
public void testCanContain_HeadTagCanContainValidChild() { [EOL] Tag parent = new Tag("head"); [EOL] Tag child = new Tag("meta"); [EOL] assertTrue(parent.canContain(child)); [EOL] }
public void testCanContain_HeadTagCannotContainInvalidChild() { [EOL] Tag parent = new Tag("head"); [EOL] Tag child = new Tag("div"); [EOL] assertFalse(parent.canContain(child)); [EOL] }
public void testCanContain_DtCannotContainDd() { [EOL] Tag parent = new Tag("dt"); [EOL] Tag child = new Tag("dd"); [EOL] assertFalse(parent.canContain(child)); [EOL] }
public void testCanContain_DdCannotContainDt() { [EOL] Tag parent = new Tag("dd"); [EOL] Tag child = new Tag("dt"); [EOL] assertFalse(parent.canContain(child)); [EOL] }
public void testCanContain_ValidParentChildCombination() { [EOL] Tag parent = new Tag("body"); [EOL] Tag child = new Tag("div"); [EOL] assertTrue(parent.canContain(child)); [EOL] }
public void testIsBlockTrue() { [EOL] Tag tag = Tag.valueOf("div"); [EOL] assertTrue(tag.isBlock()); [EOL] }
public void testIsBlockFalse() { [EOL] Tag tag = Tag.valueOf("span"); [EOL] assertFalse(tag.isBlock()); [EOL] }
public void testCanContainBlock_True() { [EOL] Tag tag = Tag.valueOf("div"); [EOL] assertTrue(tag.canContainBlock()); [EOL] }
public void testCanContainBlock_False() { [EOL] Tag tag = Tag.valueOf("img"); [EOL] assertFalse(tag.canContainBlock()); [EOL] }
public void testLoad_validFileAndCharset() throws IOException { [EOL] File tempFile = File.createTempFile("test", ".txt"); [EOL] try (FileWriter writer = new FileWriter(tempFile)) { [EOL] writer.write("Test content"); [EOL] } [EOL] String charsetName = "UTF-8"; [EOL] String result = YourClass.load(tempFile, charsetName); [EOL] assertEquals("Test content", result); [EOL] tempFile.delete(); [EOL] }
public void testLoad_nonExistentFile() { [EOL] File tempFile = new File("nonexistentfile.txt"); [EOL] String charsetName = "UTF-8"; [EOL] try { [EOL] YourClass.load(tempFile, charsetName); [EOL] fail("Expected IOException was not thrown"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testLoad_unsupportedCharset() throws IOException { [EOL] File tempFile = File.createTempFile("test", ".txt"); [EOL] try (FileWriter writer = new FileWriter(tempFile)) { [EOL] writer.write("Test content"); [EOL] } [EOL] String charsetName = "InvalidCharset"; [EOL] try { [EOL] YourClass.load(tempFile, charsetName); [EOL] fail("Expected IOException was not thrown"); [EOL] } catch (IOException expected) { [EOL] } finally { [EOL] tempFile.delete(); [EOL] } [EOL] }
public void testReadInputStreamWithEmptyStream() throws IOException { [EOL] InputStream emptyStream = new ByteArrayInputStream(new byte[0]); [EOL] String result = readInputStream(emptyStream, "UTF-8"); [EOL] assertEquals("", result); [EOL] }
public void testReadInputStreamWithContent() throws IOException { [EOL] String testString = "Hello, World!"; [EOL] InputStream stream = new ByteArrayInputStream(testString.getBytes(StandardCharsets.UTF_8)); [EOL] String result = readInputStream(stream, "UTF-8"); [EOL] assertEquals(testString, result); [EOL] }
public void testReadInputStreamWithDifferentCharset() throws IOException { [EOL] String testString = ", !"; [EOL] InputStream stream = new ByteArrayInputStream(testString.getBytes("Windows-1251")); [EOL] String result = readInputStream(stream, "Windows-1251"); [EOL] assertEquals(testString, result); [EOL] }
public void testReadInputStreamWithLargeContent() throws IOException { [EOL] StringBuilder largeTestStringBuilder = new StringBuilder(); [EOL] for (int i = 0; i < 0x20000; i++) { [EOL] largeTestStringBuilder.append("a"); [EOL] } [EOL] String largeTestString = largeTestStringBuilder.toString(); [EOL] InputStream stream = new ByteArrayInputStream(largeTestString.getBytes(StandardCharsets.UTF_8)); [EOL] String result = readInputStream(stream, "UTF-8"); [EOL] assertEquals(largeTestString, result); [EOL] }
